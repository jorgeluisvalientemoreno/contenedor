PL/SQL Developer Test script 3.0
685
DECLARE
errorNumber NUMBER;
errorMessage  VARCHAR2(4000);
-- Generated by Code Generator (PVCS Version 1.5)
 -- Open Systems Ltd, Copyright 2003.
V0 NUMBER;
V1 VARCHAR2(4000);
V2 VARCHAR2(4000);
V3 VARCHAR2(4000);
sbOrdenId VARCHAR2(4000);
NUERROR_CODE NUMBER;
SBERROR_MESSAGE VARCHAR2(4000);
V4 NUMBER;
nuOrderId NUMBER;
V5 NUMBER;
V6 VARCHAR2(4000);
V7 VARCHAR2(4000);
V8 VARCHAR2(4000);
sbContrato VARCHAR2(4000);
V9 NUMBER;
V10 NUMBER;
nuValorOrden NUMBER;
V11 NUMBER;
V12 VARCHAR2(4000);
V13 VARCHAR2(4000);
V14 VARCHAR2(4000);
sbTASK_TYPE_ID VARCHAR2(4000);
V15 NUMBER;
nuTASK_TYPE_ID NUMBER;
V16 NUMBER;
V17 VARCHAR2(4000);
V18 VARCHAR2(4000);
V19 VARCHAR2(4000);
sbValorAUIUtil VARCHAR2(4000);
nuValorAdm NUMBER;
V20 NUMBER;
V21 NUMBER;
nuValorImp NUMBER;
V22 NUMBER;
V23 NUMBER;
V24 NUMBER;
V25 VARCHAR2(4000);
V26 VARCHAR2(4000);
V27 VARCHAR2(4000);
sbCOMMON_REG VARCHAR2(4000);
V28 VARCHAR2(4000);
V29 NUMBER;
V30 VARCHAR2(4000);
nuPORCENTAJE NUMBER;
V31 NUMBER;
V32 VARCHAR2(4000);
V33 VARCHAR2(4000);
sbTipo VARCHAR2(4000);
V34 VARCHAR2(4000);
V35 NUMBER;
V36 NUMBER;
V37 NUMBER;
nuValor_AUI_Util NUMBER;
V38 NUMBER;
nuValorUtil NUMBER;
V39 NUMBER;
V40 NUMBER;
V41 NUMBER;
V42 NUMBER;
V43 NUMBER;
V44 NUMBER;
V45 NUMBER;
V46 NUMBER;
V47 NUMBER;
V48 NUMBER;
nuValorDetalle NUMBER;
V49 NUMBER;
V50 VARCHAR2(4000);
V51 NUMBER;
V52 NUMBER;
V53 VARCHAR2(4000);
V54 NUMBER;
nuIVA NUMBER;
V55 NUMBER;
V56 NUMBER;
V57 NUMBER;
nuValor NUMBER;
V58 NUMBER;
nuITEM NUMBER;
V59 NUMBER;
nuFUNCTION NUMBER;
V60 NUMBER;
V61 NUMBER;

FUNCTION fsbNovedadReversion(inuOrderid IN OPEN.or_order.order_id%TYPE) RETURN VARCHAR2 IS

    /*****************************************************************
    Propiedad intelectual de PETI.
    Unidad         : fsbNovedadReversion
    Descripcion    : funcion que retorna 'Y' si la novedad es de reversion
                     para cambiar el signo al value_reference multiplicando por -1
                     Aranda caso numero 3018
    Autor          : Emiro Leyva
    Fecha          : 04/03/2014

     Parametros              Descripcion
    ============         ===================

    Historia de Modificaciones
    Fecha             Autor             Modificacion
    =========       =========           ====================

    ******************************************************************/

    CURSOR cuSiNovedad (nuorderid IN OPEN.or_order_items.order_id%TYPE) IS
       SELECT 'Y'
       FROM OPEN.or_related_order
       WHERE or_related_order.order_id = nuorderid
       AND   or_related_order.rela_order_type_id = 15;


      sbaplica VARCHAR2(1);
  BEGIN

 --   ut_trace.trace('Inicio ldc_fsbaplicaretecree', 10);
      OPEN cuSiNovedad(inuOrderId);
      FETCH cuSiNovedad
      INTO sbaplica;
      CLOSE cuSiNovedad;

      IF (sbaplica IS NULL) THEN
          sbaplica := 'N';
      END IF;
    --ut_trace.trace('sbaplica -->' || sbaplica, 10);
    --ut_trace.trace('Fin ldc_fsbaplicaretecree', 10);

      RETURN sbaplica;

  END fsbNovedadReversion;

 PROCEDURE Procostoorden(inucontrato  IN OPEN.ge_contrato.id_contrato%TYPE,
                          inuOrderId   IN OPEN.or_order.order_id%TYPE,
                          onuOrderCost OUT NUMBER) IS

    /*****************************************************************
      Propiedad intelectual de PETI (c).

      Unidad         : procostoorden
      Descripcion    : Procedimiento que permite retornar el costo de la orden, de acuerdo a la lista de precios vigente y
                       a una fecha por defecto.
                       La fecha por defecto puede ser la fecha de: Legalizacion, Ejecucion o Asignacion de la orden.
      Autor          : Luz Andrea Angel M.
      Fecha          : 14/08/2013

      Parametros              Descripcion
      ============         ===================
      inucontrato          Codigo del contrato que se esta liquidando
      inuOrderId           Codigo de la orden
      onuOrderCost         Valor del costo total de la orden

      Historia de Modificaciones
      Fecha             Autor             Modificacion
      =========         =========         ====================
      07-01-2014 Llozada [NC 2367]        Se excluyen los items de clasificacion 21 y 8
                                          Configurados en el parametro LDC_EXCLUIR_ITEMSCLASIF
      23-08-2013        luzaa             NC535: se ajusta cursor que obtiene los items legalizados de la orden
      01-10-2013        JorVal            NC795: Se ajusta el proceso de costo retornar el costo de
                                                 al orden para aplicar los aumnetos y/o disminusiones de las ordenes
                                                 de ajuste asociadas a la orden prinicpal.
      11-10-2013        luzaa             NC1148: Se ajusta para que el valor de la orden sea calculado de acuerdo al valor del item
                                          registrado al legalizar la orden
      22-10-2013        luzaa             NC1148V2: Se valida si el contratista es de recaudos, para que el valor de la orden se obtenga
                                          por medio de la lista de costos.
      18-11-2013        llozada           Se modifica para que obtenga los valores de la orden de Ajuste y la Orden padre
      27-11-2013        luzaa             NC1776: se modifica la forma de obtener el costo de la orden cuando la orden tenga asociados items
                                          de novedad con signo positivo
      28-01-2013        llozada           Con el objetivo de mejorar el rendiemiento del proceso, se utilizan tablas PL para subir a memoria
                                          items de la orden
      10-03-2014        llozada           Se elimina la validaci?n de los items de ajuste con los items padre
    ******************************************************************/
    /*07-01-2014 Llozada [NC 2367]: Se excluyen los items de clasificacion 21 y 8
                                    Configurados en el parametro LDC_EXCLUIR_ITEMSCLASIF*/
    CURSOR cuitemslegorden(nuorderid IN OPEN.or_order_items.order_id%TYPE) IS
      SELECT OR_order_items.items_id, OR_order_items.LEGAL_ITEM_AMOUNT, OR_order_items.VALUE
       FROM OPEN.OR_order_items,OPEN.ge_items
       WHERE order_id = nuorderid
       and OR_order_items.items_id = ge_items.items_id
       and ge_items.item_classif_id not in (SELECT column_value ITEMS_ID
                                            from table (OPEN.ldc_boutilities.SPLITstrings(
                                            OPEN.dald_parameter.fsbGetValue_Chain('LDC_EXCLUIR_ITEMSCLASIF'),',')));

    /*07-01-2014 Llozada [NC 2367]: Se excluyen los items de clasificacion 21 y 8
                                    Configurados en el parametro LDC_EXCLUIR_ITEMSCLASIF*/
    CURSOR cuItemLegOrdenByItem(nuOrderId IN OPEN.or_order_items.order_id%TYPE, nuItemId NUMBER)
    IS
      SELECT OR_order_items.items_id, OR_order_items.LEGAL_ITEM_AMOUNT, OR_order_items.VALUE
        FROM OPEN.OR_order_items, OPEN.ge_items
       WHERE OR_order_items.order_id = nuorderid
        AND OR_order_items.items_id = nuItemId
        and OR_order_items.items_id = ge_items.items_id
       and ge_items.item_classif_id not in (SELECT column_value ITEMS_ID
                                            from table (OPEN.ldc_boutilities.SPLITstrings(
                                            OPEN.dald_parameter.fsbGetValue_Chain('LDC_EXCLUIR_ITEMSCLASIF'),',')));
         --and legal_item_amount > 0; --Se obtienen todos los Items del padre

    --LLOZADA: debe tomar todos los items de la orden padre
    CURSOR cuitemslegordenPadre(nuorderid IN OPEN.or_order_items.order_id%TYPE,
                                nuItems   IN OPEN.or_order_items.items_id%TYPE) IS
      SELECT items_id
        FROM OPEN.OR_order_items
       WHERE order_id = nuorderid
         AND items_id = nuItems;
         --and legal_item_amount > 0;

    -- CURSOR que trae la orden padre
    CURSOR cuOrdenSinAjuste(nuorderid IN OPEN.or_order_items.order_id%TYPE) IS
      SELECT related_order_id
        FROM OPEN.or_related_order
       WHERE order_id = nuorderid
         AND rela_order_type_id = 9;

    nucontract     OPEN.ge_contrato.id_contrato%TYPE;
    nucontrato     OPEN.ge_contrato.id_contrato%TYPE;
    nuCantidad     OPEN.OR_order_items.LEGAL_ITEM_AMOUNT%TYPE;
    dtfecha        DATE;
    onupricelistid NUMBER;
    onuvalue       NUMBER;

    --NC 795
    -- CURSOR que trae los items de la orden de ajuste
    CURSOR cuordenajustes(nuorderid IN OPEN.or_order.order_id%TYPE) IS
         SELECT OR_order_items.Order_Id, OR_order_items.LEGAL_ITEM_AMOUNT, OR_order_items.out_, OR_order_items.VALUE, OR_order_items.items_id
         FROM OPEN.OR_order_items, OPEN.ge_items
         WHERE order_id = nuorderid
         AND legal_item_amount > 0
         AND out_ IN (OPEN.Ge_Boconstants.csbYES, OPEN.Ge_Boconstants.csbNO)
         and OR_order_items.items_id = ge_items.items_id
         and ge_items.item_classif_id not in (SELECT column_value ITEMS_ID
                                            from table (OPEN.ldc_boutilities.SPLITstrings(
                                            OPEN.dald_parameter.fsbGetValue_Chain('LDC_EXCLUIR_ITEMSCLASIF'),',')));

    TYPE tyRcItemsAjuste IS RECORD (Order_Id OPEN.OR_order_items.order_id%TYPE,
                         LEGAL_ITEM_AMOUNT OPEN.OR_order_items.legal_item_amount%TYPE,
                         out_ OPEN.OR_order_items.out_%TYPE,
                         VALUE OPEN.OR_order_items.VALUE%TYPE,
                         items_id  OPEN.OR_order_items.items_id%TYPE
                         );

    TYPE tytbItemsAjuste IS TABLE OF tyRcItemsAjuste INDEX BY BINARY_INTEGER;

    tbItemsAjuste tytbItemsAjuste;

    TYPE tyRcItemsPadre IS RECORD (items_id  OPEN.OR_order_items.items_id%TYPE,
                         LEGAL_ITEM_AMOUNT OPEN.OR_order_items.legal_item_amount%TYPE,
                         VALUE OPEN.OR_order_items.VALUE%TYPE
                         );

    TYPE tytbItemsPadre IS TABLE OF tyRcItemsPadre INDEX BY BINARY_INTEGER;

    tbItemsPadre tytbItemsPadre;

    nuY           NUMBER;
    nuN           NUMBER;
    nuOrdenAjuste NUMBER := 0;
    nuOrden       NUMBER;
    nuSigValor    NUMBER;
    --FIN NC795

    --<<NC 1776
    CURSOR cuitemnovedadpos(nuitem OPEN.ge_items.items_id%TYPE) IS
      SELECT 'X'
        FROM OPEN.ct_item_novelty
       WHERE items_id = nuitem
         AND liquidation_sign = 1;

    -- ARANDA 2818
    CURSOR cuitemnovedadneg(nuitem OPEN.ge_items.items_id%TYPE) IS
      SELECT 'X', -1 SigValor
        FROM OPEN.ct_item_novelty
       WHERE items_id = nuitem
         AND items_id IN (SELECT TO_NUMBER(COLUMN_VALUE)
                                FROM TABLE(OPEN.Ldc_Boutilities.splitstrings(OPEN.Dald_Parameter.fsbGetValue_Chain('ACT_NOVEDAD_NEG_FNB'), ',')))
         AND liquidation_sign = -1;

    CURSOR cuitemslegordennov(nuorderid IN OPEN.or_order_items.order_id%TYPE) IS
      SELECT activity_id, DECODE(/*fsbNovedadReversion(nuorderid)*/'N','Y',value_reference*-1,value_reference) value_reference
        FROM OPEN.OR_ORDER_ACTIVITY
       WHERE order_id = nuorderid;

    sbliquida VARCHAR2(2);
    nuitemnov OPEN.ge_items.items_id%TYPE;

    onuCondicionSimple NUMBER;
    ochCosto VARCHAR2(100);
    ochLista VARCHAR2(100);
    ochTodosLosItems VARCHAR2(100);
    otbItemsCondSimple OPEN.Dact_Simple_Cond_Items.tytbCT_SIMPLE_COND_ITEMS;
    -->>
    nuI NUMBER;
    nuItemNew NUMBER;
    nuCantNew NUMBER;
    nuValueNew NUMBER;
    i NUMBER;
    nupos NUMBER;

    nuitem number;
    nuvalor number;

  BEGIN

    "OPEN".Ldc_Acta.LDC_ObtenerCondLiquidacion(inucontrato,onuCondicionSimple,ochCosto,ochLista,ochTodosLosItems,otbItemsCondSimple);

    nuOrden := inuOrderId;
    --obtiene la fecha con que se debe buscar el costo en la lista de costos
    "OPEN".Ldc_Acta.PROFECHALISTACOSTO(dtfecha, nuOrden);

    --Ut_Trace.TRACE('-- INICIO COSTO ACTA:',2);

    IF cuItemsLegOrden%isopen THEN
      CLOSE cuItemsLegOrden;
    END IF;

    OPEN cuOrdenSinAjuste(inuOrderId);
    FETCH cuOrdenSinAjuste
      INTO nuOrdenAjuste;
    CLOSE cuOrdenSinAjuste;

    --Valida si la orden que llega es de Ajuste
    IF nuOrdenAjuste IS NULL THEN
      nuOrdenAjuste := 0;
    END IF;

    nuContract := inucontrato;

  

    -- si creo la instancia, podra obtener el costo
    --IF (true) THEN

      --valida si es orden de novedad
      IF (OPEN.Ct_Bonovelty.fsbisnoveltyorder(nuorden) = 'N') THEN
        --ut_trace.trace('-- Paso 4. No es Novedad -->', 1);
        onuordercost := 0;

    /***************************************************************************
     *       LLOZADA:              Tabla de Items Padre
     **************************************************************************/

        -- se valida si la liquidacion es por todos los items
        IF ochTodosLosItems = 'Y' THEN

            OPEN cuitemslegorden(nuorden);
            FETCH cuitemslegorden BULK COLLECT INTO tbItemsPadre;
            CLOSE cuitemslegorden;

            --Ut_Trace.TRACE('-- CANTIDAD tbItemsPadre: '||tbItemsPadre.COUNT,5);

        ELSE
            -- se valida si la liquidacion es para algunos items
            tbItemsPadre.DELETE;
            nuI := 1;
            nupos := 1;
            -- La tabla tbItemsPadre se reemplaza con los items de la lista
            FOR nui IN 1 .. otbitemscondsimple.COUNT LOOP
                nuitemnew := NULL;
                nucantnew := NULL;
                nuValueNew := NULL;
                OPEN cuItemLegOrdenByItem(nuorden, otbItemsCondSimple(nuI).items_id);
                FETCH cuItemLegOrdenByItem INTO nuItemNew,nuCantNew,nuValueNew;
                CLOSE cuItemLegOrdenByItem;

                IF(nuitemnew IS NOT NULL)THEN
                  tbItemsPadre(nupos).items_id := nuItemNew;
                  tbitemspadre(nupos).legal_item_amount := nucantnew;
                  tbitemspadre(nupos).VALUE := nuvaluenew;
                  nupos := nupos + 1;
                END IF;
              END LOOP;

        END IF; -- END if ochTodosLosItems = 'Y'

        --Items del padre
        FOR i IN tbitemspadre.FIRST .. tbitemspadre.LAST LOOP
            onuvalue := 0;
            --LLOZADA: Solo procesa los Items del Padre con cantidad mayor a 0
            IF tbItemsPadre(i).LEGAL_ITEM_AMOUNT > 0 OR tbItemsPadre(i).LEGAL_ITEM_AMOUNT IS NOT NULL THEN

                -- Se valida si la liquidacion es por costo de la orden
                IF ochCosto = 'Y' THEN
                     onuvalue := tbItemsPadre(i).VALUE;
                END IF; -- END if ochCosto = 'Y'

                -- Se valida si es por lista de costos
                IF ochLista = 'Y' THEN

                    nuCantidad := tbItemsPadre(i).LEGAL_ITEM_AMOUNT; --rtitemslegorden.LEGAL_ITEM_AMOUNT;
          DBMS_OUTPUT.PUT_LINE('ERROR VALDIA LISTA DE COSTOS');

                    "OPEN".Ge_Bocertcontratista.obtenervaloritemlista(nuOrden,
                                                               tbItemsPadre(i).items_id, --rtitemslegorden.items_id,
                                                               'PRICE',
                                                               onupricelistid,
                                                               onuvalue,
                                                               dtfecha);
                    onuvalue := onuvalue * nucantidad;
          

                END IF; -- END if ochLista = 'Y'
                onuordercost := onuvalue + onuordercost;
            END IF;
        END LOOP;


    /***************************************************************************
     *   LLOZADA:                 Fin Recorrido Items Padre
     **************************************************************************/

        --NC 795
        --Busqueda de ordenes de ajustes con su valor total
        nuY := 0;
        nuN := 0;

    /***************************************************************************
     *                     Ordenes de Ajuste
     **************************************************************************/
        IF nuOrdenAjuste > 0 THEN

            OPEN cuordenajustes(nuOrdenAjuste);
            FETCH cuordenajustes BULK COLLECT INTO tbItemsAjuste;
            CLOSE cuordenajustes;

            FOR j IN tbItemsAjuste.FIRST .. tbItemsAjuste.LAST LOOP

                 --LOZADA 10-03-2014 NO VALIDA CONTRA LOS ITEMS PADRE
                 --Devuelve los items de la orden Padre
                  --for i in tbItemsPadre.first .. tbItemsPadre.last loop

                        onuvalue := 0;
                        nuY      := 0;
                        nuN      := 0;

                        --LOZADA 10-03-2014 NO VALIDA CONTRA LOS ITEMS PADRE
                        --if tbItemsAjuste(j).items_id = tbItemsPadre(i).items_id then  --LLOZADA

                            -- Se valida si la liquidacion es por costo de la orden
                            IF ochCosto = 'Y' THEN
                                 onuvalue := tbItemsAjuste(j).VALUE;
                            END IF; -- END if ochCosto = 'Y'

                            -- Se valida si es por lista de costos
                            IF ochLista = 'Y' THEN

                                nucantidad := tbItemsAjuste(j).legal_item_amount;
                                DBMS_OUTPUT.PUT_LINE('ERROR VALDIA LISTA DE COSTOS');

                                "OPEN".Ge_Bocertcontratista.obtenervaloritemlista(tbItemsAjuste(j).order_id, --rtordenajuste.order_id,
                                                           tbItemsAjuste(j).items_id, --rtordenajuste.items_id,
                                                           'PRICE',
                                                           onupricelistid,
                                                           onuvalue,
                                                           dtfecha);

                                onuvalue := onuvalue * nucantidad;

                            END IF; -- END if ochLista = 'Y'

                          IF tbItemsAjuste(j).out_ = OPEN.Ge_Boconstants.csbyes THEN -- LLOZADA
                                nuy := nuy + onuvalue;
                          ELSE
                                nun := nun + onuvalue;
                          END IF;
                          --exit;
                        --end if;
                  --end loop;
                  onuOrderCost := onuOrderCost + nuY - nuN;
            END LOOP;
        END IF;
    /***************************************************************************
     *                     Fin Ordenes de Ajuste
     **************************************************************************/

        --Fin Busqueda de ordenes de ajustes con su valor total
        --Fin NC 795
      ELSE
        --Se trata de una orden de Novedad
        onuordercost := 0;
        --obtener el item de or_order_activity

        --ut_trace.trace('ORDEN NOVEDAD -->' || nuorden, 1);
        --DBMS_OUTPUT.put_line('ORDEN NOVEDAD -->' || nuorden);

        FOR rtitemslegordennov IN cuitemslegordennov(nuorden) LOOP
          nuitemnov := rtitemslegordennov.activity_id;

          --ut_trace.trace('VALOR NOVEDAD -->' || nuitemnov, 1);
          --DBMS_OUTPUT.put_line('VALOR NOVEDAD -->' || nuitemnov);

          --ut_trace.trace('ITEM NOVEDAD -->' || nuitemnov, 1);
          --DBMS_OUTPUT.put_line('ITEM NOVEDAD -->' || nuitemnov);

          --valida si se trata de un item de novedad positivo
          sbliquida := NULL;
          IF cuitemnovedadpos%isopen THEN
            CLOSE cuitemnovedadpos;
          END IF;
          OPEN cuitemnovedadpos(nuitemnov); --(inuorderid);
          FETCH cuitemnovedadpos
            INTO sbLiquida;
          CLOSE cuitemnovedadpos;

          -- jjsu aranda 2818 -- cuando es novedad de devolucion brilla con signo negativo
          nuSigValor := NULL;
          IF sbliquida IS NULL THEN
             IF cuitemnovedadneg%isopen THEN
                CLOSE cuitemnovedadneg;
             END IF;
              OPEN cuitemnovedadneg(nuitemnov);
             FETCH cuitemnovedadneg
              INTO sbLiquida, nuSigValor;
             CLOSE cuitemnovedadneg;
          END IF;

          IF nuSigValor IS NULL THEN   --Si no esta configurado como item novedad negativo para devolucion brilla
             nuSigValor := 1;
          END IF;

          --si item de novedad
          if (sbliquida = 'X') then
            --<<99369
            /*onuvalue := (rtitemslegordennov.value_reference*nuSigValor);
            IF (onuvalue IS NULL) THEN
              onuvalue := 0;
            END IF;*/

            if(rtitemslegordennov.value_reference is not null or rtitemslegordennov.value_reference = 0)then
              onuvalue := (rtitemslegordennov.value_reference*nusigvalor);
              IF (onuvalue IS NULL) THEN
                onuvalue := 0;
               END IF;
            else
              OPEN cuitemslegorden(nuorden);
              fetch cuitemslegorden
              into nuitem, nucantidad, nuvalor;
              close cuitemslegorden;
              dbms_output.put_line('nucantidad NOVEDAD -->' || nucantidad);
              dbms_output.put_line('nuitem NOVEDAD -->' || nuitem);
        
              "OPEN".Ge_Bocertcontratista.obtenervaloritemlista(nuorden, --rtordenajuste.order_id,
                                                           nuitem, --rtordenajuste.items_id,
                                                           'PRICE',
                                                           onupricelistid,
                                                           onuvalue,
                                                           dtfecha);
              onuvalue := onuvalue * nucantidad;
              dbms_output.put_line('onuvalue NOVEDAD -->' || onuvalue);
            end if;
            onuordercost := onuvalue + onuordercost;
            -->>99369
          END IF;
        END LOOP;
      END IF;

    --END IF;
    --Ut_Trace.TRACE('-- Total Orden Acumu: '||onuordercost,5);
    --ut_trace.trace('-- Paso 12. Final onuOrderCost -->' || onuOrderCost, 10);
    --Ut_Trace.TRACE('Fin [llozada] ldc_procostoorden', 10);

  EXCEPTION
    WHEN "OPEN".Ex.CONTROLLED_ERROR THEN
      IF cuItemsLegOrden%isopen THEN
        CLOSE cuItemsLegOrden;
      END IF;
      onuOrderCost := -1;
      RAISE;
    WHEN OTHERS THEN
      IF cuItemsLegOrden%isopen THEN
        CLOSE cuItemsLegOrden;
      END IF;
      "OPEN".Errors.setError;
      onuOrderCost := -1;
      RAISE "OPEN".Ex.CONTROLLED_ERROR;

  END Procostoorden;

BEGIN

nuOrderId:=96733404;
V10:=OPEN.DAOR_ORDER.FNUGETDEFINED_CONTRACT_ID(nuOrderId,NULL);
PROCOSTOORDEN(V10, nuOrderId, nuValorOrden);
dbms_output.put_line(nuValorOrden);
nuTASK_TYPE_ID:=OPEN.DAOR_ORDER.FNUGETTASK_TYPE_ID(nuOrderId,NULL);
sbValorAUIUtil:=OPEN.DAGE_CONTRATO.FNUGETVALOR_AUI_UTIL(V10);
V16:= 0;
IF ( nuValorAdm is NULL )
THEN
V20 := 0;
nuValorAdm:=V20;
V21:=V20;
ELSE
null;
END IF;
IF ( nuValorImp is NULL )
THEN
V22 := 0;
nuValorImp:=V22;
V23:=V22;
ELSE
null;
END IF;
sbCOMMON_REG:=OPEN.DAGE_CONTRATista.FSBGETCOMMON_REG(OPEN.DAGE_CONTRATO.FNUGETID_CONTRATISTA(V10));
V24:= 0;
V28 := 'Y';
IF ( sbCOMMON_REG = V28 )
THEN
V30 := 'RI';
V29:="OPEN".LDC_ACTA.FNUVALIDARETENT(nuTASK_TYPE_ID, V30);
nuPORCENTAJE:=V29;
V31 := 0;
IF ( nuPORCENTAJE > V31 )
THEN
V33 := 'RI';
V32:="OPEN".LDC_ACTA.FSBTIPOITEM(nuTASK_TYPE_ID, nuPORCENTAJE, V33);
sbTipo:=V32;
V34 := 'O';
IF ( sbTipo = V34 )
THEN
DBMS_OUTPUT.PUT_LINE('ENTRO O');
V35:="OPEN".UT_CONVERT.FNUCHARTONUMBER(sbValorAUIUtil);
V36 := 100;
V37:=V35 / V36;
nuValor_AUI_Util:=V37;
"OPEN".LDC_ACTA.OBTENERAIU(nuOrderId, null, nuValorAdm, nuValorImp, nuValorUtil);
V38:= 0;
V39 := 1;
V40:=nuValorAdm + nuValorImp;
V41:=V40 + nuValorUtil;
V42 := 100;
V43:=V41 / V42;
V44:=V39 + V43;
dbms_output.put_line('V44:'||V44);
V45:=nuValorOrden / V44;
V46 := 100;
V47:=nuValorUtil / V46;
V48:=V45 * V47;
nuValorUtil:=V48;
nuValorDetalle:=nuValorUtil;
V49:=nuValorUtil;
ELSE
V50 := 'S';
IF ( sbTipo = V50 )
THEN
nuValorDetalle:=nuValorOrden;
V51:=nuValorOrden;
ELSE
null;
END IF;
V49:=V51;
END IF;
DBMS_OUTPUT.PUT_LINE('VALOR DESPUES SI'||nuValorOrden);
V53 := 'COD_VALOR_IVA';
V54 := 0;
V52:=OPEN.DALD_PARAMETER.FNUGETNUMERIC_VALUE(V53, V54);
nuIVA:=V52;
V55:=nuValorDetalle * nuIVA;
V56 := 100;
V57:=V55 / V56;
nuValor:=V57;
V58 := 4001293;
nuITEM:=V58;
--V59:=OPEN.LDC_ACTA.FNUITEMINSTANCE(nuITEM, nuValor, nuValorOrden);
DBMS_OUTPUT.PUT_LINE(nuValor);
DBMS_OUTPUT.PUT_LINE(nuValorOrden);
nuFUNCTION:=V59;
V60:=V59;
ELSE
null;
END IF;
V61:=V60;
ELSE
null;
END IF;
errorNumber := 0;
errorMessage:= NULL;
EXCEPTION
  WHEN "OPEN".ex.CONTROLLED_ERROR then
  "OPEN".errors.getError(errorNumber, errorMessage);
  WHEN OTHERS THEN
  "OPEN".errors.setError;
  "OPEN".errors.getError(errorNumber, errorMessage);
end;
0
0
