CREATE OR REPLACE PACKAGE BODY TT_BOORDER IS
   CSBVERSION CONSTANT VARCHAR2( 10 ) := 'SAO238185';
   CNUORDER_IN_USE CONSTANT GE_MESSAGE.MESSAGE_ID%TYPE := 114645;
   CNUCOMMENT_TYPE CONSTANT GE_COMMENT_TYPE.COMMENT_TYPE_ID%TYPE := 3;
   CNUPENDING_ORDER_ERROR CONSTANT GE_MESSAGE.MESSAGE_ID%TYPE := 117063;
   TYPE TYTBORDERS IS TABLE OF OR_ORDER.ORDER_ID%TYPE INDEX BY VARCHAR2( 15 );
   FUNCTION FSBVERSION
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN CSBVERSION;
   END FSBVERSION;
   FUNCTION FBLLOCKORDER( INUORDER IN OR_ORDER.ORDER_ID%TYPE, INUCOMMENTTYPE IN OR_ORDER_COMMENT.COMMENT_TYPE_ID%TYPE, ISBCOMMENT IN OR_ORDER_COMMENT.ORDER_COMMENT%TYPE, ONUERRORCODE OUT GE_ERROR_LOG.MESSAGE_ID%TYPE, OSBERRORMESSAGE OUT GE_ERROR_LOG.DESCRIPTION%TYPE )
    RETURN BOOLEAN
    IS
    BEGIN
      UT_TRACE.TRACE( 'Inicia TT_BODamageProduct.fbllockOrder', 2 );
      ONUERRORCODE := NULL;
      OSBERRORMESSAGE := NULL;
      OR_BOFWLOCKORDER.LOCKORDER( INUORDER, INUCOMMENTTYPE, ISBCOMMENT, FALSE );
      UT_TRACE.TRACE( 'Fin TT_BODamageProduct.fbllockOrder[true]', 2 );
      RETURN TRUE;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         UT_TRACE.TRACE( 'Fin TT_BODamageProduct.fbllockOrder[false]', 2 );
         ERRORS.GETERROR( ONUERRORCODE, OSBERRORMESSAGE );
         RETURN FALSE;
      WHEN OTHERS THEN
         UT_TRACE.TRACE( 'OTHERS ERROR', 2 );
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END FBLLOCKORDER;
   FUNCTION LOCKORDERS( INUPACKAGEID IN MO_PACKAGES.PACKAGE_ID%TYPE, ISBPROCESSID IN ESTAPROG.ESPRPROG%TYPE )
    RETURN BOOLEAN
    IS
      BLANULL BOOLEAN := TRUE;
      NUERRORCODE GE_MESSAGE.MESSAGE_ID%TYPE := NULL;
      SBERRORMESSAGE GE_ERROR_LOG.DESCRIPTION%TYPE := NULL;
      TBORDERS DAOR_ORDER_ACTIVITY.TYTBORDER_ID;
      NUINDEX BINARY_INTEGER;
      SBCOMMENT OR_ORDER_COMMENT.ORDER_COMMENT%TYPE;
      RCESTAPROG ESTAPROG%ROWTYPE;
    BEGIN
      UT_TRACE.TRACE( 'BEGIN TT_BOOrder.LockOrders [' || INUPACKAGEID || ']', 30 );
      OR_BCORDERACTIVITIES.GETACTPENDBYPACKLOCK( INUPACKAGEID, FALSE, TBORDERS );
      NUINDEX := TBORDERS.FIRST;
      IF ( NUINDEX IS NULL ) THEN
         RETURN FALSE;
      END IF;
      SBCOMMENT := GE_BOPARAMETER.FSBGET( TT_BCCONSTANTS.CSBCOMENTARIO_DANO_AUTO );
      IF ( ISBPROCESSID IS NOT NULL ) THEN
         RCESTAPROG := PKTBLESTAPROG.FRCGETRECORD( ISBPROCESSID );
      END IF;
      LOOP
         EXIT WHEN NUINDEX IS NULL;
         IF ( ISBPROCESSID IS NOT NULL ) THEN
            BLANULL := FBLLOCKORDER( TBORDERS( NUINDEX ), CNUCOMMENT_TYPE, SBCOMMENT, NUERRORCODE, SBERRORMESSAGE );
            WHILE NUERRORCODE IS NOT NULL AND NUERRORCODE = CNUORDER_IN_USE
             LOOP
               UT_TRACE.TRACE( 'Se duerme el hilo en espera de soltar la orden', 15 );
               PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROGRAMAT( ISBPROCESSID, 'La orden [' || TBORDERS( NUINDEX ) || '] se encuentra bloqueada.', 100, RCESTAPROG.ESPRSUPR );
               DBMS_LOCK.SLEEP( 0.25 );
               NUERRORCODE := NULL;
               SBERRORMESSAGE := NULL;
               BLANULL := FBLLOCKORDER( TBORDERS( NUINDEX ), CNUCOMMENT_TYPE, SBCOMMENT, NUERRORCODE, SBERRORMESSAGE );
            END LOOP;
          ELSE
            OR_BOFWLOCKORDER.LOCKORDER( TBORDERS( NUINDEX ), CNUCOMMENT_TYPE, SBCOMMENT, FALSE );
         END IF;
         EXIT WHEN NOT BLANULL;
         NUINDEX := TBORDERS.NEXT( NUINDEX );
      END LOOP;
      RETURN BLANULL;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         UT_TRACE.TRACE( 'EXCEPTION CONTROLLED_ERROR TT_BOOrder.LockOrders', 1 );
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         UT_TRACE.TRACE( 'EXCEPTION OTHERS TT_BOOrder.LockOrders', 1 );
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END LOCKORDERS;
   PROCEDURE VALPENDINGORDERS( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, ISBORDERSTOANNUL IN VARCHAR2 )
    IS
      BLHASERROR BOOLEAN;
      NUORDERID OR_ORDER.ORDER_ID%TYPE;
    BEGIN
      NUORDERID := TT_BOORDERDAMAGEUTILITIES.FNUGETDIAGORDER( INUFAULTID );
      BLHASERROR := TRUE;
      IF ( NUORDERID IS NOT NULL ) THEN
         IF ( ISBORDERSTOANNUL IS NOT NULL ) THEN
            IF ( INSTR( GE_BOCONSTANTS.CSBPIPE || ISBORDERSTOANNUL || GE_BOCONSTANTS.CSBPIPE, GE_BOCONSTANTS.CSBPIPE || NUORDERID || GE_BOCONSTANTS.CSBPIPE ) != 0 ) THEN
               BLHASERROR := FALSE;
            END IF;
         END IF;
       ELSE
         BLHASERROR := FALSE;
      END IF;
      IF ( BLHASERROR ) THEN
         ERRORS.SETERROR( CNUPENDING_ORDER_ERROR );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END VALPENDINGORDERS;
   PROCEDURE ANNULPENDINGORDERS( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, ISBORDERSTOANNUL IN VARCHAR2 )
    IS
      NUORDERID OR_ORDER.ORDER_ID%TYPE;
      NUINDEX BINARY_INTEGER;
      TBORDERS UT_STRING.TYTB_STRING;
    BEGIN
      UT_STRING.EXTSTRING( ISBORDERSTOANNUL, GE_BOCONSTANTS.CSBPIPE, TBORDERS );
      NUINDEX := TBORDERS.FIRST;
      LOOP
         EXIT WHEN NUINDEX IS NULL;
         NUORDERID := TO_NUMBER( TBORDERS( NUINDEX ) );
         TT_BOORDERDAMAGEUTILITIES.TRASLADARACTIVIDADESORDEN( NUORDERID, INUFAULTID );
         OR_BOANULLORDER.ANULLORDERPROCESS( NUORDERID );
         NUINDEX := TBORDERS.NEXT( NUINDEX );
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END ANNULPENDINGORDERS;
   PROCEDURE ANNULPENDINGORDERS( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE )
    IS
      NUORDERID OR_ORDER.ORDER_ID%TYPE;
      NUINDEX BINARY_INTEGER;
      TBORDERS OR_BCORDERACTIVITIES.TYTBORDERANDACTIVITY;
      TBORDERSPROCESSED TYTBORDERS;
    BEGIN
      OR_BCORDERACTIVITIES.GETACTIVITYBYPACKAGE( INUFAULTID, OR_BOORDERACTIVITIES.CSBFINISHSTATUS, TT_BOCREATEACTIVITY.FNUPROCESS_DAMAGE, TBORDERS );
      NUINDEX := TBORDERS.FIRST;
      LOOP
         EXIT WHEN NUINDEX IS NULL;
         NUORDERID := TBORDERS( NUINDEX ).NUORDERID;
         IF ( NOT ( TBORDERSPROCESSED.EXISTS( NUORDERID ) ) ) THEN
            TT_BOORDERDAMAGEUTILITIES.TRASLADARACTIVIDADESORDEN( NUORDERID, INUFAULTID );
            OR_BOANULLORDER.ANULLORDERPROCESS( NUORDERID );
            TBORDERSPROCESSED( NUORDERID ) := NUORDERID;
         END IF;
         NUINDEX := TBORDERS.NEXT( NUINDEX );
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END ANNULPENDINGORDERS;
END TT_BOORDER;
/


