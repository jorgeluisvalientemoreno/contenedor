PACKAGE BODY UT_STRING AS




















































   CSBVERSION   CONSTANT VARCHAR2(20) := 'SAO197880';

   
   
   
   CNUHASH_SIZE CONSTANT PLS_INTEGER := 99999999;

   
   
   

   
   
   
   
   SBTEMPORAL VARCHAR2(32767);

   
   
   

    FUNCTION FSBVERSION  RETURN VARCHAR2 IS
    BEGIN
        RETURN CSBVERSION;
    END;

   FUNCTION FNUINDEX RETURN NUMBER IS
   BEGIN
      RETURN (0);
   END;

   FUNCTION FNUINDEX_PARAMETER RETURN NUMBER IS
   BEGIN
      RETURN (1);
   END;

   FUNCTION FNUINDEX_VALUE RETURN NUMBER IS
   BEGIN
      RETURN (2);
   END;

   FUNCTION FNUHASH_PARAMETER RETURN NUMBER IS
   BEGIN
      RETURN (3);
   END;

   FUNCTION FNUHASH_VALUE RETURN NUMBER IS
   BEGIN
      RETURN (4);
   END;

   FUNCTION FNUHASH_PARAMETER_VALUE RETURN NUMBER IS
   BEGIN
      RETURN (5);
   END;


   FUNCTION FNUGETHASH_STRING
   (
      ISBSTRING  IN VARCHAR2
   ) RETURN NUMBER
   IS
   BEGIN
      RETURN (DBMS_UTILITY.GET_HASH_VALUE(ISBSTRING, 0, CNUHASH_SIZE));
   EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20200, 'fnuGetHash_String : '||SQLERRM);
   END;

   FUNCTION FNUGETHASH_STRING
   (
      INUTIPO      IN PLS_INTEGER,
      INUSTART     IN PLS_INTEGER,
      ISBPARAMETER IN VARCHAR2 DEFAULT NULL,
      ISBVALUE     IN VARCHAR2 DEFAULT NULL
   ) RETURN NUMBER
   IS
   BEGIN
      IF INUTIPO = FNUINDEX THEN
         RETURN (INUSTART + 1);
      ELSIF INUTIPO = FNUINDEX_PARAMETER THEN
         RETURN (TO_NUMBER(ISBPARAMETER));
      ELSIF INUTIPO = FNUINDEX_VALUE THEN
         RETURN (TO_NUMBER(ISBVALUE));
      ELSIF INUTIPO = FNUHASH_PARAMETER THEN
         RETURN (FNUGETHASH_STRING(ISBPARAMETER));
      ELSIF INUTIPO = FNUHASH_VALUE THEN
         RETURN (FNUGETHASH_STRING(ISBVALUE));
      ELSE
         RETURN (FNUGETHASH_STRING(ISBPARAMETER||'.'||ISBVALUE));
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20200, 'fnuGetHash_String : '||SQLERRM);
   END;

   PROCEDURE ADDSTRINGTBL
   (
      IOTBSTR    IN OUT NOCOPY TYTB_STRING,
      ISBVALUE   IN VARCHAR2,
      INUTIPO    IN PLS_INTEGER DEFAULT UT_STRING.FNUINDEX
   )
   IS
      NUINDEX PLS_INTEGER := IOTBSTR.COUNT;
   BEGIN
      NUINDEX := FNUGETHASH_STRING(INUTIPO, NUINDEX, ISBVALUE, ISBVALUE);
      IOTBSTR(NUINDEX) := ISBVALUE;
   END;

   FUNCTION COUNTTMPTBL RETURN NUMBER IS
   BEGIN
      RETURN TBSTRTMP.COUNT;
   END;

   PROCEDURE DELETETMPTBL IS
   BEGIN
      TBSTRTMP.DELETE;
   END;

   PROCEDURE ADDSTRINGTMPTBL
   (
      ISBVALUE   IN VARCHAR2,
      INUTIPO    IN NUMBER DEFAULT UT_STRING.FNUINDEX
   )
   IS
      NUINDEX PLS_INTEGER := TBSTRTMP.COUNT;
   BEGIN
      NUINDEX := FNUGETHASH_STRING(INUTIPO, NUINDEX, ISBVALUE, ISBVALUE);
      TBSTRTMP(NUINDEX) := ISBVALUE;
   END;

   FUNCTION GETTMPTBL_FIRST RETURN NUMBER IS
   BEGIN
      RETURN TBSTRTMP.FIRST;
   END;

   FUNCTION GETVALUETMPTBL_NEXT
   (
      IOSBVALUE  IN OUT VARCHAR2,
      IONUINDEX  IN OUT NUMBER
   )
   RETURN BOOLEAN IS
   BEGIN
      IF TBSTRTMP.EXISTS(IONUINDEX) THEN
         IOSBVALUE := TBSTRTMP(IONUINDEX);
         IONUINDEX := TBSTRTMP.NEXT(IONUINDEX);
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END;

   FUNCTION  FINDSTRINGTBL
   (
      IOTBSTR    IN OUT NOCOPY TYTB_STRING,
      ISBVALUE   IN VARCHAR2,
      INUTIPO    IN NUMBER DEFAULT UT_STRING.FNUINDEX
   ) RETURN BOOLEAN
   IS
      NUINDEX PLS_INTEGER;
   BEGIN
      IF INUTIPO = UT_STRING.FNUINDEX THEN
         FOR NUINDEX IN 1..IOTBSTR.COUNT LOOP
            IF IOTBSTR.EXISTS(NUINDEX) THEN
               RETURN (TRUE);
            END IF;
         END LOOP;
      ELSE
         RETURN (IOTBSTR.EXISTS(FNUGETHASH_STRING(INUTIPO, 0, ISBVALUE, '')));
      END IF;

      RETURN FALSE;
   END;

   PROCEDURE EXTSTRING
   (
      ISBSTRING    IN VARCHAR2,
      ICHDELIMITER IN VARCHAR2,
      TBSTRING     IN OUT NOCOPY TYTB_STRING
   )
   IS
      NULPOS      PLS_INTEGER;
      NUPOS       PLS_INTEGER := 0;
      NUCRT       PLS_INTEGER := 1;
      CHDELIMITER VARCHAR2(1):= SUBSTR(ICHDELIMITER, 1);
   BEGIN
      IF NVL(LENGTH(CHDELIMITER), 0) = 0 OR NVL(LENGTH(ISBSTRING), 0) = 0 THEN
         RETURN;
      END IF;

      LOOP
         NULPOS := NUPOS + 1;
         NUPOS  := INSTR (ISBSTRING, CHDELIMITER, NULPOS);

         IF NULPOS > 0 AND NUPOS = 0 THEN
            TBSTRING (NUCRT) := SUBSTR (ISBSTRING, NULPOS, LENGTH(ISBSTRING));
         END IF;

         EXIT WHEN NUPOS = 0;
	        TBSTRING (NUCRT) := SUBSTR (ISBSTRING, NULPOS, NUPOS - NULPOS);
         IF NUPOS = LENGTH (ISBSTRING) THEN
            TBSTRING (NUCRT + 1) := NULL;
         END IF;

         NUCRT := NUCRT + 1;
      END LOOP;
   EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20202, 'ExtString : '||SQLERRM);
   END EXTSTRING;

   PROCEDURE EXTPARAMETERS
   (
      ISBSTRING      IN VARCHAR2,
      ICHDELPARAM    IN VARCHAR2,
      ICHDELVALUE    IN VARCHAR2,
      IOTBPARAMETERS IN OUT NOCOPY TYTB_STRPARAMETERS,
      INUTHASH       IN NUMBER DEFAULT UT_STRING.FNUINDEX
   )  IS
      TBSTRING   TYTB_STRING;
      TBSVALUE   TYTB_STRING;
      NUPARAM    PLS_INTEGER := 0;
      NUPOS      PLS_INTEGER := 0;
      CHDELPARAM VARCHAR2(1) := SUBSTR(ICHDELPARAM, 1);
      CHDELVALUE VARCHAR2(1) := SUBSTR(ICHDELVALUE, 1);
   BEGIN

      IF NVL(LENGTH(CHDELPARAM), 0) = 0
      OR NVL(LENGTH(CHDELVALUE), 0) = 0
      OR NVL(LENGTH(ISBSTRING),  0) = 0
      THEN
         RETURN;
      END IF;

      EXTSTRING (ISBSTRING, CHDELPARAM, TBSTRING);

      IF TBSTRING.COUNT = 0 THEN
         RETURN;
      END IF;
      FOR NUPOS IN TBSTRING.FIRST..TBSTRING.LAST LOOP
         TBSVALUE.DELETE;
         EXTSTRING (TBSTRING(NUPOS), CHDELVALUE, TBSVALUE);

         IF TBSVALUE.COUNT = 2 THEN
            NUPARAM := FNUGETHASH_STRING(INUTHASH, NUPARAM, TBSVALUE(1), TBSVALUE(2));

            IOTBPARAMETERS(NUPARAM).SBPARAMETER := TBSVALUE(1);

            TBSVALUE(2) := REPLACE(TBSVALUE(2),'%61\','=');
            TBSVALUE(2) := REPLACE(TBSVALUE(2),'%59\',';');
            TBSVALUE(2) := REPLACE(TBSVALUE(2),'%37\','%'); 

            IOTBPARAMETERS(NUPARAM).SBVALUE     := TBSVALUE(2);
         END IF;
      END LOOP;
   EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20201, 'ExtParameters : '||SQLERRM);
   END EXTPARAMETERS;

   FUNCTION FBOTABLESTRTOKEN
   (
      ISBSTR          IN  VARCHAR2,
      ISBINITIALSCHAR IN  VARCHAR2,
      ISBSEPARATORS   IN  VARCHAR2,
      OTBSTRING       OUT NOCOPY UT_STRING.TYTB_STRING
   ) RETURN BOOLEAN
   IS
      SBTOKEN VARCHAR2(200);
      NUPOS   PLS_INTEGER := 1;
   BEGIN
      OTBSTRING.DELETE;

      LOOP
         IF NOT FBOSTRTOKEN(ISBSTR, ISBINITIALSCHAR, ISBSEPARATORS, SBTOKEN, NUPOS) THEN
            EXIT;
         END IF;

         OTBSTRING(OTBSTRING.COUNT + 1) := SBTOKEN;
         EXIT WHEN NUPOS >= LENGTH(ISBSTR);
      END LOOP;

      RETURN (OTBSTRING.COUNT > 0);
   END;

   FUNCTION FBOSTRTOKEN
   (
      ISBSTR          IN VARCHAR2,
      ISBINITIALSCHAR IN VARCHAR2,
      ISBSEPARATORS   IN VARCHAR2,
      OSBTOKEN        OUT VARCHAR2,
      IONUPOS         IN OUT NUMBER
   ) RETURN BOOLEAN
   IS
      SBCHAR VARCHAR2(1);
   BEGIN
      OSBTOKEN := '';

      IF IONUPOS > LENGTH(ISBSTR) THEN
         RETURN FALSE;
      END IF;

      WHILE IONUPOS < LENGTH(ISBSTR) LOOP
         SBCHAR := SUBSTR(ISBSTR, IONUPOS, 1);
         IF INSTR (ISBINITIALSCHAR, SBCHAR) > 0 THEN 
            WHILE INSTR(ISBSEPARATORS, SUBSTR(ISBSTR, IONUPOS, 1)) = 0 LOOP
               OSBTOKEN := OSBTOKEN||SUBSTR(ISBSTR, IONUPOS, 1);
               IONUPOS   := IONUPOS + 1;

               IF IONUPOS > LENGTH(ISBSTR) THEN
                  EXIT;
               END IF;
             END LOOP;
         END IF;

         IF LENGTH(OSBTOKEN) > 0 THEN
            EXIT;
         END IF;

         IONUPOS   := IONUPOS + 1;
      END LOOP;

      RETURN (NOT OSBTOKEN IS NULL AND LENGTH(OSBTOKEN) > 0);
   END ;

   FUNCTION FINDPARAMETERVALUE
   (
      ISBSTRING   IN VARCHAR2,
      ISBFIND     IN VARCHAR2,
      ICHDELPARAM IN VARCHAR2,
      ICHDELVALUE IN VARCHAR2,
      OSBVALUE    IN OUT NOCOPY VARCHAR2
   ) RETURN BOOLEAN
   IS
      TBSTRING   UT_STRING.TYTB_STRING;
      NUINDICE   PLS_INTEGER;
   BEGIN
      SBTEMPORAL := ICHDELPARAM||ISBSTRING;
      NUINDICE   := INSTR(SBTEMPORAL, ICHDELPARAM||ISBFIND||ICHDELVALUE);
      
      IF NUINDICE = 0 THEN
         RETURN FALSE;
      END IF;

      SBTEMPORAL := SUBSTR(SBTEMPORAL, NUINDICE + 1, LENGTH(SBTEMPORAL));
      NUINDICE   := INSTR(SBTEMPORAL, ICHDELPARAM) - 1;

      IF NUINDICE <= 0 THEN
         NUINDICE := LENGTH(SBTEMPORAL);
      END IF;

      SBTEMPORAL := SUBSTR(SBTEMPORAL, 1, NUINDICE);

      UT_STRING.EXTSTRING (SBTEMPORAL, ICHDELVALUE, TBSTRING);

      IF TBSTRING.COUNT = 0 THEN
         RETURN FALSE;
      END IF;

      OSBVALUE := TBSTRING(2);

      RETURN TRUE;
   EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20202, 'FindParameterValue : '||SQLERRM);
   END FINDPARAMETERVALUE;

   FUNCTION STRREPLACE
   (
      ISBSTRING  IN VARCHAR2,
      ISBFIND    IN VARCHAR2,
      ISBREPLACE IN VARCHAR2
   ) RETURN VARCHAR2
   IS
   BEGIN
      IF INSTR(ISBSTRING, ISBFIND) = 0 THEN
         RETURN(ISBSTRING);
      END IF;

      RETURN REPLACE (ISBSTRING, ISBFIND, ISBREPLACE);
   EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20202, 'StrReplace : '||SQLERRM);
   END STRREPLACE;

   FUNCTION PARSESTRPARAMETER
   (
     ISBSTRING    IN VARCHAR2,
     ISBTOKEN     IN VARCHAR2,
     ISBARGUMENT  IN VARCHAR2
   ) RETURN VARCHAR2
   IS
	  TBSTR UT_STRING.TYTB_STRING;
   BEGIN
      SBTEMPORAL := ISBSTRING;
      
      UT_STRING.EXTSTRING (ISBARGUMENT,  '|',  TBSTR);

      FOR NUINDEX IN 1..TBSTR.COUNT
      LOOP
         SBTEMPORAL := STRREPLACE(SBTEMPORAL, ISBTOKEN||TO_CHAR(NUINDEX), TBSTR(NUINDEX));
      END LOOP;

      RETURN (SBTEMPORAL);
   EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20202, 'ParseStrParameter : '||SQLERRM);
   END PARSESTRPARAMETER;

   



   FUNCTION  FSBGETNEXTWORD
   (
      ISBSENTENCIA IN VARCHAR2,
      ISBSEPARADOR IN VARCHAR2
   )
   RETURN VARCHAR2
   IS
   BEGIN
      IF INSTR( ISBSENTENCIA,ISBSEPARADOR) > 1 THEN
         RETURN(SUBSTR(ISBSENTENCIA, 1, INSTR(ISBSENTENCIA,ISBSEPARADOR) - 1));
      ELSE
         RETURN( ISBSENTENCIA );
      END IF;
   END;

   



   FUNCTION FSBCUTNEXTWORD
   (
      ISBSENTENCIA  IN VARCHAR2,
      ISBSEPARADOR  IN VARCHAR2
   )
   RETURN  VARCHAR2
   IS
   BEGIN
      IF INSTR(ISBSENTENCIA, ISBSEPARADOR) > 0 THEN
         RETURN SUBSTR(ISBSENTENCIA, INSTR(ISBSENTENCIA, ISBSEPARADOR) + 1 ,
                       LENGTH(ISBSENTENCIA));
      ELSE
         RETURN (ISBSENTENCIA);
      END IF;
   END;

   FUNCTION FNUCATNUMBER(INUN1 IN NUMBER, INUN2 NUMBER) RETURN NUMBER IS
   BEGIN
      RETURN TO_NUMBER(TO_CHAR(ABS(INUN1))||TO_CHAR(ABS(INUN2)));
   END;

   FUNCTION FSBCONCAT (ISBSTR1 IN VARCHAR2,
                       ISBSTR2 IN VARCHAR2,
                       ISBSEPARATOR IN VARCHAR2 DEFAULT '')
   RETURN VARCHAR2
   IS
   BEGIN
    RETURN ISBSTR1||ISBSEPARATOR||ISBSTR2;
   END;

   FUNCTION EXTSTRFIELD
   (
      ISBCADENA IN  VARCHAR2,
      ICHDEL    IN  VARCHAR2,
      INUFIELD  IN  NUMBER
   )
   RETURN VARCHAR2 IS
      SBFIELD  VARCHAR2(2048);
      NUOCURR  PLS_INTEGER := 0;
      NUFIELD  PLS_INTEGER := INUFIELD;
   BEGIN
      SBFIELD := NULL;
      NUFIELD := NUFIELD  - 1;

      FOR NUI IN 1..LENGTH(ISBCADENA)
      LOOP
          IF SUBSTR(ISBCADENA, NUI, 1) = ICHDEL THEN
             NUOCURR := NUOCURR + 1;
          ELSIF NUOCURR = NUFIELD THEN
             SBFIELD := SBFIELD||SUBSTR(ISBCADENA, NUI, 1);
          END IF;
      END LOOP;
      
      RETURN SBFIELD;
    END;

   FUNCTION GETPARAMETERVALUE
   (
      ISBSTRING   IN VARCHAR2,
      ISBFIND     IN VARCHAR2,
      ICHDELPARAM IN VARCHAR2 DEFAULT ';',
      ICHDELVALUE IN VARCHAR2 DEFAULT '='
   ) RETURN VARCHAR2 IS
      BLEXISTE BOOLEAN;
      SBVALUE  VARCHAR2(2048);
   BEGIN
      BLEXISTE := UT_STRING.FINDPARAMETERVALUE(ISBSTRING,ISBFIND,ICHDELPARAM,ICHDELVALUE,SBVALUE);
      RETURN SBVALUE;
   END;

    
    FUNCTION FSBDELETESUBSTRINGINSTRING
    (
        ISBSTRING      IN VARCHAR2,
        ISBSUBSTRTODEL IN VARCHAR2,
        IBLFINDFORWARD IN BOOLEAN DEFAULT TRUE
    )
    RETURN VARCHAR2
    IS
        
        
        
        SBFINALSTRING VARCHAR2(4000) := NULL;
        NUSUBSTRLEN   PLS_INTEGER; 
        NUSUBSTRPOS   PLS_INTEGER; 
    BEGIN
        IF (LENGTH(ISBSTRING) = 0) THEN
            RETURN ISBSTRING;
        END IF;
        
        NUSUBSTRLEN := LENGTH(ISBSUBSTRTODEL);
        IF (NUSUBSTRLEN = 0) THEN
            RETURN ISBSTRING;
        END IF;

        
        IF (IBLFINDFORWARD) THEN
            
            NUSUBSTRPOS := INSTR(ISBSTRING, ISBSUBSTRTODEL);
        ELSE
            
            NUSUBSTRPOS := INSTR(ISBSTRING, ISBSUBSTRTODEL, -1);
        END IF;

        SBFINALSTRING := SUBSTR(ISBSTRING, 1, NUSUBSTRPOS-1)||
                         SUBSTR(ISBSTRING,NUSUBSTRPOS + NUSUBSTRLEN,LENGTH(ISBSTRING));
        RETURN (SBFINALSTRING);
    EXCEPTION
        WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR (-20202, 'fsbDeleteSubstringInString : '||SQLERRM);
    END FSBDELETESUBSTRINGINSTRING;

    FUNCTION FSBSTRINGFROMTABLE
    (
        ITBSTRING    IN  TYTB_STRING,
        ISBDELIMITER IN  VARCHAR2
    )
    RETURN VARCHAR2
    IS
        
        
        
        NUINDEX  BINARY_INTEGER := 0;
        SBSTRING VARCHAR2(4000) := NULL;
    BEGIN
        SBSTRING := NULL;
        IF (ITBSTRING.COUNT = 0) THEN
            RETURN SBSTRING;
        END IF;
        NUINDEX := ITBSTRING.FIRST;
        LOOP
            SBSTRING := SBSTRING || ITBSTRING(NUINDEX)||ISBDELIMITER;
            EXIT WHEN (NUINDEX = ITBSTRING.LAST);
            NUINDEX := ITBSTRING.NEXT(NUINDEX);
        END LOOP;
        
        SBSTRING := UT_STRING.FSBDELETESUBSTRINGINSTRING(SBSTRING,
                                                         ISBDELIMITER, FALSE);
        RETURN SBSTRING;
    EXCEPTION
      WHEN OTHERS THEN
           RAISE_APPLICATION_ERROR (-20202, 'fsbStringFromTable : '||SQLERRM);
    END FSBSTRINGFROMTABLE;

    FUNCTION FSBCATARGUMENTS
    (
       ISBSTR1 IN VARCHAR2, ISBSTR2 IN VARCHAR2 DEFAULT NULL
    )
    RETURN VARCHAR2
    IS
    BEGIN
       IF ISBSTR2 IS NULL THEN
          RETURN ISBSTR1;
       ELSE
          RETURN ISBSTR1||'|'||ISBSTR2;
       END IF;
    END;


    FUNCTION FSBCATSTRING
    (
       ISBSTR1 IN VARCHAR2, ISBSTR2 IN VARCHAR2 DEFAULT NULL
    )
    RETURN VARCHAR2
    IS
    BEGIN
       IF ISBSTR2 IS NULL THEN
          RETURN ISBSTR1;
       ELSE
          RETURN ISBSTR1||ISBSTR2;
       END IF;
    END;

    FUNCTION FBOISDIFERENT
    (
       ISBSTR1 IN VARCHAR2, ISBSTR2 IN VARCHAR2
    )
    RETURN BOOLEAN
    IS
    BEGIN
        IF ISBSTR1 <> ISBSTR2 OR
           ISBSTR1 IS NULL AND ISBSTR2 IS NOT NULL OR
           ISBSTR2 IS NULL AND ISBSTR1 IS NOT NULL THEN
           RETURN(TRUE);
        ELSE
           RETURN(FALSE);
        END IF;
    END;
    
    FUNCTION FSBSUBSTR
    (
       ISBSTR1 IN VARCHAR2, INUPOS IN NUMBER, INULEN IN NUMBER
    )
    RETURN VARCHAR2
    IS
    BEGIN
         RETURN(SUBSTR( ISBSTR1, INUPOS, INULEN));
    EXCEPTION
        WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR (-20202, 'UT_STRING.fbSubstr : '||SQLERRM);
    END;
    
    FUNCTION FSBUPPER
    (
       ISBSTR1 IN VARCHAR2
    )
    RETURN VARCHAR2
    IS
    BEGIN
       IF  ISBSTR1 IS NOT NULL THEN
          RETURN UPPER(ISBSTR1);

       END IF;
    END;
    
    FUNCTION FSBINSTR
    (
       ISBSTR1 IN VARCHAR2, ISBSTR2 IN VARCHAR2, INUPOS IN INTEGER,  INUOCCUR IN NUMBER
    )
    RETURN NUMBER
    IS
    BEGIN
       IF ISBSTR1 IS NOT NULL AND ISBSTR2 IS NOT NULL AND
           INUPOS IS NOT NULL AND INUOCCUR IS NOT NULL
        THEN
          RETURN INSTR(ISBSTR1,ISBSTR2,INUPOS,INUOCCUR);

       END IF;
    END;

    
    FUNCTION FSBCONCATSTRING
    (
        ISBVALUE1    VARCHAR2,
        ISBVALUE2    VARCHAR2,
        ISBSEPARATOR VARCHAR2
    )
    RETURN VARCHAR2
    IS
    BEGIN
        IF (ISBVALUE2 IS NULL) THEN
            RETURN ISBVALUE1;
        END IF;
        RETURN ISBVALUE1||ISBSEPARATOR||ISBVALUE2;
    END FSBCONCATSTRING;
    















    FUNCTION FNUINSTR
    (
       ISBSTR1      IN VARCHAR2,
       ISBSTR2      IN VARCHAR2,
       ISBALLSTR    IN VARCHAR2 DEFAULT NULL,
       ISBDELIMITER IN VARCHAR2 DEFAULT NULL
    )
    RETURN NUMBER
    IS
    BEGIN
        IF  (ISBSTR1 = ISBALLSTR) THEN
            RETURN 1;
        ELSE
            IF  (ISBDELIMITER IS NULL) THEN
                RETURN INSTR(ISBSTR1, ISBSTR2);
            ELSE
                RETURN INSTR(ISBDELIMITER || ISBSTR1 || ISBDELIMITER, ISBDELIMITER || ISBSTR2 || ISBDELIMITER);
            END IF;
       END IF;
    END FNUINSTR;
    
    
























    FUNCTION LISTAGG
    (
        IRFVALUES IN SYS_REFCURSOR,
        ISBDELIM  IN VARCHAR2
    )
    RETURN VARCHAR2
    IS
        SBVALUE  VARCHAR2(32767);
        SBRETURN VARCHAR2(32767);

    BEGIN
        LOOP
            FETCH IRFVALUES INTO SBVALUE;

            IF IRFVALUES%NOTFOUND THEN
                EXIT;
            END IF;

            SBRETURN := SBRETURN || ISBDELIM || SBVALUE;
        END LOOP;
        
        CLOSE IRFVALUES;
        
        IF LENGTH(SBRETURN) > 0 THEN
            SBRETURN := SUBSTR(SBRETURN, 2);
        END IF;
        
        RETURN SBRETURN;
    END;

    













    FUNCTION FNULENGTH
    (
        ISBSTRING   IN  VARCHAR2
    )
    RETURN NUMBER
    IS
    BEGIN
        RETURN LENGTH(ISBSTRING);
    END FNULENGTH;
    
    
























    FUNCTION FSBGETDATABYPOSITION
    (
        ISBSTRING       IN VARCHAR2,
        ICHDELIMITER    IN VARCHAR2,
        INUPOSITION     IN NUMBER
    )
    RETURN VARCHAR2
    IS
        SBERRMSG  VARCHAR2(2000);

        TBSTRING    UT_STRING.TYTB_STRING;

    BEGIN

        PKERRORS.PUSH('UT_STRING.fsbGetAdditionalData');

        
        UT_STRING.EXTSTRING(ISBSTRING,ICHDELIMITER,TBSTRING);

        
        IF (NOT TBSTRING.EXISTS(INUPOSITION))THEN
            PKERRORS.POP;
            RETURN '';
        END IF;

        PKERRORS.POP;
        RETURN(TBSTRING(INUPOSITION));
            EXCEPTION
            WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
    	        PKERRORS.POP;
    	        RAISE;

            WHEN OTHERS THEN
    	        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
    	        PKERRORS.POP;
    	        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
    END FSBGETDATABYPOSITION;

END UT_STRING;