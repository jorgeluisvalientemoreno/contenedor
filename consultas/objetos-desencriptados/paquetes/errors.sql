CREATE OR REPLACE PACKAGE BODY ERRORS IS
   CURSOR CUMESSAGE( INUCODE IN GE_MESSAGE.MESSAGE_ID%TYPE ) IS
SELECT message_id,description,use_argument,error_level
	FROM ge_message
	WHERE message_id = inuCode;
   SUBTYPE TYRCGE_MESSAGE IS CUMESSAGE%ROWTYPE;
   TYPE TYTBMESSAGES IS TABLE OF TYRCGE_MESSAGE INDEX BY BINARY_INTEGER;
   TYPE TY_SBTOBJECT IS TABLE OF VARCHAR2( 20 ) INDEX BY BINARY_INTEGER;
   TYPE TYTB_STRING IS TABLE OF VARCHAR2( 32767 ) INDEX BY BINARY_INTEGER;
   CSBREPSTRING CONSTANT VARCHAR2( 2 ) := '%s';
   CNUMAX_LEN_MSG CONSTANT PLS_INTEGER := 980;
   CNUERRORSEXCEPTION CONSTANT PLS_INTEGER := -20100;
   CNUN_EXIST_MESSAGE CONSTANT PLS_INTEGER := 8;
   CNUEXIST_MESSAGEAPP CONSTANT PLS_INTEGER := 12;
   CNUMSG_SET_ERR_N_EXIST CONSTANT PLS_INTEGER := 9;
   CNUN_EXIST_PARAMETER CONSTANT PLS_INTEGER := 10;
   CNUN_CR_SEQUENCE CONSTANT PLS_INTEGER := 11;
   CNUREPORTERROR CONSTANT PLS_INTEGER := 15;
   CSBYES CONSTANT VARCHAR2( 1 ) := 'Y';
   CSBUNATTENDEDERROR CONSTANT VARCHAR2( 20 ) := 'UNATTENDED_ERROR';
   CSBMAX_REPORT_ERR_LEVEL CONSTANT VARCHAR2( 20 ) := 'MAX_REPORT_ERR_LEVEL';
   CSBORACLE_ERROR_LEVEL CONSTANT VARCHAR2( 20 ) := 'ORACLE_ERROR_LEVEL';
   CSBMETHOD_IN_CALL_STACK CONSTANT VARCHAR2( 20 ) := 'METHOD_IN_CALL_STACK';
   CSBSEQGE_ERROR_LOG CONSTANT VARCHAR2( 20 ) := 'seq_ge_error_log';
   NUERRORSTATUS GE_ERROR_LOG.STATUS%TYPE;
   NUMAX_REPORT_ERR_LEVEL GE_MESSAGE.ERROR_LEVEL%TYPE;
   NUORACLE_ERROR_LEVEL GE_MESSAGE.ERROR_LEVEL%TYPE;
   SBMESSAGEDESCRIPTION GE_MESSAGE.DESCRIPTION%TYPE;
   BLENVIRONMENT_OK BOOLEAN := FALSE;
   BLLOAD BOOLEAN := FALSE;
   SBTEMPORAL VARCHAR2( 32767 );
   TSBTOBJ TY_SBTOBJECT;
   SBAPPLICATION VARCHAR2( 100 );
   SBNEXIST_MESSAGEAPP VARCHAR2( 256 );
   SBERRORLOCAL VARCHAR2( 2000 );
   RCGE_MESSAGE TYRCGE_MESSAGE;
   BLBSSERROR BOOLEAN;
   SBDB_USER VARCHAR2( 255 );
   SBOS_USER VARCHAR2( 255 );
   SBSESSION_ID VARCHAR2( 255 );
   SBMACHINE VARCHAR2( 255 );
   SBTERMINAL VARCHAR2( 255 );
   SBCLIENT_IP VARCHAR2( 255 );
   TBMESSAGES_CACHE TYTBMESSAGES;
   PROCEDURE SET_PUSH_DB_OFF
    IS
    BEGIN
      BOPUSH_DB := FALSE;
   END;
   PROCEDURE SET_PUSH_DB_ON
    IS
    BEGIN
      BOPUSH_DB := TRUE;
   END;
   FUNCTION FSBVERSION
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN CSBVERSION;
   END;
   FUNCTION STRREPLACE( ISBSTRING IN VARCHAR2, ISBFIND IN VARCHAR2, ISBREPLACE IN VARCHAR2 )
    RETURN VARCHAR2
    IS
    BEGIN
      IF ( INSTR( ISBSTRING, ISBFIND ) = 0 ) THEN
         RETURN ( ISBSTRING );
      END IF;
      RETURN REPLACE( ISBSTRING, ISBFIND, ISBREPLACE );
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20202, 'StrReplace : ' || SQLERRM );
   END STRREPLACE;
   PROCEDURE EXTSTRING( ISBSTRING IN VARCHAR2, ICHDELIMITER IN VARCHAR2, TBSTRING IN OUT NOCOPY TYTB_STRING )
    IS
      NULPOS PLS_INTEGER;
      NUPOS PLS_INTEGER := 0;
      NUCRT PLS_INTEGER := 1;
      CHDELIMITER VARCHAR2( 1 ) := SUBSTR( ICHDELIMITER, 1 );
    BEGIN
      IF ( NVL( LENGTH( CHDELIMITER ), 0 ) = 0 OR NVL( LENGTH( ISBSTRING ), 0 ) = 0 ) THEN
         RETURN;
      END IF;
      LOOP
         NULPOS := NUPOS + 1;
         NUPOS := INSTR( ISBSTRING, CHDELIMITER, NULPOS );
         IF ( NULPOS > 0 AND NUPOS = 0 ) THEN
            TBSTRING( NUCRT ) := SUBSTR( ISBSTRING, NULPOS, LENGTH( ISBSTRING ) );
         END IF;
         EXIT WHEN NUPOS = 0;
         TBSTRING( NUCRT ) := SUBSTR( ISBSTRING, NULPOS, NUPOS - NULPOS );
         IF ( NUPOS = LENGTH( ISBSTRING ) ) THEN
            TBSTRING( NUCRT + 1 ) := NULL;
         END IF;
         NUCRT := NUCRT + 1;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20202, 'ExtString : ' || SQLERRM );
   END EXTSTRING;
   FUNCTION PARSESTRPARAMETER( ISBSTRING IN VARCHAR2, ISBTOKEN IN VARCHAR2, ISBARGUMENT IN VARCHAR2 )
    RETURN VARCHAR2
    IS
      TBSTR TYTB_STRING;
    BEGIN
      SBTEMPORAL := ISBSTRING;
      EXTSTRING( ISBARGUMENT, '|', TBSTR );
      FOR NUINDEX IN 1..TBSTR.COUNT
       LOOP
         SBTEMPORAL := STRREPLACE( SBTEMPORAL, ISBTOKEN || TO_CHAR( NUINDEX ), TBSTR( NUINDEX ) );
      END LOOP;
      RETURN ( SBTEMPORAL );
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20202, 'ParseStrParameter : ' || SQLERRM );
   END PARSESTRPARAMETER;
   FUNCTION FBOVALIDOBJECT( ISBOBJECT IN VARCHAR2 )
    RETURN BOOLEAN
    IS
      CURSOR CUOBJECT( SBOBJECT IN USER_OBJECTS.OBJECT_NAME%TYPE ) IS
SELECT object_name
       FROM user_objects
       WHERE object_name = upper( sbObject )
         AND status = 'VALID';
      CURSOR CUVW_GE_USER_ARGUMENTS( SBPACKAGE IN USER_OBJECTS.OBJECT_NAME%TYPE, SBARGUMENT IN USER_OBJECTS.OBJECT_NAME%TYPE ) IS
SELECT object_name
       FROM vw_ge_user_arguments
       WHERE package_name = upper( sbPackage )
         AND object_name  = upper( sbArgument );
      CURSOR CUUSER_ARGUMENTS( SBPACKAGE IN USER_OBJECTS.OBJECT_NAME%TYPE, SBARGUMENT IN USER_OBJECTS.OBJECT_NAME%TYPE ) IS
SELECT DISTINCT ( SBOBJECTNAME )
       FROM TABLE (
           CAST( UT_DESCRIBE.ftbObjectDescribe( UPPER( sbPackage ) || '.' || UPPER( sbArgument ) ) AS GE_TYTB_DESCRIBE )
       );
      SBNAME USER_OBJECTS.OBJECT_NAME%TYPE := NULL;
      SBFIRSTNAME USER_OBJECTS.OBJECT_NAME%TYPE := NULL;
      SBLASTNAME USER_OBJECTS.OBJECT_NAME%TYPE := NULL;
      BLARGUMENT BOOLEAN := FALSE;
      BLEXISTARGUMENT BOOLEAN := TRUE;
      FUNCTION FSBGETNEXTWORD( ISBSENTENCIA IN VARCHAR2, ISBSEPARADOR IN VARCHAR2 )
       RETURN VARCHAR2
       IS
       BEGIN
         IF ( INSTR( ISBSENTENCIA, ISBSEPARADOR ) > 1 ) THEN
            RETURN ( SUBSTR( ISBSENTENCIA, 1, INSTR( ISBSENTENCIA, ISBSEPARADOR ) - 1 ) );
          ELSE
            RETURN ( ISBSENTENCIA );
         END IF;
      END;
      FUNCTION FSBCUTNEXTWORD( ISBSENTENCIA IN VARCHAR2, ISBSEPARADOR IN VARCHAR2 )
       RETURN VARCHAR2
       IS
       BEGIN
         IF ( INSTR( ISBSENTENCIA, ISBSEPARADOR ) > 0 ) THEN
            RETURN SUBSTR( ISBSENTENCIA, INSTR( ISBSENTENCIA, ISBSEPARADOR ) + 1, LENGTH( ISBSENTENCIA ) );
          ELSE
            RETURN ( ISBSENTENCIA );
         END IF;
      END;
    BEGIN
      SBFIRSTNAME := ISBOBJECT;
      IF ( INSTR( ISBOBJECT, '.' ) > 0 ) THEN
         SBFIRSTNAME := FSBGETNEXTWORD( ISBOBJECT, '.' );
         SBLASTNAME := FSBCUTNEXTWORD( ISBOBJECT, '.' );
         BLARGUMENT := TRUE;
      END IF;
      OPEN CUOBJECT( SBFIRSTNAME );
      FETCH CUOBJECT
         INTO SBNAME;
      IF ( CUOBJECT%NOTFOUND ) THEN
         CLOSE CUOBJECT;
         RETURN FALSE;
      END IF;
      CLOSE CUOBJECT;
      BLEXISTARGUMENT := TRUE;
      IF ( BLARGUMENT ) THEN
         OPEN CUVW_GE_USER_ARGUMENTS( SBFIRSTNAME, SBLASTNAME );
         FETCH CUVW_GE_USER_ARGUMENTS
            INTO SBNAME;
         BLEXISTARGUMENT := CUVW_GE_USER_ARGUMENTS%FOUND;
         CLOSE CUVW_GE_USER_ARGUMENTS;
         IF NOT ( BLEXISTARGUMENT ) THEN
            OPEN CUUSER_ARGUMENTS( SBFIRSTNAME, SBLASTNAME );
            FETCH CUUSER_ARGUMENTS
               INTO SBNAME;
            BLEXISTARGUMENT := CUUSER_ARGUMENTS%FOUND;
            CLOSE CUUSER_ARGUMENTS;
         END IF;
      END IF;
      RETURN BLEXISTARGUMENT;
    EXCEPTION
      WHEN OTHERS THEN
         RETURN FALSE;
   END;
   FUNCTION VALID_LENMSG( ISBMESSAGE IN VARCHAR2 )
    RETURN VARCHAR2
    IS
    BEGIN
      IF ( LENGTH( ISBMESSAGE ) > CNUMAX_LEN_MSG ) THEN
         RETURN ( SUBSTR( ISBMESSAGE, 1, CNUMAX_LEN_MSG ) || '>..' );
      END IF;
      RETURN ISBMESSAGE;
   END;
   PROCEDURE INITVARCONTEXT
    IS
    BEGIN
      BLENVIRONMENT_OK := TRUE;
      SBDB_USER := SYS_CONTEXT( 'USERENV', 'CURRENT_USER' );
      SBOS_USER := SYS_CONTEXT( 'USERENV', 'OS_USER' );
      SBSESSION_ID := SYS_CONTEXT( 'USERENV', 'SESSIONID' );
      SBMACHINE := SYS_CONTEXT( 'USERENV', 'HOST' );
      SBTERMINAL := SYS_CONTEXT( 'USERENV', 'TERMINAL' );
      SBCLIENT_IP := SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' );
    EXCEPTION
      WHEN OTHERS THEN
         BLENVIRONMENT_OK := FALSE;
   END;
   FUNCTION EXISTMESSAGE( INUMESSAGE_ID IN GE_MESSAGE.MESSAGE_ID%TYPE, OSBDESCRIPTION OUT GE_MESSAGE.DESCRIPTION%TYPE )
    RETURN BOOLEAN
    IS
    BEGIN
      IF ( TBMESSAGES_CACHE.EXISTS( INUMESSAGE_ID ) = TRUE ) THEN
         RCGE_MESSAGE := TBMESSAGES_CACHE( INUMESSAGE_ID );
       ELSE
         OPEN CUMESSAGE( INUMESSAGE_ID );
         FETCH CUMESSAGE
            INTO RCGE_MESSAGE;
         IF ( CUMESSAGE%NOTFOUND ) THEN
            CLOSE CUMESSAGE;
            OSBDESCRIPTION := NULL;
            RETURN FALSE;
         END IF;
         CLOSE CUMESSAGE;
         TBMESSAGES_CACHE( INUMESSAGE_ID ) := RCGE_MESSAGE;
      END IF;
      OSBDESCRIPTION := RCGE_MESSAGE.DESCRIPTION;
      RETURN TRUE;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.ExisteMessage:' || SQLERRM );
   END;
   PROCEDURE CHECKMESSAGES( OSBINTERNALERROR OUT VARCHAR2 )
    IS
      NUMESSAGECODE GE_MESSAGE.MESSAGE_ID%TYPE;
    BEGIN
      BLENVIRONMENT_OK := TRUE;
      IF ( NOT EXISTMESSAGE( CNUN_EXIST_MESSAGE, SBMESSAGEDESCRIPTION ) ) THEN
         OSBINTERNALERROR := 'Errors.CheckMessages: The required message with code (' || CNUN_EXIST_MESSAGE || ') could not be found ';
         BLENVIRONMENT_OK := FALSE;
         RETURN;
      END IF;
      SBNEXIST_MESSAGEAPP := SBMESSAGEDESCRIPTION;
      IF NOT ( EXISTMESSAGE( CNUMSG_SET_ERR_N_EXIST, SBMESSAGEDESCRIPTION ) ) THEN
         NUMESSAGECODE := CNUMSG_SET_ERR_N_EXIST;
       ELSIF NOT ( EXISTMESSAGE( CNUN_CR_SEQUENCE, SBMESSAGEDESCRIPTION ) ) THEN
         NUMESSAGECODE := CNUN_CR_SEQUENCE;
       ELSIF NOT ( EXISTMESSAGE( CNUEXIST_MESSAGEAPP, SBMESSAGEDESCRIPTION ) ) THEN
         NUMESSAGECODE := CNUEXIST_MESSAGEAPP;
       ELSIF NOT ( EXISTMESSAGE( CNUN_EXIST_PARAMETER, SBMESSAGEDESCRIPTION ) ) THEN
         NUMESSAGECODE := CNUN_EXIST_PARAMETER;
       ELSIF NOT ( EXISTMESSAGE( CNUREPORTERROR, SBMESSAGEDESCRIPTION ) ) THEN
         NUMESSAGECODE := CNUREPORTERROR;
      END IF;
      IF ( NUMESSAGECODE IS NOT NULL ) THEN
         OSBINTERNALERROR := PARSESTRPARAMETER( 'Errors.CheckMessages: ' || SBERRORMESSAGE, CSBREPSTRING, NUMESSAGECODE );
         BLENVIRONMENT_OK := FALSE;
      END IF;
   END;
   FUNCTION GETNEXT( ISBSEQUENCENAME IN VARCHAR2 )
    RETURN PLS_INTEGER
    IS
      NUNEXT PLS_INTEGER;
    BEGIN
      EXECUTE IMMEDIATE 'select ' || ISBSEQUENCENAME || '.nextval from dual'
                        INTO NUNEXT;
      RETURN NUNEXT;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.GetNext: ' || SQLERRM );
   END;
   FUNCTION EXISTPARAMETER( ISBPARAMETER_ID IN GE_PARAMETER.PARAMETER_ID%TYPE, ONUVALUE OUT NOCOPY PLS_INTEGER )
    RETURN BOOLEAN
    IS
      CURSOR CUPARAMETER( ISBPARAMETER_ID IN GE_PARAMETER.PARAMETER_ID%TYPE ) IS
SELECT value, data_type
        FROM ge_parameter
        WHERE parameter_id = isbparameter_id;
      RCPARAMETER CUPARAMETER%ROWTYPE;
      BLEXIST BOOLEAN := FALSE;
    BEGIN
      ONUVALUE := NULL;
      OPEN CUPARAMETER( ISBPARAMETER_ID );
      FETCH CUPARAMETER
         INTO RCPARAMETER;
      IF ( CUPARAMETER%FOUND ) THEN
         IF ( RCPARAMETER.DATA_TYPE = 'NUMBER' ) THEN
            ONUVALUE := TO_NUMBER( RCPARAMETER.VALUE );
         END IF;
         BLEXIST := TRUE;
      END IF;
      CLOSE CUPARAMETER;
      RETURN BLEXIST;
   END;
   FUNCTION FNUERRORLOG
    RETURN PLS_INTEGER
    IS
      NUNEXT PLS_INTEGER;
    BEGIN
      NUNEXT := GETNEXT( CSBSEQGE_ERROR_LOG );
      RETURN NUNEXT;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.fnuge_error_log: ' || SQLERRM );
   END;
   FUNCTION BOGET_TYPEOBJECTSTACK( ISBSTR IN VARCHAR2, OSBTYPE OUT VARCHAR2, ONULINE OUT PLS_INTEGER, ONUPOS OUT PLS_INTEGER )
    RETURN BOOLEAN
    IS
      NUPOS PLS_INTEGER := 0;
      NUPLINE PLS_INTEGER := 0;
      NULEN PLS_INTEGER := 0;
      NUI PLS_INTEGER;
    BEGIN
      NUPLINE := INSTR( ISBSTR, ' ', 2 );
      FOR NUI IN 1..5
       LOOP
         NUPOS := INSTR( ISBSTR, TSBTOBJ( NUI ) );
         IF ( NUPOS > 0 ) THEN
            NULEN := LENGTH( TSBTOBJ( NUI ) );
            ONULINE := TO_NUMBER( SUBSTR( ISBSTR, NUPLINE, NUPOS - NUPLINE ) );
            ONUPOS := NUPOS + NULEN + 1;
            OSBTYPE := SUBSTR( ISBSTR, NUPOS, NULEN );
            RETURN TRUE;
         END IF;
      END LOOP;
      RETURN FALSE;
   END;
   PROCEDURE PARSER_STACK_ERROR( IOSBSTACK IN OUT VARCHAR2, OSBLASTOBJECT OUT VARCHAR2 )
    IS
      NUINDEX NUMBER;
      NULENGTH NUMBER;
      NUEND NUMBER;
      NULINENUM NUMBER;
      NUCALLORDER NUMBER := 1;
      SBHANDLE VARCHAR2( 20 );
      SBOBJECTNAME VARCHAR2( 80 );
      SBCALL VARCHAR2( 100 );
      SBCALLSTACK VARCHAR2( 32767 );
      CSBANONYMOUSBLOCK CONSTANT VARCHAR2( 15 ) := 'anonymous block';
      CSBPKERRORS CONSTANT VARCHAR2( 8 ) := 'PKERRORS';
      CSBERRORS CONSTANT VARCHAR2( 6 ) := 'ERRORS';
      SBNEWLINE CONSTANT CHAR( 1 ) := CHR( 10 );
    BEGIN
      SBCALLSTACK := DBMS_UTILITY.FORMAT_CALL_STACK;
      NUINDEX := INSTR( SBCALLSTACK, 'name' ) + 5;
      OSBLASTOBJECT := NULL;
      WHILE NUINDEX < LENGTH( SBCALLSTACK )
       LOOP
         NUEND := INSTR( SBCALLSTACK, SBNEWLINE, NUINDEX );
         SBCALL := SUBSTR( SBCALLSTACK, NUINDEX, NUEND - NUINDEX );
         NUINDEX := NUINDEX + LENGTH( SBCALL ) + 1;
         SBCALL := LTRIM( SBCALL );
         SBHANDLE := SUBSTR( SBCALL, 1, INSTR( SBCALL, ' ' ) );
         SBCALL := SUBSTR( SBCALL, LENGTH( SBHANDLE ) + 1 );
         SBCALL := LTRIM( SBCALL );
         NULINENUM := TO_NUMBER( SUBSTR( SBCALL, 1, INSTR( SBCALL, ' ' ) ) );
         SBCALL := SUBSTR( SBCALL, LENGTH( NULINENUM ) + 1 );
         SBCALL := LTRIM( SBCALL );
         SBOBJECTNAME := SBCALL;
         IF ( NUCALLORDER > 1 AND INSTR( SBOBJECTNAME, CSBANONYMOUSBLOCK ) = 0 AND INSTR( SBOBJECTNAME, CSBPKERRORS ) = 0 AND INSTR( SBOBJECTNAME, CSBERRORS ) = 0 ) THEN
            IOSBSTACK := IOSBSTACK || SBOBJECTNAME || '(' || TO_CHAR( NULINENUM ) || ')' || SBNEWLINE;
            IF ( OSBLASTOBJECT IS NULL ) THEN
               OSBLASTOBJECT := SBOBJECTNAME || '(' || TO_CHAR( NULINENUM ) || ')';
            END IF;
         END IF;
         NUCALLORDER := NUCALLORDER + 1;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Parser_Stack_Error : ' || '-' || SQLERRM );
   END;
   PROCEDURE CREATESEQUENCE( ISBSEQUENCENAME IN VARCHAR2, INUINITIALNUMBER IN PLS_INTEGER := 1 )
    IS
      SBSQLCOMMAND VARCHAR2( 200 );
    BEGIN
      SBSQLCOMMAND := 'CREATE SEQUENCE ' || ISBSEQUENCENAME || ' START WITH ' || TO_CHAR( INUINITIALNUMBER ) || '1 INCREMENT BY 1 ORDER ';
      EXECUTE IMMEDIATE SBSQLCOMMAND;
   END;
   PROCEDURE CHECKSEQUENCE( OSBINTERNALERROR OUT VARCHAR2 )
    IS
      BLDUMMY BOOLEAN;
    BEGIN
      BLENVIRONMENT_OK := TRUE;
      IF NOT ( FBOVALIDOBJECT( CSBSEQGE_ERROR_LOG ) ) THEN
         CREATESEQUENCE( CSBSEQGE_ERROR_LOG );
      END IF;
    EXCEPTION
      WHEN OTHERS THEN
         BLDUMMY := EXISTMESSAGE( CNUN_CR_SEQUENCE, SBMESSAGEDESCRIPTION );
         OSBINTERNALERROR := PARSESTRPARAMETER( 'Errors.CheckSequence: ' || SBERRORMESSAGE || '-' || SQLERRM, CSBREPSTRING, CSBSEQGE_ERROR_LOG );
         BLENVIRONMENT_OK := FALSE;
   END;
   PROCEDURE CHECKPARAMETERS( OSBINTERNALERROR OUT VARCHAR2 )
    IS
      BLDUMMY BOOLEAN;
    BEGIN
      BLENVIRONMENT_OK := TRUE;
      BLDUMMY := EXISTMESSAGE( CNUN_EXIST_PARAMETER, SBMESSAGEDESCRIPTION );
      IF NOT ( EXISTPARAMETER( CSBUNATTENDEDERROR, NUERRORSTATUS ) ) THEN
         OSBINTERNALERROR := PARSESTRPARAMETER( 'Errors.CheckParameters: ' || SBERRORMESSAGE, CSBREPSTRING, CSBUNATTENDEDERROR );
         BLENVIRONMENT_OK := FALSE;
       ELSIF NOT ( EXISTPARAMETER( CSBMAX_REPORT_ERR_LEVEL, NUMAX_REPORT_ERR_LEVEL ) ) THEN
         OSBINTERNALERROR := PARSESTRPARAMETER( 'Errors.CheckParameters: ' || SBERRORMESSAGE, CSBREPSTRING, CSBMAX_REPORT_ERR_LEVEL );
         BLENVIRONMENT_OK := FALSE;
       ELSIF NOT ( EXISTPARAMETER( CSBORACLE_ERROR_LEVEL, NUORACLE_ERROR_LEVEL ) ) THEN
         OSBINTERNALERROR := PARSESTRPARAMETER( 'Errors.CheckParameters: ' || SBERRORMESSAGE, CSBREPSTRING, CSBORACLE_ERROR_LEVEL );
         BLENVIRONMENT_OK := FALSE;
      END IF;
   END;
   PROCEDURE INSGE_ERROR_LOG
    IS
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      INSERT INTO ge_error_log
		(
			error_log_id,
			Message_id,
			Time_stamp,
			Db_user,
			Os_user,
			Session_id,
			Application,
			Method,
			Call_stack,
			Error_stack,
			Description,
			Machine,
			Terminal,
			Client_ip,
			Status,
			Action_date,
			Action_admin
		)
		VALUES
		(
			rcGE_Error_Log.error_log_id,
			rcGE_Error_Log.Message_id,
			rcGE_Error_Log.Time_stamp,
			rcGE_Error_Log.Db_user,
			rcGE_Error_Log.Os_user,
			rcGE_Error_Log.Session_id,
			rcGE_Error_Log.Application,
			rcGE_Error_Log.Method,
			rcGE_Error_Log.Call_stack,
			rcGE_Error_Log.Error_stack,
			rcGE_Error_Log.Description,
			rcGE_Error_Log.Machine,
			rcGE_Error_Log.Terminal,
			rcGE_Error_Log.Client_ip,
			rcGE_Error_Log.Status,
			rcGE_Error_Log.Action_date,
			rcGE_Error_Log.Action_admin
		);
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.insGE_Error_Log: ' || SQLERRM );
   END;
   PROCEDURE REPORTERROR
    IS
      SBDUMMY VARCHAR2( 200 );
    BEGIN
      RCGE_ERROR_LOG.CALL_STACK := NULL;
      PARSER_STACK_ERROR( RCGE_ERROR_LOG.CALL_STACK, RCGE_ERROR_LOG.METHOD );
      IF ( RCGE_ERROR_LOG.CALL_STACK IS NULL ) THEN
         RCGE_ERROR_LOG.CALL_STACK := FSBGETSTACKOBJECTTABLE;
      END IF;
      RCGE_ERROR_LOG.ERROR_LOG_ID := FNUERRORLOG;
      SBERRORMESSAGE := VALID_LENMSG( SBERRORMESSAGE );
      SBERRORMESSAGE := SBERRORMESSAGE || ' [' || TO_CHAR( RCGE_ERROR_LOG.ERROR_LOG_ID ) || ']';
      RCGE_ERROR_LOG.MESSAGE_ID := NUERRORCODE;
      RCGE_ERROR_LOG.TIME_STAMP := SYSDATE;
      RCGE_ERROR_LOG.DB_USER := SBDB_USER;
      RCGE_ERROR_LOG.OS_USER := SBOS_USER;
      RCGE_ERROR_LOG.SESSION_ID := SBSESSION_ID;
      DBMS_APPLICATION_INFO.READ_MODULE( SBAPPLICATION, SBDUMMY );
      IF ( SBAPPLICATION IS NULL ) THEN
         SBAPPLICATION := PKERRORS.FSBLASTOBJECT;
      END IF;
      RCGE_ERROR_LOG.APPLICATION := NVL( SBAPPLICATION, 'NULL' );
      RCGE_ERROR_LOG.ERROR_STACK := DBMS_UTILITY.FORMAT_ERROR_STACK;
      RCGE_ERROR_LOG.DESCRIPTION := SBERRORMESSAGE;
      RCGE_ERROR_LOG.MACHINE := SBMACHINE;
      RCGE_ERROR_LOG.TERMINAL := SBTERMINAL;
      RCGE_ERROR_LOG.CLIENT_IP := SBCLIENT_IP;
      RCGE_ERROR_LOG.STATUS := NUERRORSTATUS;
      INSGE_ERROR_LOG;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.ReportError' || '-' || SQLERRM );
   END;
   PROCEDURE INITTABLEOBJECT
    IS
    BEGIN
      TSBTOBJ( 1 ) := 'package body';
      TSBTOBJ( 2 ) := 'FUNCTION';
      TSBTOBJ( 3 ) := 'PROCEDURE';
      TSBTOBJ( 4 ) := 'package';
      TSBTOBJ( 5 ) := 'anonymous block';
   END;
   PROCEDURE CHECKENVIRONMENT
    IS
      CHECKENVIRONMENTFAULT EXCEPTION;
      SBINTERNALERROR VARCHAR2( 500 );
    BEGIN
      BLLOAD := FALSE;
      CHECKMESSAGES( SBINTERNALERROR );
      IF ( BLENVIRONMENT_OK = TRUE ) THEN
         CHECKPARAMETERS( SBINTERNALERROR );
      END IF;
      IF ( BLENVIRONMENT_OK = TRUE ) THEN
         CHECKSEQUENCE( SBINTERNALERROR );
      END IF;
      IF ( BLENVIRONMENT_OK = TRUE ) THEN
         INITVARCONTEXT;
      END IF;
      IF ( BLENVIRONMENT_OK = FALSE ) THEN
         RAISE CHECKENVIRONMENTFAULT;
      END IF;
      INITTABLEOBJECT;
      BLLOAD := TRUE;
    EXCEPTION
      WHEN CHECKENVIRONMENTFAULT THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, SBINTERNALERROR );
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.CheckEnvironment: ' || SQLERRM );
   END;
   PROCEDURE SETMESSAGE( ISBMESSAGE IN VARCHAR2 )
    IS
    BEGIN
      SBERRORMESSAGE := VALID_LENMSG( ISBMESSAGE );
   END;
   PROCEDURE SETERROR( INUAPPERRORCODE IN GE_ERROR_LOG.ERROR_LOG_ID%TYPE )
    IS
      N_EXIST_MESSAGE_APP EXCEPTION;
      SBDUMMY GE_MESSAGE.USE_ARGUMENT%TYPE;
      NULEVEL GE_MESSAGE.ERROR_LEVEL%TYPE;
    BEGIN
      IF NOT ( EXISTMESSAGE( INUAPPERRORCODE, SBMESSAGEDESCRIPTION ) ) THEN
         IF ( INUAPPERRORCODE > 0 ) THEN
            RAISE N_EXIST_MESSAGE_APP;
         END IF;
      END IF;
      NUERRORCODE := INUAPPERRORCODE;
      SBERRORMESSAGE := SBMESSAGEDESCRIPTION;
      IF ( RCGE_MESSAGE.ERROR_LEVEL <= NUMAX_REPORT_ERR_LEVEL ) THEN
         REPORTERROR;
      END IF;
    EXCEPTION
      WHEN N_EXIST_MESSAGE_APP THEN
         SBERRORLOCAL := PARSESTRPARAMETER( SBNEXIST_MESSAGEAPP, CSBREPSTRING, INUAPPERRORCODE );
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.SetError: ' || SBERRORLOCAL );
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.SetError: ' || SQLERRM );
   END;
   PROCEDURE SETERROR( INUAPPERRORCODE IN GE_ERROR_LOG.ERROR_LOG_ID%TYPE, ISBARGUMENT IN VARCHAR2 )
    IS
      N_EXIST_MESSAGE_APP EXCEPTION;
    BEGIN
      IF NOT ( EXISTMESSAGE( INUAPPERRORCODE, SBMESSAGEDESCRIPTION ) ) THEN
         IF ( INUAPPERRORCODE > 0 ) THEN
            RAISE N_EXIST_MESSAGE_APP;
         END IF;
      END IF;
      NUERRORCODE := INUAPPERRORCODE;
      SBERRORMESSAGE := SBMESSAGEDESCRIPTION;
      IF ( RCGE_MESSAGE.USE_ARGUMENT = CSBYES ) THEN
         SBERRORMESSAGE := VALID_LENMSG( PARSESTRPARAMETER( SBERRORMESSAGE, CSBREPSTRING, NVL( ISBARGUMENT, 'NULL' ) ) );
      END IF;
      IF ( RCGE_MESSAGE.ERROR_LEVEL <= NUMAX_REPORT_ERR_LEVEL ) THEN
         REPORTERROR;
      END IF;
    EXCEPTION
      WHEN N_EXIST_MESSAGE_APP THEN
         SBERRORLOCAL := PARSESTRPARAMETER( SBNEXIST_MESSAGEAPP, CSBREPSTRING, INUAPPERRORCODE );
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.SetError: ' || SBERRORLOCAL );
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( CNUERRORSEXCEPTION, 'Errors.SetError: ' || SQLERRM );
   END;
   PROCEDURE SETERROR
    IS
      NULEVEL PLS_INTEGER := NUORACLE_ERROR_LEVEL;
    BEGIN
      IF NOT ( BLLOAD ) THEN
         CHECKENVIRONMENT;
         ERRORS.INITIALIZE;
      END IF;
      IF ( NOT BLERRORBSS AND SQLCODE IN ( -01017, -20001, -20002 ) ) THEN
         RETURN;
      END IF;
      IF ( BLERRORBSS AND SQLCODE IN ( -01017, -20001, -20002 ) ) THEN
         ERRORS.SETBSSERROROFF;
         REPORTERROR;
         RETURN;
      END IF;
      NUERRORCODE := SQLCODE;
      SBERRORMESSAGE := SQLERRM;
      IF ( EXISTMESSAGE( NUERRORCODE, SBMESSAGEDESCRIPTION ) ) THEN
         IF ( INSTR( UPPER( LTRIM( RTRIM( NVL( SBMESSAGEDESCRIPTION, SQLERRM ) ) ) ), UPPER( LTRIM( RTRIM( SQLERRM ) ) ) ) > 0 ) THEN
            SBERRORMESSAGE := SQLERRM;
          ELSE
            SBERRORMESSAGE := SBMESSAGEDESCRIPTION;
         END IF;
       ELSE
         NULEVEL := RCGE_MESSAGE.ERROR_LEVEL;
      END IF;
      IF ( NULEVEL <= NUMAX_REPORT_ERR_LEVEL ) THEN
         REPORTERROR;
      END IF;
   END;
   PROCEDURE GETERROR( ONUERRORCODE OUT GE_ERROR_LOG.ERROR_LOG_ID%TYPE, OSBERRORMESSAGE OUT VARCHAR2 )
    IS
    BEGIN
      ONUERRORCODE := NUERRORCODE;
      OSBERRORMESSAGE := SBERRORMESSAGE;
   END;
   PROCEDURE GETERROR( OSBERRORDIVISION OUT VARCHAR2, OSBERRORMODULE OUT VARCHAR2, ONUERRORCODE OUT NUMBER, OSBERRORMESSAGE OUT VARCHAR2 )
    IS
    BEGIN
      OSBERRORDIVISION := SBERRORDIVISION;
      OSBERRORMODULE := SBERRORMODULE;
      ONUERRORCODE := NUERRORCODE;
      OSBERRORMESSAGE := SBERRORMESSAGE;
   END;
   PROCEDURE INITIALIZE
    IS
    BEGIN
      SBERRORDIVISION := '-';
      SBERRORMODULE := '-';
      NUERRORCODE := 0;
      SBERRORMESSAGE := NULL;
      SBOBJECTNAME := NULL;
   END;
   PROCEDURE SETLEVELERROR( INUERRLEVEL IN GE_MESSAGE.ERROR_LEVEL%TYPE )
    IS
    BEGIN
      IF ( INUERRLEVEL IS NOT NULL ) THEN
         NUMAX_REPORT_ERR_LEVEL := INUERRLEVEL;
      END IF;
   END;
   FUNCTION FNUGETLEVELERROR
    RETURN PLS_INTEGER
    IS
    BEGIN
      RETURN NUMAX_REPORT_ERR_LEVEL;
   END;
   PROCEDURE CHECKERROR( INUERRCODE IN GE_MESSAGE.MESSAGE_ID%TYPE )
    IS
      CNUSUCCESS CONSTANT NUMBER := 0;
    BEGIN
      IF ( INUERRCODE != CNUSUCCESS AND INUERRCODE IS NOT NULL ) THEN
         RAISE EX.CONTROLLED_ERROR;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE SETBSSERRORON
    IS
    BEGIN
      BLERRORBSS := TRUE;
   END;
   PROCEDURE SETBSSERROROFF
    IS
    BEGIN
      BLERRORBSS := FALSE;
   END;
   PROCEDURE SETBSSERROR( INUERRORCODE IN NUMBER, ISBERRORDESCRIPTION IN VARCHAR2, IBLCREATEERRORLOG IN BOOLEAN := FALSE )
    IS
      NULEVEL PLS_INTEGER := NUORACLE_ERROR_LEVEL;
    BEGIN
      BLBSSERROR := TRUE;
      NUERRORCODE := INUERRORCODE;
      SBERRORMESSAGE := ISBERRORDESCRIPTION;
      IF NOT ( IBLCREATEERRORLOG ) THEN
         RETURN;
      END IF;
      IF ( NULEVEL <= NUMAX_REPORT_ERR_LEVEL ) THEN
         REPORTERROR;
      END IF;
   END;
   PROCEDURE SETAPPLICATION( ISBAPPLICATION IN VARCHAR2 )
    IS
    BEGIN
      SBAPLICACION := ISBAPPLICATION;
   END;
   PROCEDURE SETERRORDIVISION( ISBDIVISION IN VARCHAR2 )
    IS
    BEGIN
      SBERRORDIVISION := ISBDIVISION;
   END;
   PROCEDURE SETERRORMODULE( ISBMODULE IN VARCHAR2 )
    IS
    BEGIN
      SBERRORMODULE := ISBMODULE;
   END;
   PROCEDURE SETOBJECTNAME( ISBOBJECTNAME IN VARCHAR2 )
    IS
    BEGIN
      SBOBJECTNAME := ISBOBJECTNAME;
   END;
   FUNCTION FSBGETAPPLICATION
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN ( SBAPLICACION );
   END;
   FUNCTION FSBGETOBJECTNAME
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN ( SBOBJECTNAME );
   END;
   PROCEDURE CLEAR
    IS
    BEGIN
      TBOBJECTS.DELETE;
   END;
   PROCEDURE PUSH( ISBOBJECTNAME IN VARCHAR2 )
    IS
      NUINIT NUMBER;
      NULOOPS NUMBER;
      NUSHOW NUMBER := 255;
      SBVAR VARCHAR2( 4000 );
      PROCEDURE TRACEINSERTION( ISBSTRING IN VARCHAR2 )
       IS
         PRAGMA AUTONOMOUS_TRANSACTION;
         NUCONSECU NUMBER;
         CNUSEQUENCE CONSTANT VARCHAR2( 50 ) := 'SQ_OPENFLTR_OPFTCONS';
       BEGIN
         EXECUTE IMMEDIATE 'SELECT ' || CNUSEQUENCE || '.nextval FROM dual'
                           INTO NUCONSECU;
         INSERT INTO openfltr (opftcons,opftobje,opftterm,opftuser,opftfech,opftdesc)
            VALUES (nuConsecu, sbObjectTrc, sbTerm, sbUser, sysdate, isbString);
         COMMIT;
      END TRACEINSERTION;
    BEGIN
      IF ( BLSERVERMODE ) THEN
         RETURN;
      END IF;
      SETOBJECTNAME( ISBOBJECTNAME );
      IF ( BLTRACE ) THEN
         SBVAR := 'Object name:' || LPAD( ' ', TBOBJECTS.COUNT, ' ' ) || ISBOBJECTNAME;
         NULOOPS := LENGTH( SBVAR ) / NUSHOW;
         IF ( NULOOPS > TRUNC( NULOOPS ) ) THEN
            NULOOPS := TRUNC( NULOOPS ) + 1;
         END IF;
         FOR INDX IN 1..NULOOPS
          LOOP
            NUINIT := ( ( INDX - 1 ) * NUSHOW ) + 1;
            IF ( BOPUSH_DB ) THEN
               TRACEINSERTION( SUBSTR( SBVAR, NUINIT, NUSHOW ) );
             ELSE
               DBMS_OUTPUT.PUT_LINE( SUBSTR( SBVAR, NUINIT, NUSHOW ) );
            END IF;
         END LOOP;
      END IF;
      NUIDX := NVL( TBOBJECTS.LAST, 0 ) + 1;
      TBOBJECTS( NUIDX ) := ISBOBJECTNAME;
   END;
   PROCEDURE POP
    IS
      NUIDXSTK NUMBER;
    BEGIN
      IF ( BLSERVERMODE OR TBOBJECTS.LAST IS NULL ) THEN
         RETURN;
      END IF;
      NUIDXSTK := TBOBJECTS.LAST;
      TBOBJECTS.DELETE( NUIDXSTK );
   END;
   FUNCTION FNUGETNUMBEROBJECTS
    RETURN NUMBER
    IS
    BEGIN
      RETURN ( TBOBJECTS.COUNT );
   END;
   FUNCTION FSBGETOBJECTFROMPLSTACK( INUINDEX IN NUMBER )
    RETURN VARCHAR2
    IS
    BEGIN
      IF ( INUINDEX > TBOBJECTS.COUNT ) THEN
         RETURN ( NULL );
      END IF;
      RETURN ( TBOBJECTS( INUINDEX ) );
   END;
   FUNCTION FSBGETSTACKOBJECTTABLE
    RETURN VARCHAR2
    IS
      SBOBJECT VARCHAR2( 2000 );
      SBCALLSTACK VARCHAR2( 32767 );
      CNUMAX_LENGTH_STACK NUMBER := 2000;
      CNUONE NUMBER := 1;
      SBNEWLINE CONSTANT CHAR( 1 ) := CHR( 10 );
    BEGIN
      NUIDX := TBOBJECTS.LAST;
      LOOP
         EXIT WHEN NUIDX IS NULL;
         IF ( NUIDX = TBOBJECTS.LAST ) THEN
            SBCALLSTACK := TRIM( TBOBJECTS( NUIDX ) );
          ELSE
            SBCALLSTACK := TRIM( SBCALLSTACK ) || SBNEWLINE || TRIM( TBOBJECTS( NUIDX ) );
         END IF;
         IF ( LENGTH( SBCALLSTACK ) > CNUMAX_LENGTH_STACK ) THEN
            EXIT;
         END IF;
         NUIDX := TBOBJECTS.PRIOR( NUIDX );
      END LOOP;
      RETURN ( SBCALLSTACK );
   END;
   FUNCTION FSBGETLASTOBJECTFROMPLSTACK
    RETURN VARCHAR2
    IS
      SBOBJECT GE_ERROR_LOG.APPLICATION%TYPE;
      SBCALLSTACK VARCHAR2( 32767 );
      CSBNULL_STRING CONSTANT VARCHAR2( 20 ) := '----------';
      CNUCERO CONSTANT NUMBER := 0;
    BEGIN
      IF ( BLSERVERMODE ) THEN
         PARSER_STACK_ERROR( SBCALLSTACK, SBOBJECT );
         RETURN ( SBOBJECT );
      END IF;
      IF ( FNUGETNUMBEROBJECTS > CNUCERO ) THEN
         RETURN ( TBOBJECTS( TBOBJECTS.LAST ) );
       ELSE
         RETURN ( CSBNULL_STRING );
      END IF;
   END;
   PROCEDURE TRACEOFF
    IS
    BEGIN
      BLTRACE := FALSE;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Errors.TraceOff' || '-' || SQLERRM );
   END TRACEOFF;
   PROCEDURE TRACEON
    IS
    BEGIN
      BLTRACE := TRUE;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Errors.TraceOn' || '-' || SQLERRM );
   END TRACEON;
   PROCEDURE SETEXTERNALSYSTEM
    IS
    BEGIN
      BLEXTERNALSYSTEM := TRUE;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Errors.SetExternalSystem' || '-' || SQLERRM );
   END SETEXTERNALSYSTEM;
   PROCEDURE SETSERVERMODE
    IS
    BEGIN
      BLSERVERMODE := TRUE;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Errors.SetServerMode' || '-' || SQLERRM );
   END SETSERVERMODE;
   FUNCTION GETEXTERNALSYSTEM
    RETURN BOOLEAN
    IS
    BEGIN
      RETURN BLEXTERNALSYSTEM;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Errors.GetExternalSystem' || '-' || SQLERRM );
   END;
   FUNCTION FBLISBSSERROR
    RETURN BOOLEAN
    IS
    BEGIN
      RETURN BLBSSERROR;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Errors.fblIsBSSError' || '-' || SQLERRM );
   END;
   PROCEDURE DISABLEBSSERROR
    IS
    BEGIN
      BLBSSERROR := FALSE;
    EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR( -20600, 'Errors.DisableBSSError' || '-' || SQLERRM );
   END;
 BEGIN
   CHECKENVIRONMENT;
   ERRORS.INITIALIZE;
END ERRORS;
/


