CREATE OR REPLACE PACKAGE BODY DAGE_PROCESS_SCHEDULE IS
   CNURECORD_NOT_EXIST CONSTANT NUMBER( 1 ) := 1;
   CNURECORD_ALREADY_EXIST CONSTANT NUMBER( 1 ) := 2;
   CNUAPPTABLEBUSSY CONSTANT NUMBER( 4 ) := 6951;
   CNUINS_PK_NULL CONSTANT NUMBER( 4 ) := 1682;
   CNURECORD_HAVE_CHILDREN CONSTANT NUMBER( 4 ) := -2292;
   CSBVERSION CONSTANT VARCHAR2( 20 ) := 'SAO175100';
   CSBTABLEPARAMETER CONSTANT VARCHAR2( 30 ) := 'GE_PROCESS_SCHEDULE';
   CNUGEENTITYID CONSTANT VARCHAR2( 30 ) := 1856;
   CURSOR CULOCKRCBYPK( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE ) IS
SELECT GE_process_schedule.*,GE_process_schedule.rowid 
		FROM GE_process_schedule
		WHERE  Process_Schedule_Id = inuProcess_Schedule_Id
		FOR UPDATE NOWAIT;
   CURSOR CULOCKRCBYROWID( IRIROWID IN VARCHAR2 ) IS
SELECT GE_process_schedule.*,GE_process_schedule.rowid 
		FROM GE_process_schedule
		WHERE 
			rowId = irirowid
		FOR UPDATE NOWAIT;
   TYPE TYRFGE_PROCESS_SCHEDULE IS REF CURSOR;
   RCRECOFTAB TYRCGE_PROCESS_SCHEDULE;
   RCDATA CURECORD%ROWTYPE;
   BLDAO_USE_CACHE BOOLEAN := NULL;
   FUNCTION FSBGETMESSAGEDESCRIPTION
    RETURN VARCHAR2
    IS
      SBTABLEDESCRIPTION VARCHAR2( 32000 );
    BEGIN
      IF ( CNUGEENTITYID > 0 AND DAGE_ENTITY.FBLEXIST( CNUGEENTITYID ) ) THEN
         SBTABLEDESCRIPTION := DAGE_ENTITY.FSBGETDISPLAY_NAME( CNUGEENTITYID );
       ELSE
         SBTABLEDESCRIPTION := CSBTABLEPARAMETER;
      END IF;
      RETURN SBTABLEDESCRIPTION;
   END;
   PROCEDURE GETDAO_USE_CACHE
    IS
    BEGIN
      IF ( BLDAO_USE_CACHE IS NULL ) THEN
         BLDAO_USE_CACHE := GE_BOPARAMETER.FSBGET( 'DAO_USE_CACHE' ) = 'Y';
      END IF;
   END;
   FUNCTION FSBPRIMARYKEY( RCI IN STYGE_PROCESS_SCHEDULE := RCDATA )
    RETURN VARCHAR2
    IS
      SBPK VARCHAR2( 500 );
    BEGIN
      SBPK := '[';
      SBPK := SBPK || UT_CONVERT.FSBTOCHAR( RCI.PROCESS_SCHEDULE_ID );
      SBPK := SBPK || ']';
      RETURN SBPK;
   END;
   PROCEDURE LOCKBYPK( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, ORCGE_PROCESS_SCHEDULE OUT STYGE_PROCESS_SCHEDULE )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      OPEN CULOCKRCBYPK( INUPROCESS_SCHEDULE_ID );
      FETCH CULOCKRCBYPK
         INTO ORCGE_PROCESS_SCHEDULE;
      IF CULOCKRCBYPK%NOTFOUND THEN
         CLOSE CULOCKRCBYPK;
         RAISE NO_DATA_FOUND;
      END IF;
      CLOSE CULOCKRCBYPK;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF CULOCKRCBYPK%ISOPEN THEN
            CLOSE CULOCKRCBYPK;
         END IF;
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
      WHEN EX.RESOURCE_BUSY THEN
         IF CULOCKRCBYPK%ISOPEN THEN
            CLOSE CULOCKRCBYPK;
         END IF;
         ERRORS.SETERROR( CNUAPPTABLEBUSSY, FSBPRIMARYKEY( RCERROR ) || '|' || FSBGETMESSAGEDESCRIPTION );
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         IF CULOCKRCBYPK%ISOPEN THEN
            CLOSE CULOCKRCBYPK;
         END IF;
         RAISE;
   END;
   PROCEDURE LOCKBYROWID( IRIROWID IN VARCHAR2, ORCGE_PROCESS_SCHEDULE OUT STYGE_PROCESS_SCHEDULE )
    IS
    BEGIN
      OPEN CULOCKRCBYROWID( IRIROWID );
      FETCH CULOCKRCBYROWID
         INTO ORCGE_PROCESS_SCHEDULE;
      IF CULOCKRCBYROWID%NOTFOUND THEN
         CLOSE CULOCKRCBYROWID;
         RAISE NO_DATA_FOUND;
      END IF;
      CLOSE CULOCKRCBYROWID;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF CULOCKRCBYROWID%ISOPEN THEN
            CLOSE CULOCKRCBYROWID;
         END IF;
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' rowid=[' || IRIROWID || ']' );
         RAISE EX.CONTROLLED_ERROR;
      WHEN EX.RESOURCE_BUSY THEN
         IF CULOCKRCBYROWID%ISOPEN THEN
            CLOSE CULOCKRCBYROWID;
         END IF;
         ERRORS.SETERROR( CNUAPPTABLEBUSSY, 'rowid=[' || IRIROWID || ']|' || FSBGETMESSAGEDESCRIPTION );
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         IF CULOCKRCBYROWID%ISOPEN THEN
            CLOSE CULOCKRCBYROWID;
         END IF;
         RAISE;
   END;
   PROCEDURE DELRECORDOFTABLES( ITBGE_PROCESS_SCHEDULE IN OUT NOCOPY TYTBGE_PROCESS_SCHEDULE )
    IS
    BEGIN
      RCRECOFTAB.PROCESS_SCHEDULE_ID.DELETE;
      RCRECOFTAB.EXECUTABLE_ID.DELETE;
      RCRECOFTAB.PARAMETERS_.DELETE;
      RCRECOFTAB.FREQUENCY.DELETE;
      RCRECOFTAB.STATUS.DELETE;
      RCRECOFTAB.JOB.DELETE;
      RCRECOFTAB.LOG_USER.DELETE;
      RCRECOFTAB.START_DATE_.DELETE;
      RCRECOFTAB.WHAT.DELETE;
      RCRECOFTAB.ROW_ID.DELETE;
   END;
   PROCEDURE FILLRECORDOFTABLES( ITBGE_PROCESS_SCHEDULE IN OUT NOCOPY TYTBGE_PROCESS_SCHEDULE, OBLUSEROWID OUT BOOLEAN )
    IS
    BEGIN
      DELRECORDOFTABLES( ITBGE_PROCESS_SCHEDULE );
      FOR N IN ITBGE_PROCESS_SCHEDULE.FIRST..ITBGE_PROCESS_SCHEDULE.LAST
       LOOP
         RCRECOFTAB.PROCESS_SCHEDULE_ID( N ) := ITBGE_PROCESS_SCHEDULE( N ).PROCESS_SCHEDULE_ID;
         RCRECOFTAB.EXECUTABLE_ID( N ) := ITBGE_PROCESS_SCHEDULE( N ).EXECUTABLE_ID;
         RCRECOFTAB.PARAMETERS_( N ) := ITBGE_PROCESS_SCHEDULE( N ).PARAMETERS_;
         RCRECOFTAB.FREQUENCY( N ) := ITBGE_PROCESS_SCHEDULE( N ).FREQUENCY;
         RCRECOFTAB.STATUS( N ) := ITBGE_PROCESS_SCHEDULE( N ).STATUS;
         RCRECOFTAB.JOB( N ) := ITBGE_PROCESS_SCHEDULE( N ).JOB;
         RCRECOFTAB.LOG_USER( N ) := ITBGE_PROCESS_SCHEDULE( N ).LOG_USER;
         RCRECOFTAB.START_DATE_( N ) := ITBGE_PROCESS_SCHEDULE( N ).START_DATE_;
         RCRECOFTAB.WHAT( N ) := ITBGE_PROCESS_SCHEDULE( N ).WHAT;
         RCRECOFTAB.ROW_ID( N ) := ITBGE_PROCESS_SCHEDULE( N ).ROWID;
         OBLUSEROWID := RCRECOFTAB.ROW_ID( N ) IS NOT NULL;
      END LOOP;
   END;
   PROCEDURE LOAD( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE )
    IS
      RCRECORDNULL CURECORD%ROWTYPE;
    BEGIN
      IF CURECORD%ISOPEN THEN
         CLOSE CURECORD;
      END IF;
      OPEN CURECORD( INUPROCESS_SCHEDULE_ID );
      FETCH CURECORD
         INTO RCDATA;
      IF CURECORD%NOTFOUND THEN
         CLOSE CURECORD;
         RCDATA := RCRECORDNULL;
         RAISE NO_DATA_FOUND;
      END IF;
      CLOSE CURECORD;
   END;
   PROCEDURE LOADBYROWID( IRIROWID IN VARCHAR2 )
    IS
      RCRECORDNULL CURECORDBYROWID%ROWTYPE;
    BEGIN
      IF CURECORDBYROWID%ISOPEN THEN
         CLOSE CURECORDBYROWID;
      END IF;
      OPEN CURECORDBYROWID( IRIROWID );
      FETCH CURECORDBYROWID
         INTO RCDATA;
      IF CURECORDBYROWID%NOTFOUND THEN
         CLOSE CURECORDBYROWID;
         RCDATA := RCRECORDNULL;
         RAISE NO_DATA_FOUND;
      END IF;
      CLOSE CURECORDBYROWID;
   END;
   FUNCTION FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE )
    RETURN BOOLEAN
    IS
    BEGIN
      IF ( INUPROCESS_SCHEDULE_ID = RCDATA.PROCESS_SCHEDULE_ID ) THEN
         RETURN ( TRUE );
      END IF;
      RETURN ( FALSE );
   END;
   FUNCTION FSBVERSION
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN CSBVERSION;
   END;
   PROCEDURE CLEARMEMORY
    IS
      RCRECORDNULL CURECORD%ROWTYPE;
    BEGIN
      RCDATA := RCRECORDNULL;
   END;
   FUNCTION FBLEXIST( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE )
    RETURN BOOLEAN
    IS
    BEGIN
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( TRUE );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN ( FALSE );
   END;
   PROCEDURE ACCKEY( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      LOAD( INUPROCESS_SCHEDULE_ID );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE ACCKEYBYROWID( IRIROWID IN ROWID )
    IS
    BEGIN
      LOADBYROWID( IRIROWID );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' rowid=[' || IRIROWID || ']' );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE VALDUPLICATE( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE )
    IS
    BEGIN
      LOAD( INUPROCESS_SCHEDULE_ID );
      ERRORS.SETERROR( CNURECORD_ALREADY_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY );
      RAISE EX.CONTROLLED_ERROR;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         NULL;
   END;
   PROCEDURE GETRECORD( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, ORCRECORD OUT NOCOPY STYGE_PROCESS_SCHEDULE )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      LOAD( INUPROCESS_SCHEDULE_ID );
      ORCRECORD := RCDATA;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION FRCGETRECORD( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE )
    RETURN STYGE_PROCESS_SCHEDULE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION FRCGETRCDATA( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE )
    RETURN STYGE_PROCESS_SCHEDULE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION FRCGETRCDATA
    RETURN STYGE_PROCESS_SCHEDULE
    IS
    BEGIN
      RETURN ( RCDATA );
   END;
   PROCEDURE GETRECORDS( ISBQUERY IN VARCHAR2, OTBRESULT OUT NOCOPY TYTBGE_PROCESS_SCHEDULE )
    IS
      RFGE_PROCESS_SCHEDULE TYRFGE_PROCESS_SCHEDULE;
      N NUMBER( 4 ) := 1;
      SBFULLQUERY VARCHAR2( 32000 ) := 'SELECT 
		            GE_process_schedule.Process_Schedule_Id,
		            GE_process_schedule.Executable_Id,
		            GE_process_schedule.Parameters_,
		            GE_process_schedule.Frequency,
		            GE_process_schedule.Status,
		            GE_process_schedule.Job,
		            GE_process_schedule.Log_User,
		            GE_process_schedule.Start_Date_,
		            GE_process_schedule.What,
		            GE_process_schedule.rowid
                FROM GE_process_schedule';
      NUMAXTBRECORDS NUMBER( 5 ) := GE_BOPARAMETER.FNUGET( 'MAXREGSQUERY' );
    BEGIN
      OTBRESULT.DELETE;
      IF ISBQUERY IS NOT NULL AND LENGTH( ISBQUERY ) > 0 THEN
         SBFULLQUERY := SBFULLQUERY || ' WHERE ' || ISBQUERY;
      END IF;
      OPEN RFGE_PROCESS_SCHEDULE
           FOR SBFULLQUERY;
      FETCH RFGE_PROCESS_SCHEDULE
         BULK COLLECT INTO OTBRESULT;
      CLOSE RFGE_PROCESS_SCHEDULE;
      IF OTBRESULT.COUNT = 0 THEN
         RAISE NO_DATA_FOUND;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION );
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION FRFGETRECORDS( ISBCRITERIA IN VARCHAR2 := NULL, IBLLOCK IN BOOLEAN := FALSE )
    RETURN TYREFCURSOR
    IS
      RFQUERY TYREFCURSOR;
      SBSQL VARCHAR2( 32000 ) := 'select 
		            GE_process_schedule.Process_Schedule_Id,
		            GE_process_schedule.Executable_Id,
		            GE_process_schedule.Parameters_,
		            GE_process_schedule.Frequency,
		            GE_process_schedule.Status,
		            GE_process_schedule.Job,
		            GE_process_schedule.Log_User,
		            GE_process_schedule.Start_Date_,
		            GE_process_schedule.What,
		            GE_process_schedule.rowid
                FROM GE_process_schedule';
    BEGIN
      IF ISBCRITERIA IS NOT NULL THEN
         SBSQL := SBSQL || ' where ' || ISBCRITERIA;
      END IF;
      IF IBLLOCK THEN
         SBSQL := SBSQL || ' for update nowait';
      END IF;
      OPEN RFQUERY
           FOR SBSQL;
      RETURN ( RFQUERY );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE INSRECORD( IRCGE_PROCESS_SCHEDULE IN STYGE_PROCESS_SCHEDULE )
    IS
      RIROWID VARCHAR2( 200 );
    BEGIN
      INSRECORD( IRCGE_PROCESS_SCHEDULE, RIROWID );
   END;
   PROCEDURE INSRECORD( IRCGE_PROCESS_SCHEDULE IN STYGE_PROCESS_SCHEDULE, ORIROWID OUT VARCHAR2 )
    IS
    BEGIN
      IF IRCGE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID IS NULL THEN
         ERRORS.SETERROR( CNUINS_PK_NULL, FSBGETMESSAGEDESCRIPTION || '|Process_Schedule_Id' );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
      INSERT into GE_process_schedule
		(
			Process_Schedule_Id,
			Executable_Id,
			Parameters_,
			Frequency,
			Status,
			Job,
			Log_User,
			Start_Date_,
			What
		)
		values
		(
			ircGE_process_schedule.Process_Schedule_Id,
			ircGE_process_schedule.Executable_Id,
			ircGE_process_schedule.Parameters_,
			ircGE_process_schedule.Frequency,
			ircGE_process_schedule.Status,
			ircGE_process_schedule.Job,
			ircGE_process_schedule.Log_User,
			ircGE_process_schedule.Start_Date_,
			ircGE_process_schedule.What
		)
            returning
			rowid
		into
			orirowid;
    EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
         ERRORS.SETERROR( CNURECORD_ALREADY_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( IRCGE_PROCESS_SCHEDULE ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE INSRECORDS( IOTBGE_PROCESS_SCHEDULE IN OUT NOCOPY TYTBGE_PROCESS_SCHEDULE )
    IS
      BLUSEROWID BOOLEAN;
    BEGIN
      FILLRECORDOFTABLES( IOTBGE_PROCESS_SCHEDULE, BLUSEROWID );
      FORALL N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
         INSERT into GE_process_schedule
			(
				Process_Schedule_Id,
				Executable_Id,
				Parameters_,
				Frequency,
				Status,
				Job,
				Log_User,
				Start_Date_,
				What
			)
			values
			(
				rcRecOfTab.Process_Schedule_Id(n),
				rcRecOfTab.Executable_Id(n),
				rcRecOfTab.Parameters_(n),
				rcRecOfTab.Frequency(n),
				rcRecOfTab.Status(n),
				rcRecOfTab.Job(n),
				rcRecOfTab.Log_User(n),
				rcRecOfTab.Start_Date_(n),
				rcRecOfTab.What(n)
			);
    EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
         ERRORS.SETERROR( CNURECORD_ALREADY_EXIST, FSBGETMESSAGEDESCRIPTION );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE DELRECORD( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INULOCK IN NUMBER := 1 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      DELETE
		from GE_process_schedule
		where
       		Process_Schedule_Id=inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
      WHEN EX.RECORD_HAVE_CHILDREN THEN
         ERRORS.SETERROR( CNURECORD_HAVE_CHILDREN, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE DELBYROWID( IRIROWID IN ROWID, INULOCK IN NUMBER := 1 )
    IS
      RCRECORDNULL CURECORD%ROWTYPE;
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      IF INULOCK = 1 THEN
         LOCKBYROWID( IRIROWID, RCDATA );
      END IF;
      DELETE
		from GE_process_schedule
		where
			rowid = iriRowID
		returning
			Process_Schedule_Id
		into
			rcError.Process_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      IF RCDATA.ROWID = IRIROWID THEN
         RCDATA := RCRECORDNULL;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' rowid=[' || IRIROWID || ']' );
         RAISE EX.CONTROLLED_ERROR;
      WHEN EX.RECORD_HAVE_CHILDREN THEN
         ERRORS.SETERROR( CNURECORD_HAVE_CHILDREN, FSBGETMESSAGEDESCRIPTION || ' ' || ' rowid=[' || IRIROWID || ']' );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE DELRECORDS( IOTBGE_PROCESS_SCHEDULE IN OUT NOCOPY TYTBGE_PROCESS_SCHEDULE, INULOCK IN NUMBER := 1 )
    IS
      BLUSEROWID BOOLEAN;
      RCAUX STYGE_PROCESS_SCHEDULE;
    BEGIN
      FILLRECORDOFTABLES( IOTBGE_PROCESS_SCHEDULE, BLUSEROWID );
      IF ( BLUSEROWID ) THEN
         IF INULOCK = 1 THEN
            FOR N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
             LOOP
               LOCKBYROWID( RCRECOFTAB.ROW_ID( N ), RCAUX );
            END LOOP;
         END IF;
         FORALL N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
            DELETE
				from GE_process_schedule
				where
					rowid = rcRecOfTab.row_id(n);
       ELSE
         IF INULOCK = 1 THEN
            FOR N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
             LOOP
               LOCKBYPK( RCRECOFTAB.PROCESS_SCHEDULE_ID( N ), RCAUX );
            END LOOP;
         END IF;
         FORALL N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
            DELETE
				from GE_process_schedule
				where
		         	Process_Schedule_Id = rcRecOfTab.Process_Schedule_Id(n);
      END IF;
    EXCEPTION
      WHEN EX.RECORD_HAVE_CHILDREN THEN
         ERRORS.SETERROR( CNURECORD_HAVE_CHILDREN, FSBGETMESSAGEDESCRIPTION );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDRECORD( IRCGE_PROCESS_SCHEDULE IN STYGE_PROCESS_SCHEDULE, INULOCK IN NUMBER := 0 )
    IS
      NUPROCESS_SCHEDULE_ID GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE;
    BEGIN
      IF IRCGE_PROCESS_SCHEDULE.ROWID IS NOT NULL THEN
         IF INULOCK = 1 THEN
            LOCKBYROWID( IRCGE_PROCESS_SCHEDULE.ROWID, RCDATA );
         END IF;
         UPDATE GE_process_schedule
			set
				Executable_Id = ircGE_process_schedule.Executable_Id,
				Parameters_ = ircGE_process_schedule.Parameters_,
				Frequency = ircGE_process_schedule.Frequency,
				Status = ircGE_process_schedule.Status,
				Job = ircGE_process_schedule.Job,
				Log_User = ircGE_process_schedule.Log_User,
				Start_Date_ = ircGE_process_schedule.Start_Date_,
				What = ircGE_process_schedule.What
			where
				rowid = ircGE_process_schedule.rowid
			returning
				Process_Schedule_Id
			into
				nuProcess_Schedule_Id;
       ELSE
         IF INULOCK = 1 THEN
            LOCKBYPK( IRCGE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID, RCDATA );
         END IF;
         UPDATE GE_process_schedule
			set
				Executable_Id = ircGE_process_schedule.Executable_Id,
				Parameters_ = ircGE_process_schedule.Parameters_,
				Frequency = ircGE_process_schedule.Frequency,
				Status = ircGE_process_schedule.Status,
				Job = ircGE_process_schedule.Job,
				Log_User = ircGE_process_schedule.Log_User,
				Start_Date_ = ircGE_process_schedule.Start_Date_,
				What = ircGE_process_schedule.What
			where
				Process_Schedule_Id = ircGE_process_schedule.Process_Schedule_Id
			returning
				Process_Schedule_Id
			into
				nuProcess_Schedule_Id;
      END IF;
      IF NUPROCESS_SCHEDULE_ID IS NULL THEN
         RAISE NO_DATA_FOUND;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || FSBPRIMARYKEY( IRCGE_PROCESS_SCHEDULE ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDRECORDS( IOTBGE_PROCESS_SCHEDULE IN OUT NOCOPY TYTBGE_PROCESS_SCHEDULE, INULOCK IN NUMBER := 1 )
    IS
      BLUSEROWID BOOLEAN;
      RCAUX STYGE_PROCESS_SCHEDULE;
    BEGIN
      FILLRECORDOFTABLES( IOTBGE_PROCESS_SCHEDULE, BLUSEROWID );
      IF BLUSEROWID THEN
         IF INULOCK = 1 THEN
            FOR N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
             LOOP
               LOCKBYROWID( RCRECOFTAB.ROW_ID( N ), RCAUX );
            END LOOP;
         END IF;
         FORALL N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
            UPDATE GE_process_schedule
				set
					Executable_Id = rcRecOfTab.Executable_Id(n),
					Parameters_ = rcRecOfTab.Parameters_(n),
					Frequency = rcRecOfTab.Frequency(n),
					Status = rcRecOfTab.Status(n),
					Job = rcRecOfTab.Job(n),
					Log_User = rcRecOfTab.Log_User(n),
					Start_Date_ = rcRecOfTab.Start_Date_(n),
					What = rcRecOfTab.What(n)
				where
					rowid =  rcRecOfTab.row_id(n);
       ELSE
         IF INULOCK = 1 THEN
            FOR N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
             LOOP
               LOCKBYPK( RCRECOFTAB.PROCESS_SCHEDULE_ID( N ), RCAUX );
            END LOOP;
         END IF;
         FORALL N IN IOTBGE_PROCESS_SCHEDULE.FIRST..IOTBGE_PROCESS_SCHEDULE.LAST
            UPDATE GE_process_schedule
				SET
					Executable_Id = rcRecOfTab.Executable_Id(n),
					Parameters_ = rcRecOfTab.Parameters_(n),
					Frequency = rcRecOfTab.Frequency(n),
					Status = rcRecOfTab.Status(n),
					Job = rcRecOfTab.Job(n),
					Log_User = rcRecOfTab.Log_User(n),
					Start_Date_ = rcRecOfTab.Start_Date_(n),
					What = rcRecOfTab.What(n)
				where
					Process_Schedule_Id = rcRecOfTab.Process_Schedule_Id(n)
;
      END IF;
   END;
   PROCEDURE UPDEXECUTABLE_ID( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INUEXECUTABLE_ID$ IN GE_PROCESS_SCHEDULE.EXECUTABLE_ID%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			Executable_Id = inuExecutable_Id$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.EXECUTABLE_ID := INUEXECUTABLE_ID$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDPARAMETERS_( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, ISBPARAMETERS_$ IN GE_PROCESS_SCHEDULE.PARAMETERS_%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			Parameters_ = isbParameters_$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.PARAMETERS_ := ISBPARAMETERS_$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDFREQUENCY( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, ISBFREQUENCY$ IN GE_PROCESS_SCHEDULE.FREQUENCY%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			Frequency = isbFrequency$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.FREQUENCY := ISBFREQUENCY$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDSTATUS( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, ISBSTATUS$ IN GE_PROCESS_SCHEDULE.STATUS%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			Status = isbStatus$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.STATUS := ISBSTATUS$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDJOB( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INUJOB$ IN GE_PROCESS_SCHEDULE.JOB%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			Job = inuJob$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.JOB := INUJOB$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDLOG_USER( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, ISBLOG_USER$ IN GE_PROCESS_SCHEDULE.LOG_USER%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			Log_User = isbLog_User$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.LOG_USER := ISBLOG_USER$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDSTART_DATE_( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, IDTSTART_DATE_$ IN GE_PROCESS_SCHEDULE.START_DATE_%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			Start_Date_ = idtStart_Date_$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.START_DATE_ := IDTSTART_DATE_$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDWHAT( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, ISBWHAT$ IN GE_PROCESS_SCHEDULE.WHAT%TYPE, INULOCK IN NUMBER := 0 )
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF INULOCK = 1 THEN
         LOCKBYPK( INUPROCESS_SCHEDULE_ID, RCDATA );
      END IF;
      UPDATE GE_process_schedule
		set
			What = isbWhat$
		where
			Process_Schedule_Id = inuProcess_Schedule_Id;
      IF SQL%NOTFOUND THEN
         RAISE NO_DATA_FOUND;
      END IF;
      RCDATA.WHAT := ISBWHAT$;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION FNUGETPROCESS_SCHEDULE_ID( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.PROCESS_SCHEDULE_ID );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.PROCESS_SCHEDULE_ID );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FNUGETEXECUTABLE_ID( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.EXECUTABLE_ID%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.EXECUTABLE_ID );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.EXECUTABLE_ID );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FSBGETPARAMETERS_( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.PARAMETERS_%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.PARAMETERS_ );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.PARAMETERS_ );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FSBGETFREQUENCY( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.FREQUENCY%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.FREQUENCY );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.FREQUENCY );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FSBGETSTATUS( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.STATUS%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.STATUS );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.STATUS );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FNUGETJOB( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.JOB%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.JOB );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.JOB );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FSBGETLOG_USER( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.LOG_USER%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.LOG_USER );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.LOG_USER );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FDTGETSTART_DATE_( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.START_DATE_%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.START_DATE_ );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.START_DATE_ );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   FUNCTION FSBGETWHAT( INUPROCESS_SCHEDULE_ID IN GE_PROCESS_SCHEDULE.PROCESS_SCHEDULE_ID%TYPE, INURAISEERROR IN NUMBER := 1 )
    RETURN GE_PROCESS_SCHEDULE.WHAT%TYPE
    IS
      RCERROR STYGE_PROCESS_SCHEDULE;
    BEGIN
      RCERROR.PROCESS_SCHEDULE_ID := INUPROCESS_SCHEDULE_ID;
      IF BLDAO_USE_CACHE AND FBLALREADYLOADED( INUPROCESS_SCHEDULE_ID ) THEN
         RETURN ( RCDATA.WHAT );
      END IF;
      LOAD( INUPROCESS_SCHEDULE_ID );
      RETURN ( RCDATA.WHAT );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         IF INURAISEERROR = 1 THEN
            ERRORS.SETERROR( CNURECORD_NOT_EXIST, FSBGETMESSAGEDESCRIPTION || ' ' || FSBPRIMARYKEY( RCERROR ) );
            RAISE EX.CONTROLLED_ERROR;
          ELSE
            RETURN NULL;
         END IF;
   END;
   PROCEDURE SETUSECACHE( IBLUSECACHE IN BOOLEAN )
    IS
    BEGIN
      BLDAO_USE_CACHE := IBLUSECACHE;
   END;
 BEGIN
   GETDAO_USE_CACHE;
END DAGE_PROCESS_SCHEDULE;
/


