
CREATE OR REPLACE PACKAGE AU_BOAUDITPOLICY IS
   SUBTYPE TYRFRECENTITIESENABLED IS CONSTANTS.TYREFCURSOR;
   TYPE TYENTITYATTRIBUTELIST IS TABLE OF NUMBER( 10 ) INDEX BY BINARY_INTEGER;
   TYPE TYVALIDENTATTRTYPE IS TABLE OF NUMBER( 10 ) INDEX BY BINARY_INTEGER;
   RCSAEXECUTABLECACHE DASA_EXECUTABLE.STYSA_EXECUTABLE;
   USER_POLICY_TYPE_CONST CONSTANT VARCHAR2( 1 ) := 'U';
   PROCESS_AUDIT_POLICY_TYPE CONSTANT VARCHAR2( 1 ) := 'P';
   IS_FOR_ALL_USERS CONSTANT NUMBER( 2 ) := 1;
   IS_NOT_FOR_ALL_USERS CONSTANT NUMBER( 2 ) := 0;
   AUDIT_HAS_SCHEDULE CONSTANT NUMBER( 2 ) := 1;
   FORM_EXEC_PARA_CONST CONSTANT VARCHAR2( 30 ) := 'FORM_EXECUTABLE';
   DELP_EXEC_PARA_CONST CONSTANT VARCHAR2( 30 ) := 'DELPHI_EXECUTABLE';
   FUNCTION FSBVERSION
    RETURN VARCHAR2;
   PROCEDURE SETID( INVALUE IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE );
   PROCEDURE SETNAME( ISBVALUE IN AU_AUDIT_POLICY.NAME%TYPE );
   PROCEDURE SETDESCRIPTION( ISBVALUE IN AU_AUDIT_POLICY.DESCRIPTION%TYPE );
   PROCEDURE SETMODULE( INUVALUE IN AU_AUDIT_POLICY.MODULE_ID%TYPE );
   PROCEDURE SETOWNER( ISBVALUE IN AU_AUDIT_POLICY.OWNER_ID%TYPE );
   PROCEDURE SETPOLICYTYPE( INVALUE IN AU_AUDIT_POLICY.AUD_POL_TYPE%TYPE );
   PROCEDURE SETCREATIONDATE( IDTVALUE IN AU_AUDIT_POLICY.CREATION_DATE%TYPE );
   PROCEDURE SETSTATUS( INUVALUE IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE );
   PROCEDURE SETIDFORALLUSERS( INVALUE IN AU_AUDIT_POLICY.IS_FOR_ALL_USERS%TYPE );
   FUNCTION GETNEXTID
    RETURN NUMBER;
   PROCEDURE ADD;
   PROCEDURE DELETEBYCODE;
   PROCEDURE UPDATEAUDITPOLICY( AUDITPOLICYROW IN DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY );
   FUNCTION GETAUDITPOLICYBYID
    RETURN DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY;
   PROCEDURE ADDUSERTOAUDITPOLICY( INUUSER IN NUMBER );
   PROCEDURE DELETEUSERFROMAUDITPOLICY( INUUSER IN NUMBER );
   FUNCTION GETAUDITPOLICIESBYMODULE( INUMODULEID IN NUMBER )
    RETURN DAAU_AUDIT_POLICY.TYREFCURSOR;
   PROCEDURE VALIDATEAUDITPOLICYID( INUAUDITPOLICY IN NUMBER );
   PROCEDURE VALIDATEAUDITPOLICYNAME( ISBNAME IN VARCHAR2 );
   PROCEDURE VALIDATEAUDITPOLICYDESCRP( ISBDESCRIPTION IN VARCHAR2 );
   PROCEDURE VALIDATEAUDITPOLICYTYPE( ISBPOLICYTYPE IN VARCHAR2 );
   PROCEDURE VALIDATEAUDITPOLICYOWNER( INUVALUE IN NUMBER );
   PROCEDURE VALIDATEAUDITPOLICYMODULE( INUAUDITPOLICYSET IN NUMBER );
   PROCEDURE VALIDATEAUDITPOLICYUSERID( INUUSERID IN NUMBER );
   PROCEDURE VALIDATEOBJECTENTITYID( INUVALUE IN VARCHAR2 );
   PROCEDURE VALIDATELOGPOLICYID( INUVALUE IN NUMBER );
   PROCEDURE VALIDATEPROCESSID( INUVALUE IN NUMBER );
   PROCEDURE ADDSCHEDULE( DTINITIALDATE IN DATE, DTINITIALTIME IN DATE, DTFINALDATE IN DATE, DTFINALTIME IN DATE, ONUSCHEDULEID OUT NUMBER );
   PROCEDURE GETSCHEDULECHECKFOREXISTING( SCHEDULEROW IN OUT DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE );
   PROCEDURE CHECKAUDPOLSEQUENCEEXISTING;
   PROCEDURE ADDENTITYATTRIBUTE( INUENTITYATTRBUTE IN NUMBER, INUNEXTLOGPOLICY IN NUMBER, INUMONITORED IN NUMBER := AU_BOAUDPOLICYATTR.IS_MONITORED, INUINDEXINGAPPLIES IN NUMBER := AU_BOAUDPOLICYATTR.INDEX_NOT_APPLIES_CONST );
   PROCEDURE ADDATTRIBUTESBYDEFAULT( NUNEXTLOGPOLICY IN NUMBER );
   PROCEDURE CHECKDETAILNUMBEROFATTRIBUTES( INULOGPOLICYID IN NUMBER );
   PROCEDURE GETUSER( INUUSERID OUT NUMBER );
   FUNCTION GETALLEXECUTABLES( INUEXECUTABLE IN NUMBER := NULL )
    RETURN CONSTANTS.TYREFCURSOR;
   FUNCTION GETUSERSATTACHEDENABLED
    RETURN AU_BOUSER.TYRFRECUSERS;
   FUNCTION GETEXECUTABLETYPES
    RETURN DASA_EXECUTABLE_TYPE.TYREFCURSOR;
   FUNCTION GETENTITIESBYEXECUTABLE( INUEXECUTABLEID IN NUMBER )
    RETURN CONSTANTS.TYREFCURSOR;
   PROCEDURE ADDDETAIL( INUPROCESSID IN NUMBER, INUOBJECTENTITY IN NUMBER, INUEVENT IN NUMBER, INUOWNER IN NUMBER, SBNAME IN VARCHAR2, SBDESCRIPTION IN VARCHAR2, INUNEXTLOGPOLICY IN NUMBER, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE, INUSTATEMENT IN GE_STATEMENT.STATEMENT_ID%TYPE );
   PROCEDURE ADDAUDITPOLICYDETAILSELECT( INUAUDITPOLICYID IN NUMBER, INUPROCESSID IN NUMBER, INUEVENT IN NUMBER, SBNAME IN VARCHAR2, SBDESCRIPTION IN VARCHAR2, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE );
   PROCEDURE ADDUSER( INUUSERID IN NUMBER );
   PROCEDURE DELETEUSER( INUUSERID IN NUMBER );
   FUNCTION GETAUDITPOLICYDETAILSDETAILED
    RETURN DAAU_LOG_POLICY.TYREFCURSOR;
   FUNCTION GENERATETRIGGERNAMEBEFOREBURN( INUOBJENTITYID IN NUMBER, NUOPERATION IN NUMBER, INUAUDITPOLICYID IN NUMBER, INUPROCCESS IN NUMBER, INULOGPOLICY IN NUMBER )
    RETURN VARCHAR2;
   PROCEDURE DELETEDETAILRECORD( INULOGPOLICYID IN NUMBER );
   FUNCTION GETAUDITPOLICYDETAIL( INULOGPOLICYID IN NUMBER )
    RETURN DAAU_LOG_POLICY.STYAU_LOG_POLICY;
   PROCEDURE CHECKDETAILBELONGSTOAUDPOLICY( INULOGPOLICYID IN NUMBER );
   FUNCTION GETDETAILATTRIBUTES( INULOGPOLICYID IN NUMBER )
    RETURN DAAU_AUD_POL_ATTR.TYREFCURSOR;
   FUNCTION PREPARETRIGGERSTATEMENT( INULOGPOLICYID IN NUMBER )
    RETURN CLOB;
   FUNCTION ISUSERAUDITEDBYPOLICY( INUUSERID IN NUMBER )
    RETURN BOOLEAN;
   PROCEDURE UPDATESCHEDULE( SCHEDULEROW IN DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE );
   FUNCTION GETAUDPOLSEQUENCENAME
    RETURN VARCHAR2;
   FUNCTION GETALLAUDITPOLICIES
    RETURN DAAU_AUDIT_POLICY.TYREFCURSOR;
   PROCEDURE ADDOBJECTATTRIBUTECRITERIUM( INULOGPOLICYID IN NUMBER, INOBJECTATRIBUTEID IN NUMBER );
   PROCEDURE BURNTRIGGER( INULOGPOLICYID IN NUMBER );
   PROCEDURE UPDATESTATUS( INULOGPOLICYID IN NUMBER, INUSTATUS IN NUMBER );
   PROCEDURE ENABLEAUDITPOLICYDETAIL( INULOGPOLICYID IN NUMBER );
   PROCEDURE DISABLEAUDITPOLICYDETAIL( INULOGPOLICYID IN NUMBER );
   FUNCTION ISAUDITPOLICYENABLEDBYDATE( CURRENDATE IN DATE )
    RETURN BOOLEAN;
   FUNCTION ISPROCESSAUDITEDBYPOLICY( INUAUDIT_POLICY_ID IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE, INUPROCESSID IN NUMBER )
    RETURN BOOLEAN;
   PROCEDURE DROPTRIGGER( INULOGPOLICYID IN NUMBER );
   PROCEDURE GETAUDITPOLICYDETAILS( OTBLOGPOLICIES OUT DAAU_LOG_POLICY.TYTBAU_LOG_POLICY );
   PROCEDURE CHECKISENABLED;
   PROCEDURE DROPAUDITPOLICYDETAILS;
   PROCEDURE DROPTRIGGERANDCHECKEXISTSFIRST( INULOGPOLICY IN NUMBER );
   FUNCTION ISTRIGGEREXISTONDB( INULOGPOLICY IN NUMBER )
    RETURN BOOLEAN;
   PROCEDURE CHECKAUDPOLICYDETAILISENABLED( INULOGPOLICY IN NUMBER, INUPOLICYID IN NUMBER );
   FUNCTION GETAUDITPOLICYDETAILSTATUS( INULOGPOLICY IN NUMBER )
    RETURN NUMBER;
   PROCEDURE UPDATEAUDPOLICYDETAILSTATUS( INULOGPOLICY IN NUMBER, INUSTATUS IN NUMBER );
   PROCEDURE CHECKAUDPOLICYDETGENTIONSTATUS( INULOGPOLICY IN NUMBER );
   FUNCTION ISAUDITPOLDETAILTRIGGERENABLED( INULOGPOLICYID IN NUMBER )
    RETURN BOOLEAN;
   PROCEDURE DELETEUSERSATTACHED;
   FUNCTION GETAUDITPOLICYSTATUS
    RETURN NUMBER;
   PROCEDURE ENABLEAUDITPOLICYDETAILS;
   PROCEDURE DISABLEAUDITPOLICYDETAILS;
   PROCEDURE UPDATEISFORALLUSERS( INUISFORALLUSERS IN NUMBER );
   FUNCTION ISAUDITPOLICYENABLEDBYUSER( INUUSERID IN NUMBER )
    RETURN BOOLEAN;
   FUNCTION GETRECORDSBYEXAMPLE( SBWHERE IN VARCHAR2, DTINITIALDATE IN DATE, DTFINALDATE IN DATE, INUUSESDATING IN NUMBER )
    RETURN DAAU_AUDIT_POLICY_LOG.TYREFCURSOR;
   PROCEDURE CHECKENTITYATTRIBUTETOADD( INUENTITYATTRID IN NUMBER );
   FUNCTION GETNUMBEROFUSERSATTACHED
    RETURN NUMBER;
   FUNCTION GETAUDITPOLICYTYPE
    RETURN VARCHAR2;
   PROCEDURE CHECKAUDPOLTYPEINDELETEUSER;
   FUNCTION ISFORALLUSERS
    RETURN NUMBER;
   FUNCTION GETNUMBEROFSCHEDULES
    RETURN NUMBER;
   FUNCTION ISSCHEDULED
    RETURN NUMBER;
   PROCEDURE CHECKISSCHEDULEDALREADY;
   PROCEDURE DELETESCHEDULES;
   PROCEDURE CHECKISSCHEDULED;
   PROCEDURE GETSCHEDULE( DTINITIALDATE OUT DATE, DTINITIALTIME OUT DATE, DTFINALDATE OUT DATE, DTFINALTIME OUT DATE, NUSCHEDULEID OUT NUMBER );
   FUNCTION GETSCHEDULE
    RETURN DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE;
   PROCEDURE DROPAUDITPOLICYDETAIL( INLOGPOLICY IN NUMBER );
   FUNCTION GETENTITYATTRIBUTEMONITORED( INULOGPOLICYID IN NUMBER )
    RETURN NUMBER;
   FUNCTION GETNUMBEROFAUDITPOLICYDETAILS
    RETURN NUMBER;
   PROCEDURE CHECKNUMBEROFDETAILSATTACHED;
   FUNCTION GETSYSTEMDATE
    RETURN DATE;
   PROCEDURE ENABLEDDISABLEDAUDITPOLICY( INULOGPOLICYID IN NUMBER );
   PROCEDURE POLICYSELECTREGISTRY( INUUSER IN SA_USER.USER_ID%TYPE, INUEXECUTABLEID IN AU_LOG_POLICY.EXECUTABLE_ID%TYPE, ISBDESCRIPTION IN AU_AUDIT_POLICY_LOG.CURRENT_EVEN_DESC%TYPE, ISBTEXT IN AU_AUDIT_POLICY_LOG.LOG_TEXT%TYPE );
   PROCEDURE POLICYSELECT( ISBEXECUTABLENAME IN VARCHAR2, ISBQUERY IN VARCHAR2 );
   PROCEDURE UPDATESTATUSBYPOLICY( INUAUDITPOLICY IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE );
   PROCEDURE UPDSTATUSFORLOGPOLICY( INUAUDITPOLICY IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE );
   FUNCTION GETSTATUS
    RETURN NUMBER;
   FUNCTION GETALLEXECUTABLESBYMODULE( INUMODULE IN NUMBER )
    RETURN CONSTANTS.TYREFCURSOR;
END;
/


CREATE OR REPLACE PACKAGE BODY AU_BOAUDITPOLICY IS
   CSBVERSION CONSTANT VARCHAR2( 20 ) := 'SAO184225';
   CNUALL_USERS CONSTANT NUMBER( 1 ) := 1;
   AUDITPOLICY_DFLT_ATTRS_CONST CONSTANT VARCHAR2( 30 ) := 'AUDITPOLICY_DFLT_ATT';
   STRING_SEPARATOR_CHAR_CONST CONSTANT VARCHAR2( 2 ) := ',';
   TRIGGER_SUFX_TYPE_CONST CONSTANT VARCHAR2( 80 ) := 'AU_';
   TBVALIDENTATTRTYPE TYVALIDENTATTRTYPE;
   RCRECORD DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY;
   FUNCTION FSBVERSION
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN CSBVERSION;
   END;
   PROCEDURE SETID( INVALUE IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE )
    IS
    BEGIN
      RCRECORD.AUDIT_POLICY_ID := INVALUE;
   END;
   PROCEDURE SETNAME( ISBVALUE IN AU_AUDIT_POLICY.NAME%TYPE )
    IS
    BEGIN
      RCRECORD.NAME := ISBVALUE;
   END;
   PROCEDURE SETDESCRIPTION( ISBVALUE IN AU_AUDIT_POLICY.DESCRIPTION%TYPE )
    IS
    BEGIN
      RCRECORD.DESCRIPTION := ISBVALUE;
   END;
   PROCEDURE SETMODULE( INUVALUE IN AU_AUDIT_POLICY.MODULE_ID%TYPE )
    IS
    BEGIN
      RCRECORD.MODULE_ID := INUVALUE;
   END;
   PROCEDURE SETOWNER( ISBVALUE IN AU_AUDIT_POLICY.OWNER_ID%TYPE )
    IS
    BEGIN
      RCRECORD.OWNER_ID := ISBVALUE;
   END;
   PROCEDURE SETPOLICYTYPE( INVALUE IN AU_AUDIT_POLICY.AUD_POL_TYPE%TYPE )
    IS
    BEGIN
      RCRECORD.AUD_POL_TYPE := INVALUE;
   END;
   PROCEDURE SETCREATIONDATE( IDTVALUE IN AU_AUDIT_POLICY.CREATION_DATE%TYPE )
    IS
    BEGIN
      RCRECORD.CREATION_DATE := IDTVALUE;
   END;
   PROCEDURE SETSTATUS( INUVALUE IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE )
    IS
    BEGIN
      RCRECORD.AUD_POL_STATUS_ID := INUVALUE;
   END;
   PROCEDURE SETIDFORALLUSERS( INVALUE IN AU_AUDIT_POLICY.IS_FOR_ALL_USERS%TYPE )
    IS
    BEGIN
      RCRECORD.IS_FOR_ALL_USERS := INVALUE;
   END;
   FUNCTION GETNEXTID
    RETURN NUMBER
    IS
      NUMAX NUMBER;
    BEGIN
      RETURN AU_BOSEQUENCE.NEXTAU_AUDIT_POLICY;
    EXCEPTION
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE ADD
    IS
    BEGIN
      RCRECORD.ACTIVE_NOTIFICATIONS := GE_BOCONSTANTS.CSBNO;
      DAAU_AUDIT_POLICY.INSRECORD( RCRECORD );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE DELETEBYCODE
    IS
    BEGIN
      DAAU_AUDIT_POLICY.DELRECORD( RCRECORD.AUDIT_POLICY_ID );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDATEAUDITPOLICY( AUDITPOLICYROW IN DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY )
    IS
    BEGIN
      DAAU_AUDIT_POLICY.UPDRECORD( AUDITPOLICYROW );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETAUDITPOLICYBYID
    RETURN DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY
    IS
    BEGIN
      RETURN DAAU_AUDIT_POLICY.FRCGETRECORD( RCRECORD.AUDIT_POLICY_ID );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETAUDITPOLICYTYPE
    RETURN VARCHAR2
    IS
      AUDITPOLICYROW DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY;
    BEGIN
      AUDITPOLICYROW := GETAUDITPOLICYBYID;
      RETURN AUDITPOLICYROW.AUD_POL_TYPE;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE VALIDATEAUDITPOLICYID( INUAUDITPOLICY IN NUMBER )
    IS
    BEGIN
      IF ( INUAUDITPOLICY IS NULL OR ( CEIL( INUAUDITPOLICY ) != INUAUDITPOLICY ) ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4594 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATEPROCESSID( INUVALUE IN NUMBER )
    IS
    BEGIN
      IF ( INUVALUE IS NULL OR ( CEIL( INUVALUE ) != INUVALUE ) ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4622 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATEAUDITPOLICYUSERID( INUUSERID IN NUMBER )
    IS
    BEGIN
      IF ( INUUSERID IS NULL OR ( CEIL( INUUSERID ) != INUUSERID ) ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4680 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATEAUDITPOLICYNAME( ISBNAME IN VARCHAR2 )
    IS
    BEGIN
      IF ( ISBNAME IS NULL ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4600 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATEAUDITPOLICYDESCRP( ISBDESCRIPTION IN VARCHAR2 )
    IS
    BEGIN
      IF ( ISBDESCRIPTION IS NULL ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4620 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATEAUDITPOLICYOWNER( INUVALUE IN NUMBER )
    IS
    BEGIN
      IF ( INUVALUE IS NULL OR ( CEIL( INUVALUE ) != INUVALUE ) ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4701 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATEAUDITPOLICYTYPE( ISBPOLICYTYPE IN VARCHAR2 )
    IS
    BEGIN
      IF ( ISBPOLICYTYPE IS NULL ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4702 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
      IF ( ISBPOLICYTYPE = AU_BOAUDITPOLICY.USER_POLICY_TYPE_CONST OR ISBPOLICYTYPE = AU_BOAUDITPOLICY.PROCESS_AUDIT_POLICY_TYPE ) THEN
         RETURN;
      END IF;
      ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4702 );
      RAISE EX.CONTROLLED_ERROR;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE VALIDATEAUDITPOLICYMODULE( INUAUDITPOLICYSET IN NUMBER )
    IS
    BEGIN
      IF ( INUAUDITPOLICYSET IS NULL OR ( CEIL( INUAUDITPOLICYSET ) != INUAUDITPOLICYSET ) ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4800 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATELOGPOLICYID( INUVALUE IN NUMBER )
    IS
    BEGIN
      IF ( INUVALUE IS NULL OR ( CEIL( INUVALUE ) != INUVALUE ) ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR2217 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE VALIDATEOBJECTENTITYID( INUVALUE IN VARCHAR2 )
    IS
    BEGIN
      AU_BOLOGPOLICY.VALIDATEOBJECTENTITYID( INUVALUE );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETUSERS
    RETURN AU_BOUSER.TYRFRECUSERS
    IS
      CUUSERS AU_BOUSER.TYRFRECUSERS;
    BEGIN
      OPEN CUUSERS FOR SELECT auwu.*
        FROM  au_audit_policy aupl ,AU_AUD_POLICY_USERS  auupl  ,VW_AU_USER auwu
        WHERE aupl.AUDIT_POLICY_ID = rcRecord.AUDIT_POLICY_ID  AND
            auupl.AUDIT_POLICY_ID = aupl.AUDIT_POLICY_ID AND
            auupl.USER_ID = auwu.USER_ID
        ORDER BY auwu.mask;
      RETURN CUUSERS;
    EXCEPTION
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE GETUSERS( OTBUSERS OUT AU_BOUSER.TYTAU_VWUSER )
    IS
      RFUSERS AU_BOUSER.TYRFRECUSERS;
      NUINDEX NUMBER := 1;
    BEGIN
      RFUSERS := GETUSERS;
      OTBUSERS.DELETE;
      LOOP
         FETCH RFUSERS
            INTO OTBUSERS( NUINDEX );
         EXIT WHEN ( RFUSERS%NOTFOUND );
         NUINDEX := NUINDEX + 1;
      END LOOP;
      CLOSE RFUSERS;
    EXCEPTION
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETNUMBEROFUSERSATTACHED
    RETURN NUMBER
    IS
      OTBUSERS AU_BOUSER.TYTAU_VWUSER;
    BEGIN
      GETUSERS( OTBUSERS );
      RETURN OTBUSERS.COUNT;
   END;
   PROCEDURE ADDUSERTOAUDITPOLICY( INUUSER IN NUMBER )
    IS
      POLICIESUSERROW DAAU_AUD_POLICY_USERS.STYAU_AUD_POLICY_USERS;
    BEGIN
      POLICIESUSERROW.AUDIT_POLICY_ID := RCRECORD.AUDIT_POLICY_ID;
      POLICIESUSERROW.USER_ID := INUUSER;
      DAAU_AUD_POLICY_USERS.INSRECORD( POLICIESUSERROW );
   END;
   PROCEDURE DELETEUSERFROMAUDITPOLICY( INUUSER IN NUMBER )
    IS
    BEGIN
      DAAU_AUD_POLICY_USERS.DELRECORD( RCRECORD.AUDIT_POLICY_ID, INUUSER );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETAUDITPOLICIESBYMODULE( INUMODULEID IN NUMBER )
    RETURN DAAU_AUDIT_POLICY.TYREFCURSOR
    IS
      RCAUDITPOLICIES DAAU_AUDIT_POLICY.TYREFCURSOR;
    BEGIN
      OPEN RCAUDITPOLICIES FOR SELECT au_audit_policy.*,au_audit_policy.rowid
            FROM au_audit_policy
            WHERE module_id = inuModuleId
            ORDER BY CREATION_DATE;
      RETURN RCAUDITPOLICIES;
   END;
   FUNCTION GETALLAUDITPOLICIES
    RETURN DAAU_AUDIT_POLICY.TYREFCURSOR
    IS
      RCAUDITPOLICIES DAAU_AUDIT_POLICY.TYREFCURSOR;
    BEGIN
      OPEN RCAUDITPOLICIES FOR SELECT au_audit_policy.*,au_audit_policy.rowid
            FROM au_audit_policy
            ORDER BY CREATION_DATE;
      RETURN RCAUDITPOLICIES;
   END;
   PROCEDURE ADDSCHEDULE( DTINITIALDATE IN DATE, DTINITIALTIME IN DATE, DTFINALDATE IN DATE, DTFINALTIME IN DATE, ONUSCHEDULEID OUT NUMBER )
    IS
    BEGIN
      ONUSCHEDULEID := AU_BOAUDPOLSHEDULE.GETNEXTID;
      AU_BOAUDPOLSHEDULE.SETAUDPOLSCHEDULEID( ONUSCHEDULEID );
      AU_BOAUDPOLSHEDULE.SETAUDPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      AU_BOAUDPOLSHEDULE.SETINITIALDATE( TRUNC( DTINITIALDATE ) );
      AU_BOAUDPOLSHEDULE.SETINITIALTIME( DTINITIALTIME );
      AU_BOAUDPOLSHEDULE.SETFINALDATE( TRUNC( DTFINALDATE ) );
      AU_BOAUDPOLSHEDULE.SETFINALTIME( DTFINALTIME );
      AU_BOAUDPOLSHEDULE.ADDSHEDULE;
   END;
   FUNCTION GETSCHEDULES
    RETURN DAAU_AUD_POL_SCHEDULE.TYREFCURSOR
    IS
      RCSCHEDULES DAAU_AUD_POL_SCHEDULE.TYREFCURSOR;
    BEGIN
      OPEN RCSCHEDULES FOR SELECT AU_aud_pol_schedule.*, AU_aud_pol_schedule.rowid
            FROM AU_aud_pol_schedule
            WHERE AUDIT_POLICY_ID = rcRecord.AUDIT_POLICY_ID
               -- we make sure we are fecthing just one
               -- in the feature many schedules will be posible
              AND rownum <= 1;
      RETURN RCSCHEDULES;
   END;
   FUNCTION GETNUMBEROFSCHEDULES
    RETURN NUMBER
    IS
      NUCOUNT NUMBER := 0.0;
    BEGIN
      SELECT count(*) INTO nuCount
            FROM AU_aud_pol_schedule
            WHERE AUDIT_POLICY_ID = rcRecord.AUDIT_POLICY_ID;
      RETURN NUCOUNT;
   END;
   PROCEDURE GETSCHEDULES( OTBSCHEDULES OUT DAAU_AUD_POL_SCHEDULE.TYTBAU_AUD_POL_SCHEDULE )
    IS
      RCSCHEDULES DAAU_AUD_POL_SCHEDULE.TYREFCURSOR;
      NUINDEX NUMBER := 1;
    BEGIN
      RCSCHEDULES := GETSCHEDULES;
      LOOP
         FETCH RCSCHEDULES
            INTO OTBSCHEDULES( NUINDEX );
         EXIT WHEN RCSCHEDULES%NOTFOUND;
         NUINDEX := NUINDEX + 1.0;
      END LOOP;
      CLOSE RCSCHEDULES;
   END;
   FUNCTION GETSCHEDULE
    RETURN DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE
    IS
      OTBSCHEDULES DAAU_AUD_POL_SCHEDULE.TYTBAU_AUD_POL_SCHEDULE;
    BEGIN
      GETSCHEDULES( OTBSCHEDULES );
      RETURN OTBSCHEDULES( 1 );
   END;
   PROCEDURE GETSCHEDULE( DTINITIALDATE OUT DATE, DTINITIALTIME OUT DATE, DTFINALDATE OUT DATE, DTFINALTIME OUT DATE, NUSCHEDULEID OUT NUMBER )
    IS
      SCHEDULEROW DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE;
      OTBSCHEDULES DAAU_AUD_POL_SCHEDULE.TYTBAU_AUD_POL_SCHEDULE;
    BEGIN
      GETSCHEDULES( OTBSCHEDULES );
      SCHEDULEROW := OTBSCHEDULES( 1 );
      DTINITIALDATE := SCHEDULEROW.INITIAL_DATE;
      DTINITIALTIME := SCHEDULEROW.INITIAL_TIME;
      DTFINALDATE := SCHEDULEROW.FINAL_DATE;
      DTFINALTIME := SCHEDULEROW.FINAL_TIME;
      NUSCHEDULEID := SCHEDULEROW.AUD_POL_SCHEDULE_ID;
   END;
   PROCEDURE GETSCHEDULECHECKFOREXISTING( DTINITIALDATE OUT DATE, DTINITIALTIME OUT DATE, DTFINALDATE OUT DATE, DTFINALTIME OUT DATE, NUSCHEDULEID OUT NUMBER )
    IS
      SCHEDULEROW DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE;
    BEGIN
      GETSCHEDULECHECKFOREXISTING( SCHEDULEROW );
      DTINITIALDATE := SCHEDULEROW.INITIAL_DATE;
      DTINITIALTIME := SCHEDULEROW.INITIAL_TIME;
      DTFINALDATE := SCHEDULEROW.FINAL_DATE;
      DTFINALTIME := SCHEDULEROW.FINAL_TIME;
      NUSCHEDULEID := SCHEDULEROW.AUD_POL_SCHEDULE_ID;
   END;
   PROCEDURE GETSCHEDULECHECKFOREXISTING( SCHEDULEROW IN OUT DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE )
    IS
      OTBSCHEDULES DAAU_AUD_POL_SCHEDULE.TYTBAU_AUD_POL_SCHEDULE;
    BEGIN
      GETSCHEDULES( OTBSCHEDULES );
      IF ( OTBSCHEDULES.COUNT = 0 ) THEN
         AU_BOAUDITPOLICY.ADDSCHEDULE( SCHEDULEROW.INITIAL_DATE, SCHEDULEROW.INITIAL_TIME, SCHEDULEROW.FINAL_DATE, SCHEDULEROW.FINAL_TIME, SCHEDULEROW.AUD_POL_SCHEDULE_ID );
      END IF;
      GETSCHEDULES( OTBSCHEDULES );
      SCHEDULEROW := OTBSCHEDULES( 1 );
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN;
   END;
   PROCEDURE GETUSER( INUUSERID OUT NUMBER )
    IS
      OTBUSERS AU_BOUSER.TYTAU_VWUSER;
    BEGIN
      GETUSERS( OTBUSERS );
      INUUSERID := OTBUSERS( 1 ).USER_ID;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN;
   END;
   FUNCTION GETALLEXECUTABLES( INUEXECUTABLE IN NUMBER := NULL )
    RETURN CONSTANTS.TYREFCURSOR
    IS
      RCEXECUTABLE CONSTANTS.TYREFCURSOR;
    BEGIN
      IF ( INUEXECUTABLE IS NULL ) THEN
         OPEN RCEXECUTABLE FOR SELECT unique SA_EXECUTABLE.*,SA_EXECUTABLE.rowid
	           FROM sa_executable;
       ELSE
         OPEN RCEXECUTABLE FOR SELECT unique SA_EXECUTABLE.*,SA_EXECUTABLE.rowid
	           FROM sa_executable
               WHERE sa_executable.executable_type_id = inuExecutable;
      END IF;
      RETURN RCEXECUTABLE;
   END;
   FUNCTION GETAUDPOLSEQUENCENAME
    RETURN VARCHAR2
    IS
      ATTRIBUTEROW DAGE_ATTRIBUTES.STYGE_ATTRIBUTES;
    BEGIN
      ATTRIBUTEROW := GE_BOATTRIBUTES.GETATTRIBUTEBYID( AU_BOLOGPOLICY.AUDIT_POLICY_LOG_ATTR_ID );
      RETURN ATTRIBUTEROW.DEFAULT_VALUE;
   END;
   FUNCTION ISAUDPOLSEQUENCEEXISTING
    RETURN BOOLEAN
    IS
    BEGIN
      RETURN UT_OBJECT.FBOEXISTOBJECT( GETAUDPOLSEQUENCENAME );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE CHECKAUDPOLSEQUENCEEXISTING
    IS
    BEGIN
      IF ( ISAUDPOLSEQUENCEEXISTING = FALSE ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR1720, GETAUDPOLSEQUENCENAME );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETUSERSATTACHEDENABLED
    RETURN AU_BOUSER.TYRFRECUSERS
    IS
      CUUSERS AU_BOUSER.TYRFRECUSERS;
    BEGIN
      OPEN CUUSERS FOR SELECT auwu.* , decode(nvl(auwu.user_id,-1),aupu.user_id,1,0) enabled
	        FROM  VW_AU_USER auwu , AU_AUD_POLICY_USERS aupu
	        WHERE aupu.AUDIT_POLICY_ID(+) = rcRecord.AUDIT_POLICY_ID  AND
	        aupu.user_id(+) =  auwu.user_id
	        ORDER BY auwu.mask;
      RETURN CUUSERS;
    EXCEPTION
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETEXECUTABLETYPES
    RETURN DASA_EXECUTABLE_TYPE.TYREFCURSOR
    IS
    BEGIN
      RETURN DASA_EXECUTABLE_TYPE.FRFGETRECORDS;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETENTITIESBYEXECUTABLE( INUEXECUTABLEID IN NUMBER )
    RETURN CONSTANTS.TYREFCURSOR
    IS
      ENTITYEXECUTABLE CONSTANTS.TYREFCURSOR;
    BEGIN
      OPEN ENTITYEXECUTABLE FOR SELECT ge_entity.*
			FROM SA_exec_entities, ge_entity
            WHERE SA_exec_entities.executable_id = inuExecutableId AND
                  SA_exec_entities.entity_id = ge_entity.entity_id;
      RETURN ENTITYEXECUTABLE;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETDFLTATTRSSTRINGFROMSYSVAR
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN GE_BOPARAMETER.FSBGET( AU_BOAUDITPOLICY.AUDITPOLICY_DFLT_ATTRS_CONST );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR1927 );
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETDFLTATTRSASARRFROMSYSVAR
    RETURN UT_STRING.TYTB_STRING
    IS
      SBVALUE VARCHAR2( 2500 );
      ARATTRIBUTESLIST UT_STRING.TYTB_STRING;
      NUPOS NUMBER;
    BEGIN
      SBVALUE := GETDFLTATTRSSTRINGFROMSYSVAR;
      NUPOS := INSTR( SBVALUE, STRING_SEPARATOR_CHAR_CONST, LENGTH( STRING_SEPARATOR_CHAR_CONST ), 1 );
      IF ( NUPOS = 0 ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR1928, AU_BOAUDITPOLICY.AUDITPOLICY_DFLT_ATTRS_CONST );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
      UT_STRING.EXTSTRING( SBVALUE, STRING_SEPARATOR_CHAR_CONST, ARATTRIBUTESLIST );
      RETURN ARATTRIBUTESLIST;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GENERATETRIGGERNAMEBEFOREBURN( INUOBJENTITYID IN NUMBER, NUOPERATION IN NUMBER, INUAUDITPOLICYID IN NUMBER, INUPROCCESS IN NUMBER, INULOGPOLICY IN NUMBER )
    RETURN VARCHAR2
    IS
      SBOPENAME VARCHAR2( 80 );
      SBENTITYNAME VARCHAR2( 30 );
    BEGIN
      VALIDATEAUDITPOLICYID( INUAUDITPOLICYID );
      GE_BOENTITY.SETID( INUOBJENTITYID );
      SBENTITYNAME := SUBSTR( GE_BOENTITY.GETNAME, 1, 10 );
      SBOPENAME := SUBSTR( DAGE_EVENT.FSBGETDESCRIPTION( NUOPERATION ), 1, 1 );
      RETURN AU_BOLOGPOLICY.TRIGGER_NAME_PREX_CONST || TRIGGER_SUFX_TYPE_CONST || AU_BOLOGPOLICY.TRIGGER_TIME_SUFX_CONST || SBOPENAME || '_' || SBENTITYNAME || '_' || INUAUDITPOLICYID || '_' || INULOGPOLICY;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE ADDDETAIL( INUPROCESSID IN NUMBER, INUOBJECTENTITY IN NUMBER, INUEVENT IN NUMBER, INUOWNER IN NUMBER, SBNAME IN VARCHAR2, SBDESCRIPTION IN VARCHAR2, INUNEXTLOGPOLICY IN NUMBER, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE, INUSTATEMENT IN GE_STATEMENT.STATEMENT_ID%TYPE )
    IS
      AUDITPOLICYROW DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY;
      SBTRIGGERNAME AU_LOG_POLICY.TRIGGER_NAME%TYPE;
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      AUDITPOLICYROW := GETAUDITPOLICYBYID;
      SBTRIGGERNAME := GENERATETRIGGERNAMEBEFOREBURN( INUOBJECTENTITY, INUEVENT, RCRECORD.AUDIT_POLICY_ID, INUPROCESSID, INUNEXTLOGPOLICY );
      AU_BOLOGPOLICY.SETID( INUNEXTLOGPOLICY );
      AU_BOLOGPOLICY.SETAUDPOLICY( RCRECORD.AUDIT_POLICY_ID );
      AU_BOLOGPOLICY.SETEXECUTABLEID( INUPROCESSID );
      AU_BOLOGPOLICY.SETOBJECTENTITYID( INUOBJECTENTITY );
      AU_BOLOGPOLICY.SETLOGPOLICYTYPE( AU_BOLOGPOLICY.AUDIT_POLICY_TYPE_CONST );
      AU_BOLOGPOLICY.SETCREATIONDATE( SYSDATE );
      AU_BOLOGPOLICY.SETOPERATION( INUEVENT );
      AU_BOLOGPOLICY.SETNAME( SBNAME );
      AU_BOLOGPOLICY.SETDESCRIPTION( SBDESCRIPTION );
      AU_BOLOGPOLICY.SETOWNER( INUOWNER );
      AU_BOLOGPOLICY.SETSTATUS( INUSTATUS );
      AU_BOLOGPOLICY.SETMODULE( AUDITPOLICYROW.MODULE_ID );
      AU_BOLOGPOLICY.SETTABLESPACENAME( AU_BOLOGPOLICY.TABLESPACE_NONE_NAME );
      AU_BOLOGPOLICY.SETTRIGGERNAME( SBTRIGGERNAME );
      AU_BOLOGPOLICY.SETBASETABLENAME( AU_BOLOGPOLICY.BASE_AUDIT_TABLE_NAME );
      AU_BOLOGPOLICY.SETSTATEMENTID( INUSTATEMENT );
      AU_BOLOGPOLICY.ADD;
   END;
   PROCEDURE ADDAUDITPOLICYDETAILSELECT( INUAUDITPOLICYID IN NUMBER, INUPROCESSID IN NUMBER, INUEVENT IN NUMBER, SBNAME IN VARCHAR2, SBDESCRIPTION IN VARCHAR2, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE )
    IS
      AUDITPOLICYROW DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY;
    BEGIN
      AU_BOAUDITPOLICY.SETID( INUAUDITPOLICYID );
      AUDITPOLICYROW := AU_BOAUDITPOLICY.GETAUDITPOLICYBYID;
      AU_BOLOGPOLICY.SETAUDPOLICY( INUAUDITPOLICYID );
      AU_BOLOGPOLICY.SETNAME( SBNAME );
      AU_BOLOGPOLICY.SETDESCRIPTION( SBDESCRIPTION );
      AU_BOLOGPOLICY.SETMODULE( AUDITPOLICYROW.MODULE_ID );
      AU_BOLOGPOLICY.SETLOGPOLICYTYPE( AU_BOLOGPOLICY.AUDIT_POLICY_TYPE_CONST );
      AU_BOLOGPOLICY.SETEXECUTABLEID( INUPROCESSID );
      AU_BOLOGPOLICY.SETOBJECTENTITYID( NULL );
      AU_BOLOGPOLICY.SETBASETABLENAME( AU_BOLOGPOLICY.BASE_AUDIT_TABLE_NAME );
      AU_BOLOGPOLICY.SETTRIGGERNAME( NULL );
      AU_BOLOGPOLICY.SETOPERATION( INUEVENT );
      AU_BOLOGPOLICY.SETOWNER( AU_BOSYSTEM.GETSYSTEMUSERID );
      AU_BOLOGPOLICY.SETCREATIONDATE( SYSDATE );
      AU_BOLOGPOLICY.SETSTATUS( INUSTATUS );
      AU_BOLOGPOLICY.SETTABLESPACENAME( AU_BOLOGPOLICY.TABLESPACE_NONE_NAME );
      AU_BOLOGPOLICY.ADD;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE ADDENTITYATTRIBUTE( INUENTITYATTRBUTE IN NUMBER, INUNEXTLOGPOLICY IN NUMBER, INUMONITORED IN NUMBER := AU_BOAUDPOLICYATTR.IS_MONITORED, INUINDEXINGAPPLIES IN NUMBER := AU_BOAUDPOLICYATTR.INDEX_NOT_APPLIES_CONST )
    IS
      ENTITYATTRIBUTEROW DAGE_ENTITY_ATTRIBUTES.STYGE_ENTITY_ATTRIBUTES;
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      GE_BOENTITYATTRIBUTES.SETID( INUENTITYATTRBUTE );
      ENTITYATTRIBUTEROW := GE_BOENTITYATTRIBUTES.GETENTITYATRIBUTEBYID;
      AU_BOAUDPOLICYATTR.SETTARGETFIELD( ENTITYATTRIBUTEROW.TECHNICAL_NAME );
      AU_BOAUDPOLICYATTR.SETID( AU_BOAUDPOLICYATTR.GETNEXTID );
      AU_BOAUDPOLICYATTR.SETAUDITPOLICYID( INUNEXTLOGPOLICY );
      AU_BOAUDPOLICYATTR.SETATRIBUTECLASS( AU_BOAUDPOLICYATTR.ENTITY_ATTIBUTE_TYPE_CONST );
      AU_BOAUDPOLICYATTR.SETENTITYATTRIBUTEID( INUENTITYATTRBUTE );
      AU_BOAUDPOLICYATTR.SETINDEXINGAPPLIES( INUINDEXINGAPPLIES );
      AU_BOAUDPOLICYATTR.SETPARENTATTRIBUTE( NULL );
      AU_BOAUDPOLICYATTR.SETATTRIBUTE( NULL );
      AU_BOAUDPOLICYATTR.SETISOBJECTATTRIBUTE( AU_BOAUDPOLICYATTR.IS_OBJECT_ATTRIBUTE );
      AU_BOAUDPOLICYATTR.SETISMONITORED( INUMONITORED );
      AU_BOAUDPOLICYATTR.SETORDERNUMBER( AU_BOAUDPOLICYATTR.GETNEXTSEQNUMBERID( INUNEXTLOGPOLICY ) );
      AU_BOAUDPOLICYATTR.VALIDATABASEONATTRIBUTECLASS;
      AU_BOAUDPOLICYATTR.ADD;
   END;
   PROCEDURE GETDETAILATTRIBUTES( INULOGPOLICYID IN NUMBER, OTBRESULT OUT DAAU_AUD_POL_ATTR.TYTBAU_AUD_POL_ATTR )
    IS
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      AU_BOLOGPOLICY.GETATTRIBUTES( OTBRESULT );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE CHECKDETAILNUMBEROFATTRIBUTES( INULOGPOLICYID IN NUMBER )
    IS
      OTBRESULT DAAU_AUD_POL_ATTR.TYTBAU_AUD_POL_ATTR;
    BEGIN
      GETDETAILATTRIBUTES( INULOGPOLICYID, OTBRESULT );
      IF ( OTBRESULT.COUNT = 0 ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4170 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE ADDATTRIBUTESBYDEFAULT( NUNEXTLOGPOLICY IN NUMBER )
    IS
      ARATTRIBUTESLIST UT_STRING.TYTB_STRING;
      NUATTRIBUTE NUMBER;
      ATTRIBUTEROW DAGE_ATTRIBUTES.STYGE_ATTRIBUTES;
    BEGIN
      ARATTRIBUTESLIST := GETDFLTATTRSASARRFROMSYSVAR;
      FOR I IN 1..ARATTRIBUTESLIST.COUNT
       LOOP
         NUATTRIBUTE := ARATTRIBUTESLIST( I );
         ATTRIBUTEROW := GE_BOATTRIBUTES.GETATTRIBUTEBYID( NUATTRIBUTE );
         AU_BOAUDPOLICYATTR.SETTARGETFIELD( ATTRIBUTEROW.DISPLAY_NAME );
         AU_BOAUDPOLICYATTR.SETID( AU_BOAUDPOLICYATTR.GETNEXTID );
         AU_BOAUDPOLICYATTR.SETAUDITPOLICYID( NUNEXTLOGPOLICY );
         AU_BOAUDPOLICYATTR.SETATRIBUTECLASS( ATTRIBUTEROW.ATTRIBUTE_CLASS_ID );
         AU_BOAUDPOLICYATTR.SETATTRIBUTE( NUATTRIBUTE );
         AU_BOAUDPOLICYATTR.SETENTITYATTRIBUTEID( NULL );
         AU_BOAUDPOLICYATTR.SETINDEXINGAPPLIES( AU_BOAUDPOLICYATTR.INDEX_NOT_APPLIES_CONST );
         AU_BOAUDPOLICYATTR.SETPARENTATTRIBUTE( NULL );
         AU_BOAUDPOLICYATTR.SETISOBJECTATTRIBUTE( AU_BOAUDPOLICYATTR.IS_NOT_OBJECT_ATTRIBUTE );
         AU_BOAUDPOLICYATTR.SETISMONITORED( AU_BOAUDPOLICYATTR.IS_NOT_MONITORED );
         AU_BOAUDPOLICYATTR.SETORDERNUMBER( AU_BOAUDPOLICYATTR.GETNEXTSEQNUMBERID( NUNEXTLOGPOLICY ) );
         AU_BOAUDPOLICYATTR.VALIDATABASEONATTRIBUTECLASS;
         AU_BOAUDPOLICYATTR.ADD;
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE ADDUSER( INUUSERID IN NUMBER )
    IS
      IRCAU_AUD_POLICY_USERS DAAU_AUD_POLICY_USERS.STYAU_AUD_POLICY_USERS;
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      IRCAU_AUD_POLICY_USERS.AUDIT_POLICY_ID := RCRECORD.AUDIT_POLICY_ID;
      IRCAU_AUD_POLICY_USERS.USER_ID := INUUSERID;
      IF ( NOT DAAU_AUD_POLICY_USERS.FBLEXIST( IRCAU_AUD_POLICY_USERS.AUDIT_POLICY_ID, INUUSERID ) ) THEN
         DAAU_AUD_POLICY_USERS.INSRECORD( IRCAU_AUD_POLICY_USERS );
      END IF;
   END;
   PROCEDURE DELETEUSER( INUUSERID IN NUMBER )
    IS
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      IF ( DAAU_AUD_POLICY_USERS.FBLEXIST( RCRECORD.AUDIT_POLICY_ID, INUUSERID ) ) THEN
         DAAU_AUD_POLICY_USERS.DELRECORD( RCRECORD.AUDIT_POLICY_ID, INUUSERID );
      END IF;
   END;
   FUNCTION GETAUDITPOLICYDETAILSDETAILED
    RETURN DAAU_LOG_POLICY.TYREFCURSOR
    IS
      RC DAAU_LOG_POLICY.TYREFCURSOR;
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      OPEN RC FOR SELECT alp.* ,get.name_ "OBJECT_ENTITY_NAME" ,get.display_name "DISPLAY_NAME",
            sex.name  "EXECUTABLE_NAME" ,sex.description "EXECUTABLE_DESCRIPTION"
            FROM  au_log_policy alp , ge_entity get , sa_executable sex
            WHERE alp.audit_policy_id = rcRecord.AUDIT_POLICY_ID  AND
            alp.object_entity_id =  get.entity_id(+)  AND
            alp.executable_id = sex.executable_id
            ORDER BY alp.CREATION_DATE;
      RETURN RC;
   END;
   FUNCTION GETAUDITPOLICYDETAILS
    RETURN DAAU_LOG_POLICY.TYREFCURSOR
    IS
      RC DAAU_LOG_POLICY.TYREFCURSOR;
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      OPEN RC FOR SELECT alp.*,alp.rowid
            FROM  au_log_policy alp
            WHERE alp.audit_policy_id = rcRecord.AUDIT_POLICY_ID ;
      RETURN RC;
   END;
   PROCEDURE GETAUDITPOLICYDETAILS( OTBLOGPOLICIES OUT DAAU_LOG_POLICY.TYTBAU_LOG_POLICY )
    IS
      RCLOGPOLICIES DAAU_LOG_POLICY.TYREFCURSOR;
      NUINDEX NUMBER := 1;
    BEGIN
      RCLOGPOLICIES := GETAUDITPOLICYDETAILS;
      LOOP
         FETCH RCLOGPOLICIES
            INTO OTBLOGPOLICIES( NUINDEX );
         EXIT WHEN RCLOGPOLICIES%NOTFOUND;
         NUINDEX := NUINDEX + 1.0;
      END LOOP;
      CLOSE RCLOGPOLICIES;
   END;
   PROCEDURE DELETEDETAILRECORD( INULOGPOLICYID IN NUMBER )
    IS
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      DELETE Au_log_policy
           WHERE Au_log_policy.audit_log_id = inuLogPolicyId AND
   		           Au_log_policy.audit_policy_id = rcRecord.AUDIT_POLICY_ID;
   END;
   FUNCTION GETAUDITPOLICYDETAIL( INULOGPOLICYID IN NUMBER )
    RETURN DAAU_LOG_POLICY.STYAU_LOG_POLICY
    IS
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      RETURN AU_BOLOGPOLICY.GETLOGPOLICYBYID;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE CHECKDETAILBELONGSTOAUDPOLICY( INULOGPOLICYID IN NUMBER )
    IS
      AULOGPOLICY DAAU_LOG_POLICY.STYAU_LOG_POLICY;
      SBMESSAGE VARCHAR2( 80 );
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      AULOGPOLICY := GETAUDITPOLICYDETAIL( INULOGPOLICYID );
      IF ( RCRECORD.AUDIT_POLICY_ID != AULOGPOLICY.AUDIT_POLICY_ID ) THEN
         SBMESSAGE := INULOGPOLICYID || '|' || RCRECORD.AUDIT_POLICY_ID;
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR2170, SBMESSAGE );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETDETAILATTRIBUTES( INULOGPOLICYID IN NUMBER )
    RETURN DAAU_AUD_POL_ATTR.TYREFCURSOR
    IS
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      RETURN AU_BOLOGPOLICY.GETATTRIBUTES;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION PREPARETRIGGERSTATEMENT( INULOGPOLICYID IN NUMBER )
    RETURN CLOB
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( INULOGPOLICYID );
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      AU_BOLOGPOLICY.SETLOGPOLICYDFLTATTRID( AU_BOLOGPOLICY.AUDIT_POLICY_ATTRIBUTE_ID );
      RETURN AU_BOLOGPOLICY.PREPARETRIGGERSTATEMENT;
   END;
   FUNCTION ISAUDITPOLICICYFORALLUSERS
    RETURN BOOLEAN
    IS
      NUISFORALLUSERS NUMBER := 0;
    BEGIN
      SELECT nvl(is_for_all_users,-1)
       INTO nuIsforallUsers
       FROM au_audit_policy
       WHERE AUDIT_POLICY_ID = rcRecord.AUDIT_POLICY_ID;
      IF ( NUISFORALLUSERS <= 0 ) THEN
         RETURN FALSE;
       ELSE
         RETURN TRUE;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN FALSE;
   END;
   FUNCTION ISUSERAUDITEDBYPOLICY( INUUSERID IN NUMBER )
    RETURN BOOLEAN
    IS
      NUCOUNT NUMBER := 0.0;
    BEGIN
      SELECT count(*) INTO nuCount
       FROM AU_AUD_POLICY_USERS
       WHERE AUDIT_POLICY_ID = rcRecord.AUDIT_POLICY_ID
       AND USER_ID = inuUserId;
      IF ( NUCOUNT = 0 ) THEN
         RETURN FALSE;
       ELSE
         RETURN TRUE;
      END IF;
    EXCEPTION
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION ISAUDITPOLICYENABLEDBYUSER( INUUSERID IN NUMBER )
    RETURN BOOLEAN
    IS
    BEGIN
      IF ISAUDITPOLICICYFORALLUSERS THEN
         RETURN TRUE;
      END IF;
      RETURN ISUSERAUDITEDBYPOLICY( INUUSERID );
   END;
   PROCEDURE UPDATESCHEDULE( SCHEDULEROW IN DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE )
    IS
    BEGIN
      AU_BOAUDPOLSHEDULE.UPDATESCHEDULE( SCHEDULEROW );
   END;
   PROCEDURE ADDOBJECTATTRIBUTECRITERIUM( INULOGPOLICYID IN NUMBER, INOBJECTATRIBUTEID IN NUMBER )
    IS
      NUORDER NUMBER;
      ENTITYATTROW DAGE_ENTITY_ATTRIBUTES.STYGE_ENTITY_ATTRIBUTES;
      SBVALUE VARCHAR2( 100 );
      TBREFERENCES UT_DMLTRIGGER.TYREFCOLUMNSCONST;
    BEGIN
      GE_BOENTITYATTRIBUTES.SETID( INOBJECTATRIBUTEID );
      ENTITYATTROW := GE_BOENTITYATTRIBUTES.GETENTITYATRIBUTEBYID;
      TBREFERENCES := UT_DMLTRIGGER.GETTBREFERENCES;
      SBVALUE := TBREFERENCES( UT_DMLTRIGGER.TRIGG_OLD_VALUE_CONST );
      SBVALUE := SBVALUE || ENTITYATTROW.TECHNICAL_NAME;
      NUORDER := AU_BOAUDITPOLICYCRITERIUM.GETNEXTSEQNUMBERID( INULOGPOLICYID );
      AU_BOAUDITPOLICYCRITERIUM.SETID( AU_BOAUDITPOLICYCRITERIUM.GETNEXTID );
      AU_BOAUDITPOLICYCRITERIUM.SETATRIBUTECLASS( AU_BOAUDPOLICYATTR.ENTITY_ATTIBUTE_TYPE_CONST );
      AU_BOAUDITPOLICYCRITERIUM.SETAUDITPOLICY( INULOGPOLICYID );
      AU_BOAUDITPOLICYCRITERIUM.SETATTRIBUTEENTITYID( INOBJECTATRIBUTEID );
      AU_BOAUDITPOLICYCRITERIUM.SETCRITOPERATORID( AU_BOAUDITPOLICYCRITERIUM.NO_EQUAL_OPERATOR_CONST );
      AU_BOAUDITPOLICYCRITERIUM.SETLOGICALOPERATOR( AU_BOAUDITPOLICYCRITERIUM.OR_OPERATOR_CONST );
      AU_BOAUDITPOLICYCRITERIUM.SETORDERNUMBER( NUORDER );
      AU_BOAUDITPOLICYCRITERIUM.SETAUTOGENERATED( AU_BOAUDITPOLICYCRITERIUM.IS_AUTO_GENERATED );
      AU_BOAUDITPOLICYCRITERIUM.SETVALUE( SBVALUE );
      AU_BOAUDITPOLICYCRITERIUM.SETREFERENCE( UT_DMLTRIGGER.TRIGG_NEW_VALUE_CONST );
      AU_BOAUDITPOLICYCRITERIUM.VALIDATABASEONCRITERIUMCLASS( FALSE );
      AU_BOAUDITPOLICYCRITERIUM.ADD;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE BURNTRIGGER( INULOGPOLICYID IN NUMBER )
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( INULOGPOLICYID );
      UT_DMLTRIGGER.SETTRIGGERSOURCE( AU_BOAUDITPOLICY.PREPARETRIGGERSTATEMENT( INULOGPOLICYID ) );
      UT_DMLTRIGGER.CREATETRIGGERFROMSOURCE;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE DROPTRIGGER( INULOGPOLICYID IN NUMBER )
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( INULOGPOLICYID );
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      UT_DMLTRIGGER.SETTRIGGERNAME( AU_BOLOGPOLICY.GETTRIGGERNAME );
      UT_DMLTRIGGER.DROPTRIGGER;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE;
   END;
   PROCEDURE UPDATESTATUS( INULOGPOLICYID IN NUMBER, INUSTATUS IN NUMBER )
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( INULOGPOLICYID );
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      AU_BOLOGPOLICY.UPDATESTATUS( INUSTATUS );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE ENABLEAUDITPOLICYDETAIL( INULOGPOLICYID IN NUMBER )
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( INULOGPOLICYID );
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      AU_BOLOGPOLICY.ENABLE;
   END;
   PROCEDURE DISABLEAUDITPOLICYDETAIL( INULOGPOLICYID IN NUMBER )
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( INULOGPOLICYID );
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      AU_BOLOGPOLICY.DISABLE;
   END;
   FUNCTION ISAUDITPOLDETAILTRIGGERENABLED( INULOGPOLICYID IN NUMBER )
    RETURN BOOLEAN
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( INULOGPOLICYID );
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      RETURN AU_BOLOGPOLICY.ISTRIGGERENABLED;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION ISAUDITPOLICYENABLEDBYDATE( CURRENDATE IN DATE )
    RETURN BOOLEAN
    IS
      SCHEDULEROW DAAU_AUD_POL_SCHEDULE.STYAU_AUD_POL_SCHEDULE;
    BEGIN
      IF ( AU_BOAUDITPOLICY.GETNUMBEROFSCHEDULES != 0 ) THEN
         SCHEDULEROW := GETSCHEDULE;
         RETURN UT_DATE.ISDATEBETWEEN( UT_DATE.GETDATEBYDATEANDTIME( SCHEDULEROW.INITIAL_DATE, SCHEDULEROW.INITIAL_TIME ), UT_DATE.GETDATEBYDATEANDTIME( SCHEDULEROW.FINAL_DATE, SCHEDULEROW.FINAL_TIME ), CURRENDATE );
       ELSE
         RETURN TRUE;
      END IF;
   END;
   FUNCTION GETSTACK
    RETURN VARCHAR2
    IS
      NUA NUMBER( 1 );
    BEGIN
      NUA := 'Exception';
    EXCEPTION
      WHEN OTHERS THEN
         RETURN DBMS_UTILITY.FORMAT_CALL_STACK;
   END;
   FUNCTION ISPROCESSAUDITEDBYPOLICY( INUAUDIT_POLICY_ID IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE, INUPROCESSID IN NUMBER )
    RETURN BOOLEAN
    IS
      RCLOGPOLICYROW DAAU_LOG_POLICY.STYAU_LOG_POLICY;
      RCSAEXECUTABLE DASA_EXECUTABLE.STYSA_EXECUTABLE;
      SBSTACK VARCHAR2( 2000 );
      NUPOS INTEGER;
    BEGIN
      AU_BOLOGPOLICY.SETID( INUAUDIT_POLICY_ID );
      RCLOGPOLICYROW := AU_BOLOGPOLICY.GETLOGPOLICYBYID;
      IF ( RCLOGPOLICYROW.EXECUTABLE_ID IS NULL ) THEN
         RETURN TRUE;
      END IF;
      IF ( RCLOGPOLICYROW.EXECUTABLE_ID = INUPROCESSID ) THEN
         RETURN TRUE;
      END IF;
      IF ( RCSAEXECUTABLECACHE.EXECUTABLE_ID != RCLOGPOLICYROW.EXECUTABLE_ID ) THEN
         SA_BOEXECUTABLE.SETID( RCLOGPOLICYROW.EXECUTABLE_ID );
         RCSAEXECUTABLE := SA_BOEXECUTABLE.GETEXECUTABLEBYID;
         RCSAEXECUTABLECACHE := RCSAEXECUTABLE;
       ELSE
         RCSAEXECUTABLE := RCSAEXECUTABLECACHE;
      END IF;
      SBSTACK := GETSTACK;
      NUPOS := INSTR( SBSTACK, RCSAEXECUTABLE.NAME );
      IF NUPOS = 0 THEN
         RETURN FALSE;
       ELSE
         SA_BOSYSTEM.SETSYSTEMPROCESSID( RCSAEXECUTABLE.EXECUTABLE_ID );
         SA_BOSYSTEM.SETSYSTEMPROCESSNAME( RCSAEXECUTABLE.NAME );
         RETURN TRUE;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDATEAUDPOLICYDETAILSTATUS( INULOGPOLICY IN NUMBER, INUSTATUS IN NUMBER )
    IS
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICY );
      AU_BOLOGPOLICY.UPDATESTATUS( INUSTATUS );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETAUDITPOLICYDETAILSTATUS( INULOGPOLICY IN NUMBER )
    RETURN NUMBER
    IS
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICY );
      RETURN AU_BOLOGPOLICY.GETSTATUS;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE CHECKAUDPOLICYDETAILISENABLED( INULOGPOLICY IN NUMBER, INUPOLICYID IN NUMBER )
    IS
      NUSCHEDULEACTIVO NUMBER( 1 );
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICY );
      IF ( AU_BOLOGPOLICY.GETSTATUS = AU_BOLOGPOLICY.ENABLED_POLICY_STATUS ) THEN
         IF GETNUMBEROFSCHEDULES > 0 THEN
            NUSCHEDULEACTIVO := AU_BOAUDPOLSHEDULE.ISACTIVE( INUPOLICYID );
            IF NUSCHEDULEACTIVO = AU_BOAUDPOLSHEDULE.SCHEDULED_ACTIVE THEN
               ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR2041, INUPOLICYID );
               RAISE EX.CONTROLLED_ERROR;
            END IF;
          ELSE
            ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR2041, INUPOLICYID );
            RAISE EX.CONTROLLED_ERROR;
         END IF;
      END IF;
   END;
   PROCEDURE CHECKISENABLED
    IS
      TBLOGPOLICIES DAAU_LOG_POLICY.TYTBAU_LOG_POLICY;
    BEGIN
      GETAUDITPOLICYDETAILS( TBLOGPOLICIES );
      FOR I IN 1..TBLOGPOLICIES.COUNT
       LOOP
         CHECKAUDPOLICYDETAILISENABLED( TBLOGPOLICIES( I ).AUDIT_LOG_ID, TBLOGPOLICIES( I ).AUDIT_POLICY_ID );
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION ISTRIGGEREXISTONDB( INULOGPOLICY IN NUMBER )
    RETURN BOOLEAN
    IS
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICY );
      RETURN AU_BOLOGPOLICY.ISTRIGGEREXISTONDB;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE CHECKAUDPOLICYDETGENTIONSTATUS( INULOGPOLICY IN NUMBER )
    IS
    BEGIN
      IF ( ISTRIGGEREXISTONDB( INULOGPOLICY ) != TRUE ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR3000 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE DROPTRIGGERANDCHECKEXISTSFIRST( INULOGPOLICY IN NUMBER )
    IS
    BEGIN
      IF ( ISTRIGGEREXISTONDB( INULOGPOLICY ) = TRUE ) THEN
         DROPTRIGGER( INULOGPOLICY );
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE;
   END;
   PROCEDURE DELETEUSERSATTACHED
    IS
    BEGIN
      AU_BOAUDITPOLICY.VALIDATELOGPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      DELETE  AU_AUD_POLICY_USERS WHERE
	         AU_AUD_POLICY_USERS.audit_policy_id = rcRecord.AUDIT_POLICY_ID;
   END;
   PROCEDURE DROPAUDITPOLICYDETAIL( INLOGPOLICY IN NUMBER )
    IS
    BEGIN
      AU_BOHISTORY.SETID( INLOGPOLICY );
      AU_BOHISTORY.CHKEXPORTCRLATTACHEDBEFDELETE;
      AU_BOHISTORY.DELETEGUIDEATTACHECKFIRST;
      DROPTRIGGERANDCHECKEXISTSFIRST( INLOGPOLICY );
      AU_BOLOGPOLICY.SETID( INLOGPOLICY );
      AU_BOLOGPOLICY.DELETEAUTOGENERATEDCRITERIUMS;
      AU_BOLOGPOLICY.SETID( INLOGPOLICY );
      AU_BOLOGPOLICY.DELETEBYCODE;
   END;
   PROCEDURE DROPEMAILNOTIF
    IS
      TBLOGPOLICIES DAAU_LOG_POLICY.TYTBAU_LOG_POLICY;
      TBMAILNOT DAAU_MAIL_NOTIFICATION.TYTBAU_MAIL_NOTIFICATION;
    BEGIN
      DAAU_MAIL_NOTIFICATION.GETRECORDS( 'AUDIT_POLICY_ID = ' + RCRECORD.AUDIT_POLICY_ID, TBMAILNOT );
      DAAU_MAIL_NOTIFICATION.DELRECORDS( TBMAILNOT );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         NULL;
      WHEN OTHERS THEN
         NULL;
   END;
   PROCEDURE DROPAUDITPOLICYDETAILS
    IS
      TBLOGPOLICIES DAAU_LOG_POLICY.TYTBAU_LOG_POLICY;
      TBMAILNOT DAAU_MAIL_NOTIFICATION.TYTBAU_MAIL_NOTIFICATION;
    BEGIN
      DROPEMAILNOTIF;
      GETAUDITPOLICYDETAILS( TBLOGPOLICIES );
      FOR I IN 1..TBLOGPOLICIES.COUNT
       LOOP
         DROPAUDITPOLICYDETAIL( TBLOGPOLICIES( I ).AUDIT_LOG_ID );
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETAUDITPOLICYSTATUS
    RETURN NUMBER
    IS
      TBLOGPOLICIES DAAU_LOG_POLICY.TYTBAU_LOG_POLICY;
      NUSTATUS NUMBER;
      NUDISABLEDDETAILS NUMBER := 0.0;
      NUENABLEDDETAILS NUMBER := 0.0;
      NUENABLEDINVALIDDETAILS NUMBER := 0.0;
      NUDISABLEDINVALIDDETAILS NUMBER := 0.0;
      NUNONCONSISTENTDETAILS NUMBER := 0.0;
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      GETAUDITPOLICYDETAILS( TBLOGPOLICIES );
      UT_TRACE.TRACE( 'Number OR details = ' || TBLOGPOLICIES.COUNT );
      FOR I IN 1..TBLOGPOLICIES.COUNT
       LOOP
         NUSTATUS := AU_BOAUDITPOLICY.GETAUDITPOLICYDETAILSTATUS( TBLOGPOLICIES( I ).AUDIT_LOG_ID );
         UT_TRACE.TRACE( 'Status = ' || NUSTATUS );
         IF ( NUSTATUS = AU_BOLOGPOLICY.ENABLED_POLICY_STATUS ) THEN
            NUENABLEDDETAILS := NUENABLEDDETAILS + 1;
          ELSIF ( NUSTATUS = AU_BOLOGPOLICY.DISABLED_POLICY_STATUS ) THEN
            NUDISABLEDDETAILS := NUDISABLEDDETAILS + 1;
          ELSIF ( NUSTATUS = AU_BOLOGPOLICY.DISABLED_INVALID_POLICY_STATUS ) THEN
            NUDISABLEDINVALIDDETAILS := NUDISABLEDINVALIDDETAILS + 1;
          ELSIF ( NUSTATUS = AU_BOLOGPOLICY.ENABLED_INVALID_POLICY_STATUS ) THEN
            NUENABLEDINVALIDDETAILS := NUENABLEDINVALIDDETAILS + 1;
          ELSIF ( NUSTATUS = AU_BOLOGPOLICY.NO_CONSISTENT_POLICY_STATUS ) THEN
            NUNONCONSISTENTDETAILS := NUNONCONSISTENTDETAILS + 1;
         END IF;
      END LOOP;
      UT_TRACE.TRACE( 'nuEnabledDetails' || NUENABLEDDETAILS );
      UT_TRACE.TRACE( 'nuDisabledDetails' || NUDISABLEDDETAILS );
      UT_TRACE.TRACE( 'nuEnabledInvalidDetails' || NUENABLEDINVALIDDETAILS );
      UT_TRACE.TRACE( 'nuDisabledInvalidDetails' || NUDISABLEDINVALIDDETAILS );
      UT_TRACE.TRACE( 'nuNonConsistentDetails' || NUNONCONSISTENTDETAILS );
      IF ( TBLOGPOLICIES.COUNT = 0 ) THEN
         RETURN AU_BOLOGPOLICY.JUST_CREATED_STATUS_CONST;
       ELSIF ( NUDISABLEDDETAILS = TBLOGPOLICIES.COUNT ) THEN
         RETURN AU_BOLOGPOLICY.DISABLED_POLICY_STATUS;
       ELSIF ( NUENABLEDDETAILS > 0 AND NUNONCONSISTENTDETAILS > 0 ) THEN
         RETURN AU_BOLOGPOLICY.NO_CONS_ENBLED_GENERED_STATUS;
       ELSIF ( ( NUENABLEDDETAILS > 0 AND NUENABLEDINVALIDDETAILS > 0 ) OR ( NUENABLEDDETAILS > 0 AND NUDISABLEDINVALIDDETAILS > 0 ) ) THEN
         RETURN AU_BOLOGPOLICY.NO_CONS_ENBLED_GENERED_STATUS;
       ELSIF ( NUENABLEDINVALIDDETAILS > 0 OR NUDISABLEDINVALIDDETAILS > 0 ) THEN
         RETURN AU_BOLOGPOLICY.NO_CONS_ENBLED_GENERED_STATUS;
       ELSIF ( NUENABLEDDETAILS = TBLOGPOLICIES.COUNT ) THEN
         RETURN AU_BOLOGPOLICY.ENABLED_POLICY_STATUS;
       ELSIF ( NUNONCONSISTENTDETAILS > 0 AND NUDISABLEDDETAILS > 0 ) THEN
         RETURN AU_BOLOGPOLICY.NO_CONS_DISABLE_GENERD_STATUS;
       ELSIF ( NUENABLEDDETAILS > 0 AND NUDISABLEDDETAILS > 0 ) THEN
         RETURN AU_BOLOGPOLICY.ENABLED_POLICY_STATUS;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE ENABLEAUDITPOLICYDETAILS
    IS
      TBLOGPOLICIES DAAU_LOG_POLICY.TYTBAU_LOG_POLICY;
    BEGIN
      GETAUDITPOLICYDETAILS( TBLOGPOLICIES );
      FOR I IN 1..TBLOGPOLICIES.COUNT
       LOOP
         AU_BOLOGPOLICY.SETID( TBLOGPOLICIES( I ).AUDIT_LOG_ID );
         IF ( AU_BOLOGPOLICY.GETSTATUS = AU_BOLOGPOLICY.DISABLED_POLICY_STATUS ) THEN
            ENABLEAUDITPOLICYDETAIL( TBLOGPOLICIES( I ).AUDIT_LOG_ID );
         END IF;
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE DISABLEAUDITPOLICYDETAILS
    IS
      TBLOGPOLICIES DAAU_LOG_POLICY.TYTBAU_LOG_POLICY;
      NUSTATUS NUMBER;
    BEGIN
      GETAUDITPOLICYDETAILS( TBLOGPOLICIES );
      FOR I IN 1..TBLOGPOLICIES.COUNT
       LOOP
         AU_BOLOGPOLICY.SETID( TBLOGPOLICIES( I ).AUDIT_LOG_ID );
         NUSTATUS := AU_BOLOGPOLICY.GETSTATUS;
         IF ( NUSTATUS = AU_BOLOGPOLICY.ENABLED_POLICY_STATUS OR NUSTATUS = AU_BOLOGPOLICY.DISABLED_INVALID_POLICY_STATUS ) THEN
            DISABLEAUDITPOLICYDETAIL( TBLOGPOLICIES( I ).AUDIT_LOG_ID );
         END IF;
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDATEISFORALLUSERS( INUISFORALLUSERS IN NUMBER )
    IS
    BEGIN
      DAAU_AUDIT_POLICY.UPDIS_FOR_ALL_USERS( RCRECORD.AUDIT_POLICY_ID, INUISFORALLUSERS );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETRECORDSBYEXAMPLE( SBWHERE IN VARCHAR2, DTINITIALDATE IN DATE, DTFINALDATE IN DATE, INUUSESDATING IN NUMBER )
    RETURN DAAU_AUDIT_POLICY_LOG.TYREFCURSOR
    IS
      SBQUERY VARCHAR2( 700 ) := NULL;
      SBINITIALDATE VARCHAR2( 200 );
      SBFINALDATE VARCHAR2( 200 );
    BEGIN
      IF ( INUUSESDATING = 1 ) THEN
         IF ( SBWHERE IS NOT NULL ) THEN
            SBQUERY := ' AND ';
         END IF;
         SBINITIALDATE := TO_CHAR( TRUNC( DTINITIALDATE ), UT_DATE.FSBDATE_FORMAT );
         SBFINALDATE := TO_CHAR( TRUNC( DTFINALDATE ), UT_DATE.FSBDATE_FORMAT );
         SBQUERY := SBWHERE || SBQUERY || ' CURRENT_DATE between TO_DATE(' || '''' || SBINITIALDATE || '''' || ',' || '''' || UT_DATE.FSBDATE_FORMAT || '''' || ')' || ' AND TO_DATE(' || '''' || SBFINALDATE || '''' || ',' || '''' || UT_DATE.FSBDATE_FORMAT || '''' || ')';
       ELSE
         SBQUERY := SBWHERE;
      END IF;
      RETURN DAAU_AUDIT_POLICY_LOG.FRFGETRECORDS( SBQUERY );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE CHECKAUDPOLTYPEINDELETEUSER
    IS
    BEGIN
      IF ( GETAUDITPOLICYTYPE = AU_BOAUDITPOLICY.USER_POLICY_TYPE_CONST ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR3381 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   FUNCTION GETVALIDENTITYATTRIBUTESTOADD
    RETURN TYVALIDENTATTRTYPE
    IS
    BEGIN
      RETURN TBVALIDENTATTRTYPE;
   END;
   PROCEDURE CHECKENTITYATTRIBUTETOADD( INUENTITYATTRID IN NUMBER )
    IS
      ENTITYATTROW DAGE_ENTITY_ATTRIBUTES.STYGE_ENTITY_ATTRIBUTES;
      NUENTATTFIELDTYPE NUMBER;
      ATTRBUTETYPEROW DAGE_ATTRIBUTES_TYPE.STYGE_ATTRIBUTES_TYPE;
    BEGIN
      GE_BOENTITYATTRIBUTES.SETID( INUENTITYATTRID );
      ENTITYATTROW := GE_BOENTITYATTRIBUTES.GETENTITYATRIBUTEBYID;
      NUENTATTFIELDTYPE := ENTITYATTROW.ATTRIBUTE_TYPE_ID;
      ATTRBUTETYPEROW := GE_BOATTRIBUTES_TYPE.GETATTRIBUTES_TYPE( NUENTATTFIELDTYPE );
      FOR I IN 1..TBVALIDENTATTRTYPE.COUNT
       LOOP
         IF ( TBVALIDENTATTRTYPE( I ) = NUENTATTFIELDTYPE ) THEN
            RETURN;
         END IF;
      END LOOP;
      ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR3400, ATTRBUTETYPEROW.DESCRIPTION );
      RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION ISFORALLUSERS
    RETURN NUMBER
    IS
      AUDITPOLICYEROW DAAU_AUDIT_POLICY.STYAU_AUDIT_POLICY;
    BEGIN
      AUDITPOLICYEROW := GETAUDITPOLICYBYID;
      RETURN AUDITPOLICYEROW.IS_FOR_ALL_USERS;
   END;
   FUNCTION ISSCHEDULED
    RETURN NUMBER
    IS
    BEGIN
      IF ( AU_BOAUDITPOLICY.GETNUMBEROFSCHEDULES != 0 ) THEN
         RETURN 1;
       ELSE
         RETURN 0;
      END IF;
   END;
   PROCEDURE CHECKISSCHEDULEDALREADY
    IS
    BEGIN
      IF ( ISSCHEDULED != 0 ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4883 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE CHECKISSCHEDULED
    IS
    BEGIN
      IF ( ISSCHEDULED = 0 ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR4962 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   PROCEDURE DELETESCHEDULES
    IS
    BEGIN
      DELETE aU_aud_pol_schedule
            WHERE AUDIT_POLICY_ID = rcRecord.AUDIT_POLICY_ID;
   END;
   FUNCTION GETENTITYATTRIBUTE( INULOGPOLICYID IN NUMBER )
    RETURN DAAU_AUD_POL_ATTR.STYAU_AUD_POL_ATTR
    IS
      OTBRESULT DAAU_AUD_POL_ATTR.TYTBAU_AUD_POL_ATTR;
    BEGIN
      AU_BOLOGPOLICY.SETID( INULOGPOLICYID );
      AU_BOLOGPOLICY.GETENTITYCLASSATTRIBUTES( OTBRESULT );
      IF OTBRESULT.COUNT > 0 THEN
         RETURN OTBRESULT( 1 );
      END IF;
      RETURN NULL;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETENTITYATTRIBUTEMONITORED( INULOGPOLICYID IN NUMBER )
    RETURN NUMBER
    IS
      AUDITPOLATTR DAAU_AUD_POL_ATTR.STYAU_AUD_POL_ATTR;
    BEGIN
      AUDITPOLATTR := GETENTITYATTRIBUTE( INULOGPOLICYID );
      RETURN AUDITPOLATTR.ENTITY_ATTRIBUTE_ID;
   END;
   FUNCTION GETNUMBEROFAUDITPOLICYDETAILS
    RETURN NUMBER
    IS
      NUCOUNT NUMBER;
    BEGIN
      SELECT count(*) INTO nuCount FROM  au_log_policy alp
            WHERE alp.audit_policy_id = rcRecord.AUDIT_POLICY_ID
            ORDER BY alp.CREATION_DATE;
      RETURN NUCOUNT;
   END;
   PROCEDURE CHECKNUMBEROFDETAILSATTACHED
    IS
    BEGIN
      IF ( GETNUMBEROFAUDITPOLICYDETAILS = 0 ) THEN
         ERRORS.SETERROR( AU_BOERRORCONSTANTS.CNUERR1708 );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
   END;
   FUNCTION GETSYSTEMDATE
    RETURN DATE
    IS
    BEGIN
      RETURN SYSDATE;
   END;
   PROCEDURE ENABLEDDISABLEDAUDITPOLICY( INULOGPOLICYID IN NUMBER )
    IS
    BEGIN
      IF ISSCHEDULED != AUDIT_HAS_SCHEDULE THEN
         DISABLEAUDITPOLICYDETAIL( INULOGPOLICYID );
      END IF;
      IF ( ISSCHEDULED = AUDIT_HAS_SCHEDULE ) AND ( AU_BOAUDPOLSHEDULE.ISACTIVE( INULOGPOLICYID ) != AU_BOAUDPOLSHEDULE.SCHEDULED_ACTIVE ) THEN
         DISABLEAUDITPOLICYDETAIL( INULOGPOLICYID );
      END IF;
   END;
   PROCEDURE SELECTREGISTRY( INUUSER IN SA_USER.USER_ID%TYPE, INUAUDIT_POLICY_ID IN AU_LOG_POLICY.AUDIT_POLICY_ID%TYPE, ISBDESCRIPTION IN AU_AUDIT_POLICY_LOG.CURRENT_EVEN_DESC%TYPE, ISBTEXT IN AU_AUDIT_POLICY_LOG.LOG_TEXT%TYPE )
    IS
    BEGIN
      IF DAAU_AUDIT_POLICY.FNUGETIS_FOR_ALL_USERS( INUAUDIT_POLICY_ID ) = CNUALL_USERS THEN
         IF ISAUDITPOLICYENABLEDBYDATE( SYSDATE ) THEN
            AU_BOAUDIT_POLICY_LOG.INSRECORD( INUAUDIT_POLICY_ID, ISBDESCRIPTION, ISBTEXT );
         END IF;
         RETURN;
      END IF;
      IF DAAU_AUD_POLICY_USERS.FBLEXIST( INUAUDIT_POLICY_ID, INUUSER ) THEN
         IF ISAUDITPOLICYENABLEDBYDATE( SYSDATE ) THEN
            AU_BOAUDIT_POLICY_LOG.INSRECORD( INUAUDIT_POLICY_ID, ISBDESCRIPTION, ISBTEXT );
         END IF;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE POLICYSELECTREGISTRY( INUUSER IN SA_USER.USER_ID%TYPE, INUEXECUTABLEID IN AU_LOG_POLICY.EXECUTABLE_ID%TYPE, ISBDESCRIPTION IN AU_AUDIT_POLICY_LOG.CURRENT_EVEN_DESC%TYPE, ISBTEXT IN AU_AUDIT_POLICY_LOG.LOG_TEXT%TYPE )
    IS
    BEGIN
      FOR RCPOLICYEXECUTABLE IN AU_BCLOG_POLICY.CUAU_LOG_POLICY( INUEXECUTABLEID )
       LOOP
         IF RCPOLICYEXECUTABLE.TRIGGER_NAME IS NULL THEN
            SETID( RCPOLICYEXECUTABLE.AUDIT_POLICY_ID );
            SELECTREGISTRY( INUUSER, RCPOLICYEXECUTABLE.AUDIT_POLICY_ID, ISBDESCRIPTION, ISBTEXT );
         END IF;
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE POLICYSELECT( ISBEXECUTABLENAME IN VARCHAR2, ISBQUERY IN VARCHAR2 )
    IS
      NUUSERID NUMBER;
      NUERROR NUMBER;
      SBERROR VARCHAR2( 2000 );
      RCEXECUTABLE DASA_EXECUTABLE.STYSA_EXECUTABLE;
    BEGIN
      SA_BSSYSTEMMGR.GETCURRENTUSERID( NUUSERID, NUERROR, SBERROR );
      RCEXECUTABLE := SA_BOEXECUTABLE.GETEXECUTABLEBYNAME( ISBEXECUTABLENAME );
      AU_BOAUDITPOLICY.POLICYSELECTREGISTRY( NUUSERID, RCEXECUTABLE.EXECUTABLE_ID, ISBEXECUTABLENAME, ISBQUERY );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDATESTATUSBYPOLICY( INUAUDITPOLICY IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE )
    IS
    BEGIN
      DAAU_AUDIT_POLICY.UPDAUD_POL_STATUS_ID( INUAUDITPOLICY, INUSTATUS );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   PROCEDURE UPDSTATUSFORLOGPOLICY( INUAUDITPOLICY IN AU_AUDIT_POLICY.AUDIT_POLICY_ID%TYPE, INUSTATUS IN AU_AUDIT_POLICY.AUD_POL_STATUS_ID%TYPE )
    IS
    BEGIN
      UPDATE au_log_policy
        SET aud_pol_status_id = inuStatus
        WHERE audit_policy_id = inuAuditPolicy
          AND aud_pol_status_id <> 8;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETSTATUS
    RETURN NUMBER
    IS
    BEGIN
      VALIDATEAUDITPOLICYID( RCRECORD.AUDIT_POLICY_ID );
      DAAU_AUDIT_POLICY.CLEARMEMORY;
      RETURN DAAU_AUDIT_POLICY.FNUGETAUD_POL_STATUS_ID( RCRECORD.AUDIT_POLICY_ID );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
   FUNCTION GETALLEXECUTABLESBYMODULE( INUMODULE IN NUMBER )
    RETURN CONSTANTS.TYREFCURSOR
    IS
      RCEXECUTABLE CONSTANTS.TYREFCURSOR;
    BEGIN
      OPEN RCEXECUTABLE FOR SELECT unique SA_EXECUTABLE.*,SA_EXECUTABLE.rowid
              FROM sa_executable
             WHERE sa_executable.module_id = inumodule;
      RETURN RCEXECUTABLE;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
 BEGIN
   TBVALIDENTATTRTYPE( 1 ) := 11;
   TBVALIDENTATTRTYPE( 2 ) := 2;
   TBVALIDENTATTRTYPE( 3 ) := 1;
   TBVALIDENTATTRTYPE( 4 ) := 3;
   TBVALIDENTATTRTYPE( 5 ) := 7;
END;
/


