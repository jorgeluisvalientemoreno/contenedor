
CREATE OR REPLACE PACKAGE PKLICENSEMGR IS
   LICENSEINFOPACKAGENAME CONSTANT VARCHAR2( 128 ) := 'pkLicenseInfo';
   GETSERIAL12FNNAME CONSTANT VARCHAR2( 32 ) := 'GetSerial12';
   GETKEY22FNNAME CONSTANT VARCHAR2( 32 ) := 'GetKey22';
   GETEXCLUSIONFNNAME CONSTANT VARCHAR2( 32 ) := 'GetExclusion';
   FUNCTION CHECKLICENSESTATUS
    RETURN VARCHAR2;
   FUNCTION CREATEPKLICINFOANDGETSERIAL12
    RETURN VARCHAR2;
   FUNCTION CREATEPKLICINFOBODY( SERIAL12 IN VARCHAR2, KEY22 IN VARCHAR2 )
    RETURN VARCHAR2;
   FUNCTION CHECKAUTHENTLICENSESTATUS
    RETURN NUMBER;
   FUNCTION SERVSLICENSED
    RETURN NUMBER;
   FUNCTION EXPIRATIONDATE
    RETURN DATE;
END PKLICENSEMGR;
/


CREATE OR REPLACE PACKAGE BODY PKLICENSEMGR IS
   FUNCTION GETEXCLUSIONTABLENUMBER
    RETURN VARCHAR2
    IS
      NUSUMCODE NUMBER;
      NUTABLEXIST NUMBER;
      SBSTRCMD VARCHAR2( 100 );
    BEGIN
      SELECT
         COUNT( * )
         INTO NUTABLEXIST
         FROM USER_TABLES
         WHERE TABLE_NAME = 'EXCLUSIONTABLE';
      IF ( NUTABLEXIST = 0 ) THEN
         RETURN ( '0' );
      END IF;
      SBSTRCMD := 'BEGIN select nvl(sum(id),0) into :nuSumCode from ExclusionTable; END;';
      EXECUTE IMMEDIATE SBSTRCMD
                        USING OUT NUSUMCODE;
      NUSUMCODE := NUSUMCODE * 7531 MOD 10000;
      RETURN ( TO_CHAR( NUSUMCODE ) );
   END GETEXCLUSIONTABLENUMBER;
   FUNCTION SHUFFLE( PARAM0 IN VARCHAR2 )
    RETURN VARCHAR2
    IS
      LENGTHPARAM NUMBER( 2 );
      SHUFFLEDSTR VARCHAR2( 40 );
    BEGIN
      LENGTHPARAM := LENGTH( PARAM0 );
      FOR I IN 1..LENGTHPARAM
       LOOP
         IF I MOD 2 = 0 THEN
            SHUFFLEDSTR := SHUFFLEDSTR || SUBSTR( PARAM0, I - 1, 1 );
          ELSE
            SHUFFLEDSTR := SHUFFLEDSTR || SUBSTR( PARAM0, I + 1, 1 );
         END IF;
      END LOOP;
      RETURN ( SHUFFLEDSTR );
   END SHUFFLE;
   PROCEDURE M0( PARAM0 IN VARCHAR2, PARAM1 OUT VARCHAR2, PARAM2 OUT VARCHAR2 )
    IS
      INITCHAR NUMBER( 2 );
      INITPOS NUMBER( 2 );
      NEXTCHAR NUMBER( 2 );
      NEXTPOS NUMBER( 2 );
      POSDIR NUMBER( 2 );
      CHDIR NUMBER( 2 );
      STRPOS NUMBER( 4 );
      POS NUMBER( 4 );
      ORIG VARCHAR2( 40 );
      ORIGTMP VARCHAR2( 40 );
      LENGTHORIG NUMBER( 2 );
      CHINORIG VARCHAR2( 1 );
      TRTABLE VARCHAR2( 80 );
      TEMPTRTABLE VARCHAR2( 80 );
      CHINTRTABLE VARCHAR2( 1 );
      TEMPORIG VARCHAR2( 80 );
      CHARINKEY VARCHAR2( 1 );
    BEGIN
      IF ( LENGTH( PARAM0 ) != 5 ) THEN
         PARAM1 := '';
         PARAM2 := '';
         RETURN;
      END IF;
      ORIGTMP := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      ORIG := SHUFFLE( ORIGTMP );
      CHARINKEY := SUBSTR( PARAM0, 1, 1 );
      INITCHAR := INSTR( ORIG, CHARINKEY );
      CHARINKEY := SUBSTR( PARAM0, 2, 1 );
      INITPOS := INSTR( ORIG, CHARINKEY );
      CHARINKEY := SUBSTR( PARAM0, 3, 1 );
      NEXTCHAR := INSTR( ORIG, CHARINKEY ) - 1;
      CHARINKEY := SUBSTR( PARAM0, 4, 1 );
      NEXTPOS := INSTR( ORIG, CHARINKEY ) - 1;
      POSDIR := 0;
      CHDIR := 0;
      CHARINKEY := SUBSTR( PARAM0, 5, 1 );
      IF ( CHARINKEY >= 'A' AND CHARINKEY <= 'F' ) THEN
         POSDIR := 0;
         CHDIR := 0;
       ELSIF ( CHARINKEY >= 'G' AND CHARINKEY <= 'L' ) THEN
         POSDIR := 0;
         CHDIR := 1;
       ELSIF ( CHARINKEY >= 'M' AND CHARINKEY <= 'R' ) THEN
         POSDIR := 1;
         CHDIR := 0;
       ELSIF ( CHARINKEY >= 'S' AND CHARINKEY <= 'X' ) THEN
         POSDIR := 1;
         CHDIR := 1;
      END IF;
      IF CHDIR MOD 2 = 0 THEN
         ORIGTMP := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
         ORIG := SHUFFLE( ORIGTMP );
       ELSE
         ORIGTMP := '9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA';
         ORIG := SHUFFLE( ORIGTMP );
      END IF;
      PARAM1 := ORIG;
      TRTABLE := ' ';
      FOR I IN 1..40
       LOOP
         TRTABLE := TRTABLE || ' ';
      END LOOP;
      STRPOS := 0;
      POS := INITCHAR;
      LENGTHORIG := LENGTH( ORIG );
      FOR I IN 1..LENGTHORIG
       LOOP
         WHILE POS > LENGTHORIG
          LOOP
            POS := POS - LENGTHORIG;
         END LOOP;
         LOOP
            CHINORIG := SUBSTR( ORIG, POS, 1 );
            EXIT WHEN CHINORIG != ' ';
            IF CHDIR MOD 2 = 0 THEN
               POS := POS + 1;
               WHILE POS > LENGTHORIG
                LOOP
                  POS := POS - LENGTHORIG;
               END LOOP;
             ELSE
               POS := POS - 1;
               WHILE POS < 1
                LOOP
                  POS := POS + LENGTHORIG;
               END LOOP;
            END IF;
         END LOOP;
         IF POSDIR MOD 2 = 0 THEN
            STRPOS := INITPOS + NEXTPOS;
            WHILE STRPOS > LENGTHORIG
             LOOP
               STRPOS := STRPOS - LENGTHORIG;
            END LOOP;
          ELSE
            STRPOS := INITPOS - NEXTPOS;
            WHILE STRPOS < 1
             LOOP
               STRPOS := STRPOS + LENGTHORIG;
            END LOOP;
         END IF;
         LOOP
            CHINTRTABLE := SUBSTR( TRTABLE, STRPOS, 1 );
            EXIT WHEN CHINTRTABLE = ' ';
            IF POSDIR MOD 2 = 0 THEN
               STRPOS := INITPOS + NEXTPOS;
               WHILE STRPOS > LENGTHORIG
                LOOP
                  STRPOS := STRPOS - LENGTHORIG;
               END LOOP;
             ELSE
               STRPOS := INITPOS - NEXTPOS;
               WHILE STRPOS < 1
                LOOP
                  STRPOS := STRPOS + LENGTHORIG;
               END LOOP;
            END IF;
         END LOOP;
         TEMPTRTABLE := SUBSTR( TRTABLE, 1, STRPOS - 1 ) || SUBSTR( ORIG, POS, 1 ) || SUBSTR( TRTABLE, STRPOS + 1 );
         TRTABLE := TEMPTRTABLE;
         TEMPORIG := SUBSTR( ORIG, 1, POS - 1 ) || ' ' || SUBSTR( ORIG, POS + 1 );
         ORIG := TEMPORIG;
         POS := POS + NEXTCHAR;
         NEXTCHAR := NEXTCHAR + 1;
         NEXTPOS := NEXTPOS + 1;
         CHDIR := CHDIR + 1;
      END LOOP;
      PARAM2 := TRTABLE;
      RETURN;
   END M0;
   FUNCTION M1( PARAM0 IN VARCHAR2, PARAM1 IN VARCHAR2 )
    RETURN VARCHAR2
    IS
      INPUTLEN NUMBER( 4 );
      ENCODED VARCHAR2( 2000 );
      CHARININPUT VARCHAR2( 1 );
      POSI NUMBER( 4 );
      TRTABLE VARCHAR2( 80 );
      ORIGTABLE VARCHAR2( 80 );
      TRCHARININPUT VARCHAR2( 1 );
    BEGIN
      M0( PARAM0, ORIGTABLE, TRTABLE );
      ORIGTABLE := TRIM( ORIGTABLE );
      TRTABLE := TRIM( TRTABLE );
      INPUTLEN := LENGTH( PARAM1 );
      FOR J IN 1..INPUTLEN
       LOOP
         CHARININPUT := SUBSTR( PARAM1, J, 1 );
         POSI := INSTR( ORIGTABLE, CHARININPUT );
         POSI := POSI + J - 1;
         WHILE POSI > LENGTH( TRTABLE )
          LOOP
            POSI := POSI - LENGTH( TRTABLE );
         END LOOP;
         TRCHARININPUT := SUBSTR( TRTABLE, POSI, 1 );
         ENCODED := ENCODED || TRCHARININPUT;
      END LOOP;
      RETURN ( ENCODED );
   END M1;
   FUNCTION M2( PARAM0 IN VARCHAR2, PARAM1 IN VARCHAR2 )
    RETURN VARCHAR2
    IS
      INPUTLEN NUMBER( 4 );
      DECODED VARCHAR2( 2000 );
      CHARININPUT VARCHAR2( 1 );
      POSI NUMBER( 4 );
      TRTABLE VARCHAR2( 80 );
      ORIGTABLE VARCHAR2( 80 );
    BEGIN
      M0( PARAM0, ORIGTABLE, TRTABLE );
      ORIGTABLE := TRIM( ORIGTABLE );
      TRTABLE := TRIM( TRTABLE );
      INPUTLEN := LENGTH( PARAM1 );
      FOR J IN 1..INPUTLEN
       LOOP
         CHARININPUT := SUBSTR( PARAM1, J, 1 );
         POSI := INSTR( TRTABLE, CHARININPUT );
         POSI := POSI - J + 1;
         WHILE POSI < 1
          LOOP
            POSI := POSI + LENGTH( TRTABLE );
         END LOOP;
         DECODED := DECODED || SUBSTR( ORIGTABLE, POSI, 1 );
      END LOOP;
      RETURN ( DECODED );
   END M2;
   FUNCTION M4
    RETURN VARCHAR2
    IS
      ENCKEY VARCHAR2( 10 );
      SEED NUMBER( 6 );
      RANDOMNUMBER NUMBER;
      ORIGTABLE VARCHAR2( 40 );
      LOOPINDEX NUMBER( 1 );
    BEGIN
      SEED := TO_NUMBER( TO_CHAR( SYSDATE, 'SSSSS' ) );
      ORIGTABLE := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      LOOPINDEX := 0;
      DBMS_RANDOM.INITIALIZE( SEED );
      WHILE LOOPINDEX < 4
       LOOP
         RANDOMNUMBER := ABS( DBMS_RANDOM.RANDOM() );
         RANDOMNUMBER := RANDOMNUMBER MOD 36 + 1;
         ENCKEY := ENCKEY || SUBSTR( ORIGTABLE, RANDOMNUMBER, 1 );
         LOOPINDEX := LOOPINDEX + 1;
      END LOOP;
      RANDOMNUMBER := ABS( DBMS_RANDOM.RANDOM() );
      RANDOMNUMBER := RANDOMNUMBER MOD 24 + 1;
      ENCKEY := ENCKEY || SUBSTR( ORIGTABLE, RANDOMNUMBER, 1 );
      DBMS_RANDOM.TERMINATE;
      RETURN ( ENCKEY );
   END M4;
   FUNCTION M5( PARAM0 IN VARCHAR2 )
    RETURN VARCHAR2
    IS
      ENCKEY VARCHAR2( 6 );
      ENCODED VARCHAR2( 2000 );
    BEGIN
      ENCKEY := M4;
      ENCODED := ENCKEY || M1( ENCKEY, PARAM0 );
      RETURN ( ENCODED );
   END M5;
   FUNCTION CHECKLICENSESTATUS
    RETURN VARCHAR2
    IS
      PKSPECPRESENT NUMBER( 1 );
      PKBODYPRESENT NUMBER( 1 );
      PKSPECCREATIONTIME USER_OBJECTS.CREATED%TYPE;
      PKSPECCREATIONTIMEREGISTERED DATE;
      SERIAL12 VARCHAR2( 100 );
      KEY22 VARCHAR2( 100 );
      SUBSCRIBEDSERVICESCOUNT NUMBER( 15 );
      SUBSCRIBEDSERVICESLICENSED NUMBER( 15 );
      EXPIRYDATE DATE;
      TODAY DATE;
      EXPONENT NUMBER( 3 );
      MULTIPLIER NUMBER( 5 );
      LICENSEDCAPACITYEXCEEDED VARCHAR2( 32 );
      LICENSEEXPIRED VARCHAR2( 32 );
      LICENSENOTFOUND VARCHAR2( 32 );
      LICENSETAMPERED VARCHAR2( 32 );
      LICENSEVALID VARCHAR2( 32 );
      LICENSEINVALID VARCHAR2( 32 );
      LICENSEEXCLUSIONMOD VARCHAR2( 32 );
      STATUS VARCHAR2( 40 );
      TYPE REFCURTYP IS REF CURSOR;
      CV REFCURTYP;
      ENCKEY VARCHAR2( 10 );
      ENCSERIAL12 VARCHAR2( 32 );
      DECSERIAL12 VARCHAR2( 32 );
      DECKEY22 VARCHAR2( 32 );
      SBPKEXCLUSIONTABLENUMBER VARCHAR2( 6 );
      SBEXCLUSIONTABLENUMBER VARCHAR2( 6 );
      STMT VARCHAR2( 2000 );
      SBVARIABLE VARCHAR2( 1000 );
    BEGIN
      LICENSEVALID := '0';
      LICENSENOTFOUND := '1';
      LICENSEEXPIRED := '2';
      LICENSEDCAPACITYEXCEEDED := '3';
      LICENSETAMPERED := '4';
      LICENSEINVALID := '5';
      LICENSEEXCLUSIONMOD := '6';
      SELECT
         COUNT( OBJECT_NAME )
         INTO PKSPECPRESENT
         FROM USER_OBJECTS
         WHERE OBJECT_NAME = UPPER( LICENSEINFOPACKAGENAME ) AND OBJECT_TYPE = 'PACKAGE';
      IF ( PKSPECPRESENT = 0 ) THEN
         ENCKEY := M4;
         STATUS := ENCKEY || M1( ENCKEY, LICENSENOTFOUND );
         RETURN ( STATUS );
      END IF;
      SELECT
         COUNT( OBJECT_NAME )
         INTO PKBODYPRESENT
         FROM USER_OBJECTS
         WHERE OBJECT_NAME = UPPER( LICENSEINFOPACKAGENAME ) AND OBJECT_TYPE = 'PACKAGE BODY';
      IF ( PKBODYPRESENT = 0 ) THEN
         ENCKEY := M4;
         STATUS := ENCKEY || M1( ENCKEY, LICENSENOTFOUND );
         RETURN ( STATUS );
      END IF;
      IF ( PKSPECPRESENT > 0 ) THEN
         SELECT
            CREATED
            INTO PKSPECCREATIONTIME
            FROM USER_OBJECTS
            WHERE OBJECT_NAME = UPPER( LICENSEINFOPACKAGENAME ) AND OBJECT_TYPE = 'PACKAGE';
      END IF;
      IF ( PKBODYPRESENT > 0 ) THEN
         STMT := 'SELECT ';
         STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || '.' || GETSERIAL12FNNAME;
         STMT := STMT || ' FROM dual';
         OPEN CV
              FOR STMT;
         LOOP
            FETCH CV
               INTO SERIAL12;
            EXIT WHEN CV%NOTFOUND;
         END LOOP;
         CLOSE CV;
         ENCKEY := SUBSTR( SERIAL12, 1, 5 );
         ENCSERIAL12 := SUBSTR( SERIAL12, 6 );
         DECSERIAL12 := M2( ENCKEY, ENCSERIAL12 );
         PKSPECCREATIONTIMEREGISTERED := TO_DATE( DECSERIAL12, 'DDMMYYHH24MISS' );
         IF ( PKSPECCREATIONTIMEREGISTERED != PKSPECCREATIONTIME ) THEN
            ENCKEY := M4;
            STATUS := ENCKEY || M1( ENCKEY, LICENSETAMPERED );
            RETURN ( STATUS );
         END IF;
         STMT := 'SELECT ';
         STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || '.' || GETEXCLUSIONFNNAME;
         STMT := STMT || ' FROM dual';
         OPEN CV
              FOR STMT;
         LOOP
            FETCH CV
               INTO SBPKEXCLUSIONTABLENUMBER;
            EXIT WHEN CV%NOTFOUND;
         END LOOP;
         CLOSE CV;
         SBEXCLUSIONTABLENUMBER := GETEXCLUSIONTABLENUMBER;
         IF ( SBPKEXCLUSIONTABLENUMBER != SBEXCLUSIONTABLENUMBER ) THEN
            ENCKEY := M4;
            STATUS := ENCKEY || M1( ENCKEY, LICENSEEXCLUSIONMOD );
            RETURN ( STATUS );
         END IF;
         STMT := 'SELECT ';
         STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || '.' || GETKEY22FNNAME;
         STMT := STMT || ' FROM dual';
         OPEN CV
              FOR STMT;
         LOOP
            FETCH CV
               INTO KEY22;
            EXIT WHEN CV%NOTFOUND;
         END LOOP;
         CLOSE CV;
         DECKEY22 := M2( ENCKEY, KEY22 );
         KEY22 := DECKEY22;
         EXPIRYDATE := TO_DATE( SUBSTR( KEY22, 1, 6 ), 'DDMMRR' );
         TODAY := ROUND( SYSDATE, 'J' );
         IF ( TODAY > EXPIRYDATE ) THEN
            ENCKEY := M4;
            STATUS := ENCKEY || M1( ENCKEY, LICENSEEXPIRED );
            RETURN ( STATUS );
         END IF;
         EXPONENT := TO_NUMBER( SUBSTR( KEY22, 7, 1 ) );
         MULTIPLIER := TO_NUMBER( SUBSTR( KEY22, 8 ) );
         SUBSCRIBEDSERVICESLICENSED := POWER( 10, EXPONENT ) * MULTIPLIER;
         SELECT /*+  INDEX_FFS (servsusc, ix_sesu_esco) */
            COUNT( * )
            INTO SUBSCRIBEDSERVICESCOUNT
            FROM ( SELECT SERVCODI FROM SERVICIO MINUS SELECT ID FROM EXCLUSIONTABLE ) SRVS, SERVSUSC
            WHERE EXISTS( SELECT COECCODI FROM CONFESCO WHERE COECFACT = 'S' AND COECCODI = SESUESCO AND COECSERV = SRVS.SERVCODI ) AND SESUSERV + 0 = SRVS.SERVCODI;
         IF ( SUBSCRIBEDSERVICESCOUNT > SUBSCRIBEDSERVICESLICENSED ) THEN
            ENCKEY := M4;
            STATUS := ENCKEY || M1( ENCKEY, LICENSEDCAPACITYEXCEEDED );
            RETURN ( STATUS );
         END IF;
      END IF;
      ENCKEY := M4;
      STATUS := ENCKEY || M1( ENCKEY, LICENSEVALID );
      RETURN ( STATUS );
    EXCEPTION
      WHEN OTHERS THEN
         ENCKEY := M4;
         STATUS := ENCKEY || M1( ENCKEY, LICENSEINVALID );
         PKERRORS.SETSERVERMODE;
         PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBVARIABLE );
         RETURN ( STATUS );
   END CHECKLICENSESTATUS;
   FUNCTION CREATEPKLICINFOANDGETSERIAL12
    RETURN VARCHAR2
    IS
      SERIAL12 VARCHAR2( 128 );
      ENCODED VARCHAR2( 128 );
      STMT VARCHAR2( 2000 );
      PKSPECPRESENT NUMBER( 1 );
      IPADDRESS VARCHAR2( 16 );
      INDEX1 NUMBER( 4 );
      INDEX2 NUMBER( 4 );
      LOOPCNT NUMBER( 4 );
      DBNAME VARCHAR2( 32 );
      OSUSER VARCHAR2( 32 );
      DBUSER VARCHAR2( 32 );
      IPADDNODOTS VARCHAR2( 16 );
      PARAM VARCHAR2( 32 );
    BEGIN
      SERIAL12 := 'SERIAL12';
      SELECT
         COUNT( OBJECT_NAME )
         INTO PKSPECPRESENT
         FROM USER_OBJECTS
         WHERE OBJECT_NAME = UPPER( LICENSEINFOPACKAGENAME ) AND OBJECT_TYPE = 'PACKAGE';
      IF ( PKSPECPRESENT > 0 ) THEN
         STMT := 'DROP PACKAGE ' || UPPER( LICENSEINFOPACKAGENAME );
         EXECUTE IMMEDIATE STMT;
      END IF;
      STMT := 'CREATE OR REPLACE PACKAGE ';
      STMT := STMT || UPPER( LICENSEINFOPACKAGENAME );
      STMT := STMT || ' AS FUNCTION ';
      STMT := STMT || GETSERIAL12FNNAME;
      STMT := STMT || ' RETURN VARCHAR2; FUNCTION ';
      STMT := STMT || GETKEY22FNNAME;
      STMT := STMT || ' RETURN VARCHAR2; FUNCTION ';
      STMT := STMT || GETEXCLUSIONFNNAME;
      STMT := STMT || ' RETURN VARCHAR2; END ';
      STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || ';';
      EXECUTE IMMEDIATE STMT;
      SELECT
         TO_CHAR( CREATED, 'DDMMYYHH24MISS' )
         INTO SERIAL12
         FROM USER_OBJECTS
         WHERE OBJECT_NAME = UPPER( LICENSEINFOPACKAGENAME ) AND OBJECT_TYPE = 'PACKAGE';
      DBUSER := SYS_CONTEXT( 'USERENV', 'CURRENT_USER' );
      DBUSER := RPAD( DBUSER, 8, '0' );
      OSUSER := SYS_CONTEXT( 'USERENV', 'OS_USER' );
      OSUSER := RPAD( OSUSER, 8, '0' );
      DBNAME := SYS_CONTEXT( 'USERENV', 'DB_NAME' );
      DBNAME := RPAD( DBNAME, 8, '0' );
      IPADDRESS := SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' );
      INDEX1 := 1;
      LOOPCNT := 1;
      LOOP
         INDEX2 := INSTR( IPADDRESS, '.', INDEX1, 1 );
         IF ( INDEX2 > 0 ) THEN
            PARAM := SUBSTR( IPADDRESS, INDEX1, INDEX2 - INDEX1 );
            INDEX1 := INDEX2 + 1;
          ELSE
            PARAM := SUBSTR( IPADDRESS, INDEX1, LENGTH( IPADDRESS ) - INDEX1 + 1 );
         END IF;
         PARAM := LPAD( PARAM, 3, '0' );
         IPADDNODOTS := IPADDNODOTS || PARAM;
         EXIT WHEN INDEX2 = 0 OR LOOPCNT > 10;
         LOOPCNT := LOOPCNT + 1;
      END LOOP;
      SERIAL12 := SERIAL12 || DBUSER || OSUSER || DBNAME || IPADDNODOTS;
      SERIAL12 := UPPER( SERIAL12 );
      ENCODED := M5( SERIAL12 );
      RETURN ( ENCODED );
   END CREATEPKLICINFOANDGETSERIAL12;
   FUNCTION CREATEPKLICINFOBODY( SERIAL12 IN VARCHAR2, KEY22 IN VARCHAR2 )
    RETURN VARCHAR2
    IS
      INDEX1 NUMBER;
      INDEX2 NUMBER;
      VALIDPKCREATIONTIME VARCHAR2( 32 );
      VALIDDBUSER VARCHAR2( 32 );
      VALIDOSUSER VARCHAR2( 32 );
      VALIDDBNAME VARCHAR2( 32 );
      VALIDCLIENTIP VARCHAR2( 32 );
      PARAM VARCHAR2( 128 );
      LOOPCNT NUMBER( 2 );
      ACTUALPKCREATIONTIME DATE;
      SBEXCLUSIONTABLENUMBER VARCHAR2( 6 );
      PKSPECPRESENT NUMBER( 2 );
      STMT VARCHAR2( 4000 );
      ENCKEY VARCHAR2( 10 );
      ENCODEDSERIAL12 VARCHAR2( 128 );
      DECODEDSERIAL12 VARCHAR2( 128 );
      DBNAME VARCHAR2( 16 );
      DBUSER VARCHAR2( 16 );
      OSUSER VARCHAR2( 16 );
      IPADDRESS VARCHAR2( 16 );
      IPADDNODOTS VARCHAR2( 16 );
      ENCPKCREATIONTIME VARCHAR2( 32 );
      NOPACKAGESPECFOUND VARCHAR2( 2 );
      PKSPECCRTIMEMISMATCH VARCHAR2( 2 );
      DBUSERMISMATCH VARCHAR2( 2 );
      OSUSERMISMATCH VARCHAR2( 2 );
      DBNAMEMISMATCH VARCHAR2( 2 );
      IPADDRESSMISMATCH VARCHAR2( 2 );
      STATUSOK VARCHAR2( 2 );
    BEGIN
      STATUSOK := '0';
      NOPACKAGESPECFOUND := '1';
      PKSPECCRTIMEMISMATCH := '2';
      DBUSERMISMATCH := '3';
      OSUSERMISMATCH := '4';
      DBNAMEMISMATCH := '5';
      IPADDRESSMISMATCH := '6';
      ENCKEY := SUBSTR( SERIAL12, 1, 5 );
      ENCODEDSERIAL12 := SUBSTR( SERIAL12, 6 );
      DECODEDSERIAL12 := M2( ENCKEY, ENCODEDSERIAL12 );
      VALIDPKCREATIONTIME := SUBSTR( DECODEDSERIAL12, 1, 12 );
      VALIDDBUSER := SUBSTR( DECODEDSERIAL12, 13, 8 );
      VALIDOSUSER := SUBSTR( DECODEDSERIAL12, 21, 8 );
      VALIDDBNAME := SUBSTR( DECODEDSERIAL12, 29, 8 );
      VALIDCLIENTIP := SUBSTR( DECODEDSERIAL12, 37, 12 );
      SELECT
         COUNT( OBJECT_NAME )
         INTO PKSPECPRESENT
         FROM USER_OBJECTS
         WHERE OBJECT_NAME = UPPER( LICENSEINFOPACKAGENAME ) AND OBJECT_TYPE = 'PACKAGE';
      IF ( PKSPECPRESENT = 0 ) THEN
         RETURN ( NOPACKAGESPECFOUND );
      END IF;
      SELECT
         CREATED
         INTO ACTUALPKCREATIONTIME
         FROM USER_OBJECTS
         WHERE OBJECT_NAME = UPPER( LICENSEINFOPACKAGENAME ) AND OBJECT_TYPE = 'PACKAGE';
      IF ( TO_DATE( VALIDPKCREATIONTIME, 'DDMMYYHH24MISS' ) != ACTUALPKCREATIONTIME ) THEN
         RETURN ( PKSPECCRTIMEMISMATCH );
      END IF;
      DBUSER := SYS_CONTEXT( 'USERENV', 'CURRENT_USER' );
      DBUSER := UPPER( RPAD( DBUSER, 8, '0' ) );
      OSUSER := SYS_CONTEXT( 'USERENV', 'OS_USER' );
      OSUSER := UPPER( RPAD( OSUSER, 8, '0' ) );
      DBNAME := SYS_CONTEXT( 'USERENV', 'DB_NAME' );
      DBNAME := UPPER( RPAD( DBNAME, 8, '0' ) );
      IF ( DBUSER != VALIDDBUSER ) THEN
         RETURN ( DBUSERMISMATCH );
      END IF;
      IF ( OSUSER != VALIDOSUSER ) THEN
         RETURN ( OSUSERMISMATCH );
      END IF;
      IF ( DBNAME != VALIDDBNAME ) THEN
         RETURN ( DBNAMEMISMATCH );
      END IF;
      IPADDRESS := SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' );
      INDEX1 := 1;
      LOOPCNT := 1;
      LOOP
         INDEX2 := INSTR( IPADDRESS, '.', INDEX1, 1 );
         IF ( INDEX2 > 0 ) THEN
            PARAM := SUBSTR( IPADDRESS, INDEX1, INDEX2 - INDEX1 );
            INDEX1 := INDEX2 + 1;
          ELSE
            PARAM := SUBSTR( IPADDRESS, INDEX1, LENGTH( IPADDRESS ) - INDEX1 + 1 );
         END IF;
         PARAM := LPAD( PARAM, 3, '0' );
         IPADDNODOTS := IPADDNODOTS || PARAM;
         EXIT WHEN INDEX2 = 0 OR LOOPCNT > 10;
         LOOPCNT := LOOPCNT + 1;
      END LOOP;
      IF ( IPADDNODOTS != VALIDCLIENTIP ) THEN
         RETURN ( IPADDRESSMISMATCH );
      END IF;
      ENCPKCREATIONTIME := M1( ENCKEY, TO_CHAR( ACTUALPKCREATIONTIME, 'DDMMYYHH24MISS' ) );
      ENCPKCREATIONTIME := ENCKEY || ENCPKCREATIONTIME;
      SBEXCLUSIONTABLENUMBER := GETEXCLUSIONTABLENUMBER;
      STMT := 'CREATE OR REPLACE PACKAGE BODY ';
      STMT := STMT || UPPER( LICENSEINFOPACKAGENAME );
      STMT := STMT || ' AS ';
      STMT := STMT || 'FUNCTION ';
      STMT := STMT || GETSERIAL12FNNAME;
      STMT := STMT || ' RETURN VARCHAR2 IS ';
      STMT := STMT || 'var1 varchar2(128);';
      STMT := STMT || 'BEGIN var1 := ''' || ENCPKCREATIONTIME || ''';';
      STMT := STMT || 'return (var1);';
      STMT := STMT || 'END ' || GETSERIAL12FNNAME || ';';
      STMT := STMT || 'FUNCTION ';
      STMT := STMT || GETKEY22FNNAME;
      STMT := STMT || ' RETURN VARCHAR2 IS ';
      STMT := STMT || 'var2 varchar2(100);';
      STMT := STMT || 'BEGIN var2 := ''' || KEY22 || ''';';
      STMT := STMT || 'return (var2);';
      STMT := STMT || 'END ' || GETKEY22FNNAME || ';';
      STMT := STMT || 'FUNCTION ';
      STMT := STMT || GETEXCLUSIONFNNAME;
      STMT := STMT || ' RETURN VARCHAR2 IS ';
      STMT := STMT || 'var3 number(4);';
      STMT := STMT || 'BEGIN var3 := ''' || SBEXCLUSIONTABLENUMBER || ''';';
      STMT := STMT || 'return (var3);';
      STMT := STMT || 'END ' || GETEXCLUSIONFNNAME || ';';
      STMT := STMT || 'END ' || UPPER( LICENSEINFOPACKAGENAME ) || ';';
      EXECUTE IMMEDIATE STMT;
      RETURN ( STATUSOK );
   END CREATEPKLICINFOBODY;
   FUNCTION CHECKAUTHENTLICENSESTATUS
    RETURN NUMBER
    IS
      STATUS VARCHAR2( 40 );
      SBERRORCODE VARCHAR2( 20 );
      NUERRORMSG NUMBER;
    BEGIN
      STATUS := CHECKLICENSESTATUS;
      SBERRORCODE := M2( SUBSTR( STATUS, 1, LENGTH( STATUS ) - 1 ), SUBSTR( STATUS, LENGTH( STATUS ) ) );
      IF ( SBERRORCODE = '1' ) THEN
         NUERRORMSG := 102;
       ELSIF ( SBERRORCODE = '2' ) THEN
         NUERRORMSG := 103;
       ELSIF ( SBERRORCODE = '3' ) THEN
         NUERRORMSG := 104;
       ELSIF ( SBERRORCODE = '4' ) THEN
         NUERRORMSG := 105;
       ELSIF ( SBERRORCODE = '5' ) THEN
         NUERRORMSG := 106;
       ELSIF ( SBERRORCODE = '6' ) THEN
         NUERRORMSG := 12531;
      END IF;
      IF ( SBERRORCODE != '0' ) THEN
         PKERRORS.SETERRORCODE( PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_BIL, NUERRORMSG );
         RAISE LOGIN_DENIED;
      END IF;
      RETURN ( 19611010 );
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         RAISE LOGIN_DENIED;
   END CHECKAUTHENTLICENSESTATUS;
   FUNCTION SERVSLICENSED
    RETURN NUMBER
    IS
      SERIAL12 VARCHAR2( 100 );
      KEY22 VARCHAR2( 100 );
      SUBSCRIBEDSERVICESLICENSED NUMBER( 15 );
      EXPIRYDATE DATE;
      EXPONENT NUMBER( 3 );
      MULTIPLIER NUMBER( 5 );
      TYPE REFCURTYP IS REF CURSOR;
      CV REFCURTYP;
      ENCKEY VARCHAR2( 10 );
      DECKEY22 VARCHAR2( 32 );
      STMT VARCHAR2( 2000 );
    BEGIN
      STMT := 'SELECT ';
      STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || '.' || GETSERIAL12FNNAME;
      STMT := STMT || ' FROM dual';
      OPEN CV
           FOR STMT;
      LOOP
         FETCH CV
            INTO SERIAL12;
         EXIT WHEN CV%NOTFOUND;
      END LOOP;
      CLOSE CV;
      ENCKEY := SUBSTR( SERIAL12, 1, 5 );
      STMT := 'SELECT ';
      STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || '.' || GETKEY22FNNAME;
      STMT := STMT || ' FROM dual';
      OPEN CV
           FOR STMT;
      LOOP
         FETCH CV
            INTO KEY22;
         EXIT WHEN CV%NOTFOUND;
      END LOOP;
      CLOSE CV;
      DECKEY22 := M2( ENCKEY, KEY22 );
      KEY22 := DECKEY22;
      EXPIRYDATE := TO_DATE( SUBSTR( KEY22, 1, 6 ), 'DDMMRR' );
      EXPONENT := TO_NUMBER( SUBSTR( KEY22, 7, 1 ) );
      MULTIPLIER := TO_NUMBER( SUBSTR( KEY22, 8 ) );
      SUBSCRIBEDSERVICESLICENSED := POWER( 10, EXPONENT ) * MULTIPLIER;
      RETURN ( SUBSCRIBEDSERVICESLICENSED );
   END SERVSLICENSED;
   FUNCTION EXPIRATIONDATE
    RETURN DATE
    IS
      SERIAL12 VARCHAR2( 100 );
      KEY22 VARCHAR2( 100 );
      SUBSCRIBEDSERVICESLICENSED NUMBER( 15 );
      EXPIRYDATE DATE;
      EXPONENT NUMBER( 3 );
      MULTIPLIER NUMBER( 5 );
      TYPE REFCURTYP IS REF CURSOR;
      CV REFCURTYP;
      ENCKEY VARCHAR2( 10 );
      DECKEY22 VARCHAR2( 32 );
      STMT VARCHAR2( 2000 );
    BEGIN
      STMT := 'SELECT ';
      STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || '.' || GETSERIAL12FNNAME;
      STMT := STMT || ' FROM dual';
      OPEN CV
           FOR STMT;
      LOOP
         FETCH CV
            INTO SERIAL12;
         EXIT WHEN CV%NOTFOUND;
      END LOOP;
      CLOSE CV;
      ENCKEY := SUBSTR( SERIAL12, 1, 5 );
      STMT := 'SELECT ';
      STMT := STMT || UPPER( LICENSEINFOPACKAGENAME ) || '.' || GETKEY22FNNAME;
      STMT := STMT || ' FROM dual';
      OPEN CV
           FOR STMT;
      LOOP
         FETCH CV
            INTO KEY22;
         EXIT WHEN CV%NOTFOUND;
      END LOOP;
      CLOSE CV;
      DECKEY22 := M2( ENCKEY, KEY22 );
      KEY22 := DECKEY22;
      EXPIRYDATE := TO_DATE( SUBSTR( KEY22, 1, 6 ), 'DDMMRR' );
      EXPONENT := TO_NUMBER( SUBSTR( KEY22, 7, 1 ) );
      MULTIPLIER := TO_NUMBER( SUBSTR( KEY22, 8 ) );
      SUBSCRIBEDSERVICESLICENSED := POWER( 10, EXPONENT ) * MULTIPLIER;
      RETURN ( EXPIRYDATE );
   END EXPIRATIONDATE;
END PKLICENSEMGR;
/


