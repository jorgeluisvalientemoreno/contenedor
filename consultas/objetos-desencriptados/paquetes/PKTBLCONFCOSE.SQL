
CREATE OR REPLACE PACKAGE PKTBLCONFCOSE IS
   TYPE TYCOCSSERV IS TABLE OF CONFCOSE.COCSSERV%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYCOCSNCDX IS TABLE OF CONFCOSE.COCSNCDX%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYCOCSNCCX IS TABLE OF CONFCOSE.COCSNCCX%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYCOCSMNCR IS TABLE OF CONFCOSE.COCSMNCR%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYCOCSPDCX IS TABLE OF CONFCOSE.COCSPDCX%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYCOCSNDRL IS TABLE OF CONFCOSE.COCSNDRL%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYCOCSPDCR IS TABLE OF CONFCOSE.COCSPDCR%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYCOCSNCRI IS TABLE OF CONFCOSE.COCSNCRI%TYPE INDEX BY BINARY_INTEGER;
   TYPE TYTBCONFCOSE IS RECORD
    (
      COCSSERV TYCOCSSERV,
      COCSNCDX TYCOCSNCDX,
      COCSNCCX TYCOCSNCCX,
      COCSMNCR TYCOCSMNCR,
      COCSPDCX TYCOCSPDCX,
      COCSNDRL TYCOCSNDRL,
      COCSPDCR TYCOCSPDCR,
      COCSNCRI TYCOCSNCRI
    );
   CURSOR CUCONFCOSE( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE ) IS
SELECT *
    FROM   confcose
    WHERE  cocsserv = inuCocsserv;
   PROCEDURE INSRECORD( IRCRECORD IN CONFCOSE%ROWTYPE );
   PROCEDURE INSRECORDS( IRCTBRECORD IN OUT NOCOPY TYTBCONFCOSE );
   PROCEDURE INSFOREACHCOLUMN( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCOCSNCDX IN CONFCOSE.COCSNCDX%TYPE, INUCOCSNCCX IN CONFCOSE.COCSNCCX%TYPE, INUCOCSMNCR IN CONFCOSE.COCSMNCR%TYPE, INUCOCSPDCX IN CONFCOSE.COCSPDCX%TYPE, INUCOCSNDRL IN CONFCOSE.COCSNDRL%TYPE, INUCOCSPDCR IN CONFCOSE.COCSPDCR%TYPE, INUCOCSNCRI IN CONFCOSE.COCSNCRI%TYPE );
   PROCEDURE INSFOREACHCOLUMNBULK( INUCOCSSERV IN OUT NOCOPY TYCOCSSERV, INUCOCSNCDX IN OUT NOCOPY TYCOCSNCDX, INUCOCSNCCX IN OUT NOCOPY TYCOCSNCCX, INUCOCSMNCR IN OUT NOCOPY TYCOCSMNCR, INUCOCSPDCX IN OUT NOCOPY TYCOCSPDCX, INUCOCSNDRL IN OUT NOCOPY TYCOCSNDRL, INUCOCSPDCR IN OUT NOCOPY TYCOCSPDCR, INUCOCSNCRI IN OUT NOCOPY TYCOCSNCRI );
   PROCEDURE CLEARMEMORY;
   PROCEDURE DELRECORD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE );
   PROCEDURE UPRECORD( IRCRECORD IN CONFCOSE%ROWTYPE );
   PROCEDURE DELRECORDS( INUCOCSSERV IN OUT NOCOPY TYCOCSSERV );
   FUNCTION FBLEXIST( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN BOOLEAN;
   FUNCTION FRCGETRECORD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN CONFCOSE%ROWTYPE;
   PROCEDURE ACCKEY( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 );
   PROCEDURE VALIDATEDUPVALUES( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 );
   FUNCTION FNUGETMAXNUMSUSACC( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN CONFCOSE.COCSNCDX%TYPE;
   FUNCTION FNUGETMINNUMCONACC( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN CONFCOSE.COCSNCCX%TYPE;
   FUNCTION FNUGETREINSTALLNUMACC( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN NUMBER;
   FUNCTION FNUGETDEBTPERCTOREINSTALL( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN NUMBER;
END;
/


CREATE OR REPLACE PACKAGE BODY PKTBLCONFCOSE IS
   RCCONFCOSE CUCONFCOSE%ROWTYPE;
   RCRECORDNULL CONFCOSE%ROWTYPE;
   PROCEDURE LOAD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE );
   PROCEDURE LOADRECORD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE );
   FUNCTION FBLINMEMORY( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE )
    RETURN BOOLEAN;
   CACHE CONSTANT NUMBER := 1;
   CNURECORD_NO_EXISTE CONSTANT NUMBER := 10054;
   CNURECORD_YA_EXISTE CONSTANT NUMBER := 10053;
   CSBDIVISION CONSTANT VARCHAR2( 20 ) := PKCONSTANTE.CSBDIVISION;
   CSBMODULE CONSTANT VARCHAR2( 20 ) := PKCONSTANTE.CSBMOD_BIL;
   PROCEDURE LOAD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.Load' );
      LOADRECORD( INUCOCSSERV );
      IF ( RCCONFCOSE.COCSSERV IS NULL ) THEN
         PKERRORS.POP;
         RAISE NO_DATA_FOUND;
      END IF;
      PKERRORS.POP;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_NO_EXISTE );
         RAISE LOGIN_DENIED;
   END LOAD;
   PROCEDURE LOADRECORD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.LoadRecord' );
      IF ( CUCONFCOSE%ISOPEN ) THEN
         CLOSE CUCONFCOSE;
      END IF;
      OPEN CUCONFCOSE( INUCOCSSERV );
      FETCH CUCONFCOSE
         INTO RCCONFCOSE;
      IF ( CUCONFCOSE%NOTFOUND ) THEN
         CLOSE CUCONFCOSE;
         PKERRORS.POP;
         RCCONFCOSE := RCRECORDNULL;
         RETURN;
      END IF;
      CLOSE CUCONFCOSE;
      PKERRORS.POP;
   END LOADRECORD;
   FUNCTION FBLINMEMORY( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE )
    RETURN BOOLEAN
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.fblInMemory' );
      IF ( RCCONFCOSE.COCSSERV = INUCOCSSERV ) THEN
         PKERRORS.POP;
         RETURN ( TRUE );
      END IF;
      PKERRORS.POP;
      RETURN ( FALSE );
   END FBLINMEMORY;
   PROCEDURE ACCKEY( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.AccKey' );
      IF ( INUCACHE = CACHE ) THEN
         IF ( FBLINMEMORY( INUCOCSSERV ) ) THEN
            PKERRORS.POP;
            RETURN;
         END IF;
      END IF;
      LOAD( INUCOCSSERV );
      PKERRORS.POP;
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END ACCKEY;
   PROCEDURE CLEARMEMORY
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.ClearMemory' );
      RCCONFCOSE := RCRECORDNULL;
      PKERRORS.POP;
   END CLEARMEMORY;
   PROCEDURE DELRECORD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.DelRecord' );
      DELETE confcose
    WHERE  cocsserv = inuCocsserv;
      IF ( SQL%NOTFOUND ) THEN
         PKERRORS.POP;
         RAISE NO_DATA_FOUND;
      END IF;
      PKERRORS.POP;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_NO_EXISTE );
         RAISE LOGIN_DENIED;
   END DELRECORD;
   PROCEDURE DELRECORDS( INUCOCSSERV IN OUT NOCOPY TYCOCSSERV )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.DelRecords' );
      FORALL INDX IN INUCOCSSERV.FIRST..INUCOCSSERV.LAST
         DELETE confcose
    WHERE  cocsserv = inuCocsserv(indx);
      IF ( SQL%NOTFOUND ) THEN
         PKERRORS.POP;
         RAISE NO_DATA_FOUND;
      END IF;
      PKERRORS.POP;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_NO_EXISTE );
         RAISE LOGIN_DENIED;
   END DELRECORDS;
   PROCEDURE INSFOREACHCOLUMN( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCOCSNCDX IN CONFCOSE.COCSNCDX%TYPE, INUCOCSNCCX IN CONFCOSE.COCSNCCX%TYPE, INUCOCSMNCR IN CONFCOSE.COCSMNCR%TYPE, INUCOCSPDCX IN CONFCOSE.COCSPDCX%TYPE, INUCOCSNDRL IN CONFCOSE.COCSNDRL%TYPE, INUCOCSPDCR IN CONFCOSE.COCSPDCR%TYPE, INUCOCSNCRI IN CONFCOSE.COCSNCRI%TYPE )
    IS
      RCRECORD CONFCOSE%ROWTYPE;
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.InsForEachColumn' );
      RCRECORD.COCSSERV := INUCOCSSERV;
      RCRECORD.COCSNCDX := INUCOCSNCDX;
      RCRECORD.COCSNCCX := INUCOCSNCCX;
      RCRECORD.COCSMNCR := INUCOCSMNCR;
      RCRECORD.COCSPDCX := INUCOCSPDCX;
      RCRECORD.COCSNDRL := INUCOCSNDRL;
      RCRECORD.COCSPDCR := INUCOCSPDCR;
      RCRECORD.COCSNCRI := INUCOCSNCRI;
      INSRECORD( RCRECORD );
      PKERRORS.POP;
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END INSFOREACHCOLUMN;
   PROCEDURE INSFOREACHCOLUMNBULK( INUCOCSSERV IN OUT NOCOPY TYCOCSSERV, INUCOCSNCDX IN OUT NOCOPY TYCOCSNCDX, INUCOCSNCCX IN OUT NOCOPY TYCOCSNCCX, INUCOCSMNCR IN OUT NOCOPY TYCOCSMNCR, INUCOCSPDCX IN OUT NOCOPY TYCOCSPDCX, INUCOCSNDRL IN OUT NOCOPY TYCOCSNDRL, INUCOCSPDCR IN OUT NOCOPY TYCOCSPDCR, INUCOCSNCRI IN OUT NOCOPY TYCOCSNCRI )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.InsForEachColumnBulk' );
      FORALL INDX IN INUCOCSSERV.FIRST..INUCOCSSERV.LAST
         INSERT INTO confcose
    (
        cocsserv,
        cocsncdx,
        cocsnccx,
        cocsmncr,
        cocspdcx,
        cocsndrl,
        cocspdcr,
        cocsncri
    )
    VALUES
    (
        inuCocsserv(indx),
        inuCocsncdx(indx),
        inuCocsnccx(indx),
        inuCocsmncr(indx),
        inuCocspdcx(indx),
        inuCocsndrl(indx),
        inuCocspdcr(indx),
        inuCocsncri(indx)
    );
      PKERRORS.POP;
    EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_YA_EXISTE );
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END INSFOREACHCOLUMNBULK;
   PROCEDURE INSRECORD( IRCRECORD IN CONFCOSE%ROWTYPE )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.InsRecord' );
      INSERT INTO confcose
    (
        cocsserv,
        cocsncdx,
        cocsnccx,
        cocsmncr,
        cocspdcx,
        cocsndrl,
        cocspdcr,
        cocsncri
    )
    VALUES
    (
        ircRecord.cocsserv,
        ircRecord.cocsncdx,
        ircRecord.cocsnccx,
        ircRecord.cocsmncr,
        ircRecord.cocspdcx,
        ircRecord.cocsndrl,
        ircRecord.cocspdcr,
        ircRecord.cocsncri
    );
      PKERRORS.POP;
    EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_YA_EXISTE );
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END INSRECORD;
   PROCEDURE INSRECORDS( IRCTBRECORD IN OUT NOCOPY TYTBCONFCOSE )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.InsRecords' );
      FORALL INDX IN IRCTBRECORD.COCSSERV.FIRST..IRCTBRECORD.COCSSERV.LAST
         INSERT INTO confcose
    (
        cocsserv,
        cocsncdx,
        cocsnccx,
        cocsmncr,
        cocspdcx,
        cocsndrl,
        cocspdcr,
        cocsncri
    )
    VALUES
    (
        irctbRecord.cocsserv(indx),
        irctbRecord.cocsncdx(indx),
        irctbRecord.cocsnccx(indx),
        irctbRecord.cocsmncr(indx),
        irctbRecord.cocspdcx(indx),
        irctbRecord.cocsndrl(indx),
        irctbRecord.cocspdcr(indx),
        irctbRecord.cocsncri(indx)
    );
      PKERRORS.POP;
    EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_YA_EXISTE );
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END INSRECORDS;
   PROCEDURE UPRECORD( IRCRECORD IN CONFCOSE%ROWTYPE )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.UpRecord' );
      UPDATE confcose
    SET
        cocsncdx = ircRecord.cocsncdx,
        cocsnccx = ircRecord.cocsnccx,
        cocsmncr = ircRecord.cocsmncr,
        cocspdcx = ircRecord.cocspdcx,
        cocsndrl = ircRecord.cocsndrl,
        cocspdcr = ircRecord.cocspdcr,
        cocsncri = ircRecord.cocsncri
    WHERE  cocsserv = ircRecord.cocsserv;
      IF ( SQL%NOTFOUND ) THEN
         PKERRORS.POP;
         RAISE NO_DATA_FOUND;
      END IF;
      PKERRORS.POP;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_NO_EXISTE );
         RAISE LOGIN_DENIED;
   END UPRECORD;
   PROCEDURE VALIDATEDUPVALUES( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.ValidateDupValues' );
      IF ( FBLEXIST( INUCOCSSERV, INUCACHE ) ) THEN
         PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_YA_EXISTE );
         RAISE LOGIN_DENIED;
      END IF;
      PKERRORS.POP;
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END VALIDATEDUPVALUES;
   FUNCTION FBLEXIST( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN BOOLEAN
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.fblExist' );
      IF ( INUCACHE = CACHE ) THEN
         IF ( FBLINMEMORY( INUCOCSSERV ) ) THEN
            PKERRORS.POP;
            RETURN ( TRUE );
         END IF;
      END IF;
      LOADRECORD( INUCOCSSERV );
      IF ( RCCONFCOSE.COCSSERV IS NULL ) THEN
         PKERRORS.POP;
         RETURN ( FALSE );
      END IF;
      PKERRORS.POP;
      RETURN ( TRUE );
   END FBLEXIST;
   FUNCTION FNUGETDEBTPERCTOREINSTALL( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN NUMBER
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.fnuGetDebtPercToReinstall' );
      ACCKEY( INUCOCSSERV, INUCACHE );
      PKERRORS.POP;
      RETURN ( RCCONFCOSE.COCSPDCR );
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END FNUGETDEBTPERCTOREINSTALL;
   FUNCTION FNUGETMAXNUMSUSACC( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN CONFCOSE.COCSNCDX%TYPE
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.fnuGetMaxNumSusAcc' );
      ACCKEY( INUCOCSSERV, INUCACHE );
      PKERRORS.POP;
      RETURN ( RCCONFCOSE.COCSNCDX );
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END FNUGETMAXNUMSUSACC;
   FUNCTION FNUGETMINNUMCONACC( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN CONFCOSE.COCSNCCX%TYPE
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.fnuGetMinNumConAcc' );
      ACCKEY( INUCOCSSERV, INUCACHE );
      PKERRORS.POP;
      RETURN ( RCCONFCOSE.COCSNCCX );
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END FNUGETMINNUMCONACC;
   FUNCTION FNUGETREINSTALLNUMACC( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN NUMBER
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.fnuGetReinstallNumAcc' );
      ACCKEY( INUCOCSSERV, INUCACHE );
      PKERRORS.POP;
      RETURN ( RCCONFCOSE.COCSNCRI );
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END FNUGETREINSTALLNUMACC;
   FUNCTION FRCGETRECORD( INUCOCSSERV IN CONFCOSE.COCSSERV%TYPE, INUCACHE IN NUMBER := 1 )
    RETURN CONFCOSE%ROWTYPE
    IS
    BEGIN
      PKERRORS.PUSH( 'pktblConfcose.frcGetRecord' );
      ACCKEY( INUCOCSSERV, INUCACHE );
      PKERRORS.POP;
      RETURN ( RCCONFCOSE );
    EXCEPTION
      WHEN LOGIN_DENIED THEN
         PKERRORS.POP;
         RAISE LOGIN_DENIED;
   END FRCGETRECORD;
END PKTBLCONFCOSE;
/


