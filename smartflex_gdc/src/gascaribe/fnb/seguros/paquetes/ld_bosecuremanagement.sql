create or replace PACKAGE      ld_bosecuremanagement IS
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : Ld_BoSecureManagement
  Descripcion    : Paquete BO con las funciones y/o procedimientos que contendrá la gestión de seguros.
  Autor          : AAcuña
  Fecha          : 14/08/2012 SAO 147879
  Metodos
  Nombre         :
  Parametros         Descripcion
  ============   ===================
  Historia de Modificaciones
  Fecha            Autor                Modificacion
  =========      =========              ====================
  19/06/2024     GDGuevara              OSF-2822: Se modifica ProcSaleByFile incluyendo el manejo del proceso en ESTAPROC
                                        y el bloqueo del archivo que se esta leyendo.
  19/04/2024     GDGuevara              OSF-2572: bloqueo en el cargue de ventas de seguros
                                        Se actualiza el metodo ProcSaleByFile
  21/03/2024     pacosta                OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                        Se actualizan los siguientes métodos:
                                        ProcSaleCreate
                                        ProcSaleByFile
                                        ProcDeffereadCreate
                                        ProcValiNoRenewpoli
                                        ProcValBornDate
                                        GetValueCancelBySubsc
                                        ProcCancelPolicy
                                        ProcCancelByFile
                                        ProcCancelPolByJob
                                        ProcRenew
                                        ProcValPolyCont
                                        ProcValidateClifin
                                        ProcValidateShare
                                        GetSecureInitialValue
                                        FnuValidateCanc
                                        registerOrderReSale
                                        RC_ApplyOSICoupon
                                        valPolicyAmount
                                        cancelPolicyByAge
                                        proccantpolicontexq
                                        GetLiquidationSecurevaluerenew
                                        ldc_valprodmiganuldife
                                        fsbGetExequial
                                        ProcValiNoRenew
                                        CreateNoteCR
                                        fnuGetFirstValueByCon
                                        ProcValProd
                                        ProcValiPoliType
                                        ProcValPolyActi
                                        ProcValStateProdSal
                                        UpdateStatePolicy
                                        GetUnitOperational
                                        GetCatSubBySuscripc
                                        GetLiquidationSecurevalue
                                        GetPolicyCanBySusc
                                        ProcValidateProductparam
                                        ValidateProdEstacort
                                        fnuGetCollectiveNumber
                                        ValidateCreateVisit
                                        ProcValNumberPol
                                        Cambio UTL_FILE.FILE_TYPE por PKG_GESTIONARCHIVOS.STYARCHIVO
  26/01/2024     jsoto  	            (OSF-1751)
										Eliminación código en comentarios
										Eliminación validaciones con: fblAplicaEntrega, fblAplicaEntregaxCaso y LDC_CONFIGURACIONRQ
										Cambio de la gestión de errores, trazas y excepciones para que usen objetos personalizados
										Reemplazar	OS_LEGALIZEORDERALLACTIVITIES	por	API_LEGALIZEORDERS
										Reemplazar	GE_BOCONSTANTS.CSBNO	por	CONSTANTS_PER.CSBNO
										Reemplazar	PKBILLINGNOTEMGR.CREATEBILLINGNOTE	por	API_REGISTRANOTAYDETALLE
										Reemplazar	DAPR_PRODUCT.FNUGETSUBCATEGORY_ID	por	PKG_BCPRODUCTO.FNUSUBCATEGORIA
										Reemplazar	SA_BOSYSTEM.FNUGETUSERCOMPANYID	por	PKG_SESSION.FNUGETEMPRESADEUSUARIO
										Reemplazar	OR_BOCONSTANTS.CNUSUCCESCAUSAL	por	PKG_GESTIONORDENES.CNUCAUSALEXITO
										Reemplazar	OR_BOORDERACTIVITIES.CREATEACTIVITY	por	API_CREATEORDER
										Reemplazar	GE_BOERRORS.SETERRORCODE	por	PKG_ERROR.SETERROR
										Reemplazar	PKTBLSUSCRIPC.FNUGETSUSCCLIE	por	PKG_BCCONTRATO.FNUIDCLIENTE
										Reemplazar	OS_REGISTERREQUESTWITHXML	por	API_REGISTERREQUESTBYXML
										Reemplazar	DAGE_SUBSCRIBER.FNUGETADDRESS_ID	por	PKG_BCCLIENTE.FNUDIRECCION
										Reemplazar	DAOR_ORDER.FNUGETORDER_STATUS_ID	por	PKG_BCORDENES.FNUOBTIENEESTADO
										Reemplazar	ERRORS.SETERROR	por	PKG_ERROR.SETERROR
										Reemplazar	UT_DATE.FDTSYSDATE	por	LDC_BOCONSGENERALES.FDTGETSYSDATE
										Reemplazar	OR_BOLEGALIZEORDER.FNUGETCURRENTORDER	por	PKG_BCORDENES.FNUOBTENEROTINSTANCIALEGAL
										Reemplazar	SA_BOUSER.FNUGETUSERID	por	PKG_SESSION.FNUGETUSERIDBYMASK
										Reemplazar	FA_BOBILLINGNOTES.DETAILREGISTER	por	API_REGISTRANOTAYDETALLE
										Reemplazar	DAPR_PRODUCT.FNUGETCATEGORY_ID	por	PKG_BCPRODUCTO.FNUCATEGORIA
										Reemplazar	DAMO_PACKAGES.GETRECORD	por	PKG_BCSOLICITUDES.FRCGETRECORD
										Reemplazar	PKTBLSERVSUSC.FNUGETSESUESCO	por	PKG_BCPRODUCTO.FNUESTADOCORTE
										Reemplazar	PKERRORS.SETAPPLICATION	por	PKG_ERROR.SETAPPLICATION
										Reemplazar	DAOR_ORDER_ACTIVITY.FNUGETORDER_ID	por	PKG_BCORDENES.FNUOBTIENEORDENDEACTIVIDAD
										Reemplazar	PKTBLSERVSUSC.FNUGETSUSCRIPTION	por	PKG_BCPRODUCTO.FNUCONTRATO
										Reemplazar	PKGENERALSERVICES.FDTGETSYSTEMDATE	por	LDC_BOCONSGENERALES.FDTGETSYSDATE
										Reemplazar	LDC_BOUTILITIES.SPLITSTRINGS	por	REGEXP_SUBSTR
										Reemplazar	GE_BOCONSTANTS.CSBYES	por	CONSTANTS_PER.CSBYES
										Reemplazar	GE_BOERRORS.SETERRORCODEARGUMENT	por	PKG_ERORR.SETERRORMESSAGE
										Reemplazar	DAGE_SUBSCRIBER.FSBGETIDENTIFICATION	por	PKG_BCCLIENTE.FSBIDENTIFICACION
										Reemplazar	OR_BOPROCESSORDER.ASSIGN	por	API_ASSIGN_ORDER
										Reemplazar	DAAB_ADDRESS.FNUGETESTATE_NUMBER	por	PKG_BCDIRECCIONES.FNUGETPREDIO
										Reemplazar	DAOR_ORDER.FNUGETOPERATING_UNIT_ID	por	PKG_BCORDENES.FNUOBTIENEUNIDADOPERATIVA
										Reemplazar	PKTBLSERVSUSC.FNUGETSESUSUSC	por	PKG_BCPRODUCTO.FNUCONTRATO
										Reemplazar	DAPR_PRODUCT.FNUGETPRODUCT_STATUS_ID	por	PKG_BCPRODUCTO.FNUESTADOPRODUCTO
										Reemplazar	EX.CONTROLLED_ERROR	por	PKG_ERROR.CONTROLLED_ERROR
										Reemplazar	PKTBLSUSCRIPC.FNUGETSUSCCICL	por	PKG_BCCONTRATO.FNUCICLOFACTURACION
										Reemplazar	UT_TRACE.TRACE	por	PKG_TRAZA.TRACE
										Reemplazar	GE_BOPERSONAL.FNUGETPERSONID	por	PKG_BOPERSONAL.FNUGETPERSONAID
										Reemplazar	PR_BOPRODUCT.GETCATSUBCATBYPROD	por	PKG_BCPRODUCTO.FNUCATEGORIA
										Reemplazar	CONSTANTS.TYREFCURSOR	por	CONSTANTS_PER.TYREFCURSOR
										Reemplazar	ERRORS.GETERROR	por	PKG_ERROR.GETERROR
										Eliminar el método CANCELPOLICIESBYNORENEW ya que se realizó la validación y este no está siendo usado
										Se elimina del método CommitAdjustsCharges la lógica para creación de ajustes
									    ya que en el método CommitCharges se llama al api_registranotaydetalle que realiza el
									    ajuste. Se deja solo la lógica de validación del saldo de la cuenta.
										Eliminar linea dbms_output.enable(10000000);
										Reemplazar pktblServSusc.fnuGetSuscription -> pkg_bcproducto.fnuContrato
										Reemplazar pktblServsusc.fnuGetService -> pkg_bcproducto.fnuTipoProducto
										Reemplazar pktblServsusc.fdtGetRetireDate -> pkg_bcproducto.fdtFechaRetiro
										Reemplazar pktblSuscripc.fnuGetBillingCycle -> pkg_bccontrato.fnuCicloFacturacion
										Reemplazar pr_bcproduct.fnuGetAddressId -> pkg_bcproducto.fnuIdDireccInstalacion

 27/02/2021	 Olsoftware.caso:718    Se Agrega validacion con la nueva causal 208 - CANCELACION POR JOB/ FACTURAS VENCIDAS
										el cual valida si al momento de realizar la cancelacion de seguros (ProcCancelPolicy) se escoge
										la causal 208 el sistema solo anulará la deuda diferida que tenga ese producto, dejará vigente
										la deuda corriente y la deuda que tenga el producto en diferidos de Alivios COVID.

										Ademas tambien validará si despues del proceso de cancelacion de seguros (ProcCancelPolicy) si el
										producto llega a tener deuda de covid o deuda corriente y/i diferida, dejará el producto activo
										para que pueda seguir facturando

  12/02/2020     ESANTIAGO.CASO:277     se medifica <<ProcCancelPolicy>> y <<FnuValidateCanc>>
  06/12/2019     ESANTIAGO.CASO:155     se medifica <<GetUnitOperational>>
  08/06/2017    KBaquero.caso 200-1225  se medifica <<GetLiquidationSecurevalue>>
                                           <<GetLiquidationSecurevaluerenew>>
                                           <<fnuGetFirstValueByCon>>
  10/05/2017  KBaquero.caso 100-35955   Se modifica <<ProcSaleByFile>>
  28/02/2017  KBaquero.caso 200-1121    Se modifica <<GetLiquidationSecurevaluerenew>>
                                        Se modifica <<GetLiquidationSecurevalue>>
  20/02/2017    KBaquero CA 200-1054    Se adiciona <GetLiquidationSecurevaluerenew>
                                        Se modifica <<ProcRenew>>
  17/02/2017    KBaquero CA 200-1106    Se modifica el metodo <<ProcSaleByFile>>
                                        Se adiciona <proccantpolicontexq>
  21-12-2016    FCastro CA 200-336      Se modifica el metodo <<ProcCancelPolicy>> para que si la causal
                                        de anulacion es por edad cree la nota CR por el valor del saldo
                                        pendiente de la poliza (diferido y corriente) y no genere saldo
                                        a favor al usuario por las cuotas canceladas
  22-10-2016    KBaquero CA 200-746     Se modifica el metodo <<ProcCancelPolicy>>
  22-06-2016    AAcuna.SS_100_10068     Se modifica el metodo <<fdtGetEndDatePeriod>>
  12/02/2016    AAcuna SS_100-8096      Se modificara el proceso de renovación de seguros con el fin de evitar que a la hora de ejecución del proceso
                                         no se encuentren productos  que se encuentren en proceso de facturación (cargos con cuenta de cobro -1).
  17-09-2015     Llozada [ARA 8740]     Se modifica el metodo <<ProcSaleByFile>>
  07/07/2015     mgarcia.SAO334174      Se modifican los metodos
                                         <ProcSaleByFile><ProcValNumberPol>
                                         <ProcValPolyCont><ProcValidateShare>
                                         <ValidateCreateVisit>
                                         Se crea la funcion <fboGetIsNumber>
  24-06-2015    KCienfuegos.ARA7920     Se modifica el metodo <<fdtGetEndDatePeriod>>
  21-04-2015    KCienfuegos.SAO310516   Se modifica el metodo <<ProcRenew>>
  24-02-2015    Llozada NC 4038         Se modifica el metodo <<ProcCancelPolicy>>
  21-01-2015    Llozada NC 4038         Se modifica el metodo <<ProcCancelPolicy>>
  15-12-2014    Llozada NC 4230         Se modifica el metodo <<ProcDeffereadCreate>>
  15-12-2014    Llozada NC 4230         Se modifica el metodo <<ProcSaleCreate>>
  09/12/2014   Oscar Restrepo            TEAM 3862  solucionar el tema de los saldo a Favor en OSF porque en algunos
                                         casos en la cancelacion de seguro no esta quedando en cargcodo iguala  a la Nota.
  14-10-2014    Llozada RQ 1217         Se modifica el metodo <<CreateNoteCR>>
  4-10-2014    Llozada RQ 1217          Se modifica el metodo <<ProcCancelPolicy>>
  08-10-2014    llarrarte.RQ2172        Se modifica <fnuGetCollectiveNumber>
                                        Se adiciona <cancelPolicyByAge>
                                                    <fdtGetEndDatePeriod>
                                                    <CancelPoliciesByNoRenew>
  05-10-2014    Llozada RQ 1217         Se modifica el metodo <<ProcCancelPolicy>>
  30-09-2014    llarrarte.RQ1834        Se crea <fnuGetCollectiveNumber>
  16-09-2014    llarrarte.RQ1178        Se adiciona <valPolicyAmount>
  05-09-2014    AEcheverry.4769         Se modifican los servicios
                                        <<CommitFinanc.GenerateDiscountNotes>>
                                        y <<CreateNoteCR>>
  01/09/2014    KCienfuegos.NC962       Se modifica metodo <<ProcDeffereadCreate>>
  28/08/2014    KCienfuegos.NC1177      Se modifica metodo <<Procsalebyfile>>
  08/08/2014    AEcheverry.4152         se modifican los metodos:
                                            <<ProcDeffereadCreate>>
                                            <<ProcSaleCreate>> y
                                            <<ProcRenew>>
  04/08/2014    KCienfuegos.NC1079      Se modifica el metodo <<Procsalebyfile>>
  18/07/2014    KCienfuegos.RNP550      Se modifica el metodo <<ProcRenew>>
  17/07/2014    KCienfuegos.NC606       Se crea el metodo <<ProcValidateShare>>
  01/07/2014    AEcheverry.4031         se modifican los metodos
                                            <<ProcRenew>> y <<ProcDeffereadCreate>>
  27/06/2014    aesguerra.4029          Se modifica el metodo <<ProcRenew>>
  29/04/2014    JCarmona.3504           Se modifica el metodo <<ValSubscAndProd>>
  14/04/2014    JCarmona.3404           Se modifica el metodo <<ProcCancel>>
  03-03-2014    hjgomez.SAO234504       Se modifica <<ProcRenew>>, <<ProcSaleCreate>>
  12-02-2014    AEcheverrySAO232542     se modifica <<ProcCancelPolicy>>
  29-01-2014    AEcheverrySAO231292     Se modifica <<ProcCancelByFile>> <<ProcCancelPolByJob>>
  17-12-2013     JCarmona.SAO227834     Se modifica el metodo <ProcRenew>
  11-12-2013     hjgomez.SAO227078      Se modifica <<ProcCancelPolicy>>
  27-11-2013     hjgomez.SAO224982      Se modifica <GetSecureInitialValue>
  22-11-2013     hjgomez.SAO224511      Se modifica <GetSecureInitialValue>
  20/09/2013     mmira.SAO217497        Se modifica el metodo <ProcSaleCreate>
  19/09/2013     mmira.SAO217284        Se modifica el metodo <ValidateProdEstacort>.
  09/09/2013     jcarrillo.SAO214516    Se modifica el metodo:
                                            <GetValueCancelBySubsc>
  07/09/2013    jrobayo.SAO216575       Se modifica el metodo
                                        <ProcRenew>
  07/09/2013     mmeusburgger.SAO214427 Se modifica el metodo:
                                         - <<GetSecureInitialValue>>
  07/09/2013     jcarrillo.SAO213279    Se modifica el metodos:
                                            <ProcCancelByFile>
                                        Se adiciona el metodo
                                            <ValidateDataCancel>
  06/09/2013     jcarrillo.SAO214516    Se modifica el metodo:
                                            <ProcCancelPolicy>
                                        Se adicionan los metodos:
                                            <TraslateDefer><CreateNoteCR>
                                            <GetValueCancelByAge>
                                            <GetValueCancelByContr>
                                            <GetValueCancelBySubsc>
  06/09/2013     mmeusburgger.SAO214427 Se modifica
                                        - <<GetSecureInitialValue>>
                                        - <<ProcCancelByFile>>
  06/09/2013     jrobayo.SAO214416      Se modifica el metodo
                                        <ProcSaleByFile>
  06/09/2013     jcarrillo.SAO213248    Se modifica el metodo:
                                            <ProcCancelByFile>
  05/09/2013     mmeusburgger.SAO213104 Se modifica
                                        - <<ProcSaleByFile>>
                                        - <<GetSecureInitialValue>>
                                        - <<RC_ApplyOSICoupon>>
  04/09/2013     jrobayo.SAO216330      Se adiciona el metodo
                                        <ProcUpdBirth>
  04/09/2013     jrobayo.SAO216330      Se modifica el metodo
                                        <ProcSaleCreate>
  04/09/2013     jcarrillo.SAO214549    Se modifica el metodo
                                        <ProcValNumberPol>
  04/09/2013     mmeusburgger.SAO213279 Se modifica
                                        - <<ProcCancelByFile>>
  04/09/2013     jrobayo.SAO213381      Se modifica el metodo
                                        <<ProcSaleByFile>>
  04/09/2013     mmeusburgger.SAO214427 Se Modifica
                                        - <<RC_ApplyOSICoupon>>
                                        - <<GetSecureInitialValue>>
  03/09/2013     mmeusburgger.SAO214423 Se modifica
                                        - <<ProcCancelPolicy>>
                                        - <<GetSecureInitialValue>>
  03/09/2013     jcarrillo.SAO212983    Se adiciona el metodo:
                                        <fsbGetExequial>
                                        Se modifican los metodos:
                                        <ProcSaleCreate><ProcRenew>
  03/09/2013     jcarrillo.SAO214425    Se modifican los metodos:
                                        <ProcDeffereadCreate><ProcRenew>
  03/09/2013     jcarrillo.SAO214416    Se adiciona el metodo:
                                        <ValidateProdEstacort>
                                        Se modifica el metodo:
                                        <ProcSaleByFile>
  02/09/2013     jcarrillo.SAO211267    ValidateProdEstacort
                                        <fnuGetActivityVisit><ValidateCreateVisit>
                                        Se modifica el metodo: <ProcSaleByFile>
  02/09/2013     jrobayo.SAO213977      Se crea el metodo ProcGetPackagesByContract
  31/08/2013     jcarrillo.SAO213976    Se modifican los metodos:
                                        <ProcSaleCreate><ProcDeffereadCreate>
  30/08/2013     jcarrillo.SAO213276    Se elimina el metodo <ProcValProductLine>
                                        Se adicionan los metodos:
                                            <fsbGetValueParameter>
                                            <fnuGetFirstValueByCon>
  29/08/2013     jcarrillo.SAO214742    Se modifica el metodo <ProcSaleCreate>
  29/08/2013     jcarrillo.SAO213191    Se elimina el metodo <ProcValidateProduct>
  27/08/2013     jcarrillo.SAO214426    Se modifican los metodos:
                                        <ProcSaleCreate><ProcSaleByFile>
                                        <ProcDeffereadCreate><ProcRenew>
                                        <GetLiquidationSecurevalue><GetValuePolicyType>
                                        <GetValuepolitypesusc><RC_ApplyOSICoupon>
  14/08/2013     hvera.SAO213138        Se modifica el metodo <ProcCancelPolicy>
  27/08/2015     heiberb Cambio 8540    se modifica el metodo  <GetLiquidationSecurevalue>
  ******************************************************************/
  -- Declaracion de Tipos de datos publicos
  -- Declaracion de variables publicas
  nuGas_Service     ld_parameter.numeric_value%type; -- Parametro del servicio de gas
  sbState           ld_parameter.value_chain%type; -- Parametro del estado de la póliza
  nuPerVen          ld_parameter.numeric_value%type; -- Parametro del periodo de meses vencidos
  nuServSusc        servsusc.sesunuse%type; -- Parametro del servicio suscrito
  nuFactProg        ld_parameter.numeric_value%type; -- Parametro del servicio de programa FGCC
  nuTypeProduct     servicio.servcodi%type; -- Parametro del tipo de producto seguros brilla
  nuCantbyCont      ld_parameter.numeric_value%type; -- Parametro para saber la cantidad de pólizas permitidas
  nuDateMin         ld_parameter.numeric_value%type; -- Parametro para saber la edad minima permitida para el suscriptor
  nuDateMax         ld_parameter.numeric_value%type; -- Parametro para saber la edad maxima permitida para el suscriptor
  nuNumDobCup       ld_parameter.numeric_value%type; -- Parametro de la linea de producto Doble Cupon
  sbEstacort        ld_parameter.value_chain%type; -- Parametro del estado de corte
  sbCate            ld_parameter.value_chain%type; -- Parametro de la categoria permitida
  nuCoutaFin        ld_parameter.numeric_value%type; -- Parametro para saber el valor de cuota de financiación permitida
  sbCauCumpl        ld_parameter.value_chain%type; -- Parametro para la causal de cumplimiento de venta
  sbRutLogs         ld_parameter.value_chain%type; -- Parametro de la ruta de seguro
  sbCanByFil        ld_parameter.value_chain%type; -- Parametro del tipo de cancelacion
  nuTypeLiqDn       ld_parameter.value_chain%type; -- Parametro para devolución por Número de meses
  nuTypeLiqVnp      ld_parameter.value_chain%type; -- Parametro por valor no pagado
  sbFileManagementf pkg_gestionarchivos.styarchivo; -- Parametro para Log de erroes en archivo CSV
  nuPolicyNum       ld_policy.policy_number%type; -- Parametro para Log de erroes en archivo CSV
  nuContrato        suscripc.susccodi%type; -- Parametro para Log de erroes en archivo CSV
  fboAge            boolean := false; --variable para saber si la cancelacion es por edad
  /*Tipo tabla para almacenar facturas con sus saldos*/
  TYPE rcStatAccoAndBalance IS RECORD(
    StatusAccount factura.factcodi%TYPE,
    AccountValue  cuencobr.cucosacu%TYPE);
  TYPE tytbStatAccoAndBalance IS TABLE OF rcStatAccoAndBalance INDEX BY BINARY_INTEGER;
  blIsPrinted boolean := FALSE;
  -----------------------
  -- Constants
  -----------------------
  -- Constante del tipo de liquidacion del pago total
  nuTypeLiqDt CONSTANT NUMBER := 1;
  -- Constante del tipo de liquidacion del pago parcial
  nuTypeLiqDp CONSTANT NUMBER := 2;
  -- Constante de la causal de legalizacion de exito para las ordenes
  nuTypeCausalExit CONSTANT NUMBER := 1;
  -- Constante de la causal de legalizacion con fallo para las ordenes
  nuTypeCausalF CONSTANT NUMBER := 0;
  -- Constante de accion de atencion de solicitud de cancelacion de seguros
  cnuActionId CONSTANT Ge_Action_Module.Action_Id%TYPE := 310;
  -----------------------
  --------------------------------------------------------------------
  -- Variables
  --------------------------------------------------------------------
  --------------------------------------------------------------------
  -- Cursores
  --------------------------------------------------------------------
  -----------------------------------
  -- Metodos publicos del package
  -----------------------------------
  /*****************************************************************
  Propiedad intelectual de Open International Systems. (c).
  Procedure      :  fsbVersion
  Descripcion    :  Obtiene la Version actual del Paquete
  Parametros     :  Descripción
  Retorno        :
  csbVersion        Version del Paquete
  Autor          :  AAcuña SAO 147879
  Fecha          :  20/09/2012
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  *****************************************************************/
  FUNCTION fsbVersion return varchar2;
  sbconsultation varchar2(4000);
  /*****************************************************************/
  FUNCTION fnugetprod(nucontra   suscripc.susccodi%type,
                      nuprodtype pr_product.product_type_id%type)
    RETURN number;
  /*****************************************************************
  Propiedad intelectual de PETI (c).
  Unidad         : fnuGetCollectiveNumber
  Descripcion    : Calcula el numero del colectivo para la poliza
  Autor          : llarrarte
  Fecha          : 30-09-2014
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  30-09-2014  llarrarte.RQ1834  Creacion
  ******************************************************************/
  FUNCTION fnuGetCollectiveNumber(inuProductLine  ld_product_line.product_line_id%type,
                                  inuPolicyNumber ld_policy.policy_number%type,
                                  idtCreationDate ld_policy.dtcreate_policy%type)
    return ld_policy.collective_number%type;
  /*****************************************************************
  Propiedad intelectual de PETI (c).
  Unidad         : valPolicyAmount
  Descripcion    : Valida la cantidad de polizas asociadas a una cedula
  Autor          : llarrarte
  Fecha          : 16-09-2014
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  16-09-2014  llarrarte.RQ1178  Creacion
  ******************************************************************/
  PROCEDURE valPolicyAmount(inuProductLine  in ld_product_line.product_line_id%type,
                            inuSubscriberId in ge_subscriber.subscriber_id%type,
                            inuPolicyType   in ld_policy_type.policy_type_id%type,
                            inuPolicyNumber in ld_policy.policy_number%type);
  /*****************************************************************
      Propiedad intelectual de Open International Systems (c).
      Unidad         : ProcUpdBirth
      Descripcion    : Objeto de negocio para actualizar la fecha de nacimiento
                       de un suscriptor, el cual adquiere una nueva poliza de seguro.
      Autor          : jrobayo
      Fecha          : 04/09/2013 SAO 216330
      Parametros         Descripcion
      ============  ===================
      inuSubscriber:     Codigo del suscriptor
      idtBirth:           Fecha de nacimiento del suscriptor
      Historia de Modificaciones
      Fecha            Autor          Modificacion
      ==========  =================== =======================
      04/09/2013  jrobayo.SAO216330   1 - Se crea el metodo para actualizar la fecha
                                          de nacimiento del suscriptor que adquiere
                                          una nueva poliza.
  ******************************************************************/
  PROCEDURE ProcUpdBirth(inuSubscriber in ge_subscriber.subscriber_id%type,
                         idtBirth      in ge_subs_general_data.date_birth%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcSaleCreate
  Descripcion    : Objeto de negocio para el registro de una solicitud de venta
                   creando su respectivo producto de seguros.
  Autor          : AAcuña
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripción
  ============  ===================
   inuPackage:     Número de la solicitud
  Historia de Modificaciones
  Fecha         Autor       Modificación
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcSaleCreate(inuPackage in mo_packages.package_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcSaleByJob
  Descripcion    : Objeto de negocio para la ejecución por job llamando al proceso de
                   ProcSaleByFile
  Autor          : AAcuña
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcSaleByJob;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcSaleByFile
  Descripcion    : Objeto de negocio para la busqueda del archivo de venta enviado por la aseguradora
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor               Modificacion
  =========       =========        ====================
  14/08/2012   AAcuna.SAO147879       Creacion
  ******************************************************************/
  PROCEDURE ProcSaleByFile;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValPoly
  Descripcion    : Obtiene el parametro cantidad de cédula desde la entidad ld_policy_type
                   teniendo en cuenta que el tipo de póliza se debe encontrar vigente.
  Autor          : AAcuña
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
      inuPoly:     Código de la póliza
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValPoly(inuPoly in ld_policy_type.policy_type_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancel
  Descripcion    : Objeto de negocio con los procedimientos para realizar  la cancelación de seguros
  Autor          : AAcuña
  Fecha          : 13/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
    inuPackage:   Numero de la solicitud
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcCancel(inupackage in mo_packages.package_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancelPolicy
  Descripcion    : Objeto de negocio con los procedimientos para realizar  la cancelación de seguros
  Autor          : AAcuña
  Fecha          : 13/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuPackage:    Número del paquete
  inuPolicy:     Número de la póliza
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  05-10-2014  Llozada RQ 1217     Se valida que la causal sea de tipo de liquidacion parcial
                                    para que le cree notas a todos los diferidos.
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcCancelPolicy(inupackage in mo_packages.package_id%type,
                             inupolicy  ld_policy.policy_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancelPolByJob
  Descripcion    : Proceso que verifica los seguros que presenten atraso en sus pagos,
                   teniendo en cuenta el parámetro del sistema que contiene el numero de periodo vencidos
  Autor          : AAcuña
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcCancelPolByJob;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancelByFile
  Descripcion    : Proceso que busca los archivos de cancelación montados por la aseguradaora
                   con extensión .txt y empiezen con ANUL para su respectiva cancelación de pólizas
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcCancelByFile;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcRenew
  Descripcion    : Proceso que verifica las pólizas que hayan cumplido con la
                   fecha de vigencia al momento de ejecución del proceso y no presenten una solicitud de no renovación.
  Autor          : AAcuña
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcRenew;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValiNoRenew
  Descripcion    : Realiza validaciones de la solicitud de no renovación
  Autor          : kbaquero
  Fecha          : 26/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuSubscriptionId    Identificador del contrato
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  12/02/2016    AAcuna SS_100-8096    Se modificara el proceso de renovación de seguros con el fin de evitar que a la hora de ejecución del proceso
                                        no se encuentren productos  que se encuentren en proceso de facturación (cargos con cuenta de cobro -1).
  ******************************************************************/
  PROCEDURE ProcValiNoRenew(inuSubscriptionId IN suscripc.susccodi%TYPE);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValiNoRenewpoli
  Descripcion    : Realiza validaciones de la solicitud de no renovacion
                   en cuanto a la poliza
  Autor          : kbaquero
  Fecha          : 04/07/2013 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuSubscriptionId    Identificador del contrato
  inupoli              Identificador de la poliza
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcValiNoRenewpoli(inupoli in ld_policy.policy_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcGetValueParameter
  Descripcion    : Retorna el valor del parametro del tramite de venta de seguros
  Autor          : AAcuna
  Fecha          : 23/07/2012 SAO 147879
    Parametros      Descripcion
  ============   ===================
  nuValue:        Valor del parametro
  Historia de Modificaciones
  Fecha               Autor             Modificacion
  =========         =========         ====================
  ******************************************************************/
  PROCEDURE ProcGetValueParameter(nuValue out varchar2);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fsbGetValueParameter
  Descripcion    : Retorna el valor del parametro del tramite de venta de seguros
  ******************************************************************/
  FUNCTION fsbGetValueParameter Return ps_pack_type_param.value%type;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fnuGetFirstValueByCon
  Descripcion    : Retorna la primera linea de negocio dde tipo puerta a
                     puerta para el contratista en caso de no tener
                     levanta error
  ******************************************************************/
  FUNCTION fnuGetFirstValueByCon(inuContratist in ld_prod_line_ge_cont.contratistas_id%type)
    RETURN ld_prod_line_ge_cont.product_line_id%type;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValiPoliType
  Descripcion    : Valida que la cedula del asegurado no pase del limite configurado
                   en la entidad tipo de póliza
  Autor          : AAcuña
  Fecha          : 28/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuSubscriptionId:    Identificador del contrato
  inuIdentification:    Identificador del subscriber
  inuPolicyType:        Tipo de póliza
  Historia de Modificaciones
  Fecha         Autor      Modificación
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcValiPoliType(inuSubscriptionId in suscripc.susccodi%type,
                             inuIdentification in ge_subscriber.identification%type,
                             inuPolicyType     in ld_policy_type.policy_type_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValProd
  Descripcion    : Valida si el contrato tiene gas activo y la categoria sea de tipo residencial y comercial.
  Autor          : AAcuña
  Fecha          : 29/08/2012 SAO 147879
  Parametros          Descripción
  ============     ==================
  inuSusc:         Número de suscripción
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValProd(inuSusc in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValPolyCont
  Descripcion    : Valida que no se debe permitir tener más de n pólizas vigentes por contrato.
  Autor          : AAcuña
  Fecha          : 29/08/2012 SAO 147879
  Parametros          Descripción
  ============     ==================
  inuSuscripc:         Número de suscripción
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValPolyCont(inuSuscripc in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValBornDate
  Descripcion    : Valida que el suscritor no pase del parámetro de la edad máxima y mínima para tomar el seguro.
  Autor          : AAcuña
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  idtDateBorn:    Fecha de nacimiento
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValBornDate(idtDateBorn in ld_secure_sale.born_date%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValidateClifin
  Descripcion    : Se obtiene el valor de cuota de financiación por suscritor.
  Autor          : AAcuña
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuSuscripc:     Número de suscripción
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValidateClifin(inuSuscripc in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de PETI (c).
  Unidad         : ProcValidateShare
  Descripcion    : Se valida que la cuota de la nueva venta seguro, no supere el valor
                   configurado en el parametro COD_CUOTA_FIN
  Autor          : KCienfuegos
  Fecha          : 17/07/2014 - RNP 606-607-608
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:     Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  17/07/2014     KCienfuegos  Creacion
  ******************************************************************/
  PROCEDURE ProcValidateShare(inuSuscripc in suscripc.susccodi%type,
                              inuvalue    in number);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValPolyActi
  Descripcion    : La cédula no puede tener una póliza activa en otro contrato
  Autor          : AAcuña
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuIdentase:     Número de identificación del asegurado
  inuSuscripc:     Número de suscripción
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValPolyActi(inuIdentase in ld_policy.identification_id%type,
                            inuSuscripc in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcDataPoli
  Descripcion    : Se obtiene datos de la póliza para el trámite de no renovación.
  Autor          : kbaquero
  Fecha          : 28/09/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuPoli:         Número de la póliza
  onupolitype:     Código del tipo de póliza
  onuValuep   :    Valor de la póliza
  onuPayFeed  :    Cutoas pagadas
  onuNumDife  :    Numero del diferido
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcDataPoli(inuPoli     in ld_policy.policy_id%type,
                         onupolitype Out ld_policy.policy_type_id%type,
                         onuValuep   Out ld_policy.value_policy%type,
                         onuPayFeed  Out ld_policy.fees_to_return%type,
                         onuNumDife  Out ld_policy.deferred_policy_id%type,
                         oNucontra   Out ld_policy.contratist_code%type,
                         ONuproline  Out ld_policy.product_line_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValAddressBySusc
  Descripcion    : Valida que la dirección del contrato exista
  Autor          : AAcuna
  Fecha          : 17/10/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuSuscripc:      Número del suscritor
  onuValue:         Valor de retorno
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValAddressBySusc(inuSuscripc in suscripc.susccodi%type,
                                 onuValue    out number);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetPlanDifSale
  Descripcion    : Obtiene los datos a partir del plan de financiación para la venta de seguros
  Autor          : AAcuna
  Fecha          : 06/11/2012 SAO 147879
  Parametros              Descripción
  ============        ===================
  inuFinancingPlan:      Plan de financiación
  dtRequestDate:         Fecha de registro
  onuComputeMethod       Metodo de compute
  onuInteresPercent      Porcentaje de interes
  onuInterestRate        Rango de porcentaje
  onuSpread              Spread
  onuPercentFin          Porncentaje de financiación
  sbDocumentSuppport     Documento de soporte
  dtFitsPay              Fecha de pago
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************
  PROCEDURE GetPlanDifSale(inuFinancingPlan   in cc_sales_financ_cond.financing_plan_id%type,
                           dtRequestDate      in mo_packages.request_date%type,
                           onuComputeMethod   out cc_sales_financ_cond.compute_method_id%type,
                           onuInteresPercent  out cc_sales_financ_cond.interest_percent%type,
                           onuInterestRate    out cc_sales_financ_cond.interest_rate_id%type,
                           onuSpread          out cc_sales_financ_cond.spread%type,
                           onuPercentFin      out cc_sales_financ_cond.percent_to_finance%type,
                           sbDocumentSuppport out cc_sales_financ_cond.document_support%type,
                           dtFitsPay          out cc_sales_financ_cond.first_pay_date%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcDataPolicy
  Descripcion    : Se obtiene datos de la póliza para el trámite de cancelación.
  Autor          : kbaquero
  Fecha          : 04/10/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuPoli:         Número de la póliza
  osbname:         Nombre del asegurado
  onuidenti:       Numero de identificación del asegurado
  onucontr:        Aseguradora
  onuprodli:       Linea de Producto
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcDataPolicy(inuPoli   in ld_policy.policy_id%type,
                           osbname   Out ld_policy.name_insured%type,
                           onuidenti Out ld_policy.identification_id%type,
                           onucontr  Out ld_policy.contratist_code%type,
                           onuprodli Out ld_policy.product_line_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcDeffereadCreate
  Descripcion    : Creación de diferidos a partir del Número del producto
  Autor          : AAcuna
  Fecha          : 30/10/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
      inuPackage     Número del paquete
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcDeffereadCreate(inuPackage mo_packages.package_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValNumberPol
  Descripcion    : Validar el Número de póliza ingresado
  Autor          : AAcuna
  Fecha          : 20/12/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuPolicy:      Número de la póliza
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValNumberPol(inuPolicy in ld_policy.policy_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValContractorId
  Descripcion    : Validar que el contratista de la persona conectada
                   tiene configurada al menos un tipo de poliza asociada al contratista.
                   Retorna los siguientes valores:
                   (0) Sino encuentra el contratista dentro del tipo de poliza
                   (1) Si se encuentra el contratista dentro del tipo de poliza
  Autor          : AAcuna
  Fecha          : 07/05/2013 SAO 147879
  Parametros         Descripcion
  ============   ===================
  onuFlag_Val:       Flag_validate
  onuContractorId:   Contratista
  onuErrorCode:      Codigo de error
  osbErrorMessage:   Mensaje de error
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  07/05/2013     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcValContractorId(onuFlag_Val     out number,
                                onuContractorId out or_operating_unit.Contractor_Id%type,
                                onuErrorCode    out ge_message.message_id %type,
                                osbErrorMessage out ge_message.description%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValStateProdSal
  Descripcion    : Validar que el estado asociado al servicio de gas del contrato cumpla
                   con el parametro de estado de producto de venta de seguros llamado "COD_STATE_PROD_BYSALE",
                   Si la consulta que busca el servicio asociado al producto gas del contrato contiene que su
                   estado de producto es igual al parametro retorna (1) y puede abrir el tramite en caso
                   contrario mostrara mensaje de error y no dejara continuar con el proceso
  Autor          : AAcuna
  Fecha          : 10/05/2013 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:   : Numero del contrato
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  10/05/2013     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcValStateProdSal(inuSuscripc in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcIniCalcMeth
  Descripcion    : Inicializa el calculo de metodo del plan de financiacion para la venta
                   de seguros
  Autor          : AAcuna
  Fecha          : 15/03/2013 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuProductLine:   Numero de la linea de producto
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcIniCalcMeth(onuCompute_Method_Id out cc_sales_financ_cond.compute_method_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetUnitOperationa
  Descripcion    : Retorna 1 si la unidad operativa fue el mismo que realizo la venta y cancelación
  Autor          : AAcuna
  Fecha          : 18/10/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuPackage:      Número del paquete
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  FUNCTION GetUnitOperational(inuPackage in mo_packages.package_id%type)
    RETURN NUMBER;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetProductPolicy
  Descripcion    : Obtiene el producto a partir de la póliza
  Autor          : AAcuna
  Fecha          : 06/10/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuSuscripc:      Número del suscritor
  onuProduct:       Número del producto
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE GetProductPolicy(inuPolicy  in ld_policy.policy_id%type,
                             onuProduct out servsusc.sesunuse%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetCatSubBySuscripc
  Descripcion    : Obtiene la categoria y la subcategoria del contrato con producto
                   de gas activo.
  Autor          : AAcuna
  Fecha          : 23/10/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuSuscripc:      Número del contrato
  onuCategory:      Categoria del contrato
  onuSubcateg:      Subcategoria del contrato
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE GetCatSubBySuscripc(inuSuscripc in suscripc.susccodi%type,
                                onuCategory out categori.catecodi%type,
                                onuSubcateg out subcateg.sucacodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetLiquidationSecurevalue
  Descripcion    : Obtiene el valor  a liquidar a partir del Número de la orden
  Autor          : AAcuna
  Fecha          : 23/10/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuorder:      Número de la orden
  onuValue:      Valor del tipo de póliza
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************
  PROCEDURE GetLiquidationSecurevalue(inuorder in or_order.order_id%type,
                                      onuValue out ld_validity_policy_type.policy_value%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetPolicyCanBySusc
  Descripcion    : Retorna un dato mayor a cero si tiene una póliza asociada y en estado activa
                   sino retorna cero
  Autor          : AAcuna
  Fecha          : 02/11/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuSusc:       Identificador del contrato
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE GetPolicyCanBySusc(inuSusc in suscripc.susccodi%type);
  /*****************************************************************
   Propiedad intelectual de Open International Systems (c).
   Unidad         : GetSecureInitialValue
   Descripcion    : Devuelve el valor que debe tener la factura a partir del contrato.
   Autor          : AAcuña
   Fecha          : 29/08/2012 SAO 147879
   Parametros           Descripción
   ============     ===================
  inuSubscription:   Número del contrato
      onuValue:      Valor a imprimir
   Historia de Modificaciones
   Fecha            Autor       Modificación
   =========      =========  ====================
   ******************************************************************/
  PROCEDURE GetSecureInitialValue(inuSubscription in suscripc.susccodi%type,
                                  nuPremValue     out ld_validity_policy_type.share_value%type,
                                  inuRequestdate  in mo_packages.request_date%type default null);
  /*****************************************************************
    Propiedad intelectual de Open International Systems (c).
    Unidad         : GetValuePolicyType
    Descripcion    : Obtiene el valor a financiar y la cantidad de meses a diferir
    Autor          : AAcuña
    Fecha          : 29/08/2012 SAO 147879
    Parametros         Descripción
    ============   ===================
  inuPolicyType:     Código del tipo de póliza
       onuValue:     Valor a financiar
  onuCoverage_Month: Meses de covertura
    Historia de Modificaciones
    Fecha            Autor       Modificación
    =========      =========  ====================
    ******************************************************************/
  PROCEDURE GetValuePolicyType(inuPolicyType     in ld_policy_type.policy_type_id%type,
                               idtRequestDate    in mo_packages.request_date%type,
                               onuValue          out ld_validity_policy_type.share_value%type,
                               onuCoverage_Month out ld_validity_policy_type.coverage_month%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValuePolicy
  Descripcion    : Dependiendo el codigo del tipo de póliza obtiene el valor asociado a ese tipo de póliza
  Autor          : AAcuña
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuPolicyType:   Código de la póliza
  onuValuePolicy:  Cantidad de cedula por tipo de poliza que se encuentren vigentes.
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE GetValuePolicy(inuPolicyType  in ld_policy_type.policy_type_id%type,
                           idtRequestDate in mo_packages.request_date%type,
                           onuValuePolicy out ld_validity_policy_type.share_value%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetAddressBySusc
  Descripcion    : Se obtiene la dirección de contrato del suscritor
  Autor          : AAcuna
  Fecha          : 06/11/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuSuscripc:      Número del suscritor
  onuValue:         dirección
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE GetAddressBySusc(inuSuscripc in suscripc.susccodi%type,
                             onuValue    out ab_address.address_id%type,
                             onuGeo      out ge_geogra_location.geograp_location_id%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetAddressBySusc
  Descripcion    : Se obtiene la dirección de contrato del suscritor
  Autor          : AAcuna
  Fecha          : 00/10/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuSuscripc:      Número del suscritor
  onuValue:         dirección
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE GetAddress(inuSuscripc in suscripc.susccodi%type,
                       onuValue    out ab_address.address%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetPlanDifSale
  Descripcion    : Obtiene los datos a partir del plan de financiación para la venta de seguros
  Autor          : AAcuna
  Fecha          : 06/11/2012 SAO 147879
  Parametros              Descripción
  ============        ===================
  inuFinancingPlan:      Plan de financiación
  dtRequestDate:         Fecha de registro
  onuComputeMethod       Metodo de compute
  onuInteresPercent      Porcentaje de interes
  onuInterestRate        Rango de porcentaje
  onuSpread              Spread
  onuPercentFin          Porncentaje de financiación
  sbDocumentSuppport     Documento de soporte
  dtFitsPay              Fecha de pago
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE GetPlanDifSale(inuFinancingPlan   in cc_sales_financ_cond.financing_plan_id%type,
                           dtRequestDate      in mo_packages.request_date%type,
                           onuComputeMethod   out cc_sales_financ_cond.compute_method_id%type,
                           onuInteresPercent  out cc_sales_financ_cond.interest_percent%type,
                           onuInterestRate    out cc_sales_financ_cond.interest_rate_id%type,
                           onuSpread          out cc_sales_financ_cond.spread%type,
                           onuPercentFin      out cc_sales_financ_cond.percent_to_finance%type,
                           sbDocumentSuppport out cc_sales_financ_cond.document_support%type,
                           dtFitsPay          out cc_sales_financ_cond.first_pay_date%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetLiquidationSecurevalue
  Descripcion    : Obtiene el valor  a liquidar a partir del numero de la orden
  Autor          : KarBaq
  Fecha          : 23/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuorder:      Numero de la orden
  onuValue:      Valor del tipo de poliza
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  23/10/2012     KarBaq     Creacion
  27/08/2015     heiberb    Cambio 8540 Se modifica el metodo para que al momento de activar la estrategia
                            se calcule valor base de cobro de comision y este sea tomado para
                            la venta y cancelacion de la misma.
  ******************************************************************/
  PROCEDURE GetLiquidationSecurevalue(inuorder     in or_order.order_id%type,
                                      onuValue     out ld_validity_policy_type.policy_value%type,
                                      inuValueNota in number default 0);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : FnuValidateCanc
  Descripcion    : Retorna 1 si la cancelación viene por un tramite de siniestros o cancelación por archivo
                   plano y 0 si viene por una solicitud de cancelación
  Autor          : AAcuna
  Fecha          : 20/12/2012 SAO 147879
  Parametros         Descripción
  ============   ===================
  inuPackage:      Número del paquete
  Historia de Modificaciones
  Fecha            Autor       Modificación
  =========      =========  ====================
  ******************************************************************/
  FUNCTION FnuValidateCanc(inuPackage in mo_packages.package_id%type)
    RETURN NUMBER;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : UpdateStatePolicy
  Descripcion    : Cambia el estado de las polizas dependiendo el proceso de lanzamiento
                   Si el proceso es :
                   1. Cancelacion por archivo plano se le debe de enviar el tipo de proceso (3)
                   para que le cambie el valor del estado a 3 (Proceso de cancelacion por archivo plano)
                   2. Cancelacion por cartera se le debe de enviar el tipo de proceso (4)
                   para que le cambie el valor del estado a 4 (Proceso de anulacion por cartera)
                   3. Cancelacion por renovacion se le debe de enviar el tipo de proceso (4)
                   para que le cambie el valor del estado a 4 (Proceso de anulacion por cartera)
  Autor          : AAcuna
  Fecha          : 20/12/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPolicy:     Numero de la poliza
  inuProcess     Tipo de proceso:
                 (3) Cancelacion por archivo plano
                 (4) Cancelacion por cartera
                 (6) Cancelacion por siniestros
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE UpdateStatePolicy(inuPolicy  in ld_policy.policy_id%type,
                              inuProcess number);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : registerOrderReSale
  Descripcion    : Se crea y se asigna la orden de recuperacion de venta teniendo
                   en cuenta que se asigna la orden a la unidad operativa asociado al tipo de poliza
  Autor          : AAcuna
  Fecha          : 24/04/2013 05:55:27 p.m.
  Parametros              Descripcion
  ============            ===================
  inuPackage              Numero de solicitud
  onuOrderId              Numero de la orden
  onuOrderActivityRet     Numero de actividad de la orden retornada
  onuError                Numero de error
  osbMessage              Mensaje de error
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========         =========         ====================
  ******************************************************************/
  PROCEDURE registerOrderReSale(inuPackage          IN mo_packages.package_id%type,
                                onuOrderId          OUT or_order.order_id%TYPE,
                                onuOrderActivityRet OUT or_order_activity.order_activity_id%TYPE,
                                onuError            OUT number,
                                osbMessage          OUT varchar2);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : RC_ApplyOSICoupon
  Descripcion    : Se realiza la venta de seguros de doble cupon
  Autor          : Kbaquero
  Fecha          : 22/06/2013 08:55:27 p.m.
  Parametros              Descripcion
  ============            ===================
  inuCoupon               Identificador del cupon
  onuError                Numero de error
  osbMessage              Mensaje de error
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========         =========         ====================
  ******************************************************************/
  PROCEDURE RC_ApplyOSICoupon(inuCoupon   in cupon.cuponume%type,
                              onuvalue    in ld_validity_policy_type.share_value%type,
                              onupolitype in ld_policy_type.policy_type_id%type,
                              onuadd      in ab_address.address%type,
                              onuError    OUT number,
                              osbMessage  OUT varchar2);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValuepolitypesusc
  Descripcion    : Se busca el valor de la poliza y el tipo de poliza al que pertenece
                   Para asi enviarsela a el cupon
  Autor          : KBaquero
  Fecha          : 23/06/2013 10:38:27 a.m.
  Parametros              Descripcion
  ============            ===================
  inususc               Numero de suscriptor
  onuvalue              Valor del tipo de poliza
  onupolitype           Id. del tipo de poliza
  onuError              Numero de error
  osbMessage            Mensaje de error
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========         =========         ====================
  ******************************************************************/
  PROCEDURE GetValuepolitypesusc(inususc      IN suscripc.susccodi%type,
                                 onupremValue OUT ld_validity_policy_type.share_value%type,
                                 onupolitype  OUT ld_policy_type.policy_type_id%type,
                                 onuadd       out ab_address.address%type,
                                 onuError     OUT number,
                                 osbMessage   OUT varchar2);
  /*****************************************************************
   Propiedad intelectual de Open International Systems (c).
   Unidad         : ProcValidateProductparam
   Descripcion    : Valida que el contrato tenga gas activo
   Autor          : Aacuna
   Fecha          : 09/07/2013 SAO 147879
   Parametros               Descripcion
   ============         ===================
  inuSubscriptionId:     Identificador del contrato
   Historia de Modificaciones
   Fecha         Autor      Modificacion
   =========   ========= ====================
   28/09/2012  AAcuna    Creacion
   ******************************************************************/
  PROCEDURE ProcValidateProductparam(inuSubscriptionId in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ValidateProdEstacort
  Descripcion    : Valida que el contrato tenga gas en los estado
                   de corte permitido
  ******************************************************************/
  PROCEDURE ValidateProdEstacort(inuSubscriptionId in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcGetPackagesByContract
  Descripcion    : Valida si existen solicitudes para la cancelacion
                   de Seguros en estado registrado
  Autor          : jrobayo
  Fecha          : 31/08/2013 SAO 147879
  Parametros               Descripcion
  ============         ===================
  inuSusccodi:     Codigo del contrato
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========   =========           ====================
  31/08/2013  jrobayo.SAO213977   Creacion
  ******************************************************************/
  PROCEDURE ProcGetPackagesByContract(inuSusccodi IN suscripc.susccodi%TYPE);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetAddressFromSinister
  Descripcion    : Obtiene la direccion parseada y la ubicacion
                   geografica de ab_address para el reporte de siniestros
  Autor          : Jorge Alejandro Carmona Duque
  Fecha          : 24/10/2013
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:        Numero del suscritor
  inuProductTypeId:   Tipo de Producto Registrado
  onuAddress:         Direccion Parseada
  onuParserAddress:   Identificador de la direccion
  onuGeo:             Ubicacion Geografica
  Historia de Modificaciones
  Fecha            Autor                  Modificacion
  =========       =========               ====================
  24-10-2013      JCarmona.SAO221126      Creacion.
  ******************************************************************/
  PROCEDURE GetAddressFromSinister(inuSuscripc      in suscripc.susccodi%type,
                                   inuProductTypeId in mo_motive.product_type_id%type,
                                   onuAddress       out mo_address.address%type,
                                   onuParserAddress out mo_address.parser_address_id%type,
                                   onuGeograpLoc    out mo_address.geograp_location_id%type);
  PROCEDURE cancelPolicyByAge;
  FUNCTION fdtGetEndDatePeriod(inuProductId in servsusc.sesunuse%type)
    return date;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fboGetIsNumber
  Descripcion    : Valida si un variable esta compuesta unicamente de
                   caracteres numericos
  Autor          : Manuel Fernando Garcia
  Fecha          : 31/08/2014
  Parametros         Descripcion
  ============   ===================
  isbValue:      Variable a validar
  Historia de Modificaciones
  Fecha            Autor                  Modificacion
  =========       =========               ====================
  31-08-2015      MGarcia.SAO334174      Creacion.
  ******************************************************************/
  FUNCTION fboGetIsNumber(isbValue VARCHAR2) RETURN BOOLEAN;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : proccantpolicontexq
  Descripcion    : Valida que no se debe permitir tener mas de n polizas vigentes exequiales
                    por contrato.
  Autor          : KBaquero
  Fecha          :  17/02/2017 caso 200-1106
  Parametros          Descripcion
  ============     ==================
  inuSuscripc    : Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  17/02/2017     KBaquero    Creacion
  ******************************************************************/
  PROCEDURE proccantpolicontexq(inuSuscripc in suscripc.susccodi%type);
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetLiquidationSecurevaluerenew
  Descripcion    : Obtiene el valor  a liquidar a partir del numero de la orden
  Autor          : KBaquero - JMGestion informatica
  Fecha          : 20/02/2017 caso 200-1054
  Parametros         Descripcion
  ============   ===================
  inuorder:      Numero de la orden
  onuValue:      Valor del tipo de poliza
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  20/02/2017  KBaquero            Creacion
  ******************************************************************/
  PROCEDURE GetLiquidationSecurevaluerenew(inuorder     in or_order.order_id%type,
                                           onuValue     out ld_validity_policy_type.policy_value%type,
                                           inuValueNota in number default 0);
   /**************************************************************
    Unidad      :  LDC_VALPRODMIGANULDIFE
    Descripcion :  CASO 539: Este proceso se encarga de realizar las configuraciones a la cuenta corriente
				   despues de haberse hecho la anulacion de diferido y de haberse consultado si la poliza a
				   cancelar esta en la tabla de migracion LDC_MIGRAPOLIZA, lo que hace es dejar el valor de
				   la deuda corriente con el valor anterior que tenia antes de la anulacion y lo mismo con el
				   saldo a favor, ademas que crea la nota de credito a la cuenta de cobro generada de la anulacion
				   del diferido.
    Parametros  :  inuProduct   		-- Codigo del producto
                   inuContrato  		-- Codigo del contrato
				   inuDeudaCorriente	-- valor de la deuda corriente
				   inuCodigoDiferido	-- codigo del diferido
				   inuSaldoFavor		-- saldo a favor del producto
    Autor	       : Miguel Ballesteros
    Fecha	       : 13/11/2020
    Historia de Modificaciones
    Fecha        Autor                  Modificacion
    =========    =========              ====================
    ***************************************************************/
	PROCEDURE LDC_VALPRODMIGANULDIFE(	inuProduct   			in servsusc.sesunuse%type,
										inuContrato  			in suscripc.susccodi%type,
										inuDeudaCorriente		in number,
										inuCodigoDiferido		in diferido.difecodi%type,
										inuDeudaDiferida		in diferido.difesape%type,
										inuSaldoFavor			in number,
										inuPackage				in mo_packages.package_id%type);



	/**************************************************************
    Unidad      :  FNUGETSALPENPOL
    Descripcion :  CASO 651: funcion que devuelve el valor acreditado de una poliza




    Parametros  :  inuDiferido   	    -- Codigo del diferido
                   inuproducto  		-- Codigo del producto


    Autor	       : Olsoftware
    Fecha	       : 19/02/2021

    Historia de Modificaciones
    Fecha        Autor                  Modificacion
    =========    =========              ====================
    ***************************************************************/
    FUNCTION FNUGETSALPENPOL ( inuDiferido IN NUMBER,
							 inuproducto IN NUMBER) RETURN NUMBER;


	/**************************************************************
    Unidad      :  LDC_VALRETIROPRODUCTO
    Descripcion :  CASO 718: Este proceso se encarga de validar si el producto tiene deudas o alivios de covid
				   y asi no retirar el producto, de lo contrario se retira el producto



    Parametros  :  inuProduct   		-- Codigo del producto



    Autor	       : Olsoftware
    Fecha	       : 27/02/2021

    Historia de Modificaciones
    Fecha        Autor                  Modificacion
    =========    =========              ====================
    ***************************************************************/

  PROCEDURE LDC_VALRETIROPRODUCTO( inuProduct   		in servsusc.sesunuse%type,
									inuPackage			in mo_packages.package_id%type);

END Ld_BoSecureManagement;
/

create or replace PACKAGE BODY      ld_bosecuremanagement IS
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : Ld_BoSecureManagement
  Descripcion    : Paquete BO con las funciones y/o procedimientos que contendrá la gestión de seguros.
  Autor          : AAcuña
  Fecha          : 14/08/2012 SAO 147879
  Metodos
  Nombre         :
  Parametros         Descripcion
  ============   ===================
  Historia de Modificaciones
  Fecha         Autor                   Modificacion
  =========     =========               ====================
  27/02/2021	Olsoftware.caso:718     Se Agrega validacion con la nueva causal 208 - CANCELACION POR JOB/ FACTURAS VENCIDAS
										el cual valida si al momento de realizar la cancelacion de seguros (ProcCancelPolicy) se escoge
										la causal 208 el sistema solo anulará la deuda diferida que tenga ese producto, dejará vigente
										la deuda corriente y la deuda que tenga el producto en diferidos de Alivios COVID.

										Ademas tambien validará si despues del proceso de cancelacion de seguros (ProcCancelPolicy) si el
										producto llega a tener deuda de covid o deuda corriente y/i diferida, dejará el producto activo
										para que pueda seguir facturando
  08/06/2017    KBaquero.caso 200-1225  se modifica <<GetLiquidationSecurevalue>>
                                           <<GetLiquidationSecurevaluerenew>>
                                           <<fnuGetFirstValueByCon>>
  10/05/2017    KBaquero.caso 100-35955 Se modifica <<ProcSaleByFile>>
  28/02/2017    KBaquero.caso 200-1121  Se modifica <<GetLiquidationSecurevaluerenew>>
                                        Se modifica <<GetLiquidationSecurevalue>>
  20/02/2017    KBaquero CA 200-1054    Se modifica el proceso <<procrenew>>
                                        Se adiciona <GetLiquidationSecurevaluerenew>
  17/02/2017    KBaquero CA 200-1106    Se modifica el metodo <<ProcSaleByFile>>
                                        Se adiciona <proccantpolicontexq>
  21-12-2016    FCastro CA 200-336      Se modifica el metodo <<ProcCancelPolicy>> para que si la causal
                                        de anulacion es por edad cree la nota CR por el valor del saldo
                                        pendiente de la poliza (diferido y corriente) y no genere saldo
                                        a favor al usuario por las cuotas canceladas
    22-10-2016    KBaquero CA 200-746   Se modifica el metodo <<ProcCancelPolicy>>
    22-06-2016    AAcuna.SS_100_10068   Se modifica el metodo <<fdtGetEndDatePeriod>>
    12/02/2016    AAcuna SS_100-8096    Se modificara el proceso de renovación de seguros con el fin de evitar que a la hora de ejecución del proceso
                                        no se encuentren productos  que se encuentren en proceso de facturación (cargos con cuenta de cobro -1).
    17-09-2015    Llozada [ARA 8740]    Se modifica el metodo <<ProcSaleByFile>>
    07/07/2015    mgarcia.SAO334174     Se modifican los metodos
                                        <ProcSaleByFile><ProcValNumberPol>
                                        <ProcValPolyCont><ProcValidateShare>
                                        <ValidateCreateVisit>
                                        Se crea la funcion <fboGetIsNumber>
    24-06-2015    KCienfuegos.ARA7920   Se modifica el metodo <<fdtGetEndDatePeriod>>
    21-04-2015    KCienfuegos.SAO310516 Se modifica el metodo <<ProcRenew>>
    01-04-2015    Llozada NC 4038       Se modifica el metodo <<ProcCancelPolicy>>
    24-02-2015    Llozada NC 4038       Se modifica el metodo <<ProcCancelPolicy>>
    28-01-2015    ggamarra Cambio 6005  Se modifica el metodo <<ProcDeffereadCreate>>
    21-01-2015    Llozada NC 4038       Se modifica el metodo <<ProcCancelPolicy>>
    15-12-2014    Llozada NC 4230       Se modifica el metodo <<ProcDeffereadCreate>>
    15-12-2014    Llozada NC 4230       Se modifica el metodo <<ProcSaleCreate>>
    14-10-2014    Llozada RQ 1217       Se modifica el metodo <<CreateNoteCR>>
    14-10-2014    Llozada RQ 1217       Se modifica el metodo <<ProcCancelPolicy>>
    08-10-2014    llarrarte.RQ2172      Se modifica <fnuGetCollectiveNumber>
                                        Se adiciona <cancelPolicyByAge>
                                                    <fdtGetEndDatePeriod>
                                                    <CancelPoliciesByNoRenew>
    05-10-2014    Llozada RQ 1217       Se modifica el metodo <<ProcCancelPolicy>>
    30-09-2014    llarrarte.RQ1834      Se crea <fnuGetCollectiveNumber>
                                        Se modifica <ProcRenew>
                                                    <ProcCancelPolicy>
    26-09-2014    llarrarte.RQ1719      Se modifican <ProcSaleCreate>
                                                     <ProcDeffereadCreate>
                                                     <ProcRenew>
    16-09-2014    llarrarte.RQ1178      Se adiciona <valPolicyAmount>
                                        Se modifica <ProcRenew>
                                        Se modifica <ProcSaleCreate>
    05-09-2014    AEcheverry.4769       Se modifican los servicios
                                        <<CommitFinanc.GenerateDiscountNotes>>
                                        y <<CreateNoteCR>>
    01/09/2014    KCienfuegos.NC962     Se modifica metodo <<ProcDeffereadCreate>>
    28/08/2014    KCienfuegos.NC1177    Se modifica metodo <<Procsalebyfile>>
    08/08/2014    AEcheverry.4152       se modifican los metodos
                                            <<ProcDeffereadCreate>>
                                            <<ProcSaleCreate>> y
                                            <<ProcRenew>>
    04/08/2014    KCienfuegos.NC1079    Se modifica el metodo <<Procsalebyfile>>
    18/07/2014    KCienfuegos.RNP550    Se modifica el metodo <<ProcRenew>>
    17/07/2014    KCienfuegos.NC606     Se crea el metodo <<ProcValidateShare>>
    01/07/2014    AEcheverry.4031       se modifican los metodos
                                            <<ProcRenew>> y <<ProcDeffereadCreate>>
    27/06/2014    aesguerra.4029    Se modifica el metodo <<ProcRenew>>
    29/04/2014    JCarmona.3504         Se modifica el metodo <<ValSubscAndProd>>
    14/04/2014    JCarmona.3404           Se modifica el metodo <<ProcCancel>>
    01/04/2014    AEcheverrySAO236799     se modifican los metodos
                                            <<ProcCancelPolByJob>> y <<ProcRenew>>
    03-03-2014    hjgomez.SAO234504       Se modifica <<ProcRenew>>, <<ProcSaleCreate>>
    12-02-2014    AEcheverrySAO232542     se modifica <<ProcCancelPolicy>>
    29-01-2014    AEcheverrySAO231292     Se modifica <<ProcCancelByFile>> <<ProcCancelPolByJob>>
    22/12/2013    JCarmona.SAO227979      Se modifica el metodo <ProcDeffereadCreate>
    21-12-2013    jrobayo.SAO228441       Se modifica para enviar el valor correpondiente
                                        a la poliza para su vigencia actual.
    19-12-2013    lfernandez.SAO227670    <CreateNoteCR> Se modifica para que no
                                        cree una sola nota en una cuenta del
                                        producto del seguro sino una nota por
                                        cada cuenta con saldo del producto
    19-12-2013    lfernandez.SAO228280    <CreateNoteCR> Si el valor de la nota a
                                        crear es mayor al saldo del producto del
                                        seguro se crea una nota por el saldo del
                                        seguro para el producto del seguro y el
                                        resto va para el producto de gas
    17-12-2013     JCarmona.SAO227834      Se modifica el metodo <ProcRenew>
    13-12-2013     JCarmona.SAO227561      Se modifica el metodo <RC_ApplyOSICoupon>
    11-12-2013     hjgomez.SAO227078      Se modifica <<ProcCancelPolicy>>
    27/11/2013     JCarmona.SAO224868     Se modifican metodos <ProcSaleCreate> y
                                        <ProcRenew>    ProcDeffereadCreate
    27-11-2013     hjgomez.SAO224982      Se modifica <GetSecureInitialValue>
    26-11-2013     jrobayo.SAO224855      Se modifica el metodo <CreateNoteCR>
    22-11-2013     hjgomez.SAO224511      Se modifica <GetSecureInitialValue>
    20/09/2013     mmira.SAO217497        Se modifica el metodo <ProcSaleCreate>
    19/09/2013     mmira.SAO217284        Se modifica el metodo <ValidateProdEstacort>.
    09/09/2013     jcarrillo.SAO214516    Se modifica el metodo:
                                            <GetValueCancelBySubsc>
    07/09/2013    jrobayo.SAO216575       Se modifica el metodo
                                        <ProcRenew>
    07/09/2013     mmeusburgger.SAO214427 Se modifica el metodo:
                                         - <<GetSecureInitialValue>>
    07/09/2013     jcarrillo.SAO213279    Se modifica el metodos:
                                            <ProcCancelByFile>
                                        Se adiciona el metodo
                                            <ValidateDataCancel>
    06/09/2013     jcarrillo.SAO214516 Se modifica el metodo:
                                            <ProcCancelPolicy>
                                        Se adicionan los metodos:
                                            <TraslateDefer><CreateNoteCR>
                                            <GetValueCancelByAge>
                                            <GetValueCancelByContr>
                                            <GetValueCancelBySubsc>
    06/09/2013     mmeusburgger.SAO214427 Se modifica
                                        - <<GetSecureInitialValue>>
                                        - <<ProcCancelByFile>>
    06/09/2013     jrobayo.SAO214416      Se modifica el metodo
                                        <ProcSaleByFile>
    06/09/2013     jcarrillo.SAO213248    Se modifica el metodo:
                                            <ProcCancelByFile>
    05/09/2013     mmeusburgger.SAO213104 Se modifica
                                        - <<ProcSaleByFile>>
                                        - <<GetSecureInitialValue>>
                                        - <<RC_ApplyOSICoupon>>
    04/09/2013     jrobayo.SAO216330      Se adiciona el metodo
                                        <ProcUpdBirth>
    04/09/2013     jrobayo.SAO216330      Se modifica el metodo
                                        <ProcSaleCreate>
    04/09/2013     jcarrillo.SAO214549    Se modifica el metodo
                                        <ProcValNumberPol>
    04/09/2013     mmeusburgger.SAO213279 Se modifica
                                        - <<ProcCancelByFile>>
    04/09/2013     jrobayo.SAO213381      Se modifica el metodo
                                        <<ProcSaleByFile>>
    04/09/2013     mmeusburgger.SAO214427 Se Modifica
                                        - <<RC_ApplyOSICoupon>>
                                        - <<GetSecureInitialValue>>
    03/09/2013     mmeusburgger.SAO214423 Se modifica
                                        - <<ProcCancelPolicy>>
                                        - <<GetSecureInitialValue>>
    03/09/2013     jcarrillo.SAO212983    Se adiciona el metodo:
                                        <fsbGetExequial>
                                        Se modifican los metodos:
                                        <ProcSaleCreate><ProcRenew>
    03/09/2013     jcarrillo.SAO214425    Se modifican los metodos:
                                        <ProcDeffereadCreate><ProcRenew>
    03/09/2013     jcarrillo.SAO214416    Se adiciona el metodo:
                                        <ValidateProdEstacort>
                                        Se modifica el metodo:
                                        <ProcSaleByFile>
    02/09/2013     jcarrillo.SAO211267    ValidateProdEstacort
                                        <fnuGetActivityVisit><ValidateCreateVisit>
                                        Se modifica el metodo: <ProcSaleByFile>
    02/09/2013     jrobayo.SAO213977      Se crea el metodo ProcGetPackagesByContract
    31/08/2013     jcarrillo.SAO213976    Se modifican los metodos:
                                        <ProcSaleCreate><ProcDeffereadCreate>
    30/08/2013     jcarrillo.SAO213276    Se elimina el metodo <ProcValProductLine>
                                        Se adicionan los metodos:
                                            <fsbGetValueParameter>
                                            <fnuGetFirstValueByCon>
    29/08/2013     jcarrillo.SAO214742    Se modifica el metodo <ProcSaleCreate>
    29/08/2013     jcarrillo.SAO213191    Se elimina el metodo <ProcValidateProduct>
    27/08/2013     jcarrillo.SAO214426    Se modifican los metodos:
                                        <ProcSaleCreate><ProcSaleByFile>
                                        <ProcDeffereadCreate><ProcRenew>
                                        <GetLiquidationSecurevalue><GetValuePolicyType>
                                        <GetValuepolitypesusc><RC_ApplyOSICoupon>
    14/08/2013     hvera.SAO213138        Se modifica el metodo <ProcCancelPolicy>
  ******************************************************************/
  -- Declaracion de variables y tipos globales privados del paquete
  -- Definicion de metodos publicos y privados del paquete
  -- Constante con el SAO de la ultima version aplicada
  csbVERSION CONSTANT VARCHAR2(10) := 'OSF-2822';
  csbPIPE CONSTANT VARCHAR2(10) := ge_boconstants.csbPIPE;

  csbNOMPKG    	CONSTANT VARCHAR2(35):= $$PLSQL_UNIT||'.'; -- Constantes para el control de la traza
  nuCodMenErro  NUMBER;
  sbMensaError  ge_message.description%type;
  csbPrefMerr    varchar2(10) := 'Error: ';

  sbdataorder   VARCHAR2 (2000);

  -- Verifica si se genero estado de cuenta
  boAccountStGenerado boolean;
  sbErrMsg varchar2(2000); -- Mensajes de Error
  -- Record del servicio suscrito current
  rcSeSuCurr servsusc%rowtype;
  -- Record del periodo de facturacion current
  rcPerifactCurr perifact%rowtype;
  -- Programa
  sbApplication varchar2(10);
  -- Verifica si se genero la cuenta
  boCuentaGenerada boolean;
  sbTerminal       factura.factterm%type;
  gnuCouponPayment pagos.pagocupo%type; -- Cupon de Pago
  -- Tipo de documento
  gnuTipoDocumento ge_document_type.document_type_id%type;
  -- Fecha contable del periodo contable current
  dtFechaContable date;
  dtFechaCurrent date;
  -- Nombre del programa ejecutor Generate Invoice
  csbPROGRAMA constant varchar2(4) := 'GINV';
  -- Valores facturados cuenta por servicio
  nuVlrFactCta    cuencobr.cucovafa%type;
  nuVlrIvaFactCta cuencobr.cucoimfa%type;
  -- Record de la suscripcion current
  rcSuscCurr suscripc%rowtype;
  -- Numero del estado de cuenta current
  nuEstadoCuenta factura.factcodi%type;
  -- Numero de la cuenta de cobro current
  nuCuenta cuencobr.cucocodi%type;
  -- Codigo del contrato
  nuSuscriptor suscripc.susccodi%type := -1;
  -- Fecha de generacion de las cuentas
  dtFechaGene  date;
  grcEstadoCta factura%rowtype; -- Global de la factura generada
  -- Valores facturados de la factura
  nuVlrFactFac    pkbcfactura.styfactvafa;
  nuVlrIvaFactFac pkbcfactura.styfactivfa;
  -- Variables de valores de cartera actualizados despues de realizar
  -- una actualizacion
  nuCart_ValorCta cuencobr.cucovato%type; -- Valor cuenta
  nuCart_AbonoCta cuencobr.cucovaab%type; -- Abonos cuenta
  nuCart_SaldoCta cuencobr.cucosacu%type; -- Saldo cuenta
  -- Saldo pendiente de la factura
  nuSaldoFac pkbcfactura.styfactspfa;
  -- Concepto de ajuste
  nuConcAjuste concepto.conccodi%type;
  -- Concepto de pago
  nuConcPago concepto.conccodi%type;
  ------------------
  -- Tipos de Datos
  ------------------
  -- Tabla de Estados de cuenta
  TYPE tytbCargfact IS TABLE OF cuencobr.cucofact%type INDEX BY binary_integer;
  tbCargfact tytbCargfact;
  -- Tabla de cuentas de cobro
  TYPE tytbCargcuco IS TABLE OF cargos.cargcuco%type INDEX BY binary_integer;
  tbCargcuco tytbCargcuco;
  -- Tabla de fechas contables
  TYPE tytbCargfeco IS TABLE OF pkbccargos.stycargfeco INDEX BY binary_integer;
  tbCargfeco tytbCargfeco;
  -- Tabla de documentos de soporte
  TYPE tytbCargdoso IS TABLE OF cargos.cargdoso%type INDEX BY binary_integer;
  tbCargdoso tytbCargdoso;
  -- Tabla de documentos de soporte
  TYPE tytbCargtipr IS TABLE OF cargos.cargtipr%type INDEX BY binary_integer;
  tbCargtipr tytbCargtipr;
  -- Tabla de rowids de los cargos
  TYPE tytbRowid IS TABLE OF rowid INDEX BY binary_integer;
  tbRowid tytbRowid;
  --------------------------------
  -- Movimientos de Pagos       --
  --------------------------------
  TYPE tyrcCargos IS RECORD(
    sbRowid  rowid,
    cargconc cargos.cargconc%type,
    cargcaca cargos.cargcaca%type,
    cargsign cargos.cargsign%type,
    cargdoso cargos.cargdoso%type,
    cargvalo cargos.cargvalo%type,
    cargfecr cargos.cargfecr%type,
    cargnuse cargos.cargnuse%type,
    cargpeco cargos.cargpeco%type);
  TYPE tytbCargos IS TABLE OF tyrcCargos INDEX BY BINARY_INTEGER;
  TYPE tyrcMaxPericosePorConcepto IS RECORD(
    rcPeriodoConsumo pericose%rowtype,
    dtFechaUltLiq    feullico.felifeul%type,
    sbTipoCobro      concepto.concticc%type);
  TYPE tytbMaxPericoseConcepto IS TABLE OF tyrcMaxPericosePorConcepto INDEX BY BINARY_INTEGER;
  -- CAMBIO 3504
  /**************************************************************/
  TYPE tyrcCuenta IS RECORD(
    cucocodi   cuencobr.cucocodi%type,
    cuconuse   cuencobr.cuconuse%type,
    cucosacu   cuencobr.cucosacu%type,
    cucofact   cuencobr.cucofact%type,
    sbCancAjus cargos.cargsign%type,
    nuCancVlrA cargos.cargvalo%type,
    sbAjuste   cargos.cargsign%type,
    nuAjuste   cargos.cargvalo%type);
  TYPE tyCuenta IS TABLE OF tyrcCuenta INDEX BY VARCHAR(20);
  tbCuenta tyCuenta;
  -- Definicion de tabla de memoria de movimientos de diferido
  type tyMovidife is table of movidife%rowtype index by binary_integer;
  -- Arreglos de memoria
  tbModi tyMovidife; -- Arreglo de Movidife
  -- Tipo para de conceptos de financiacion del impuesto
  type tyrcNoteFact IS record(
    nuNotaNume notas.notanume%type,
    sbNotaDoso notas.notadoso%type);
  type tyNotas is table of tyrcNoteFact index by varchar2(20);
  tbNoteSesu tyNotas;
  nugSimulate varchar2(1); -- Modo simulacion de financiacion (S|N)
  -- Acumuladores de cuotas extras por numero de cuota
  type tytbAcumExtraPay IS table of number index BY binary_integer;
  tbgAcumExtraPay tytbAcumExtraPay;
  -- Acumulador de cuotas extras para cambio de condiciones.
  tbgAcumExtraPay1 tytbAcumExtraPay;
  -- Colecciones para simulacion y/o creacion de financiaciones
  tbgDeferred      mo_tytbdeferred;
  tbgExtraPayments mo_tytbextrapayments;
  tbgCharges       mo_tytbCharges;
  tbgQuotaSimulate mo_tytbQuotaSimulate;
  nuIdxDife number; -- Indice de tabla de diferidos
  nuIdxCarg number; -- Indice tabla de cargos
  nuIdxExtr number; -- Indice de tabla Cuotras Extras
  gblValToFinGreaterZero boolean;
  nugVlrFinIva diferido.difevatd%type;
  -- Valor cargos del total de financiacion tomado de saldos por concepto
  nugVlrFinCargos diferido.difevatd%type;
  -- Valor componente IVA de los cargos del total de financiacion tomado
  -- de saldos por concepto
  nugVlrFinIVACargos diferido.difevatd%type;
  -- Valores totales para la financiacion
  nugVlrFinanciable cc_tmp_bal_by_conc.financing_balance%type;
  -- Valor total financiacion aplicado el porcentaje a financiar
  nugVlrFinTotal diferido.difevatd%type;
  -- Acumulador de diferidos financiados para toda la financiacion
  nugAcumFinancing number;
  nugAcumChCond    number;
  -- Suscripcion en proceso
  nugSubscription suscripc.susccodi%type;
  nugFinanCode diferido.difecofi%type;
  -- Valor financiable por producto
  nugFinancingBalance cc_tmp_bal_by_conc.financing_balance%type;
  nugNumCuotaExt cuotextr.cuexnume%type; -- Numero de Cuota extras
  nugTotCuotaExt cuotextr.cuexvalo%type; -- Total de Cuota extras
  ----------------------------------------------------------------------------
  -- Variables migradas de pkfinancing
  ----------------------------------------------------------------------------
  nugAcumCuota   number; -- Acumulador Cuota
  nugMetodo      diferido.difemeca%type; -- Metodo Cuota
  nugPlan        diferido.difepldi%type; -- Plan del Diferido
  dtgFecha       diferido.difefein%type; -- Fecha diferido
  nugSpread      diferido.difespre%type; -- valor del Spread
  nugPorcInteres diferido.difeinte%type; -- Interes Efectivo
  dtgProceso     diferido.difefein%type; -- Fecha proceso
  -- Estructura en la que el cliente .net registra las cuotas extras
  tbExtraPayment cc_bcfinancing.tytbExtraPayment;
  -- Concepto de ajuste
  gnuConcAjuste concepto.conccodi%type;
  blgFinanciarIVA     boolean; -- Flag de Financiar IVA
  blgInteSobreIvaFina boolean; -- Flag Interes sobre IVA Finan.
  nugSuscripcion suscripc.susccodi%type; -- Codigo suscripcion
  nugVlrDeuda pkbcservsusc.stysesusape; -- Deuda del Servicio Suscrito
  nugCiclo    ciclo.ciclcodi%type; -- Codigo Ciclo Facturacion
  nugAno      perifact.pefaano%type; -- Ano periodo current
  nugMes      perifact.pefames%type; -- Mes periodo current
  nugPeriodo  perifact.pefacodi%type; -- Periodo current
  nugTasaInte diferido.difetain%type; -- Codigo Tasa Interes
  blgParamLoaded boolean := FALSE;
  -- Empresa del funcionario
  nugFunctionaryEnterprise sistema.sistcodi%type;
  --Token de diferido para cuota capital
  sbTokenDF varchar2(3);
  --Token para cargo que disminuye la cartera corriente
  sbTokenFD varchar2(3);
  --Token para cargo de descuento por acuerdo de pago
  sbTokenAP varchar2(3);
  --Token diferido cuota extra
  sbTokenCX varchar2(3);
  gnuFinDebtPckTypId    ps_package_type.package_type_id%type;
  gnuChCondDebtPckTypId ps_package_type.package_type_id%type;
  -- Tag Name para tipo de paquete financiacion de deuda
  csbP_FINANCING_DEBT constant varchar2(30) := 'P_FINANCING_DEBT';
  -- Tag Name para tipo de paquete cambio de condiciones de financiacion
  csbP_CHANGE_COND_DEBT constant varchar2(30) := 'P_CHANGE_COND_DEBT';
  -- Constante Programa de financiacion de la entidad diferidos
  csbFINANCING_PROGRAM constant varchar2(30) := 'FINAN';
  -- correspondiente a solicitud de financiacion de deuda
  cnuNOTEXISTFINPACKTYPE constant number(6) := 116120;
  -- Maximo numero de Financiaciones incumplidas para bloqueo.
  gnuFinIncumpParaBloqueo NUMBER;
  nugPorIntNominal diferido.difeinte%type; -- Interes Nominal
  nugFactor        diferido.difefagr%type; -- Factor Gradiente
  -- Porcentaje de Mora segun el plan de financiacion
  nugPorcMora plandife.pldiprmo%type;
  -- Error en el porcentaje de mora configurado para el plan %s1
  cnuBadOverChargePercent constant number(6) := 120782;
  cnuSALDO_NEGATIVO_SERV constant number(5) := 12503;
  cnuSALDO_NEGATIVO constant number(5) := 12504;
  nugCuenta  cuencobr.cucocodi%type; -- Numero cuenta
  nugNumServ servsusc.sesunuse%type; -- Numero servicio
  csbYes constant varchar2(1) := 'Y';
  csbNo  constant varchar2(1) := 'N';
  sbgUser     varchar2(50); -- Nombre usuario
  sbgTerminal varchar2(50); -- Terminal
  gnuPersonId ge_person.person_id%type; -- Id de la persona
  sbTipoDiferido varchar2(1) := 'D'; -- OJO Crear parametro o utilizar
  -- uno ya existente
  -- Error en la configuracion normal de cuotas
  cnuERROR_CUOTA constant number(6) := 10381;
  csbERROR_CUOTA CONSTANT VARCHAR2(100) := 'El valor de la cuota extra es mayor al valor a financiar';
  -- Valores absolutos de diferencia de totales menores a este valor
  -- podran ser ajustados.
  cnuValorTopeAjuste constant number := 1;
  --  Variable para el valor total de los diferidos
  gnuTotalValue number;
  cnuONE constant number := LD_BOConstans.cnuonenumber;
  -- Constantes Signos
  cnuZERO       constant number := pkBillConst.CERO;
  -- Excepcion de Financiaciones
  cnuFinancingException constant number(6) := 114305;
  /**************************************************************************/
  PROCEDURE GenerateBySuppDoc(inuSubscription    IN suscripc.susccodi%type,
                              inuServNumber      IN servsusc.sesunuse%type,
                              isbDocumentSupport IN cargos.cargdoso%type,
                              onuInvoice         OUT factura.factcodi%type,
                              onuAccount         OUT cuencobr.cucocodi%type,
                              onuBalanceInvoice  OUT pkbcfactura.styfactspfa,
                              onuErrorCode       OUT GE_ERROR_LOG.ERROR_LOG_ID%TYPE,
                              osbErrorMessage    OUT GE_ERROR_LOG.DESCRIPTION%TYPE);

  /*****************************************************************
  Propiedad intelectual de Open International Systems.(c).
  Procedure      :  fnugetprod
  Descripcion    :  Obtiene el producto de gas desde un contrato
  Parametros     :  Descripcion
  Retorno        :
  nuproduct        Id. Producto
  Autor          :  Kbaquero
  Fecha          :  13/05/2017  Caso 100-35955
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  *****************************************************************/
  FUNCTION fnugetprod(nucontra   suscripc.susccodi%type,
                      nuprodtype pr_product.product_type_id%type)
    RETURN number IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnugetprod'; --Nombre del método en la traza
    nuproduct pr_product.product_id%type;
    cursor cuproduct is
    select p.product_id
      from pr_product p
     where p.subscription_id = nucontra
       and p.product_type_id = nuprodtype;
    -- Retorna el numero del producto
  BEGIN
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      open cuproduct;
           fetch cuproduct into nuproduct;
      close cuproduct;
      -- Retorna el numero del producto
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      RETURN(nuproduct);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fnugetprod;

  /*****************************************************************
  Propiedad intelectual de Open International Systems.(c).
  Procedure      :  fsbVersion
  Descripcion    :  Obtiene la Version actual del Paquete
  Parametros     :  Descripcion
  Retorno        :
  csbVersion        Version del Paquete
  Autor          :  AAcuna
  Fecha          :  20/09/2012 SAO 147879
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  *****************************************************************/
  FUNCTION fsbVersion RETURN varchar2 IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fsbVersion'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    -- Retorna el SAO con que se realizo la ultima entrega
    RETURN(csbVERSION);
  END fsbVersion;
  /**********************************************************************
    Propiedad intelectual de OPEN International Systems
    Nombre              ajustaCuenta
    Autor       Andres Felipe Esguerra Restrepo
    Fecha               06-may-2014
    Descripcion         Creado para cuadrar las cuentas de cobro despues de crearles notas.
                        Esto debido a que cuando se estan generando las notas, las cuentas
            estan quedando descuadradas
    ***Parametros***
    Nombre        Descripcion
  inuCuenta           Cuenta de cobro a ajustar
  ***********************************************************************/
  PROCEDURE ajustaCuenta(inucuenta in cuencobr.cucocodi%type) is
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ajustaCuenta'; --Nombre del método en la traza
    cnunivtrz  CONSTANT NUMBER := 2;

    rcCargos       cargos%ROWTYPE := NULL;
    varcucovato    cuencobr.cucovato%type;
    varCUCOVAAB    cuencobr.cucovaab%type;
    varcucovafa    cuencobr.cucovafa%type;
    varcucoimfa    cuencobr.cucoimfa%type;
    inuConcSaFa    cargos.cargconc%type default NULL;
    inuSalFav      pkBCCuencobr.styCucosafa Default pkBillConst.CERO;
    isbTipoProceso cargos.cargtipr%type Default pkBillConst.POST_FACTURACION;
    idtFechaCargo  cargos.cargfecr%type Default sysdate;
    CURSOR cuDatos(inuCucocodi in cuencobr.cucocodi%type) IS
      SELECT cargos.cargcuco CUENTA,
             cargos.cargnuse PRODUCTO,
             NVL(SUM(DECODE(cargsign,
                            'DB',
                            (cargvalo),
                            'CR',
                            - (cargvalo),
                            0)),
                 0) cucovato,
             NVL(SUM(DECODE(cargsign,
                            'PA',
                            cargvalo,
                            'AS',
                            cargvalo,
                            'SA',
                            -cargvalo,
                            0)),
                 0) cucovaab,
             NVL(SUM(DECODE(cargtipr,
                            'P',
                            0,
                            DECODE(INSTR('DF-CX-',
                                         LPAD(SUBSTR(cargdoso, 1, 3), 3, ' ')),
                                   0,
                                   DECODE(cargsign,
                                          'DB',
                                          (cargvalo),
                                          'CR',
                                          - (cargvalo),
                                          0),
                                   0))),
                 0) cucovafa,
             NVL(SUM(DECODE(cargtipr,
                            'P',
                            0,
                            DECODE(INSTR('DF-CX-',
                                         LPAD(SUBSTR(cargdoso, 1, 3), 3, ' ')),
                                   0,
                                   CASE
                                     WHEN concticl = pkBillConst.fnuObtTipoImp THEN
                                      DECODE(cargsign, 'DB', cargvalo, 'CR', -cargvalo, 0)
                                     ELSE
                                      0
                                   END,
                                   0))),
                 0) cucoimfa,
             NVL(SUM(DECODE(SIGN(cargvalo), -1, 1, 0)), 0) cucocane
        FROM cargos, concepto
       WHERE cargcuco = inuCucocodi
         AND cargconc = conccodi
         AND cargsign IN ('DB',
                          'CR', -- Facturado
                          'PA', -- Pagos
                          'RD',
                          'RC',
                          'AD',
                          'AC', -- Reclamos
                          'AS',
                          'SA',
                          'ST',
                          'TS' -- Saldo favor
                          )
       GROUP BY cargos.cargcuco, cargos.cargnuse;


    v_datos cuDatos%rowtype;

      procedure prInfoCuencobr(inucuenta in cuencobr.cucocodi%type) is
          cursor cucuencobr is
          SELECT CUENCOBR.cucovato,
                  CUENCOBR.CUCOVAAB,
                  CUENCOBR.cucovafa,
                  CUENCOBR.cucoimfa
            FROM CUENCOBR
            WHERE CUCOCODI = inucuenta;
      begin
          open cucuencobr;
                fetch cucuencobr
                    into varcucovato, varCUCOVAAB, varcucovafa, varcucoimfa;
          close cucuencobr;
      end prInfoCuencobr;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_error.setApplication(CC_BOConstants.csbCUSTOMERCARE);

    open cuDatos(inucuenta);
    fetch cuDatos
      into v_datos;
    close cuDatos;
    prInfoCuencobr(v_datos.CUENTA);


    if (v_datos.cucovato != varcucovato OR v_datos.cucovaab != varCUCOVAAB OR
       v_datos.cucoimfa != varcucoimfa) then
      pkg_traza.traza_tabla;
      pkg_traza.SetLevel(cnunivtrz);
      pkg_traza.trace('DFGHKL Seguros cucocodi: ' || v_datos.CUENTA,cnunivtrz);
      pkg_traza.trace('Cuenta: ' || inucuenta || ' cucovato ' ||
                     v_datos.cucovato || '/' || varcucovato ||
                     ' - Cucovaab ' || v_datos.cucovaab || '/' ||
                     varCUCOVAAB,cnunivtrz);

      UPDATE cuencobr
         SET cucovato = NVL(v_datos.cucovato, 0),
             cucovaab = NVL(v_datos.cucovaab, 0),
             cucovafa = NVL(v_datos.cucovafa, 0),
             cucoimfa = NVL(v_datos.cucoimfa, 0)
       WHERE cucocodi = v_datos.CUENTA;
       pkg_traza.trace('Despues updateCuenta: ' || v_datos.CUENTA || ' - ' ||
                     pktblcuencobr.fnugetcucovato(v_datos.CUENTA, 0) ||
                     ' - ' ||
                     pktblcuencobr.fnugetcucovaab(v_datos.CUENTA, 0),cnunivtrz);

      pkAccountMgr.AdjustAccount(v_datos.CUENTA,
                                 v_datos.PRODUCTO,
                                 47,
                                 1,
                                 rcCargos.cargsign,
                                 rcCargos.cargvalo);

      pkg_traza.trace('Despues ajuste Cuenta: ' || v_datos.CUENTA || ' - ' ||
                     pktblcuencobr.fnugetcucovato(v_datos.CUENTA, 0) ||
                     ' - ' ||
                     pktblcuencobr.fnugetcucovaab(v_datos.CUENTA, 0),cnunivtrz);
      pkAccountMgr.GenPositiveBal(v_datos.CUENTA,
                                  inuConcSaFa,
                                  inuSalFav,
                                  isbTipoProceso,
                                  idtFechaCargo);
      pkg_traza.trace('Despues GenPosBal Cuenta: ' || v_datos.CUENTA ||
                     ' - ' ||
                     pktblcuencobr.fnugetcucovato(v_datos.CUENTA, 0) ||
                     ' - ' ||
                     pktblcuencobr.fnugetcucovaab(v_datos.CUENTA, 0),cnunivtrz);
      pkg_traza.SetLevel(0);
      pkAccountMgr.ApplyPositiveBalServ(v_datos.PRODUCTO);
    END if;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ajustaCuenta;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fsbGetExequial
  Descripcion    : Valida si el tipo de poliza es exequial y retorna Y o N
                      Y, es Exequial
                      N, no es Exequial
  Autor          : jcarrillo
  Fecha          : 03/09/2012
  Parametros         Descripcion
  ============  ===================
  inuPackage:     Numero de la solicitud
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  03/09/2013    jcarrillo         SAO212983 1 - Creacion
  ******************************************************************/
  FUNCTION fsbGetExequial(inuProdLine in ld_product_line.product_line_id%type)
    return varchar2 IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fsbGetExequial'; --Nombre del método en la traza
    sbProdLinesExe ld_parameter.value_chain%type;
    nuPosition     number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    sbProdLinesExe := pkg_bcld_parameter.fsbobtienevalorcadena(ld_boconstans.csbProdLineExe);
    nuPosition := instr(csbPIPE || sbProdLinesExe || csbPIPE,
                        csbPIPE || inuProdLine || csbPIPE);
    if (nuPosition > 0) then
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return CONSTANTS_PER.CSBYES;
    else
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return CONSTANTS_PER.CSBNO;
    end if;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fsbGetExequial;

  /*****************************************************************
      Propiedad intelectual de Open International Systems (c).
      Unidad         : ProcUpdBirth
      Descripcion    : Objeto de negocio para actualizar la fecha de nacimiento
                       de un suscriptor, el cual adquiere una nueva poliza de seguro.
      Autor          : jrobayo
      Fecha          : 04/09/2013 SAO 216330
      Parametros         Descripcion
      ============  ===================
      inuSubscriber:     Codigo del suscriptor
      idtBirth:           Fecha de nacimiento del suscriptor
      Historia de Modificaciones
      Fecha            Autor          Modificacion
      ==========  =================== =======================
      04/09/2013  jrobayo.SAO216330   1 - Se crea el metodo para actualizar la fecha
                                          de nacimiento del suscriptor que adquiere
                                          una nueva poliza.
  ******************************************************************/
  PROCEDURE ProcUpdBirth(inuSubscriber in ge_subscriber.subscriber_id%type,
                         idtBirth      in ge_subs_general_data.date_birth%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcUpdBirth'; --Nombre del método en la traza
    rcSubscriber dage_subs_general_data.styge_subs_general_data;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (dage_subs_general_data.fblexist(inuSubscriber)) then
      dage_subs_general_data.upddate_birth(inuSubscriber, idtBirth);
    else
      rcSubscriber.subscriber_id := inuSubscriber;
      rcSubscriber.date_birth    := idtBirth;
      dage_subs_general_data.insrecord(rcSubscriber);
    END if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ProcUpdBirth;

  PROCEDURE TransReqPosBalance(inuPackageId in mo_packages.package_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'TransReqPosBalance'; --Nombre del método en la traza
    -- Codigo y mensaje de error
    nuErrorCode    GE_ERROR_LOG.ERROR_LOG_ID%TYPE;
    sbErrorMessage GE_ERROR_LOG.DESCRIPTION%TYPE;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Tralada el saldo a favor remanente para la solicitud
    pkBSTransferCredits.TransPosBalByRequest(inuPackageId,
                                             nuErrorCode,
                                             sbErrorMessage);
    IF (nuErrorCode <> GE_BOConstants.OK) THEN
       pkg_error.setErrorMessage(CC_BOCONSTERROR.cnuBILLSERVICEERROR,
                                 'pkBSTransferCredits.TransPosBalByRequest' || '|' ||
                                 nuErrorCode || ' - ' || sbErrorMessage
                                 );
    END IF;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  END TransReqPosBalance;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcSaleCreate
  Descripcion    : Objeto de negocio para el registro de una solicitud de venta
                 creando su respectivo producto de seguros.
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuPackage:     Numero de la solicitud
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                  Cambio DAOR_ORDER.FRCGETRECORD por PKG_BCORDENES.FRCGETRECORD
  19-03-2015  Spacheco nc 4416    Se actualiza para redondear valores de liquidacion de las ordenes
                                  de comision de a contraista y pago a contratista de seguro
  15-12-2014  Llozada [NC 4230]   Se actualiza la solicitud con el Policy_Id
  26-09-2014  llarrarte.RQ1719    Se adiciona numero del colectivo en el XML
  18-09-2014  llarrarte.RQ1178    Se modifica para validaciones cuando se vende por renovacion
  08-08-2014  AEcheverry.4152     Se elimina la generacion de los cargos, ya que
                                  estos se generaran en el flujo en la actividad
                                  que genera los diferidos.
                                  Se generan solo cargos para la cuota inicial
                                  de las polizas por doble cupon, para que se
                                  pueda cancelar este cargo por el pago realizado.
  03-03-2014  hjgomez.SAO234504   Se aplica saldo a favor al final del proceso (para que financie la poliza)
  27/11/2013  JCarmona.SAO224868  Se modifica para que no se cree el producto brilla seguros cuando
                                  se trate de una renovacion.
  22/10/2013  AEcheverry          Se modifica para calcular y actualziar el valor de la liquidacion
  20/09/2013  mmira.SAO217497     1 - Se modifica para almacenar correctamente la
                                  informacion del asegurado en el registro de la poliza.
  04/09/2013  jrobayo.SAO216330   1 - Se modifica para actualizar fecha de nacimiento
                                      del suscriptor, o crear un nuevo suscriptor en
                                      caso que este no exista
  04/09/2013  jrobayo.SAO213381   1 - Se modifica para recibir la fecha de nacimiento
                                      del suscriptor para Venta de Seguros
                                      por archivo plano.
  03/09/2013  jcarrillo.SAO212983 1 - Se modifica para almacenar el campo que indica
                                      si una poliza es exequial
  31-08-2013  jcarrillo.SAO213976 1 - Se modifica para no antender la solicitud
                                      y la activacion del producto
  29-08-2013  jcarrilo.SAO214742  1 - Se validan que los parametros se encuentren
                                      configurados.
                                  2 - Se modifica para no atender la solicitud
  27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  27-08-2013  jcarrillo.SAO214426 1 - Se modifica por borrado de la constante
                                      <LD_BOConstans.CnuStateOrder>
  ******************************************************************/
  PROCEDURE ProcSaleCreate(inuPackage in mo_packages.package_id%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcSaleCreate'; --Nombre del método en la traza
    rcSecure_Sale     dald_secure_sale.styLD_secure_sale;
    rcMotive          damo_motive.styMO_motive;
    tbpolicy          dald_policy.tytbLD_policy;
    rcMopackage       damo_packages.styMO_packages;
    nuMotive          mo_motive.motive_id%type;
    nuAddress         mo_packages.address_id%type;
    nuOrderId         or_order.order_id%type;
    nuOrderActivityId or_order_activity.order_activity_id%type;
    /* Tipo de Poliza y Vigenca del Tipo de poliza*/
    rcPolicyType      dald_policy_type.styLD_policy_type;
    rcValidityPolicyType dald_validity_policy_type.styLD_validity_policy_type; -- JCASTRO
    nuValPolTypId     ld_validity_policy_type.validity_policy_type_id%TYPE; -- JCASTRO
    nuOrderPay        ld_parameter.numeric_value%type;
    nuOrderSale       ld_parameter.numeric_value%type;
    nuOrderCharge     ld_parameter.numeric_value%type;
    rcSubscriber      dage_subscriber.styGE_subscriber;
    rcInsured         dage_subscriber.styGE_subscriber;
    sbState           ld_parameter.value_chain%type;
    nuState           ld_parameter.numeric_value%type;
    nuError           number;
    sbMessage         varchar2(2000);
    nuvalor           number; --- valor con el que se va a generar el cargo
    nuConcept         concepto.conccodi%type;
    nuCause           causcarg.cacacodi%type;
    nuUnitOper        mo_packages.pos_oper_unit_id%type;
    frfOperating      CONSTANTS_PER.TYREFCURSOR;
    recOrope          or_operating_unit%ROWTYPE;
    rcOrder           daor_order.styor_order;
    dtIniPolicy       ld_validity_policy_type.initial_date%type;
    dtEndPolicy       ld_validity_policy_type.final_date%type;
    nuadd             number;
    nuGeo             number;
    nugesubs          ge_subscriber.subscriber_id%type;
    nuValue           ld_validity_policy_type.policy_value%type;
    nuProductId       mo_motive.product_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Se valida que los parametros exitan en la base de datos*/
    if ((dald_parameter.fblexist(LD_BOConstans.cnuCodTypeProduct)) And
       (dald_parameter.fblexist(LD_BOConstans.CsbActivityPay)) And
       (dald_parameter.fblexist(LD_BOConstans.CsbActivityCharge)) And
       (dald_parameter.fblexist(LD_BOConstans.CsbSaleOrder)) And
       (dald_parameter.fblexist(LD_BOConstans.csbCodStatePolicy)) And
       (dald_parameter.fblexist(LD_BOConstans.csbCauCumpl))) then
      /* Se obtienen los parametros*/
      nuOrderPay    := to_number(pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityPay));
      nuOrderSale   := to_number(pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbSaleOrder));
      nuOrderCharge := to_number(pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityCharge));
      sbState       := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      sbCauCumpl    := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCauCumpl);
      /* Se validan que los parametros esten configurados */
      if (nuOrderPay IS null) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Falta la configuracion del parametro "NUM_ACT_PAYMENT" que identifica el codigo de la actividad de pago.');
      end if;
      if (nuOrderSale IS null) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Falta la configuracion del parametro "NUM_ORDER_SALE" que identifica el codigo de la actividad de venta.');
      end if;
      if (nuOrderCharge IS null) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Falta la configuracion del parametro "NUM_ACT_CHARGE" que identifica el codigo de la actividad de cobro.');
      end if;
      if (sbState IS null) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Falta la configuracion del parametro "COD_STATE" que identifica el estado de la poliza activa.');
      end if;
      if (sbCauCumpl IS null) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Falta la configuracion del parametro "COD_CAU_CUMP" que identifica la causal de cumplimiento de la orden deventa seguros.');
      end if;
      /* Se valida que los parametros sean diferente de cero*/
      if ((nvl(nuOrderCharge, LD_BOConstans.cnuCero) <>
         LD_BOConstans.cnuCero)) then
        -- Se obtiene el record de la venta de la poliza
        dald_secure_sale.getRecord(inuPackage, rcSecure_Sale);
        /*Se obtiene la unidad operativa del tipo de poliza, esta unidad operativa se usara para la
        asignacion de ordenes*/
        frfOperating := ld_bcsecuremanagement.frfGetOperating(rcSecure_Sale.policy_type_id);
        FETCH frfOperating
          INTO recOrope;
        nuUnitOper := recOrope.operating_unit_id;
        CLOSE frfOperating;
        /*verifica si la causal del parametro se encuentra en null*/
        if sbCauCumpl is not null then
          /* Se valida si la causal de la venta fue exitosa, esta validacion se hace
          con respecto al valor configurado por parametro*/
          if (rcSecure_Sale.causal_id = sbCauCumpl or
             rcSecure_Sale.causal_id is null) then
            -- Se obtiene el numero de motivo de la solicitud
            nuMotive := mo_bopackages.fnuGetInitialMotive(inuPackage);
            /* Se obtiene el record de la solicitud*/
            rcMopackage := pkg_bcsolicitudes.frcgetrecord(inuPackage);
            -- Se obtiene el record del tipo de poliza*/
            dald_policy_type.getRecord(rcSecure_Sale.policy_type_id,
                                       rcPolicyType);
            -- Asigna el Id del registro de la Vigencia por Tipo de Poliza
            Ld_BcSecureManagement.GetValidityPolicyType(rcSecure_Sale.policy_type_id,
                                                        rcMopackage.request_date,
                                                        nuValPolTypId);
            if (nuValPolTypId IS null) then
              pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                        'El tipo de poliza [' ||
                                        rcSecure_Sale.policy_type_id ||
                                        '] no se encuentra vigente' ||
                                        ' en la fecha [' ||
                                        rcMopackage.request_date || ']');
            end if;
            -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
            dald_validity_policy_type.getRecord(nuValPolTypId,
                                                rcValidityPolicyType);
            /* Se levanta el error de programara para poder realizar la facturacion y
            los cargos sin esta linea no se puede hacer este proceso*/
            pkg_error.setapplication(cc_boconstants.csbCUSTOMERCARE);
            /*Se obtiene el estado de la poliza */
            nuState := to_number(substr(sbState,
                                        1,
                                        instr(sbState, '|', 1, 1) - 1));
            damo_motive.getRecord(nuMotive, rcMotive);
            pkg_traza.trace('Producto del Motivo: ' || rcMotive.product_id,pkg_traza.cnuNivelTrzDef);

            /* Si el producto NO es nulo, no se crea el tipo de producto Seguros Brilla */
            if rcMotive.product_id IS null then
              /*Creacion del producto tipo Seguros Brilla*/
              Pr_Bocreationproduct.initialCreationProduct(inuPackage);
              damo_motive.getRecord(nuMotive, rcMotive);
              nuProductId := rcMotive.product_id;
              pkg_traza.trace('Se crea el Producto nuevo ' || nuProductId,pkg_traza.cnuNivelTrzDef);

              -- SOLO SE GENERA CARGO SI LA VENTA SE REALIZO POR EL PAGO EN UN DOBLE CUPON
              IF (rcMopackage.COMM_EXCEPTION = 'Y') THEN
                /* Se obtiene el concepto de la linea de producto*/
                nuConcept := dald_product_line.fnuGetConcept_Id(rcSecure_Sale.PRODUCT_LINE_ID);
                nuCause := pkg_bcld_parameter.fnuobtienevalornumerico('COD_CAUSE_CARG_SALE');
                /* Valor del Cargo por el valor de una cuota*/
                nuValor := rcValidityPolicyType.share_value;
                pkg_traza.trace('Valor del cargo ' || nuValor,pkg_traza.cnuNivelTrzDef);

                /* Se genera el cargo con el producto generado por el servicio de producto, se asocia
                al concepto y a la causa configurada por el parametro de la solicitud,se inicializa con cargo
                DB*/
                pkChargeMgr.GenerateCharge(rcMotive.product_id,
                                           -1,
                                           nuConcept,
                                           nuCause,
                                           nuvalor, --rcPolicyType.share_value,
                                           'DB',
                                           'PP-' || inuPackage,
                                           'A',
                                           0,
                                           null,
                                           null,
                                           null,
                                           false,
                                           sysdate);
                /*Creacion de factura*/
                cc_boaccounts.GenerateAccountByPack(inuPackage);
                pkg_traza.trace('Se creo la factura ',pkg_traza.cnuNivelTrzDef);

              END IF;
              dtIniPolicy := trunc(rcMopackage.request_date);
              dtEndPolicy := Ld_BcSecureManagement.fdtfechendtypoli(rcValidityPolicyType.coverage_month,
                                                                    dtIniPolicy);
              pkg_traza.trace('Contrato ' || rcMotive.subscription_id, pkg_traza.cnuNivelTrzDef);
              GetAddressBySusc(rcMotive.subscription_id, nuadd, nuGeo);
              pkg_traza.trace('nuadd ' || nuadd || ' nuGeo ' || nuGeo, pkg_traza.cnuNivelTrzDef);
              /*Se obtiene la informacion del cliente a raiz del suscriptor*/
              nugesubs := PKG_BCCONTRATO.FNUIDCLIENTE(rcMotive.subscription_id);
              pkg_traza.Trace('El codigo del cliente' || ' - ' || nugesubs,pkg_traza.cnuNivelTrzDef);
              /*Se obtiene el record del cliente*/
              dage_subscriber.getrecord(nugesubs, rcSubscriber);
              /*Actualizacion de datos del cliente*/
              ProcUpdBirth(nugesubs, rcSecure_Sale.born_date);
              /* Se obtiene informacion del asegurado */
              dage_subscriber.getrecord(rcSecure_Sale.identification_id,
                                        rcInsured);
              /* Se realiza la creacion de la poliza */
              tbpolicy(1).policy_id := ld_bosequence.fnuSeqPolicy;
              tbpolicy(1).state_policy := nuState;
              tbpolicy(1).contratist_code := rcSecure_Sale.id_contratista;
              tbpolicy(1).product_line_id := rcSecure_Sale.product_line_id;
              -- La Poliza inicia desde las 00:00 del dia en que se registra la solicitud
              tbpolicy(1).dt_in_policy := dtIniPolicy;
              tbpolicy(1).dt_en_policy := dtEndPolicy;
              tbpolicy(1).value_policy := rcValidityPolicyType.policy_value;
              tbpolicy(1).prem_policy := rcValidityPolicyType.share_value;
              tbpolicy(1).name_insured := rcInsured.subscriber_name;
              tbpolicy(1).suscription_id := rcMotive.subscription_id;
              tbpolicy(1).product_id := nuProductId;
              tbpolicy(1).identification_id := rcInsured.identification;
              tbpolicy(1).period_policy := to_number(to_char(sysdate, 'MM'));
              tbpolicy(1).year_policy := to_number(to_char(rcValidityPolicyType.initial_date,
                                                           'yyyy'));
              tbpolicy(1).month_policy := to_number(to_char(rcValidityPolicyType.initial_date,
                                                            'MM'));
              tbpolicy(1).dtcreate_policy := sysdate;
              tbpolicy(1).share_policy := rcValidityPolicyType.coverage_month;
              tbpolicy(1).dt_insured_policy := rcSecure_Sale.born_date;
              tbpolicy(1).policy_type_id := rcSecure_Sale.policy_type_id;
              tbpolicy(1).comments := rcMopackage.COMMENT_ ||
                                      ' Poliza vendida asociada al siguiente asegurado ' ||
                                      rcInsured.subscriber_name ||
                                      ' con la identificacion ' ||
                                      rcInsured.identification;
              tbpolicy(1).geograp_location_id := nuGeo;
              tbpolicy(1).validity_policy_type_id := nuValPolTypId;
              tbpolicy(1).policy_exq := dald_policy_type.fsbGetIS_EXQ(rcSecure_Sale.policy_type_id);
              tbpolicy(1).policy_number := rcSecure_Sale.policy_number;
              tbpolicy(1).collective_number := fnuGetCollectiveNumber(tbpolicy                   (1)
                                                                      .product_line_id,
                                                                      rcSecure_Sale.policy_number,
                                                                      tbpolicy                   (1)
                                                                      .dtcreate_policy);
              dald_policy.insRecords(tbpolicy);
              /*Se procede a realizar la creacion de ordenes las cuales son: De venta,De comision,De facturacion*/
               /*Creacion y legalizacion de orden de venta, esta orden
              es la unica que se va legalizar automaticamente*/
              /*Se obtiene la direccion asociada a la solicitud*/
              nuAddress := mo_bopackages.fnuFindAddressId(inuPackage);
              /*Se crea la orden asociada a la solicitud,al tipo de actividad de venta,a la direccion,
              al cliente,contrato,producto obtenido del motivo,numero de proceso*/
              nuCodMenErro := null;
              api_createorder(inuItemsid         => nuOrderSale,
                              inuPackageid       => inuPackage,
                              inuMotiveid        => nuMotive,
                              inuComponentid     => null,
                              inuInstanceid      => null,
                              inuAddressid       => nuAddress,
                              inuElementid       => null,
                              inuSubscriberid    => rcSubscriber.subscriber_id,
                              inuSubscriptionid  => rcMotive.subscription_id,
                              inuProductid       => nuProductId,
                              inuOperunitid      => null,
                              idtExecestimdate   => null,
                              inuProcessid       => null,
                              isbComment         => rcMopackage.COMMENT_,
                              iblProcessorder    => null,
                              inuPriorityid      => null,
                              inuOrdertemplateid => null,
                              isbCompensate      => null,
                              inuConsecutive     => null,
                              inuRouteid         => null,
                              inuRouteConsecutive=> null,
                              inuLegalizetrytimes=> null,
                              isbTagname         => null,
                              iblIsacttoGroup    => null,
                              inuRefvalue        => null,
                              inuActionid        => null,
                              ionuOrderid        => nuOrderId,
                              ionuOrderactivityid=> nuorderactivityid,
                              onuErrorCode       => nuCodMenErro,
                              osbErrorMessage    => sbMensaError
                             );

               if nvl(nuCodMenErro,0) != 0 then
                  RAISE PKG_ERROR.CONTROLLED_ERROR;
               end if;


              /*Se asigna la orden a la unidad operativa asociada al tipo de poliza*/
              rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
              OR_boProcessOrder.updBasicData(rcOrder,
                                             rcOrder.operating_sector_id,
                                             null);

              if nuUnitOper is null then
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          'La unidad operativa no permite asignar '||
                                          nuUnitOper || ' ' ||
                                          nuOrderId);
              end if;

              nuCodMenErro := null;

              api_assign_order (inuOrder          => nuOrderId,
                                inuOperatingUnit  => nuUnitOper,
                                onuErrorCode      => nuCodMenErro,
                                osbErrorMessage   => sbMensaError
                               );
             if nvl(nuCodMenErro,0) != 0 then
                 RAISE PKG_ERROR.CONTROLLED_ERROR;
             end if;

			sbdataorder := NULL;
			sbdataorder :=
				   nuOrderId
				|| '|'
				|| pkg_gestionordenes.cnucausalexito
				|| '|'
				|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
				|| '||'
				|| nuorderactivityid
				|| '>'
				|| 1
				|| ';;;;|||1277;Legalizacion de la orden de venta';

             -- Se legaliza la orden de venta
             api_legalizeOrders(isbDataOrder    => sbdataorder,
                                idtInitDate     => sysdate,
                               idtFinalDate    => sysdate,
                                idtChangeDate   => null,
                                onuErrorCode    => nuError,
                                osbErrorMessage => sbMessage
                               );

             if (nvl(nuError,0) <> 0) then
                gw_boerrors.checkerror(nuError, sbMessage);
             end if;
              --  Crea orden de facturacion
              nuorderid         := null;
              nuorderactivityid := null;
              nuCodMenErro      := null;
              /*Se crea la orden asociada a la solicitud,al tipo de actividad de facturacion,a la direccion,
              al cliente,contrato,producto obtenido del motivo,numero de proceso*/
              nuCodMenErro := null;
              api_createorder(inuItemsid         => nuOrderPay,
                              inuPackageid       => inuPackage,
                              inuMotiveid        => nuMotive,
                              inuComponentid     => null,
                              inuInstanceid      => null,
                              inuAddressid       => nuAddress,
                              inuElementid       => null,
                              inuSubscriberid    => rcSubscriber.subscriber_id,
                              inuSubscriptionid  => rcMotive.subscription_id,
                              inuProductid       => nuProductId,
                              inuOperunitid      => null,
                              idtExecestimdate   => null,
                              inuProcessid       => null,
                              isbComment         => 'Orden de pago para la aseguradora',
                              iblProcessorder    => null,
                              inuPriorityid      => null,
                              inuOrdertemplateid => null,
                              isbCompensate      => null,
                              inuConsecutive     => null,
                              inuRouteid         => null,
                              inuRouteConsecutive=> null,
                              inuLegalizetrytimes=> null,
                              isbTagname         => null,
                              iblIsacttoGroup    => null,
                              inuRefvalue        => null,
                              inuActionid        => null,
                              ionuOrderid        => nuOrderId,
                              ionuOrderactivityid=> nuorderactivityid,
                              onuErrorCode       => nuCodMenErro,
                              osbErrorMessage    => sbMensaError
                             );

               if nvl(nuCodMenErro,0) != 0 then
                  RAISE PKG_ERROR.CONTROLLED_ERROR;
               end if;

              --Se asigna la orden a la unidad operativa asociada al tipo de poliza
              rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
              OR_boProcessOrder.updBasicData(rcOrder,
                                             rcOrder.operating_sector_id,
                                             null);



              if nuUnitOper is null then
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          'La unidad operativa no permite asignar' ||
                                          nuUnitOper || ' ' ||
                                          nuOrderId);
              end if;
               nuCodMenErro := null;
               api_assign_order (inuOrder          => nuOrderId,
                                 inuOperatingUnit  => nuUnitOper,
                                 onuErrorCode      => nuCodMenErro,
                                 osbErrorMessage   => sbMensaError
                                );
               if nvl(nuCodMenErro,0) != 0 then
                  RAISE PKG_ERROR.CONTROLLED_ERROR;
               end if;

				sbdataorder := NULL;
				sbdataorder :=
					   nuOrderId
					|| '|'
					|| pkg_gestionordenes.cnucausalexito
					|| '|'
					|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
					|| '||'
					|| nuorderactivityid
					|| '>'
					|| 1
					|| ';;;;|||1277;Legalizacion de la orden de cobro';

              -- Se legaliza la orden de cobro con causal de exito
              api_legalizeOrders(isbDataOrder    => sbdataorder,
                                 idtInitDate     => sysdate,
                                 idtFinalDate    => sysdate,
                                 idtChangeDate   => null,
                                 onuErrorCode    => nuError,
                                 osbErrorMessage => sbMessage
                                );

              if (nvl(nuError,0) <> 0) then
                 gw_boerrors.checkerror(nuError, sbMessage);
              end if;

              -- actualizar valor de liquidacion de la actividad
              LD_BOSECUREMANAGEMENT.GETLIQUIDATIONSECUREVALUE(nuOrderId, nuValue);
                 pkg_traza.trace('nuValue: ' || nuValue, pkg_traza.cnuNivelTrzDef);

              nuValue := round(nuValue, 0); --Spacheco  Nc 4416 se modifica para redondear valor de la
              --orden para evitar decimales q afecten liquiedacion de acta
              daor_order_items.updvalue(daor_order_activity.fnugetorder_item_id(nuorderactivityid),
                                        nuValue);
              daor_order.updorder_value(pkg_bcordenes.fnuobtieneordendeactividad
                                        (nuorderactivityid),
                                        nuValue);
              pkg_traza.trace('nuValue: ' || nuValue, pkg_traza.cnuNivelTrzDef);
              /*  Crea orden de comision*/
              nuvalue           := null;
              nuorderid         := null;
              nuorderactivityid := null;
              nuCodMenErro      := null;
              /*Se crea la orden asociada a la solicitud,al tipo de actividad de comision,a la direccion,
              al cliente,contrato,producto obtenido del motivo,numero de proceso*/

              api_createorder(inuItemsid         => nuOrderCharge,
                              inuPackageid       => inuPackage,
                              inuMotiveid        => nuMotive,
                              inuComponentid     => null,
                              inuInstanceid      => null,
                              inuAddressid       => nuAddress,
                              inuElementid       => null,
                              inuSubscriberid    => rcSubscriber.subscriber_id,
                              inuSubscriptionid  => rcMotive.subscription_id,
                              inuProductid       => nuProductId,
                              inuOperunitid      => null,
                              idtExecestimdate   => null,
                              inuProcessid       => null,
                              isbComment         => 'Orden de pago para la aseguradora',
                              iblProcessorder    => null,
                              inuPriorityid      => null,
                              inuOrdertemplateid => null,
                              isbCompensate      => null,
                              inuConsecutive     => null,
                              inuRouteid         => null,
                              inuRouteConsecutive=> null,
                              inuLegalizetrytimes=> null,
                              isbTagname         => null,
                              iblIsacttoGroup    => null,
                              inuRefvalue        => null,
                              inuActionid        => null,
                              ionuOrderid        => nuOrderId,
                              ionuOrderactivityid=> nuorderactivityid,
                              onuErrorCode       => nuCodMenErro,
                              osbErrorMessage    => sbMensaError
                             );

               if nvl(nuCodMenErro,0) != 0 then
                  RAISE PKG_ERROR.CONTROLLED_ERROR;
               end if;

              rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
              OR_boProcessOrder.updBasicData(rcOrder,
                                             rcOrder.operating_sector_id,
                                             null);

              if nuUnitOper is null then
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          'La unidad operativa no permite asignar' ||
                                          nuUnitOper || ' ' ||
                                          nuOrderId);
              end if;

              nuCodMenErro := null;
              api_assign_order (inuOrder          => nuOrderId,
                                inuOperatingUnit  => nuUnitOper,
                                onuErrorCode      => nuCodMenErro,
                                osbErrorMessage   => sbMensaError
                              );
              if nvl(nuCodMenErro,0) != 0 then
                RAISE PKG_ERROR.CONTROLLED_ERROR;
              end if;

				sbdataorder := NULL;
				sbdataorder :=
					   nuOrderId
					|| '|'
					|| pkg_gestionordenes.cnucausalexito
					|| '|'
					|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
					|| '||'
					|| nuorderactivityid
					|| '>'
					|| 1
					|| ';;;;|||1277;Legalizacion de la orden de cobro';

              -- Se legaliza la orden de cobro con causal de exito
              api_legalizeOrders(isbDataOrder    => sbdataorder,
                                 idtInitDate     => sysdate,
                                 idtFinalDate    => sysdate,
                                 idtChangeDate   => null,
                                 onuErrorCode    => nuError,
                                 osbErrorMessage => sbMessage
                                );

              if (nvl(nuError,0) <> 0) then
                 gw_boerrors.checkerror(nuError, sbMessage);
              end if;
              -- se actualiza valor de la liquidacion
              LD_BOSECUREMANAGEMENT.GETLIQUIDATIONSECUREVALUE(nuOrderId,
                                                              nuValue);
              nuValue := round(nuValue, 0); --Spacheco  Nc 4416 se modifica para redondear valor de la
              --orden para evitar decimales q afecten liquiedacion de acta
              daor_order_items.updvalue(daor_order_activity.fnugetorder_item_id(nuorderactivityid),
                                        nuValue);
              daor_order.updorder_value(pkg_bcordenes.fnuobtieneordendeactividad(nuorderactivityid),nuValue);
            else
              nuProductId := rcMotive.product_id;
              pkg_traza.trace('El Producto ya existe ' || nuProductId, pkg_traza.cnuNivelTrzDef);
              dtIniPolicy := trunc(rcMopackage.request_date);
              dtEndPolicy := Ld_BcSecureManagement.fdtfechendtypoli(rcValidityPolicyType.coverage_month,
                                                                    dtIniPolicy);
              GetAddressBySusc(rcMotive.subscription_id, nuadd, nuGeo);
              /*Se obtiene la informacion del cliente a raiz del suscriptor*/
              nugesubs := PKG_BCCONTRATO.FNUIDCLIENTE(rcMotive.subscription_id);
              pkg_traza.Trace('El codigo del cliente' || ' - ' || nugesubs,pkg_traza.cnuNivelTrzDef);
              --Se obtiene el record del cliente*/
              dage_subscriber.getrecord(nugesubs, rcSubscriber);
              --/*Actualizacion de datos del cliente*/
              ProcUpdBirth(nugesubs, rcSecure_Sale.born_date);
              /* Se obtiene informacion del asegurado */
              dage_subscriber.getrecord(rcSecure_Sale.identification_id,
                                        rcInsured);
              /* Se realiza la creacion de la poliza */
              tbpolicy(1).policy_id := ld_bosequence.fnuSeqPolicy;
              tbpolicy(1).state_policy := nuState;
              tbpolicy(1).contratist_code := rcSecure_Sale.id_contratista;
              tbpolicy(1).product_line_id := rcSecure_Sale.product_line_id;
              -- La Poliza inicia desde las 00:00 del dia en que se registra la solicitud
              tbpolicy(1).dt_in_policy := dtIniPolicy;
              tbpolicy(1).dt_en_policy := dtEndPolicy;
              tbpolicy(1).value_policy := rcValidityPolicyType.policy_value;
              tbpolicy(1).prem_policy := rcValidityPolicyType.share_value;
              tbpolicy(1).name_insured := rcInsured.subscriber_name;
              tbpolicy(1).suscription_id := rcMotive.subscription_id;
              tbpolicy(1).product_id := nuProductId;
              tbpolicy(1).identification_id := rcInsured.identification;
              tbpolicy(1).period_policy := to_number(to_char(sysdate, 'MM'));
              tbpolicy(1).year_policy := to_number(to_char(rcValidityPolicyType.initial_date,
                                                           'yyyy'));
              tbpolicy(1).month_policy := to_number(to_char(rcValidityPolicyType.initial_date,
                                                            'MM'));
              tbpolicy(1).dtcreate_policy := sysdate;
              tbpolicy(1).share_policy := rcValidityPolicyType.coverage_month;
              tbpolicy(1).dt_insured_policy := rcSecure_Sale.born_date;
              tbpolicy(1).policy_type_id := rcSecure_Sale.policy_type_id;
              tbpolicy(1).comments := rcMopackage.COMMENT_;
              tbpolicy(1).geograp_location_id := nuGeo;
              tbpolicy(1).validity_policy_type_id := nuValPolTypId;
              tbpolicy(1).policy_exq := dald_policy_type.fsbGetIS_EXQ(rcSecure_Sale.policy_type_id);
              tbpolicy(1).policy_number := ld_bcsecuremanagement.fnuGetRenewPolicyByProduct(nuProductId);
              tbpolicy(1).collective_number := ld_bcsecuremanagement.fnuGetCollectiveNumber(tbpolicy(1)
                                                                                            .policy_number);
              pkg_traza.Trace('-- PASO 100. tbpolicy(1).collective_number: ' || tbpolicy(1).collective_number ||
                             ', tbpolicy(1).policy_number: ' || tbpolicy(1).policy_number,
                             pkg_traza.cnuNivelTrzDef);
              dald_policy.insRecords(tbpolicy);
            END if;
            --Llozada [NC 4230]: Se actualiza la solicitud con el Policy_Id
            if tbpolicy(1).policy_id is not null then
              update ld_secure_sale
                 set policy_number = tbpolicy(1).policy_id
               where secure_sale_id = inuPackage;
            end if;
          else
            /* Si la orden no tuvo causal de exito se procede a crear la orden de venta
            con causal de fallo */
            nuMotive := mo_bopackages.fnuGetInitialMotive(inuPackage);
            damo_motive.getRecord(nuMotive, rcMotive);
            /* Creacion y legalizacion de orden de venta con causal de fallo */
            nuAddress := mo_bopackages.fnuFindAddressId(inuPackage);
            /*Se crea la orden asociada a la solicitud,al tipo de actividad de venta,a la direccion,
            al cliente,contrato,producto obtenido del motivo,numero de proceso*/

            nuCodMenErro := null;
            api_createorder(inuItemsid         => nuOrderSale,
                            inuPackageid       => inuPackage,
                            inuMotiveid        => nuMotive,
                            inuComponentid     => null,
                            inuInstanceid      => null,
                            inuAddressid       => nuAddress,
                            inuElementid       => null,
                            inuSubscriberid    => rcSubscriber.subscriber_id,
                            inuSubscriptionid  => rcMotive.subscription_id,
                            inuProductid       => nuProductId,
                            inuOperunitid      => null,
                            idtExecestimdate   => null,
                            inuProcessid       => null,
                            isbComment         => 'Orden de pago para la aseguradora',
                            iblProcessorder    => null,
                            inuPriorityid      => null,
                            inuOrdertemplateid => null,
                            isbCompensate      => null,
                            inuConsecutive     => null,
                            inuRouteid         => null,
                            inuRouteConsecutive=> null,
                            inuLegalizetrytimes=> null,
                            isbTagname         => null,
                            iblIsacttoGroup    => null,
                            inuRefvalue        => null,
                            inuActionid        => null,
                            ionuOrderid        => nuOrderId,
                            ionuOrderactivityid=> nuorderactivityid,
                            onuErrorCode       => nuCodMenErro,
                            osbErrorMessage    => sbMensaError
                            );

            if nvl(nuCodMenErro,0) != 0 then
              RAISE PKG_ERROR.CONTROLLED_ERROR;
            end if;

            rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
            OR_boProcessOrder.updBasicData(rcOrder,
                                           rcOrder.operating_sector_id,
                                           null);


            if nuUnitOper is null then
              pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                        'La unidad operativa no permite asignar' ||
                                        nuUnitOper || ' ' ||
                                        nuOrderId);
            end if;
            nuCodMenErro := null;
            api_assign_order (inuOrder          => nuOrderId,
                              inuOperatingUnit  => nuUnitOper,
                              onuErrorCode      => nuCodMenErro,
                              osbErrorMessage   => sbMensaError
                             );
            if nvl(nuCodMenErro,0) != 0 then
                RAISE PKG_ERROR.CONTROLLED_ERROR;
            end if;

			sbdataorder := NULL;
			sbdataorder :=
				   nuOrderId
				|| '|'
				|| pkg_gestionordenes.cnucausalexito
				|| '|'
				|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
				|| '||'
				|| nuorderactivityid
				|| '>'
				|| 1
				|| ';;;;|||1277;Legalizacion de la orden de venta';

            -- Se legaliza la orden de venta
            api_legalizeOrders(isbDataOrder    => sbdataorder,
                              idtInitDate     => sysdate,
                              idtFinalDate    => sysdate,
                              idtChangeDate   => null,
                              onuErrorCode    => nuError,
                              osbErrorMessage => sbMessage
                             );

            if (nvl(nuError,0) <> 0) then
               gw_boerrors.checkerror(nuError, sbMessage);
            end if;
          end if;
        else
           gw_boerrors.checkerror(nuError,
                                     'El parametro de la causal de cumplimiento');
        end if;
      end if;
    else
       gw_boerrors.checkerror(nuError,
                                 'Los parametros de configuracion de la venta se encuentran en blanco, favor Validar');
    end if;
    --Se aplica el saldo a favor
    TransReqPosBalance(inuPackage);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcSaleCreate;
  -- CAMBIO 3504
  /**************************************************************************/
  FUNCTION GetPackageIdByFinancingId(inuFinancingId number)
    RETURN mo_packages.package_id%type IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetPackageIdByFinancingId'; --Nombre del método en la traza
    rcFinancingRequest DACC_Financing_Request.styCC_financing_request;
    rcSalesFinancing   cc_sales_financ_cond%rowtype;
    nuPackageId        mo_packages.package_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuFinancingId:'||inuFinancingId,pkg_traza.cnuNivelTrzDef);

    --  Obtiene la solicitud de financiacion a partir de la financiacion origen
    CC_BCFinancing_Request.GetFinanReqByFinanId(inuFinancingId,
                                                rcFinancingRequest,
                                                false); --no levanta error
    nuPackageId := rcFinancingRequest.package_id;
    pkg_traza.trace('nuPackageId de cc_financing_request: ' || nuPackageId,pkg_traza.cnuNivelTrzDef);
    -- Si no encontro solititud de financiacion en cc_financig_request
    -- se busca en cc_sales_financ_cond
    if (nuPackageId IS null) then
      FI_BCCC_Sales_Financ_Cond.GetSalFinReqByFinanId(inuFinancingId,
                                                      false,
                                                      rcSalesFinancing);
      nuPackageId := rcSalesFinancing.package_id;
      pkg_traza.trace('nuPackageId de cc_sales_financ_cond: ' ||
                     nuPackageId,pkg_traza.cnuNivelTrzDef);
    END if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return nuPackageId;

  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR  then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetPackageIdByFinancingId;


  FUNCTION fnuGetProductBalance(inuProductId in servsusc.sesunuse%type)
    RETURN number IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnuGetProductBalance'; --Nombre del método en la traza
    /* Saldo pendiente de una cuenta de cobro */
    nuAccPendBal number;
    /* Valor del ajuste correspondiente a una cuenta de cobro */
    nuAdjustValue cargos.cargvalo%type;
    /* Signo del ajuste correspondiente a una cuenta de cobro */
    sbAdjustSign cargos.cargsign%type;
    /* Saldo pendiente del producto especificado teniendo en cuenta el valor
    a financiar para cada cuenta de cobro y el ajuste correspondiente */
    nuProdPendBal number := 0;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuProductId:'||inuProductId,pkg_traza.cnuNivelTrzDef);

    /* Se recorren las cuentas de cobro para el producto especificado */
    for rcPendBalToFinByAcc in CC_BCFinancing.cuPendBalToFinByAcc(inuProductId) loop
      /* Se calcula el saldo pendiente teniendo en cuenta el valor a
      financiar */
      nuAccPendBal := nvl(rcPendBalToFinByAcc.s_pending_balance, 0) -
                      nvl(rcPendBalToFinByAcc.s_pend_balance_to_finance, 0);
      /* Se calcula el ajuste correspondiente */
      pkAccountMgr.CalcAdjustValue(inuProductId,
                                   nuAccPendBal,
                                   nuAdjustValue,
                                   sbAdjustSign);
      /* Se adiciona el valor del ajuste al saldo pendiente de la cuenta
      de cobro */
      if (nuAdjustValue > pkBillConst.CERO) then

        if (sbAdjustSign = pkBillConst.DEBITO) then
          nuAccPendBal := nuAccPendBal + nuAdjustValue;
        else
          nuAccPendBal := nuAccPendBal - nuAdjustValue;
        end if;
      end if;
      /* Se acumula el saldo pendiente del producto */
      nuProdPendBal := nuProdPendBal + nuAccPendBal;
    end loop;
    pkg_traza.Trace('Saldo pendiente del producto [' ||
                   to_char(inuProductId) || '] despues de financiar -> ' ||
                   to_char(nuProdPendBal),
                   pkg_traza.cnuNivelTrzDef);
     pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return nuProdPendBal;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR  then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fnuGetProductBalance;

  PROCEDURE GetExtraPayTotals(onuExtraPayCount out number,
                              onuExtraPayValue out number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetExtraPayTotals'; --Nombre del método en la traza
    nuIndex number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('cc_bofinancing.GetExtraPayTotals (onuExtraPayCount,onuExtraPayValue)',
                   pkg_traza.cnuNivelTrzDef);
    onuExtraPayCount := 0;
    onuExtraPayValue := 0;
    if (nvl(tbExtraPayment.count, 0) = 0) then
      return;
    END if;
    nuIndex := tbExtraPayment.FIRST;
    loop
      exit when nuIndex is null;
      --acumula contador del numero de cuotas extras configuradas al servicio
      --suscrito
      onuExtraPayCount := onuExtraPayCount + 1;
      onuExtraPayValue := onuExtraPayValue + tbExtraPayment(nuIndex)
                         .extraPayValue;
      -- Pasa al proximo registro
      nuIndex := tbExtraPayment.next(nuIndex);
    END loop;
    pkg_traza.trace('onuExtraPayCount=>' || onuExtraPayCount, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('onuExtraPayValue=>' || onuExtraPayValue, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR  then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetExtraPayTotals;

  procedure ClearMemory is
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ClearMemory'; --Nombre del método en la traza
  BEGIN

    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Limpia toda la memoria cache
    pktblParaFact.ClearMemory;
    pktblPeriFact.ClearMemory;
    pktblConsecut.ClearMemory;
    pktblMeCaDife.ClearMemory;
    pktblServSusc.ClearMemory;
    pktblSuscripc.ClearMemory;
    pktblConcepto.ClearMemory;
    pktblCuencobr.ClearMemory;
    pktblMensaje.ClearMemory;
    pktblParametr.ClearMemory;
    pktblParaFact.ClearMemory;
    pktblCiclo.ClearMemory;
    pktblDiferido.ClearMemory;
    pktblEstaFina.ClearMemory;
    pktblPlandife.ClearMemory;
    pktblCauscarg.ClearMemory;
    pktblTasaInte.ClearMemory;
    pktblCuotExtr.ClearMemory;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR  then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ClearMemory;

  PROCEDURE ValidateParam IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValidateParam'; --Nombre del método en la traza
  BEGIN
     pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida Concepto de Ajuste
    pkBillingParamMgr.GetAdjustConcept(gnuConcAjuste);
    -- Valida parametro INTESOBREIVAFINAN
    blgInteSobreIvaFina := pkParameterMgr.fblFinanVATInter;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValidateParam;

  PROCEDURE GetParametros IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetParametros'; --Nombre del método en la traza
  BEGIN

    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (blgParamLoaded) then

      pkg_traza.Trace('Fin: [CC_BOFinancing.GetParametros]', pkg_traza.cnuNivelTrzDef);
      return;
    end if;
    -- Obtiene la empresa del funcionario
    nugFunctionaryEnterprise := pkg_session.fnugetempresadeusuario;
    -- Se fija cache de parametros.
    pkGrlParamExtendedMgr.SetCacheOn;
    sbTokenDF := pkbillconst.csbTOKEN_DIFERIDO; -- Token CObro Capital Cuota
    -- Normal.
    -- Token para cargos que que reducen la cartera corriente
    sbTokenFD := pkbillconst.csbTOKEN_FINANCIACION;
    -- Token para cuotas extras
    sbTokenCX := pkbillconst.csbTOKEN_CUOTA_EXTRA; --Token cuota extra
    -- Token para Acuerdo de Pago
    sbTokenAP := pkBillConst.csbTOKEN_ACUERDO_PAGO;
    -- Obtiene tipo de paquete para financiar deuda
    gnuFinDebtPckTypId := PS_BOPackageType.fnuGetPackTypeByTagName(csbP_FINANCING_DEBT);

    if (gnuFinDebtPckTypId is null) then
      pkg_error.setErrorMessage(cnuNOTEXISTFINPACKTYPE, csbP_FINANCING_DEBT);
    end if;

    -- Obtiene tipo de paquete para cambio de condiciones de financiacion
    gnuChCondDebtPckTypId := ps_bopackagetype.fnuGetPackTypeByTagName(csbP_CHANGE_COND_DEBT);
    if (gnuChCondDebtPckTypId is null) then
      pkg_error.setErrorMessage(cnuNOTEXISTFINPACKTYPE, csbP_CHANGE_COND_DEBT);
    end if;
    gnuFinIncumpParaBloqueo := pktblsistema.fnuMaxFinIncump(pkg_session.fnugetempresadeusuario);
    blgParamLoaded := TRUE;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when  PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END GetParametros;

  PROCEDURE ValFlagOnePayIVA(ichIVAUnaCuota in char) IS
     csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValFlagOnePayIVA'; --Nombre del método en la traza
     cnuFLAG_ERRADO constant number := 9567; -- EL flag debe ser S o N
     csbFLAG_ERRADO CONSTANT VARCHAR2(100) := 'El flag de financiacion de IVA a una cuota debe ser S o N';
  BEGIN

    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Evalua si se financia IVA
    if (not blgFinanciarIVA) then
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return;
    end if;
    -- Evalua si el flag esta nulo
    if (ichIVAUnaCuota is null) then
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    end if;
    -- Evalua si el flag es S o N
    if (ichIVAUnaCuota != constants_per.CSBSI and
       ichIVAUnaCuota != constants_per.CSBNO) then
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuFLAG_ERRADO||'-'||csbFLAG_ERRADO);
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValFlagOnePayIVA;

  PROCEDURE ValConcept(inuNumServ  in servsusc.sesunuse%type,
                       inuConcepto in concepto.conccodi%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValConcept'; --Nombre del método en la traza
  BEGIN
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      pkg_traza.trace('prod=' || inuNumServ ||
                      ',conc=' || inuConcepto,pkg_traza.cnuNivelTrzDef);

      -- Valida si el codigo del concepto es nulo
      pkConceptMgr.ValidateNull(inuConcepto);
      -- Valida si el concepto existe en BD
      pktblConcepto.AccKey(inuConcepto);
      -- Valida si el concepto es diferible
      pkConceptMgr.ValidDeferable(inuConcepto);
      -- Realiza la validacion del concepto de financiacion
      pkConceptMgr.ValFinancingConcept(inuConcepto);

      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);

  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValConcept;

  /*
      Propiedad intelectual de Open Systems (c).
      Metodo      : valConcepts
      Descripcion : Valida los conceptos de un producto para
                    financiar deuda
      Parametros           Descripcion
      Autor       : Arturo Mendez Zambrano
      Historia de modificaciones
      Fecha       IDEntrega       Modificacion
      17-Abr-2008 amendezSAO67102 Creacion
  */
  PROCEDURE valConcepts(inuProductId in servsusc.sesunuse%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'valConcepts'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    for rc in cc_bcfinancing.cu_concepts(inuProductId) loop
      ValConcept(inuProductId, rc.concept_ID);
    END loop;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END valConcepts;

  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValProgramName
      Descripcion : Valida el nombre del programa
        Validate Program Name
      Parametros  :   Descripcion
    isbPrograma Nombre del programa
      Retorno :
      Autor : cquinter
      Fecha : 28-ABR-1999
      Historia de Modificaciones
      Fecha Autor Modificacion
      14-01-2009  aframirezSAO88760
      Se cambia el tipo de dato del parametro de programa, ya no es cargos.
      cargprog, ahora es procesos.proccodi.
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
  */
  PROCEDURE ValProgramName(isbPrograma in procesos.proccodi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValProgramName'; --Nombre del método en la traza
    -- El documento de soporte es nulo
    cnuPROGRAM_NAME_NULL constant number := 9568;
    csbPROGRAM_NAME_NULL CONSTANT VARCHAR2(100) := 'El nombre del programa no debe ser nulo';
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida que el nombre del programa no sea nulo
    if (isbPrograma is null) then
       pkg_error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuPROGRAM_NAME_NULL||'-'||csbPROGRAM_NAME_NULL);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValProgramName;
  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValPaymentMethod
      Descripcion : Valida metodo de calculo de cuota del diferido
        Validate Payment Method
      Parametros  :   Descripcion
      Retorno :
      Autor : cquinter
      Fecha : 28-ABR-1999
      Historia de Modificaciones
      Fecha Autor Modificacion
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
      24-Dic-2001 mgutierrezOP8954
      Valida el metodo con el valor que tenga el plan por defecto
  */
  PROCEDURE ValPaymentMethod IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValPaymentMethod'; --Nombre del método en la traza
  BEGIN
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida si el codigo del metodo es nulo
    if (nugMetodo is null) then
      -- Asigna metodo de calculo del Plan de financiacion
      nugMetodo := pktblPlandife.fnuGetInterestRateCod(nugPlan);
    end if;
    if (nugMetodo is null) then
      -- Asigna metodo de calculo por default
      nugMetodo := pktblParaFact.fnuGetPaymentMethod(pkConstante.SISTEMA);
    end if;
    -- Valida si el metodo existe
    pkPaymentMethodMgr.ValidateData(nugMetodo);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValPaymentMethod;
  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValPaymentsNumber
      Descripcion : Valida el numero de cuotas del diferido
        Validate Payments Number
      Parametros  :   Descripcion
    inuPlan   Codigo del plan del diferido
    inuNumeroCuotas Numero de cuotas
    inuPorcCuotaIni Porcentaje de cuota inicial
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : 28-ABR-1999
      Historia de Modificaciones
      Fecha Autor Modificacion
      03-04-2012  lfernandez.SAO181109
      Se elimina parametro inuPorcCuotaIni
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
      25-May-2002 mgutierrSAO12013
      La validacion del numero de cuotas permitodo se hara de acuerdo al Plan de
      Financiacion
      15.jun.2000 Caq Se adiciona parametro Plan de diferido. Se valida que el
        numero de cuotas del diferido se encuentre dentro del
        rango permitido en el plan del diferido
  */
  PROCEDURE ValPaymentsNumber(inuPlan         in plandife.pldicodi%type,
                              inuNumeroCuotas in diferido.difenucu%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValPaymentsNumber'; --Nombre del método en la traza
    -- El numero de cuotas del diferido no es valido
    cnuNUM_CUOTAS_NO_VALIDO constant number := 9519;
    csbNUM_CUOTAS_NO_VALIDO CONSTANT VARCHAR2(100) := 'El numero de cuotas del diferido no es valido';
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

    -- Valida que el numero de cuotas sea mayor a 0
    if (inuNumeroCuotas < pkBillConst.CERO) then
      Pkg_Error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuNUM_CUOTAS_NO_VALIDO||'-'||csbNUM_CUOTAS_NO_VALIDO);
    end if;
    -- Valida el numero de cuotas contra el rango de cuotas del plan
    pkDeferredMgr.ValInstallNumRange(inuPlan, inuNumeroCuotas);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValPaymentsNumber;

  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValIntPercent
      Descripcion : Valida el porcentaje de interes del diferido
        Validate Interest Percentage
      Parametros  :   Descripcion
    inuPorcInteres  Porcentaje de Interes
      Retorno :
      Autor : cquinter
      Fecha : 28-ABR_1999
      Historia de Modificaciones
      Fecha Autor Modificacion
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
  */
  PROCEDURE ValIntPercent(inuPorcInteres in diferido.difeinte%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValIntPercent'; --Nombre del método en la traza
    -- El % de interes del diferido no esta entre 0 y 100
    cnuPORCENTAJE_NO_VALIDO constant number := 9513;
    csbPORCENTAJE_NO_VALIDO CONSTANT VARCHAR2(100) := 'El porcentaje de interes del diferido debe estar entre 0 y 100%';
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

    -- Valida que el porcentaje este entre 0 y 100
    if (inuPorcInteres < pkBillConst.CERO or
       inuPorcInteres > pkBillConst.CIENPORCIEN) then
       pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,cnuPORCENTAJE_NO_VALIDO||'-'||csbPORCENTAJE_NO_VALIDO);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValIntPercent;

  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValDeferredDate
      Descripcion : Valida la fecha del diferido
        Validate Deferred Date
      Parametros  :   Descripcion
    inuPlan   Plan del diferido
      Retorno :
      Autor : cquinter
      Fecha : 28-ABR-1999
      Historia de Modificaciones
      Fecha Autor     Modificacion
      10-11-2009  jradaSAO106096
      Se elimina el uso del mensaje OPF-SAT-9628.  Se elimina validacion de que
      la fecha del diferido no sea menor a la fecha inicial de movimientos del
      periodo de facturacion.
      22-AGO-2000 fmanrique   Cambia el primary key de perifact
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
            igualmente el acceso a primer nivel.
      15.jun.2000 Caq     Se adiciona parametro Plan de diferido. Se
            valida que la fecha de los diferidos se
            encuentre dentro del rango de fechas del plan.
      04-Sep-1999 jcastro     Se incluye la validacion de que la Fecha de la
            Financiacion no sea menor a la Fecha Actual del
            sistema. Y se cambia la validacion contra la Fecha
            Inicial del Periodo current a ser contra la Fecha
            Inicial de Movimientos. Open Cali.
  */
  PROCEDURE ValDeferredDate(inuPlan in plandife.pldicodi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValDeferredDate'; --Nombre del método en la traza
    -- Fecha menor que la Fecha Actual del sistema
    cnuFECHA_MENOR_ACTUAL constant number := 9627;
    csbFECHA_MENOR_ACTUAL CONSTANT VARCHAR2(100) := 'La Fecha digitada no puede ser menor a la Fecha Actual del sistema';
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida si la fecha es nula
    if (dtgFecha is null) then
      -- Asigna fecha actual
      dtgFecha := dtgProceso;
    end if;
    -- Valida que la Fecha no sea menor a la actual
    if (dtgFecha < trunc(dtgProceso)) then
      Pkg_Error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuFECHA_MENOR_ACTUAL||'-'||csbFECHA_MENOR_ACTUAL);
    end if;
    -- Valida ano 2000
    pkGeneralServices.ValDateY2K(dtgFecha);
    -- Valida que la fecha del diferido se encuentre dentro del rango de
    -- fechas del plan del diferido
    pkDeferredMgr.ValRangeDefDate(inuPlan, dtgFecha);
    -- Accesa el periodo current
    pkBillingPeriodMgr.AccCurrentPeriod(nugCiclo,
                                        nugAno,
                                        nugMes,
                                        nugPeriodo);
    -- Valida que el periodo exista
    pktblPeriFact.AccKey(nugPeriodo);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValDeferredDate;

  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValBackDocument
      Descripcion : Valida el documento de soporte del diferido
        Validate Back Document
      Parametros  :   Descripcion
    isbDocumento  Documento de soporte de la operacion
      Retorno :
      Autor : cquinter
      Fecha : 28-ABR-1999
      Historia de Modificaciones
      Fecha Autor Modificacion
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
  */
  PROCEDURE ValBackDocument(isbDocumento in diferido.difenudo%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValBackDocument'; --Nombre del método en la traza
    -- El documento de soporte es nulo
    cnuDOCUMENTO_NULO constant number := 9507;
    csbDOCUMENTO_NULO CONSTANT VARCHAR2(100) := 'El documento de soporte no puede ser nulo';
  BEGIN
     pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (nugSimulate = constants_per.CSBSI) then
      return;
    END if;
    -- Valida que el documento de soporte no sea nulo
    if (isbDocumento is null) then
      pkg_error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuDOCUMENTO_NULO||'-'||csbDOCUMENTO_NULO);
      raise PKG_ERROR.CONTROLLED_ERROR;
    end if;
    -- Valida si el documento de soporte tiene solo espacios
    if (length(ltrim(rtrim(isbDocumento))) is null) then
      pkg_error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuDOCUMENTO_NULO||'-'||csbDOCUMENTO_NULO);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValBackDocument;

  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValidatePlan
      Descripcion : Valida el plan de diferido
                      Validate Plan
      Parametros  :   Descripcion
    inuPlan   Codigo del plan de diferido
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : Junio 15 del 2000
      Historia de Modificaciones
      Fecha Autor Modificacion
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
      24-Dic-2001 mgutierrezOP8954
      Se adiciona tasas de Interes, Spread y Cuotas extras
  */
  PROCEDURE ValidatePlan(inuPlan in plandife.pldicodi%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValidatePlan'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida si el codigo del plan es nulo
    pkDeferredPlanMgr.ValidateNull(inuPlan);
    -- Valida si el plan existe en BD
    nugTasaInte := pktblPlandife.fnuGetInterestRateCod(inuPlan);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValidatePlan;

  PROCEDURE CheckFinanceIVA(inuProductId in servsusc.sesunuse%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'CheckFinanceIVA'; --Nombre del método en la traza
    blFuncEnterpriseTaxFinan boolean;
    nuProductEnterPrise      sistema.sistcodi%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Obtiene la empresa del funcionario
    GetParametros;
    -- La empresa del funcionario no financia IVA
    blFuncEnterpriseTaxFinan := (cc_bcfinancing.fsbFinIVAEnterprise(nugFunctionaryEnterprise) =
                                constants_per.CSBSI);
    if not blFuncEnterpriseTaxFinan then
      blgFinanciarIVA := FALSE;
      pkg_traza.trace('La empresa del funcionario no financia IVA', pkg_traza.cnuNivelTrzDef);
      return;
    END if;
    -- La financiacion del IVA la define la empresa dueña del producto
    nuProductEnterprise := cc_bcfinancing.fnuProductEnterprise(inuProductId);
    blgFinanciarIVA := (cc_bcfinancing.fsbFinIVAEnterprise(nuProductEnterprise) =
                       constants_per.CSBSI);
    if blgFinanciarIVA then
      pkg_traza.trace('Se financiara IVA para el producto ' || inuProductId,pkg_traza.cnuNivelTrzDef);
    else
      pkg_traza.trace('No se financiara IVA para el producto ' ||
                     inuProductId,
                     pkg_traza.cnuNivelTrzDef);
    END if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END CheckFinanceIVA;
  /*
      Propiedad intelectual de Open Systems (c).
      Procedure : ValFinanPercentage
      Descripcion : Valida el porcentaje a financiar de la deuda
                      Validate Financing Percentage
      Parametros  :   Descripcion
    inuPorcAFinanciar Porcentaje de la deuda que se va a financiar
      Retorno :
      Autor : cquinter
      Fecha : 28-ABR-1999
      Historia de Modificaciones
      Fecha Autor Modificacion
    --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
  */
  PROCEDURE ValFinanPercentage(inuPorcAFinanciar in number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValFinanPercentage'; --Nombre del método en la traza
    -- El porcentaje de deuda a financiar esta errado
    cnuPORC_FINANCIAR_ERRADO constant number := 9566;
    csbPORC_FINANCIAR_ERRADO CONSTANT VARCHAR2(100) := 'El porcentaje de deuda a financiar debe ser mayor que cero y menor o igual al 100%';
  BEGIN
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida que el porcentaje a financiar de la deuda este entre 0 y 100
    if (inuPorcAFinanciar <= pkBillConst.CERO or
       inuPorcAFinanciar > pkBillConst.CIENPORCIEN) then
      pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,cnuPORC_FINANCIAR_ERRADO||'-'||csbPORC_FINANCIAR_ERRADO);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValFinanPercentage;

  PROCEDURE ValSubscriber IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValSubscriber'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida si el codigo de la suscripcion es nulo
    pkSubscriberMgr.ValidateNull(nugSuscripcion);
    -- Valida si el codigo de la suscripcion es -1
    pkSubscriberMgr.ValidateNullApp(nugSuscripcion);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValSubscriber;

  PROCEDURE ValServiceNumber(inuNumServ            in servsusc.sesunuse%type,
                             isbSimulate           in varchar2,
                             isbIgnoreClaimRequest in varchar2) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValServiceNumber'; --Nombre del método en la traza
    /* Tipo de solicitud financiacion */
    nuFinancingPackageType ps_package_type.package_type_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuNumServ'|| to_char(inuNumServ) ,pkg_traza.cnuNivelTrzDef);

    -- Valida numero de servicio
    pkServNumberMgr.ValBasicData(inuNumServ);
    -- Evita algunas validaciones cuando esta simulando la financiacion
    if (isbSimulate = constants_per.CSBNO) then

      -- Validaciones que no aplican cuando la financiacion
      -- se ejecuta desde un estado de Espera (Ej.Espera-pago)
      if (isbIgnoreClaimRequest = constants_per.CSBNO) then
        pkg_traza.Trace('Se realizaran validaciones para estados que no son de espera',
                       pkg_traza.cnuNivelTrzDef);
        -- Valida que el producto no tenga financiaciones en proceso
        CC_BCWaitforpayment.ValFinReqInProccess(inuNumServ);
        -- Valida que el servicio suscrito no tenga reclamos en tramite
        pkg_traza.Trace('Validando que el producto no tenga reclamos en tramite',
                       pkg_traza.cnuNivelTrzDef);
        -- pkServNumberMgr.ValWithoutClaim( inuNumServ );
        -- Valida que el producto no tenga bloqueo para financiaciacion
        pkg_traza.Trace('Validando que el contrato no se encuentre bloqueado para financiaciones',
                       pkg_traza.cnuNivelTrzDef);
        /* Obtiene el tipo de solicitud financiacion de deuda */
        nuFinancingPackageType := ps_bopackagetype.fnuGetPackTypeByTagName(ps_bopackagetype.csbP_FINANCING_DEBT);
        /* Valida si existen impedimento para financiar el contrato */
        CC_BORestriction.valExistRestByPackType(inuSubscription_id => pkg_bcproducto.fnucontrato(inuNumServ),
                                                inuProduct_type_id => null,
                                                inuMotive_type_id  => null,
                                                inuPackage_type_id => nuFinancingPackageType);
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValServiceNumber;

  PROCEDURE ValCancelMinPercByProd(inuSuscripc  in diferido.difesusc%type,
                                   inuProductId in diferido.difenuse%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValCancelMinPercByProd'; --Nombre del método en la traza
    nuServNumber diferido.difenuse%type;
    nuCodeFinanc diferido.difecofi%type;
    --nuFinDebtBalPercent   number;
    nuMINCANCELDEBTTOFIN number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    GetParametros;
    pkGeneralServices.TraceData('Validando minimo porcentaje cancelado');
    nuServNumber := pkConstante.NULLNUM;
    nuCodeFinanc := pkConstante.NULLNUM;
    -- Obtiene el parametro de porcentaje minimo de cancelacion de deuda
    -- de financiaciones en curso
    -- para poder financiar.
    nuMINCANCELDEBTTOFIN := cc_bcfinancing.fnuMinPercCancelDebtToFinanc(inuProductId);
    pkGeneralServices.TraceData('Valor parametro del sistema maximo porcentaje de deuda permitido para poder financiar ' ||
                                nuMINCANCELDEBTTOFIN);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValCancelMinPercByProd;

  PROCEDURE ValInputData(inuNumServ            in diferido.difenuse%type,
                         inuPlan               in diferido.difepldi%type,
                         inuPorcInteres        in diferido.difeinte%type,
                         inuNumeroCuotas       in diferido.difenucu%type,
                         isbDocumento          in diferido.difenudo%type,
                         inuPorcAFinanciar     in number,
                         ichIVAUnaCuota        in char,
                         inuSpread             in diferido.difespre%type,
                         isbPrograma           in procesos.proccodi%type,
                         isbSimulate           in varchar2,
                         isbIgnoreClaimRequest in varchar2) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValInputData'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida el numero de servicio
    ValServiceNumber(inuNumServ, isbSimulate, isbIgnoreClaimRequest);
    -- Obtiene la suscripcion asociada al numero de servicio
    nugSuscripcion := pkg_bcproducto.fnucontrato(inuNumServ);
    -- Obtiene el Saldo pendiente del numero de servicio
    nugVlrDeuda := pkBCCuencobr.fnuGetOutStandBal(inuNumServ);
    -- Valida la suscripcion
    ValSubscriber;
    -- Valida el porcentaje a financiar de la deuda
    ValFinanPercentage(inuPorcAFinanciar);
    -- Valida los conceptos del servio suscrito
    -- Se modifica para .net, teniendo en cuenta que puede seleccionarse
    -- uno algunos o todos los conceptos, entonces no se utiliza el
    -- parametro -1, para indicar todos los conceptos,
    -- sino que se recorre todos los conceptos seleccionados.
    ValConcepts(inuNumServ);
    -- Valida el plan de diferido
    ValidatePlan(inuPlan);
    -- Determina si para el producto se financia IVA
    CheckFinanceIVA(inuNumServ);
    -- Valida el documento de soporte
    ValBackDocument(isbDocumento);
    -- Obtiene el ciclo de facturacion de la suscripcion
    nugCiclo := pkg_bccontrato.fnuCicloFacturacion(nugSuscripcion);
    -- Valida la fecha del Diferido
    ValDeferredDate(inuPlan);
    -- Valida el porcentaje de interes
    ValIntPercent(inuPorcInteres);
    -- Valida el numero de cuotas
    ValPaymentsNumber(inuPlan, inuNumeroCuotas);
    -- Valida el flag de financiacion de IVA a una cuota
    ValFlagOnePayIVA(ichIVAUnaCuota);
    -- Valida el metodo de calculo de cuota del diferido
    ValPaymentMethod;
    -- Valida Spread dado
    pkDeferredPlanMgr.ValidateSpread(inuPlan, inuSpread);
    -- Configura manejo de porcentaje de interes y el spread
    pkDeferredMgr.ValInterestSpread(nugMetodo,
                                    nugPorcInteres,
                                    nugSpread,
                                    nugPorIntNominal);
    -- Valida el Factor Gradiente
    pkDeferredMgr.ValGradiantFactor(inuPlan,
                                    nugMetodo,
                                    nugPorcInteres + nugSpread,
                                    inuNumeroCuotas,
                                    nugFactor);
    -- Valida el programa desde donde se ejecuta el package
    ValProgramName(isbPrograma);
    -- Valida el maximo porcentaje de deuda que puede tener el
    -- producto para financiar
    ValCancelMinPercByProd(nugSuscripcion, inuNumServ);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValInputData;

  FUNCTION SearchCharge(inuCuencobrId in cuencobr.cucocodi%type,
                        inuConceptId  in concepto.conccodi%type,
                        inuProductId  in cargos.cargnuse%type,
                        isbDocSupport in cargos.cargdoso%type) RETURN number IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'SearchCharge'; --Nombre del método en la traza
    rcCharge    mo_tyobCharges;
    nuIdxCharge number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuConceptId:'||inuConceptId || ', inuCuencobrId:' ||inuCuencobrId ||
                    ', isbDocSupport:' ||isbDocSupport|| ', inuProductId:' || inuProductId || ')]',
                    pkg_traza.cnuNivelTrzDef);

    nuIdxCharge := tbgCharges.first;
    loop
      EXIT WHEN(nuIdxCharge IS NULL);
      rcCharge := tbgCharges(nuIdxCharge);
      if (rcCharge.BILL_ACCOUNT_ID = inuCuencobrId AND
         rcCharge.CONCEPT_ID = inuConceptId AND
         rcCharge.PRODUCT_ID = inuProductId AND
         rcCharge.DOCUMENT_SUPPORT = isbDocSupport) THEN
         pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
        return nuIdxCharge;
      END if;
      nuIdxCharge := tbgCharges.NEXT(nuIdxCharge);
    END loop;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    -- Si no encontro cargo retorna null.
    return null;

  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END SearchCharge;

  FUNCTION fblAccountInMem(inuCta in cuencobr.cucocodi%type) RETURN boolean IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fblAccountInMem'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (tbCuenta.exists(TO_CHAR(inuCta))) then
      return(true);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return(false);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fblAccountInMem;

  PROCEDURE AddCharge(inuConc        in concepto.conccodi%type,
                      inuValor       in cargos.cargvalo%type,
                      isbSigno       in cargos.cargsign%type,
                      isbPrograma    in procesos.proccodi%type,
                      inuEstadoCta   in factura.factcodi%type,
                      isbDocSupport  in cargos.cargdoso%type,
                      isbIsDiscount  in cc_tmp_bal_by_conc.is_discount%type default 'N',
                      inuDiscPercent in cc_tmp_bal_by_conc.discount_percentage%type default 0.0,
                      inuCauseCharge in cargos.cargcaca%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AddCharge'; --Nombre del método en la traza
    rcCharge    mo_tyobCharges;
    nuIdxCharge number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuConc: '||inuConc || ', inuValor:' ||inuValor ||
                    ', isbSigno:' ||isbSigno,pkg_traza.cnuNivelTrzDef);

    -- Se verifica que el valor del cargo sea mayor a cero(0)
    if (abs(inuValor) > 0) then
      -- Busca en coleccion de cargos para verificar si ya existe un registro
      -- para el mismo concepto, cuenta y diferido. Si existe se acumula el
      -- valor para no crear varios registros para el mismo concepto.
      nuIdxCharge := SearchCharge(nugCuenta,
                                  inuConc,
                                  nugNumServ,
                                  isbDocSupport);
      pkg_traza.trace('Indice de busqueda: ' || nuIdxCharge, 10);
      if (nuIdxCharge IS not null) then
        rcCharge := tbgCharges(nuIdxCharge);
        -- Si tienen el mismo signo se suman los valores
        if (rcCharge.SIGN_ = isbSigno) then
          rcCharge.CHARGE_VALUE := rcCharge.CHARGE_VALUE + abs(inuValor);
          -- Sino se restan y se deja el signo del mayor.
        else
          if (rcCharge.CHARGE_VALUE >= abs(inuValor)) then
            rcCharge.CHARGE_VALUE := rcCharge.CHARGE_VALUE - abs(inuValor);
          else
            rcCharge.CHARGE_VALUE := rcCharge.CHARGE_VALUE - abs(inuValor);
            rcCharge.SIGN_        := isbSigno;
          END if;
        END if;
        tbgCharges(nuIdxCharge) := rcCharge;
      else
        rcCharge := mo_tyobCharges(nugCuenta, --cargcuco -- BILL_ACCOUNT_ID
                                   nugNumServ, --cargnuse -- PRODUCT_ID
                                   pkg_bcproducto.fnuTipoProducto(nugNumServ), -- PRODUCT_TYPE_ID --cargserv
                                   inuConc, --cargconc -- CONCEPT_ID
                                   inuCauseCharge, --cargcaca -- CHARGE_CAUSE
                                   isbSigno, --cargsign -- SIGN_
                                   nugPeriodo, --cargpefa -- BILLING_PERIOD
                                   abs(inuValor), --cargvalo -- CHARGE_VALUE
                                   isbDocSupport, --cargdoso -- DOCUMENT_SUPPORT
                                   pkBillConst.CERO, --cargcodo -- DOCUMENT_ID
                                   pkBillConst.POST_FACTURACION, --cargtipr -- PROCESS_TYPE
                                   pkBillConst.CERO, --cargunid -- UNITS
                                   dtgProceso, --cargfecr -- CREATION_DATE
                                   isbPrograma, --cargprog -- PROGRAM
                                   NULL, --CALL_SEQUENCE
                                   NULL, --OUTSIDER_MONEY_VALUE
                                   NULL, --BALANCE
                                   NULL, --ORIGINAL_BALANCE
                                   NULL, --LIST_DIST_CREDITS
                                   nuIdxCarg, --ROW_NUMBER_ -- Secuencia en la coleccion de cargos
                                   isbIsDiscount,
                                   inuDiscPercent,
                                   sbgUser --cargusua -- USERNAME
                                   );
        -- Adiciona cargo a tabla en memoria
        tbgCharges.extend;
        tbgCharges(nuIdxCarg) := rcCharge;
        nuIdxCarg := tbgCharges.count + 1;
      END if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END;
  PROCEDURE AddAccountToMem(inuCta     in cuencobr.cucocodi%type,
                            inuNumServ in cuencobr.cuconuse%type,
                            inuBill    in cuencobr.cucofact%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AddAccountToMem'; --Nombre del método en la traza
    sbCta      varchar2(20);
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuCta:'|| inuCta || ', inuNumServ: ' ||inuNumServ,
                    pkg_traza.cnuNivelTrzDef);

    sbCta := to_char(inuCta);
    tbCuenta(sbCta).cucocodi := inuCta;
    tbCuenta(sbCta).cuconuse := inuNumServ;
    tbCuenta(sbCta).cucofact := inuBill;
    tbCuenta(sbCta).sbCancAjus := NULL;
    tbCuenta(sbCta).nuCancVlrA := 0;
    tbCuenta(sbCta).sbAjuste := NULL;
    tbCuenta(sbCta).nuAjuste := 0;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END AddAccountToMem;

  PROCEDURE AddRecAccoTable(inuAccount in cuencobr.cucocodi%type,
                            inuNumServ in cuencobr.cuconuse%type,
                            inuBill    in cuencobr.cucofact%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AddRecAccoTable'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Evalua si la cuenta ya existe en la tabla en memoria
    if (fblAccountInMem(inuAccount)) then
      return;
    end if;
    -- Adiciona cuenta a tabla en memoria
    AddAccountToMem(inuAccount, inuNumServ, inuBill);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END AddRecAccoTable;

  PROCEDURE ValInterestConcept(inuConc in concepto.conccodi%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValInterestConcept'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida si el codigo del concepto es nulo
    pkConceptMgr.ValidateNull(inuConc);
    -- Valida si el concepto existe en BD
    pktblConcepto.AccKey(inuConc);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValInterestConcept;

  PROCEDURE GetExtraPayTotal(inuExtraPayNumber in number,
                             onuExtraPayValue  out number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetExtraPayTotal'; --Nombre del método en la traza
    nuIndex number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuExtraPayNumber:'||inuExtraPayNumber,pkg_traza.cnuNivelTrzDef);
    onuExtraPayValue := 0;
    if (nvl(tbExtraPayment.count, 0) = 0) then
      return;
    END if;
    nuIndex := tbExtraPayment.FIRST;
    loop
      exit when nuIndex is null;
      if (tbExtraPayment(nuIndex).ExtraPayNumber = inuExtraPayNumber) then
        onuExtraPayValue := onuExtraPayValue + tbExtraPayment(nuIndex)
                           .extraPayValue;
      END IF;
      nuIndex := tbExtraPayment.next(nuIndex);
    END loop;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetExtraPayTotal;

  PROCEDURE FillAditionalInstalments(inuValorDife  in diferido.difevatd%type,
                                     isbSigno      in diferido.difesign%type,
                                     ichIVA        in char,
                                     iblLastRecord in boolean) IS
     csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'FillAditionalInstalments'; --Nombre del método en la traza
    -- Variables Locales
    /* ***************************************************************** */
    /* ********           Procedimientos Encapsulados           ******** */
    /* ***************************************************************** */
    /* -------------------------------------------------------------- */
    /*
    Procedure       :       LoadInstalments
    Descripcion     :       Carga Cuotas
          Load Instalments
      */
    PROCEDURE LoadInstalments IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.LoadInstalments';
      nuIndex    number;
      nuVlrCuota cuotextr.cuexvalo%type;
      rcCuotExtr cuotextr%rowtype;
      rcExtraPayments mo_tyobExtraPayments;
      nuQuotaNumber number;
      nuTotCuotaNumber number;
      nuSigno number;
      nuAcumCuotExtr cuotextr.cuexvalo%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      /* Se establece el signo de la cuota */
      nuSigno := pkBillConst.cnuSUMA_CARGO;
      if (isbSigno = pkBillConst.CREDITO) then
        nuSigno := pkBillConst.cnuRESTA_CARGO;
      end if;
      nugTotCuotaExt := nvl(nugTotCuotaExt, pkBillConst.CERO);
      nugNumCuotaExt := nvl(nugNumCuotaExt, pkBillConst.CERO);
      -- Valida si hay Valor a distribuir
      if (nugTotCuotaExt = pkBillConst.CERO) then
        pkg_traza.Trace('No hay cuotas extras a distribuir para el producto ' ||
                       to_char(nugNumServ),
                       pkg_traza.cnuNivelTrzDef);
        return;
      end if;
      -- Guarda como numero de diferido la posicion del diferido
      -- en el arreglo de memoria
      rcCuotExtr.cuexdife := nuIdxDife;
      rcCuotExtr.cuexcobr := constants_per.CSBNO;
      /* Se procesan las cuotas extra */
      nuIndex := tbExtraPayment.first;
      while (nuIndex is not null) loop
        nuQuotaNumber := tbExtraPayment(nuIndex).ExtraPayNumber;
        /* Se verifica que el valor total a financiar no sea igual al valor
        a financiar del IVA */
        if (nugVlrFinTotal = nugVlrFinIva) then
          /* Error: Error en la configuracion de la cuota normal del diferido           */
            pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,cnuERROR_CUOTA||'-'||csbERROR_CUOTA);
        end if;
        /* Calcula el valor proporcional de cuota extra */
        nuVlrCuota := tbExtraPayment(nuIndex).ExtraPayValue;
        nuVlrCuota := nuVlrCuota * inuValorDife /
                      (nugVlrFinTotal - nugVlrFinIva);
        /* Se aplica la politica de redondeo sobre el valor de la cuota
        extra calculado */
        FA_BOPoliticaRedondeo.AplicaPolitica(nugNumServ, nuVlrCuota);
        rcCuotExtr.cuexvalo := nuVlrCuota;
        -- Actualiza acumuladores por numero de cuota.
        if tbgAcumExtraPay.exists(nuQuotaNumber) then
          tbgAcumExtraPay(nuQuotaNumber) := tbgAcumExtraPay(nuQuotaNumber) +
                                            nuSigno * rcCuotExtr.cuexvalo;
        else
          tbgAcumExtraPay(nuQuotaNumber) := nuSigno * rcCuotExtr.cuexvalo;
        end if;
        rcCuotExtr.cuexnume := tbExtraPayment(nuIndex).ExtraPayNumber;
        -- Si se trata de la ultima cuota extra del ultimo diferido
        -- Ajusta el valor en caso de que haya diferencia
        -- respecto del acumulado.
        nuAcumCuotExtr := tbgAcumExtraPay(nuQuotaNumber);
        if iblLastRecord then
          GetExtraPayTotal(nuQuotaNumber, nuTotCuotaNumber);
          if (nuAcumCuotExtr <> nuTotCuotaNumber) and
             (abs(nuAcumCuotExtr - nuTotCuotaNumber) < cnuValorTopeAjuste) then
            pkg_traza.trace('Ajuste de la cuota extra #' || nuQuotaNumber,
                           pkg_traza.cnuNivelTrzDef);
            nuVlrCuota := rcCuotExtr.cuexvalo +
                          (nuTotCuotaNumber - nuAcumCuotExtr);
            pkg_traza.trace('Valor Cuota extra=' || rcCuotExtr.cuexvalo ||
                           '+ (' || nuTotCuotaNumber || '-' ||
                           nuAcumCuotExtr || ') =>' || nuVlrCuota,
                           pkg_traza.cnuNivelTrzDef);
            rcCuotExtr.cuexvalo := nuVlrCuota;
          end if;
        END if;
        pkg_traza.Trace('Numero cuota extra -> [' || to_char(nuQuotaNumber) || ']',
                       pkg_traza.cnuNivelTrzDef);
        pkg_traza.Trace('Valor cuota extra  -> [' ||
                       to_char(rcCuotExtr.cuexvalo) || ']',
                       pkg_traza.cnuNivelTrzDef);
        -- Carga las cuotas Cuotas extras para calculos por Diferido
        pkAditionalPaymentMgr.AddRecord(rcCuotExtr);
        -- Guarda las cuotas Cuotas extras proporcionales en memoria
        rcExtraPayments := mo_tyobExtraPayments(rcCuotExtr.cuexdife, -- "CUEXDIFE"
                                                rcCuotExtr.cuexnume, -- "CUEXNUME"
                                                rcCuotExtr.cuexvalo, -- "CUEXVALO"
                                                rcCuotExtr.cuexcobr, -- "CUEXCOBR"
                                                null -- "CUEXCODO"
                                                );
        tbgExtraPayments.extend;
        nuIdxExtr := tbgExtraPayments.count;
        tbgExtraPayments(nuIdxExtr) := rcExtraPayments;
        nuIndex := tbExtraPayment.next(nuIndex);
      end loop;
      pkg_traza.Trace('Fin: [CC_BOFinancing.FillAditionalInstalments.LoadInstalments]',
                     pkg_traza.cnuNivelTrzDef);
       pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR  then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END LoadInstalments;
    /* -------------------------------------------------------------- */
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Limpia memoria de Cuotas Extras */
    pkAditionalPaymentMgr.ClearMemory;
    /* Si el diferido es de IVA, no se procesa */
    if (ichIVA = constants_per.CSBSI) then
      return;
    end if;
    /* Calcula el valor de cada cuota extra para el diferido de manera
    proporcional */
    LoadInstalments;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END FillAditionalInstalments;


  PROCEDURE CreateDeferred(inuFinanceCode        in diferido.difecofi%type,
                           inuSubscriptionId     in diferido.difesusc%type,
                           inuConc               in concepto.conccodi%type,
                           inuValor              in diferido.difevatd%type,
                           inuNumCuotas          in diferido.difenucu%type,
                           isbDocumento          in diferido.difenudo%type,
                           isbPrograma           in diferido.difeprog%type,
                           inuPorIntNominal      in diferido.difeinte%type,
                           ichIVA                in varchar2 default csbNO,
                           inuPorcInteres        in diferido.difeinte%type default NULL,
                           inuTasaInte           in diferido.difepldi%type default NULL,
                           inuSpread             in diferido.difespre%type default NULL,
                           inuConcInteres        in diferido.difecoin%type default NULL,
                           isbFunciona           in funciona.funccodi%type default NULL,
                           isbSrcConceptInterest in varchar2 default csbNO,
                           iblLastRecord         in boolean default FALSE,
                           isbSimulate           in varchar2 default constants_per.CSBSI --  Simular (S|N)
                           ) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'CreateDeferred'; --Nombre del método en la traza
    nuFincCode         number; --codigo de financiacion.
    nuValorDife        diferido.difevatd%type; -- Valor diferido
    nuValorCuota       diferido.difevacu%type; -- Valor de la cuota
    nuConcInteres      concepto.conccodi%type; -- Concepto de Interes
    sbSignoDife        diferido.difesign%type; -- Signo diferido
    nuSgOper           number(1); -- Signo operacion acumulativa
    nuLocPorcInteres   diferido.difeinte%type; -- Porcentaje de interes
    nuLocPorIntNominal diferido.difeinte%type; -- Porcentaje Nominal
    nuLocTasaInte      diferido.difepldi%type; -- Codigo Tasa Interes
    nuLocSpread        diferido.difespre%type; -- Valor del Spread
    nuVlr              number;
    nuNumCuotas  diferido.difevacu%type; -- Numero de cuotas
    blAjuste     boolean;
    nuFactAjuste timoempr.tmemfaaj%type;
    /* -------------------------------------------------------------- */
    /*
    Procedure : FillDefMemTab
    Descripcion : Llena la Tabla de memoria de Diferidos
              Fill Deferred Memory Table
      */
    PROCEDURE FillDefMemTab IS
      csbSubmtd      CONSTANT VARCHAR2(100) := csbMetodo||'.FillDefMemTab';
      rcDeferred     mo_tyobdeferred;
      nuDeferredCode diferido.difecodi%type;
      nuSigno        number;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      pkg_traza.Trace('Se marcara temporalmente el diferido con codigo [' ||
                     nuIdxDife || ']',
                     pkg_traza.cnuNivelTrzDef);
      rcDeferred := mo_tyobdeferred(nuIdxDife, -- "DIFECODI"
                                    inuConc, -- "DIFECONC"
                                    nuValorDife, -- "DIFEVATD"
                                    pkBillConst.CERO, -- "DIFECUPA"  -- OJO no son cuotas pagadas, son cuotas cobradas
                                    nuValorCuota, -- "DIFEVACU"
                                    nuNumCuotas, -- "DIFENUCU"
                                    nuValorDife, -- "DIFESAPE"
                                    isbDocumento, -- "DIFENUDO"
                                    nuLocPorcInteres, -- "DIFEINTE"
                                    pkBillConst.CERO, -- "DIFEINAC"
                                    sbgUser, -- "DIFEUSUA"
                                    sbgTerminal, -- "DIFETERM"
                                    sbSignoDife, -- "DIFESIGN"
                                    nugNumServ, -- "DIFENUSE"
                                    nugMetodo, -- "DIFEMECA"
                                    nuConcInteres, -- "DIFECOIN"
                                    isbPrograma, -- "DIFEPROG"
                                    nugPlan, -- "DIFEPLDI"
                                    dtgProceso, -- "DIFEFEIN"
                                    dtgProceso, -- "DIFEFUMO"
                                    nuLocSpread, -- "DIFESPRE"
                                    nuLocTasaInte, -- "DIFETAIN"
                                    nugFactor, -- "DIFEFAGR"
                                    nuFincCode, -- "DIFECOFI"
                                    sbTipoDiferido, -- "DIFETIRE"
                                    isbFunciona, -- "DIFEFUNC"
                                    null, -- "DIFELURE"
                                    pkBillConst.CERO, -- Numero de cuotas pagadas, debe calcularse mediante algun proceso con el distribuidor de pagos
                                    pkBillConst.CERO, -- Valor pagado, debe calcularse mediante algun proceso con el distribuidor de pagos
                                    pkBillConst.CERO, -- Cuotas vencidas calculadas
                                    pkBillConst.CERO, -- Valor cobrado del diferido y que todavia no se ha cancelado
                                    pkBillConst.CERO, -- Numero de cuotas cobradas y no pagadas todavia en su totalidad
                                    CONSTANTS_PER.CSBNO, -- Indica si el diferido es seleccionado
                                    null -- Posicion de la informacion dentro de una coleccion
                                    );
      tbgDeferred.extend;
      pkg_traza.Trace('Insertando diferido en memoria (' || nuIdxDife ||
                     ') valor = ' || nuValorDife,
                     pkg_traza.cnuNivelTrzDef);
      tbgDeferred(nuIdxDife) := rcDeferred;
      if (sbSignoDife = pkBillConst.DEBITO) then
        nuSigno := pkBillConst.cnuSUMA_CARGO;
      elsif (sbSignoDife = pkBillConst.CREDITO) then
        nuSigno := pkBillConst.cnuRESTA_CARGO;
      end if;
      -- Actualiza acumulador total de la financiacion
      pkg_traza.Trace('Acumulando valor de diferido ' ||
                     to_char(nuSigno * nuValorDife),
                     pkg_traza.cnuNivelTrzDef);
      nugAcumFinancing := nugAcumFinancing + nuSigno * nuValorDife;
      pkg_traza.Trace('Nuevo acumulado = ' || nugAcumFinancing,
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR  then
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.setError;
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END FillDefMemTab;

    /* -------------------------------------------------------------- */
    /*
    Procedure : FillTransDefMemTab
    Descripcion : Llena la Tabla de memoria de Mvmto. Diferido
              Fill Transaction Deferred Memory Table
      */
    PROCEDURE FillTransDefMemTab IS
      csbSubmtd      CONSTANT VARCHAR2(100) := csbMetodo||'.FillTransDefMemTab';
      /* Tipo de producto asociado al producto */
      nuProductType servicio.servcodi%type;
      /* Causa de cargo para el movimiento */
      nuChargeCause causcarg.cacacodi%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      /* Se obtiene el tipo de producto */
      nuProductType := pkg_bcproducto.fnuTipoProducto(nugNumServ);
      /* Se obtiene causa de cargo para paso a diferido (43) */
      nuChargeCause := FA_BOChargeCauses.fnuDeferredChCause(nuProductType);
      tbModi(nuIdxDife).modisusc := inuSubscriptionId;
      tbModi(nuIdxDife).modisign := sbSignoDife;
      tbModi(nuIdxDife).modifeca := dtgProceso;
      tbModi(nuIdxDife).modicuap := pkBillConst.CERO;
      tbModi(nuIdxDife).modivacu := nuValorDife;
      tbModi(nuIdxDife).modidoso := isbDocumento;
      tbModi(nuIdxDife).modicaca := nuChargeCause;
      tbModi(nuIdxDife).modifech := dtgProceso;
      tbModi(nuIdxDife).modiusua := sbgUser;
      tbModi(nuIdxDife).moditerm := sbgTerminal;
      tbModi(nuIdxDife).modiprog := isbPrograma;
      tbModi(nuIdxDife).modinuse := nugNumServ;
      tbModi(nuIdxDife).modidiin := pkBillConst.CERO;
      tbModi(nuIdxDife).modipoin := pkBillConst.CERO;
      tbModi(nuIdxDife).modivain := pkBillConst.CERO;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END FillTransDefMemTab;
    /* -------------------------------------------------------------- */
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

    pkg_traza.trace('inuFinanceCode        = ' || inuFinanceCode, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuConc               = ' || inuConc, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuValor              = ' || inuValor, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbDocumento          = ' || isbDocumento, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbPrograma           = ' || isbPrograma, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuPorIntNominal      = ' || inuPorIntNominal, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('ichIVA                = ' || ichIVA, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuPorcInteres        = ' || inuPorcInteres, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuTasaInte           = ' || inuTasaInte, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuSpread             = ' || inuSpread, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuConcInteres        = ' || inuConcInteres, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbFunciona           = ' || isbFunciona, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbSrcConceptInterest = ' || isbSrcConceptInterest, pkg_traza.cnuNivelTrzDef);
    if (iblLastRecord) then
      pkg_traza.Trace('iblLastRecord         = TRUE', pkg_traza.cnuNivelTrzDef);
    else
      pkg_traza.Trace('iblLastRecord         = FALSE', pkg_traza.cnuNivelTrzDef);
    end if;
    pkg_traza.Trace('isbSimulate           = ' || isbSimulate,
                   pkg_traza.cnuNivelTrzDef);
    pkg_traza.Trace(')', pkg_traza.cnuNivelTrzDef);
    -- codigo temporal del diferido que se generara
    nuIdxDife := tbgDeferred.count + 1;
    nuFincCode := inuFinanceCode;
    --Si el codigo de financiacion es null, se obtiene uno nuevo
    if (nvl(nuFincCode, pkBillConst.CERO) = pkBillConst.CERO) then
      pkDeferredMgr.nuGetNextFincCode(nuFincCode);
    end if;
    nugFinanCode := nuFincCode;
    ----------------------------------------------------------
    -- Averigua si se trata de un concepto de Interes
    if (nvl(isbSrcConceptInterest, csbNO) = csbYES) then
      pkg_traza.Trace('Se detecto concepto de interes, el interes para el diferido sera CERO',
                     pkg_traza.cnuNivelTrzDef);
      nuLocPorcInteres   := pkBillConst.CERO;
      nuLocTasaInte      := nugTasaInte;
      nuLocSpread        := pkBillConst.CERO;
      nuLocPorIntNominal := pkBillConst.CERO;
    else
      nuLocPorcInteres   := nvl(inuPorcInteres, nugPorcInteres);
      nuLocTasaInte      := nvl(inuTasaInte, nugTasaInte);
      nuLocSpread        := nvl(inuSpread, nugSpread);
      nuLocPorIntNominal := inuPorIntNominal;
    end if;
    -- Valor a diferir
    nuValorDife := abs(inuValor);
    -- Evalua si no hay valor a diferir
    if (nuValorDife = pkBillConst.CERO) then
      pkg_traza.Trace('Valor del diferido CERO, no sera creado',
                     pkg_traza.cnuNivelTrzDef);
      -- Como no crea diferido, actualiza la referencia de los cargos
      -- para que sea manejado mas adelante
      CC_BCFinancing.DeleteDeferredReference(nuIdxDife);
      -- Se restaura el indice global de diferidos
      nuIdxDife := tbgDeferred.count;
      return;
    end if;
    -- Establecer signo con el que se debe generar el diferido
    sbSignoDife := pkDeferredMgr.fsbGetDefSign(inuValor);
    -- Obtiene concepto de interes asociado al concepto
    -- solo si el parametro de concepto de interes es nulo
    if (inuConcInteres is NULL) then
      nuConcInteres := pktblConcepto.fnuGetInterestConc(inuConc);
    else
      nuConcInteres := inuConcInteres;
    end if;
    -- Valida el concepto de Interes
    ValInterestConcept(nuConcInteres);
    -- Determina el porcentaje de Interes de acuerdo al codigo del
    -- Concepto de Interes configurado
    if (nuConcInteres = pkBillConst.NULOSAT) then
      nuLocPorcInteres   := pkBillConst.CERO;
      nuLocTasaInte      := nugTasaInte;
      nuLocSpread        := pkBillConst.CERO;
      nuLocPorIntNominal := pkBillConst.CERO;
    end if;
    -- Adiciona cuotas extras a los diferidos que no corresponden
    -- a conceptos IVA
    FillAditionalInstalments(nuValorDife,
                             sbSignoDife,
                             ichIVA,
                             iblLastRecord);
    -- Se modifica DIFENUCU para valores menores al Valor Ajuste
    nuNumCuotas := inuNumCuotas;
    FA_BOPoliticaRedondeo.ObtienePoliticaAjuste(inuSubscriptionId,
                                                blAjuste,
                                                nuFactAjuste);
    if (nuValorDife <= nuFactAjuste) then
      nuNumCuotas  := 1;
      nuValorCuota := nuValorDife;
    end if;
    -- Calcula el valor de la cuota
    pkDeferredMgr.CalcPeriodPayment(nuValorDife,
                                    nuNumCuotas,
                                    nuLocPorIntNominal,
                                    nuLocPorcInteres,
                                    nuLocSpread,
                                    nugMetodo,
                                    nugFactor,
                                    nuValorCuota);
    pkg_traza.Trace('nuLocPorcInteres: ' || nuLocPorcInteres,
                   pkg_traza.cnuNivelTrzDef);
    pkg_traza.Trace('nuLocSpread: ' || nuLocSpread, pkg_traza.cnuNivelTrzDef);
    pkg_traza.Trace('nugMetodo: ' || nugMetodo, pkg_traza.cnuNivelTrzDef);
    pkg_traza.Trace('nugFactor: ' || nugFactor, pkg_traza.cnuNivelTrzDef);
    pkg_traza.Trace('nuValorCuota: ' || nuValorCuota, pkg_traza.cnuNivelTrzDef);
    pkg_traza.Trace('Diferido: ' || nuValorDife, pkg_traza.cnuNivelTrzDef);
    -- Valida el valor de la cuota con respecto a los intereses de la
    -- primera cuota
    pkg_traza.Trace('Validando cuota < intereses primera cuota...',
                   pkg_traza.cnuNivelTrzDef);
    nuVlr := nuValorDife;
    pkg_traza.Trace('? Cuota < Primer Interes ? => ? ' || nuValorCuota ||
                   ' < ' || to_char(nuVlr * nuLocPorIntNominal /
                                    pkBillConst.CIENPORCIEN) || ' ?',
                   pkg_traza.cnuNivelTrzDef);
    pkDeferredMgr.ValPayment(nugMetodo,
                             nuLocPorIntNominal,
                             nuValorCuota,
                             nuVlr);
    /* Se aplica la politica de redondeo sobre el valor de la cuota */
    FA_BOPoliticaRedondeo.AplicaPolitica(nugNumServ, nuValorCuota);
    /*Se incluye esta modificacion para tener en cuenta los valores de
    cuotas que despues del redondeo son cero para que queden en una cuota */
    if (nuValorCuota = 0) then
      nuNumCuotas  := 1;
      nuValorCuota := nuValorDife;
    end if;
    -- Adiciona diferido a tabla en memoria
    FillDefMemTab;
    -- Actualiza acumuladores
    nuSgOper := pkBillConst.cnuSUMA_CARGO;
    -- Evalua si el signo del diferido es credito
    if (sbSignoDife = pkBillConst.CREDITO) then
      nuSgOper := pkBillConst.cnuRESTA_CARGO;
    end if;
    -- Acumula valor de la cuota
    nugAcumCuota := nugAcumCuota + (nuValorCuota * nuSgOper);
    -- Adiciona movimiento de diferido a tabla en memoria
    FillTransDefMemTab;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END CreateDeferred;


  PROCEDURE ValDeferToRefinance(inuDeferred  in diferido.difecodi%type,
                                inuProductId in diferido.difenuse%type,
                                isbPrograma  in procesos.proccodi%type) IS
  csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValDeferToRefinance'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida que la forma se pueda ejecutar para el servicio y estado de corte
    -- del servicio suscrito
    pkBOProcessSecurity.ValidateProductSecurity(inuProductId, isbPrograma);
    --Valida el numero de refinanciaciones
    pkDeferred.ValNumRefinanc(inuDeferred);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValDeferToRefinance;

  PROCEDURE ChangeCondition(inuDeferred    in diferido.difecodi%type,
                            inuProductId   in diferido.difenuse%type,
                            inuFinanceCode in diferido.difecofi%type,
                            inuValor       in diferido.difevatd%type,
                            inuNumCuotas   in diferido.difenucu%type,
                            isbPrograma    in diferido.difeprog%type,
                            ichIVA         in char,
                            inuTasaInte    in diferido.difepldi%type,
                            inuSpread      in diferido.difespre%type,
                            inuConcInteres in diferido.difecoin%type,
                            isbFunciona    in funciona.funccodi%type,
                            iblLastRecord  in boolean) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ChangeCondition'; --Nombre del método en la traza
    nuErrorCode number;
    sbErrorMsg  varchar2(2000);
    -- Diferido con el cual se realizo el cambio de condiciones
    nuNumDife diferido.difecodi%type;
    sbSigno   diferido.difesign%type;
    chIVA     varchar2(1);
    -- Valores de tasa de interes y spread para el diferido
    nuPorcInteres diferido.difeinte%type;
    nuSpread      diferido.difespre%type;
    nuNumCuotas diferido.difevacu%type; -- Numero de cuotas
    rcTimoempr  timoempr%rowtype;
    /*
        Propiedad Intelectual de Open Systems International (c).
        Procedimiento: FillAdInstalments
        Descripcion : Adiciona las cuotas extras al Diferido
        Parametros  : Descripcion
        inuValorDife  Valor del Diferido
        inuSigno      Signo del Diferido
        ichIVA          Flag si el diferido es para el Iva
        iblLastRecord   Indica si se encuentra en la ultima cuenta de cobro
                           de un producto
        Retorno :
        Autor : Mauricio Gutierrez C.
        Fecha : 19 Diciembre 2001
        Historia de Modificaciones
        Fecha Autor Modificacion
         --14-MAY-05  cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
        09-Abr-2002 mgutierrSAO10553
        Se adiciona flag para no adicionar cuotas extras a diferido por IVA
        Limpia tabla de cuotas extras antes de cargar nuevas cuotas
        pkAditionalPaymentMgr.ClearMemory;
        19-Dic-2001 mgutierrezOP8954
        Creacion del procedimiento
    */
    PROCEDURE FillAdInstalments(inuValorDife  in diferido.difevatd%type,
                                isbSigno      in diferido.difesign%type,
                                ichIVA        in char,
                                iblLastRecord in boolean) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.FillAdInstalments';
      -- Variables Locales
      /* ************************************************************** */
      /* ********           Procedimientos Encapsulados        ******** */
      /* ************************************************************** */
      /* -------------------------------------------------------------- */
      /*
      Procedure       :       LoadInstalments
      Descripcion     :       Carga Cuotas
            Load Instalments
        */
      PROCEDURE LoadInstalments IS
        nuIndex          number;
        nuVlrCuota       cuotextr.cuexvalo%type;
        rcCuotExtr       cuotextr%rowtype;
        nuTotD           cuotextr.cuexvalo%type;
        rcExtraPayments  mo_tyobExtraPayments;
        nuQuotaNumber    number;
        nuTotCuotaNumber number;
        nuSigno          number;
        nuAcumCuotExtr   cuotextr.cuexvalo%type;
      BEGIN
        pkg_traza.trace(csbSubmtd||'.LoadInstalments',pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
        if isbSigno = 'DB' then
          nuSigno := 1;
        elsif isbSigno = 'CR' then
          nuSigno := -1;
        END if;
        nugTotCuotaExt := nvl(nugTotCuotaExt, pkBillConst.CERO);
        nugNumCuotaExt := nvl(nugNumCuotaExt, pkBillConst.CERO);
        -- Valida si hay Valor a distribuir
        if (nugTotCuotaExt = 0) then
          pkg_traza.trace('No hay cuotas extras a distribuir para el producto ' ||
                         nugNumServ,
                         pkg_traza.cnuNivelTrzDef);
          return;
        end if;
        -- Guarda como numero de diferido la posicion del diferido
        -- en el arreglo de memoria
        rcCuotExtr.cuexdife := nuIdxDife;
        rcCuotExtr.cuexcobr := 'N';
        nuTotD := nugTotCuotaExt * inuValorDife / nugVlrFinTotal;
        pkg_traza.trace('Vr de cuotas extras a distribuir en el diferido VlrTotCuotsParaProducto*ValorDife/VlrDiferir :' ||
                       nugTotCuotaExt || ' * ' || inuValorDife || ' / ' ||
                       nugVlrFinTotal || ' = ' || nuTotD,
                       pkg_traza.cnuNivelTrzDef);
        -- Prepara cuotas proporcionales
        nuIndex := tbExtraPayment.first;
        loop
          exit when nuIndex IS null;
          pkg_traza.trace('nuindex=' || nuIndex, pkg_traza.cnuNivelTrzDef);
          nuQuotaNumber := tbExtraPayment(nuIndex).ExtraPayNumber;
          pkg_traza.trace('Calculo del valor de la cuota extra #' ||
                         nuQuotaNumber,
                         pkg_traza.cnuNivelTrzDef);
          -- Calcula el valor proporcional de cuota extra
          nuVlrCuota := tbExtraPayment(nuIndex).ExtraPayValue;
          nuVlrCuota := nuVlrCuota * inuValorDife / nugVlrFinTotal;
          rcCuotExtr.cuexvalo := nuVlrCUota;
          pkg_traza.trace('Valor Cuota extra=' || tbExtraPayment(nuIndex)
                         .ExtraPayValue || ' * ' || inuValorDife || ' / ' ||
                         nugVlrFinTotal || '=' || rcCuotExtr.cuexvalo,
                         pkg_traza.cnuNivelTrzDef);
          -- Actualiza acumuladores por numero de cuota.
          if tbgAcumExtraPay1.exists(nuQuotaNumber) then
            tbgAcumExtraPay1(nuQuotaNumber) := tbgAcumExtraPay1(nuQuotaNumber) +
                                               nuSigno *
                                               rcCuotExtr.cuexvalo;
          else
            tbgAcumExtraPay1(nuQuotaNumber) := nuSigno *
                                               rcCuotExtr.cuexvalo;
          END if;
          rcCuotExtr.cuexnume := tbExtraPayment(nuIndex).ExtraPayNumber;
          -- Si se trata de la ultima cuota extra del ultimo diferido
          -- Ajusta el valor en caso de que haya diferencia
          -- respecto del acumulado.
          nuAcumCuotExtr := tbgAcumExtraPay1(nuQuotaNumber);
          if iblLastRecord then
            GetExtraPayTotal(nuQuotaNumber, nuTotCuotaNumber);
            if (nuAcumCuotExtr <> nuTotCuotaNumber) AND
               (abs(nuAcumCuotExtr - nuTotCuotaNumber) < cnuValorTopeAjuste) then
              pkg_traza.trace('Ajuste de la cuota extra #' || nuQuotaNumber,
                             pkg_traza.cnuNivelTrzDef);
              nuVlrCuota := rcCuotExtr.cuexvalo +
                            (nuTotCuotaNumber - nuAcumCuotExtr);
              pkg_traza.trace('Valor Cuota extra=' || rcCuotExtr.cuexvalo ||
                             '+ (' || nuTotCuotaNumber || '-' ||
                             nuAcumCuotExtr || ') =>' || nuVlrCuota,
                             pkg_traza.cnuNivelTrzDef);
              rcCuotExtr.cuexvalo := nuVlrCuota;
            end if;
          END if;
          -- Carga las cuotas Cuotas extras para calculos por Diferido
          pkAditionalPaymentMgr.AddRecord(rcCuotExtr);
          -- Guarda las cuotas Cuotas extras proporcionales en memoria
          rcExtraPayments := mo_tyobExtraPayments(rcCuotExtr.cuexdife, -- "CUEXDIFE"
                                                  rcCuotExtr.cuexnume, -- "CUEXNUME"
                                                  rcCuotExtr.cuexvalo, -- "CUEXVALO"
                                                  rcCuotExtr.cuexcobr, -- "CUEXCOBR"
                                                  null -- "CUEXCODO"
                                                  );
          tbgExtraPayments.extend;
          nuIdxExtr := tbgExtraPayments.count;
          tbgExtraPayments(nuIdxExtr) := rcExtraPayments;
          nuIndex := tbExtraPayment.next(nuIndex);
        end loop;
        pkg_traza.trace(csbSubmtd||'.LoadInstalments',pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      EXCEPTION
        WHEN PKG_ERROR.CONTROLLED_ERROR then
          pkg_traza.trace(csbSubmtd||'.LoadInstalments',pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
          raise PKG_ERROR.CONTROLLED_ERROR;
        when others then
          pkg_error.setError;
          pkg_traza.trace(csbSubmtd||'.LoadInstalments',pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
          raise PKG_ERROR.CONTROLLED_ERROR;
      END LoadInstalments;
      /* ------------------------------------------------------------------ */
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Limpia memoria de Cuotas Extras
      pkAditionalPaymentMgr.ClearMemory;
      if (ichIVA = constants_per.CSBSI) then
        return;
      end if;
      -- Carga Cuotas Extras
      LoadInstalments;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END FillAdInstalments;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkAditionalPaymentMgr.ClearMemory;
    -- Se establece el porcentaje de interes y el spread de acuerdo al concepto
    -- de interes configurado
    if (inuConcInteres = pkBillConst.NULOSAT) then
      nuPorcInteres := pkBillConst.CERO;
      nuSpread      := pkBillConst.CERO;
    else
      nuPorcInteres := nugPorcInteres;
      nuSpread      := inuSpread;
    end if;
    ValDeferToRefinance(inuDeferred, inuProductId, isbPrograma);
    -- Dummy requerido para que FillAditionalInstalments funcione
    chIVA := constants_per.CSBNO;
    sbSigno := pkDeferredMgr.fsbGetDefSign(inuValor);
    -- Adiciona cuotas extras
    FillAdInstalments(inuValor, sbSigno, ichIVA, iblLastRecord);
    -- Se modifica DIFENUCU para valores menores al Valor Ajuste
    nuNumCuotas := inuNumCuotas;
    FA_BOPoliticaRedondeo.ObtienePoliticaAjuste(inuProductId, rcTimoempr);
    if (inuValor <= rcTimoempr.tmemfaaj) then
      nuNumCuotas := 1;
    end if;
    -- Ejecuta el cambio de condiciones del diferido
    pkg_traza.trace('Ejecutando pkDeferred.RefinanDeferred(' || inuDeferred || ')',
                   pkg_traza.cnuNivelTrzDef);
    pkDeferred.RefinanDeferred(inuDeferred,
                               nugMetodo,
                               dtgFecha,
                               nuPorcInteres,
                               nuNumCuotas,
                               isbPrograma,
                               nugPlan,
                               inuTasaInte,
                               nuSpread,
                               inuFinanceCode,
                               isbFunciona,
                               nuNumDife,
                               nuErrorCode,
                               sbErrorMsg);
    nugAcumChCond := nugAcumChCond + inuValor;
    if nvl(nuErrorCode, 0) != 0 then
      pkg_traza.trace('nuErrorCode:'||nuErrorCode,pkg_traza.cnuNivelTrzDef);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    END if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ChangeCondition;

  PROCEDURE FinanDebtProcess(inuNumServ          in diferido.difenuse%type,
                             inuNumeroCuotas     in diferido.difenucu%type,
                             isbDocumento        in diferido.difenudo%type,
                             inuPorcAFinanciar   in number,
                             ichIVAUnaCuota      in char,
                             isbPrograma         in procesos.proccodi%type,
                             inuFinanCod         in diferido.difecofi%type,
                             isbFunciona         in funciona.funccodi%type default null,
                             isbSimulate         in varchar2,
                             isbChangeConditions in varchar2,
                             iblLastProduct      in boolean) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'FinanDebtProcess'; --Nombre del método en la traza
    nuNextFincCode number; --Codigo de financiacion co el que se generaran
    --los diferidos
    nuConcFinanCurr concepto.conccodi%type := NULL; -- Concepto de financ. current
    nuConcInteres   diferido.difecoin%type; -- Concepto de interes.
    nuVlrFinanCnc   number := 0; -- Valor a financiar del conc.
    nuPorcNomi      diferido.difeinte%type; -- Interes Nominal de Financ
    nuPorcInte      diferido.difeinte%type; -- Interes de Financiacion
    nuSpread        diferido.difespre%type; -- Valor del Spread
    bllastRecord boolean; -- Indica que esta en el ultimo registro procesado
    nuQuantityRec       number;
    nuQuantityCurr      number := 0;
    sbIsInterestConcept CC_Tmp_Bal_By_Conc.Is_Interest_Concept%type;
    nuNumeroCuotas      Diferido.Difenucu%type;
    nuPackageId         mo_packages.package_id%type;
    nuFunctionaryId     funciona.funccodi%type;
    rcFunciona          funciona%rowtype;
    /***********************************************************************/
    /*          METODOS ENCAPSULADOS                             */
    /***********************************************************************/
    /**************************************************************
    Propiedad intelectual de Open International Systems (c).
    Unidad      :  AddCancelCharges
    Descripcion :  Adiciona a la coleccion global de memoria, los cargos de
                   cancelacion de la deuda por financiacion correspondientes
                   al producto especificado.
    Autor       :  Diego Alejandro Ruiz Tabares
    Fecha       :  05-09-2012
    Parametros  :
                   inuProductId     Identificador del producto
    Historia de Modificaciones
    Fecha        Autor              Modificacion
    =========    =========          ====================
    05-Sep-2013 jllanoSAO214557
    Se modifica la forma en que se realiza la cancelacion de la cartera corriente, ya
    que se crean cargos contrarios por cada cargo incluido en la financiacion y se crean
    los cargos contrarios por cada cargo credito incluido en una distribucion hacia un
    cargo debito.
    05-09-2012   druiz.SAO181106    Creacion
    ***************************************************************/
    PROCEDURE AddCancelCharges(inuProductId in servsusc.sesunuse%type) IS
      csbSubmtd CONSTANT VARCHAR2(100) := csbMetodo||'.AddCancelCharges';
      -- Tipo de producto asociado al producto
      nuProductType servicio.servcodi%type;
      /* Causa de cargo para cancelacion de deuda */
      nuChargeCause causcarg.cacacodi%type;
      /* Factura asociada a la cuenta de cobro a procesar */
      nuAccStatusId factura.factcodi%type;
      /* Signo para el cargo de cancelacion de deuda */
      sbCancelSign cargos.cargsign%type;
      /* Indice  */
      nuIndx number;
      tbListado ut_string.TyTb_String;
      tbDist    ut_string.TyTb_String;
      nuValorCredito  number;
      nuValorDebito   number;
      nuTotalCreditos number;
      /* Factor de redondeo de cobros configurado para la suscripcion cuya
      deuda esta siendo financiada */
      nuRoundFactor timoempr.tmemfare%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      pkg_traza.trace('Porcentaje de financiacion: ' || inuPorcAFinanciar,pkg_traza.cnuNivelTrzDef);

      /* Se obtiene el tipo de producto */
      nuProductType := pkg_bcproducto.fnuTipoProducto(inuProductId);
      /* Se obtiene el factor de redondeo configurado para la suscripcion */
      FA_BOPoliticaRedondeo.ObtFactorRedondeo(pkg_bcproducto.fnucontrato(inuProductId),
                                              nuRoundFactor);
      /* Se obtiene causa de cargo para paso a diferido (43) */
      nuChargeCause := FA_BOChargeCauses.fnuDeferredChCause(nuProductType);
      pkg_traza.Trace('Creando cargos de cancelacion de deuda por financiacion',
                     pkg_traza.cnuNivelTrzDef);
      /* Se recorren las cuentas de cobro sobre las cuales se registra la
      financiacion */
      for rcAccounts in CC_BCFinancing.cu_Accounts(inuProductId) loop
        pkg_traza.Trace('Procesando cuenta [' ||
                       to_char(rcAccounts.account_number) || ']',
                       pkg_traza.cnuNivelTrzDef);
        /* Se establece el identificador de la cuenta en memoria */
        nugCuenta := rcAccounts.account_number;
        /* Se obtiene la factura asociada a la cuenta de cobro */
        nuAccStatusId := pktblCuencobr.fnuGetAccountStatus(nugCuenta);
        -- Se recorren los cargos financiados para la cuenta de cobro
        for rc in CC_BCFinancing.cu_PendingBalanceByConcept(inuProductId,
                                                            nugCuenta) loop
          -- Si lista de distribucion de creditos esta vacia, se agrega el cargo
          -- directamente.
          IF (rc.list_dist_credits IS null) THEN
            /* Se obtiene signo para cancelacion de saldo */
            sbCancelSign := pkChargeMgr.fsbGetCancelSign(rc.s_financing_balance);
            pkg_traza.Trace('Cuenta :[' || to_char(nugCuenta) ||
                           '] Concepto: [' || to_char(rc.concept_id) ||
                           '] Signo: [' || sbCancelSign || '] Valor: [' ||
                           to_char(rc.s_pend_bal_to_finance) || ']',
                           pkg_traza.cnuNivelTrzDef);
            /* Adiciona el cargo a la coleccion de memoria global */
            AddCharge(rc.concept_id,
                      rc.s_pend_bal_to_finance,
                      sbCancelSign,
                      isbPrograma,
                      nuAccStatusId,
                      to_char(rc.temp_deferred_id),
                      csbNo,
                      pkBillConst.CERO,
                      nuChargeCause);
          else
            -- Adiciona los cargos de la distribucion de creditos.
            -- el campo list_dist_credits tiene el listado de los descuentos
            -- por distribucion de creditos del concepto. El formato es:
            -- concepto|valor,concepto|valor,...
            pkg_traza.trace('Listado de distribucion: ' ||
                           rc.list_dist_credits,
                           pkg_traza.cnuNivelTrzDef);
            -- Inicializa total de creditos
            nuTotalCreditos := 0;
            -- Redondea valor original del debito
            nuValorDebito := round(rc.s_orig_pending_balance *
                                   (inuPorcAFinanciar / 100),
                                   nuRoundFactor);
            /* Se obtiene signo para cancelacion de saldo */
            sbCancelSign := pkChargeMgr.fsbGetCancelSign(nuValorDebito);
            pkg_traza.Trace('Cuenta :[' || to_char(nugCuenta) ||
                           '] Concepto: [' || to_char(rc.concept_id) ||
                           '] Signo: [' || sbCancelSign || '] Valor: [' ||
                           to_char(nuValorDebito) || ']',
                           pkg_traza.cnuNivelTrzDef);
            pkg_traza.trace('Valor a financiar: ' ||
                           rc.s_pend_bal_to_finance,
                           pkg_traza.cnuNivelTrzDef);
            /* Adiciona el cargo a la coleccion de memoria global */
            AddCharge(rc.concept_id,
                      nuValorDebito,
                      sbCancelSign,
                      isbPrograma,
                      nuAccStatusId,
                      to_char(rc.temp_deferred_id),
                      csbNo,
                      pkBillConst.CERO,
                      nuChargeCause);
            ut_string.ExtString(rc.list_dist_credits, ',', tbListado);
            nuIndx := tbListado.first;
            LOOP
              EXIT WHEN nuIndx IS null;
              IF tbListado(nuIndx) IS NOT NULL AND
                 length(tbListado(nuIndx)) > 0 THEN
                ut_string.ExtString(tbListado(nuIndx), '|', tbDist);
                pkg_traza.trace('Distribucion: ' || tbListado(nuIndx),
                               pkg_traza.cnuNivelTrzDef);
                nuValorCredito := round(to_number(tbDist(2)) *
                                        (inuPorcAFinanciar / 100),
                                        nuRoundFactor);
                pkg_traza.trace('Valor Credito: ' || nuValorCredito,
                               pkg_traza.cnuNivelTrzDef);
                nuTotalCreditos := nuTotalCreditos + nuValorCredito;
                pkg_traza.trace('Total de creditos: ' || nuTotalCreditos,
                               pkg_traza.cnuNivelTrzDef);
                -- Si es el ultimo credito, se ajusta el valor
                -- para que cuadre con el valor pendiente de financiar
                -- Se resta -1 por que el ultimo valor de la tabla es token vacio por
                -- que la lista de distribucion termina en comma.
                if (nuIndx = (tbListado.last - 1)) then
                  pkg_traza.trace('Ultimo. Valor referencia: ' ||
                                 (nuValorDebito - nuTotalCreditos) ||
                                 ' - Valor financiacion: ' ||
                                 rc.s_pend_bal_to_finance,
                                 pkg_traza.cnuNivelTrzDef);
                  if (rc.s_pend_bal_to_finance >
                     (nuValorDebito - nuTotalCreditos)) then
                    nuValorCredito := nuValorCredito -
                                      abs(rc.s_pend_bal_to_finance -
                                          (nuValorDebito - nuTotalCreditos));
                    pkg_traza.trace('Valor Credito Despues: ' ||
                                   nuValorCredito,
                                   pkg_traza.cnuNivelTrzDef);
                  elsif (rc.s_pend_bal_to_finance <
                        (nuValorDebito - nuTotalCreditos)) then
                    nuValorCredito := nuValorCredito +
                                      abs(rc.s_pend_bal_to_finance -
                                          (nuValorDebito - nuTotalCreditos));
                    pkg_traza.trace('Valor Credito Despues: ' ||
                                   nuValorCredito,
                                   pkg_traza.cnuNivelTrzDef);
                  END if;
                END if;
                /* Adiciona el cargo a la coleccion de memoria global */
                AddCharge(tbDist(1),
                          nuValorCredito,
                          pkBillConst.DEBITO,
                          isbPrograma,
                          nuAccStatusId,
                          to_char(rc.temp_deferred_id),
                          csbNo,
                          pkBillConst.CERO,
                          nuChargeCause);
              END IF;
              nuIndx := tbListado.next(nuIndx);
            END LOOP;
          END if;
          -- Adiciona la cuenta de cobro al arreglo de cuentas a ajustar */
          AddRecAccoTable(nugCuenta, inuProductId, nuAccStatusId);
        end loop;
      end loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR  then
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END AddCancelCharges;
    /**************************************************************
    Propiedad intelectual de Open International Systems (c).
    Unidad      :  AddDiscounts
    Descripcion :  Adiciona a la coleccion global de memoria, los cargos de
                   descuento por acuerdo de pago correspondientes al producto
                   especificado.
    Autor       :  Arturo Mendez Zambrano
    Fecha       :  26-07-2008
    Parametros  :
                   inuProductId     Identificador del producto
    Historia de Modificaciones
    Fecha        Autor              Modificacion
    =========    =========          ====================
    24-09-2012   druiz.SAO191987
    Se modifica el procedimiento de manera que cree el cargo de descuento por
    el valor correcto.
    05-09-2012   druiz.SAO181112
    Se modifica el procedimiento de manera que no actualice la cartera de las
    cuentas de cobro del producto.
    26-07-2008   amendez.SAO79403   Creacion
    ***************************************************************/
    PROCEDURE AddDiscounts(inuProductId in servsusc.sesunuse%type) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.AddDiscounts';
      /* Tipo de producto asociado al producto */
      nuProductType servicio.servcodi%type;
      /* Causa de cargo para cancelacion de deuda */
      nuChargeCause causcarg.cacacodi%type;
      /* Factura asociada a la cuenta de cobro a procesar */
      nuAccStatusId factura.factcodi%type;
      /* Signo para el cargo de cancelacion de deuda */
      sbCancelSign cargos.cargsign%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      /* Se obtiene el tipo de producto */
      nuProductType := pkg_bcproducto.fnuTipoProducto(inuProductId);
      /* Se obtiene causa de cargo para descuentos por acuerdo de pago */
      nuChargeCause := FA_BOChargeCauses.fnuSpecialFinChCause(nuProductType);
      pkg_traza.Trace('Creando cargos de descuento por acuerdo de pago',
                     pkg_traza.cnuNivelTrzDef);
      /* Se recorren las cuentas de cobro sobre las cuales aplican descuentos
      por acuerdo de pago */
      for rcAccounts in CC_BCFinancing.cu_Accounts_to_discounts(inuProductId) loop
        pkg_traza.Trace('Procesando cuenta [' ||
                       to_char(rcAccounts.account_number) || ']',
                       pkg_traza.cnuNivelTrzDef);
        /* Se establece el identificador de la cuenta en memoria */
        nugCuenta := rcAccounts.account_number;
        /* Se obtiene la factura asociada a la cuenta de cobro */
        nuAccStatusId := pktblCuencobr.fnuGetAccountStatus(nugCuenta);
        -- Se recorren los cargos de descuento a aplicar para la cuenta de cobro
        for rc in CC_BCFinancing.cu_Discounts(inuProductId, nugCuenta) loop
          /* Se establece signo para cancelacion de saldo */
          sbCancelSign := pkBillConst.CREDITO;
          pkg_traza.Trace('Cuenta :[' || to_char(nugCuenta) ||
                         '] Concepto: [' || to_char(rc.concept_id) ||
                         '] Signo: [' || sbCancelSign || '] Valor: [' ||
                         to_char(rc.s_pending_balance) || ']',
                         pkg_traza.cnuNivelTrzDef);
          /* Adiciona el cargo a la coleccion de memoria global }*/
          AddCharge(rc.concept_id,
                    rc.s_pending_balance,
                    sbCancelSign,
                    isbPrograma,
                    nuAccStatusId,
                    sbTokenAP || to_char(inuFinanCod),
                    csbYes,
                    pkBillConst.CERO,
                    nuChargeCause);
          /* Adiciona la cuenta de cobro al arreglo de cuentas a ajustar */
          AddRecAccoTable(nugCuenta, inuProductId, nuAccStatusId);
        end loop;
      end loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END AddDiscounts;
    /**********************************************************************/
    /*          FIN METODOS ENCAPSULADOS                        */
    /**********************************************************************/
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuNextFincCode := inuFinanCod;
    nugNumServ     := inuNumServ;
    --Si el codigo de financiacion es null, se obtiene uno nuevo
    if (nvl(nuNextFincCode, 0) = 0) then
      pkDeferredMgr.nuGetNextFincCode(nuNextFincCode);
    end if;
    nugFinanCode := nuNextFincCode;
    -- Obtiene usuario y terminal
    nuPackageId := GetPackageIdByFinancingId(nugFinanCode);
    -- Si el paquete es diferente de nulo, buscamos el usuario que creo
    -- la solicitud de financiacion o negociacion.
    if nuPackageId IS not null then
      sbgUser         := damo_packages.fsbGetUser_Id(nuPackageId);
      rcFunciona      := pkBCFunciona.frcFunciona(sbgUser);
      sbgTerminal     := damo_packages.fsbGetTerminal_Id(nuPackageId);
      gnuPersonId     := GE_BCPerson.fnuGetFirstPersonByUserId(pkg_session.fnugetuseridbymask(sbgUser));
      nuFunctionaryId := rcFunciona.funccodi;
      -- Si no es posible obtener un funcionario se establecen los valores
      -- por defecto
      if nuFunctionaryId IS null then
        nuFunctionaryId := isbFunciona;
        gnuPersonId     := pkg_bopersonal.fnugetpersonaid;
      END if;
    else
      sbgUser         := pkGeneralServices.fsbGetUserName;
      sbgTerminal     := pkGeneralServices.fsbGetTerminal;
      gnuPersonId     := pkg_bopersonal.fnugetpersonaid;
      nuFunctionaryId := isbFunciona;
    end if;
    pkg_traza.trace('sbgUser: ' || sbgUser, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('nuFuncionaryId: ' || nuFunctionaryId, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('sbgTerminal: ' || sbgTerminal, pkg_traza.cnuNivelTrzDef);
    -- Obtiene el numero de registros a procesar
    for rcRec in CC_BCFinancing.cuQuantityfinancingConcepts(inuNumServ) loop
      nuQuantityRec := rcRec.Quantity;
    end loop;
    pkg_traza.Trace('Total Registros [' || nuQuantityRec || ']', pkg_traza.cnuNivelTrzDef);
    if (blgFinanciarIVA) then
      if (ichIVAUnaCuota = constants_per.CSBSI) then
        nuPorcNomi     := pkBillConst.CERO;
        nuPorcInte     := pkBillConst.CERO;
        nuSpread       := pkBillConst.CERO;
        nuNumeroCuotas := 1;
      else
        nuPorcNomi     := nugPorIntNominal;
        nuPorcInte     := nugPorcInteres;
        nuSpread       := nugSpread;
        nuNumeroCuotas := inuNumeroCuotas;
        if (not blgInteSobreIvaFina) then
          nuPorcNomi := pkBillConst.CERO;
          nuPorcInte := pkBillConst.CERO;
          nuSpread   := pkBillConst.CERO;
        end if;
      end if;
      pkg_traza.Trace('Procesando conceptos de impuesto', pkg_traza.cnuNivelTrzDef);
      for rcIVA in CC_BCFinancing.cu_Taxes(inuNumServ) loop
        pkg_traza.Trace('Concepto [' || rcIVA.Financing_Concept_Id ||
                       '] Saldo [' || rcIVA.S_Pending_Balance ||
                       '] Saldo a Financiar [' ||
                       rcIVA.S_Pend_Bal_To_Finance || ']',
                       pkg_traza.cnuNivelTrzDef);
        pkg_traza.Trace('Cuenta [' || rcIVA.Financing_Concept_Id ||
                       '] Concepto Interes [' || rcIVA.Interest_Concept_Id || ']',
                       pkg_traza.cnuNivelTrzDef);
        -- Valida si cambio el concepto de financiacion. Rompimiento por concepto de financiacion
        if (nvl(nuConcFinanCurr, rcIVA.Financing_Concept_Id) <>
           rcIVA.Financing_Concept_Id) then
          -- Crea diferido
          CreateDeferred(nuNextFincCode,
                         nugSubscription,
                         nuConcFinanCurr,
                         nuVlrFinanCnc,
                         nuNumeroCuotas,
                         isbDocumento,
                         isbPrograma,
                         nuPorcNomi,
                         constants_per.CSBSI,
                         nuPorcInte,
                         nugTasaInte,
                         nuSpread,
                         nuConcInteres,
                         nuFunctionaryId,
                         sbIsInterestConcept,
                         blLastRecord,
                         isbSimulate);
          -- Se limpia el valor a financiar para el concepto de financiacion
          nuVlrFinanCnc := pkBillConst.CERO;
        end if;
        -- Almacena el concepto de financiacion a procesar
        nuConcFinanCurr := rcIVA.Financing_Concept_Id;
        -- Almacena la cuenta de cobro
        nugCuenta := rcIVA.Account_Number;
        -- Acumula el valor a fiananciar
        nuVlrFinanCnc := nuVlrFinanCnc + rcIVA.S_Pend_Bal_To_Finance;
        -- Obtiene el concepto de interes a partir del concepto base
        nuConcInteres := rcIVA.Interest_Concept_Id;
        sbIsInterestConcept := rcIVA.Is_Interest_Concept;
        /* Se actualiza la cantidad de conceptos procesados */
        nuQuantityCurr := nuQuantityCurr + 1;
        /* En el ultimo diferido de la financiacion ajusta el valor en caso
        de que tenga una muy pequeña diferencia con el total financiado. */
        blLastRecord := (nuQuantityRec = nuQuantityCurr) and iblLastProduct;
        -- Si es el ultimo diferido del ultimo producto de la financiacion
        -- ajusta el valor a financiar
        if (blLastRecord) then
          if (((nugAcumFinancing + nuVlrFinanCnc) <> nugVlrFinTotal) and
             (abs(nugAcumFinancing + nuVlrFinanCnc - nugVlrFinTotal) <
             cnuValorTopeAjuste)) then
            nuVlrFinanCnc := nugVlrFinTotal - nugAcumFinancing;
          end if;
        end if;
        -- Actualiza registro procesado, con el identificador temporal del diferido
        CC_BCFinancing.UpDeferredIdByTax(inuNumServ,
                                         rcIVA.Account_Number,
                                         rcIVA.Financing_Concept_Id,
                                         rcIVA.Is_Interest_Concept,
                                         nuIdxDife + 1,
                                         rcIVA.Interest_Concept_Id);
      end loop;
      -- Crea diferido para el ultimo concepto de financiacion de impuestos procesados
      CreateDeferred(nuNextFincCode,
                     nugSubscription,
                     nuConcFinanCurr,
                     nuVlrFinanCnc,
                     nuNumeroCuotas,
                     isbDocumento,
                     isbPrograma,
                     nuPorcNomi,
                     constants_per.CSBSI,
                     nuPorcInte,
                     nugTasaInte,
                     nuSpread,
                     nuConcInteres,
                     nuFunctionaryId,
                     sbIsInterestConcept,
                     blLastRecord,
                     isbSimulate);
      -- Se limpia el valor a financiar para el concepto de financiacion
      nuVlrFinanCnc := pkBillConst.CERO;
      -- Se limpia el concepto de financiacion procesado
      nuConcFinanCurr := NULL;
    end if;
    pkg_traza.Trace('Procesando conceptos que NO son de impuesto', pkg_traza.cnuNivelTrzDef);
    for rcChargeFin in CC_BCFinancing.cu_financingConcepts(inuNumServ) loop
      pkg_traza.Trace('Concepto [' || rcChargeFin.Financing_Concept_Id ||
                     '] Saldo [' || rcChargeFin.S_Pending_Balance ||
                     '] Saldo a Financiar [' ||
                     rcChargeFin.S_Pend_Bal_To_Finance || ']',
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.Trace('Cuenta [' || rcChargeFin.Financing_Concept_Id ||
                     '] Concepto Interes [' ||
                     rcChargeFin.Interest_Concept_Id || ']',
                     pkg_traza.cnuNivelTrzDef);
      -- Valida si cambio el concepto de financiacion. Rompimiento por concepto de financiacion
      if (nvl(nuConcFinanCurr, rcChargeFin.Financing_Concept_Id) <>
         rcChargeFin.Financing_Concept_Id) then
        -- Crea diferido
        CreateDeferred(nuNextFincCode, -- Cod.Financiacion
                       nugSubscription,
                       nuConcFinanCurr, -- Concepto
                       nuVlrFinanCnc, -- Valor
                       inuNumeroCuotas, -- Cuotas
                       isbDocumento, -- Doc.
                       isbPrograma, -- Programa
                       nugPorIntNominal, -- inuPorIntNominal Lo obtiene valinputdata
                       constants_per.CSBNO, -- ichIVA --
                       NULL, -- inuPorcInteres -- porcentaje de interes
                       NULL, -- inuTasaInte
                       NULL, -- inuSpread
                       nuConcInteres, -- inuConcInteres Lo obtiene a partir del concepto Origen
                       nuFunctionaryId,
                       sbIsInterestConcept,
                       blLastRecord,
                       isbSimulate);
        nuVlrFinanCnc := pkBillConst.CERO;
      end if;
      -- Almacena el concepto de financiacion a procesar
      nuConcFinanCurr := rcChargeFin.Financing_Concept_Id;
      -- Almacena la cuenta de cobro
      nugCuenta := rcChargeFin.Account_Number;
      -- Acumula el valor a fiananciar
      nuVlrFinanCnc := nuVlrFinanCnc + rcChargeFin.S_Pend_Bal_To_Finance;
      -- Obtiene el concepto de interes a partir del concepto base
      nuConcInteres := rcChargeFin.Interest_Concept_Id;
      sbIsInterestConcept := rcChargeFin.Is_Interest_Concept;
      -- Se actualiza la cantidad de conceptos procesados
      nuQuantityCurr := nuQuantityCurr + 1;
      /* En el ultimo diferido de la financiacion ajusta el valor en caso
      de que tenga una muy pequeña diferencia con el total financiado. */
      blLastRecord := (nuQuantityRec = nuQuantityCurr) and iblLastProduct;
      -- Si es el ultimo diferido del ultimo producto de la financiacion ajusta el valor a financiar
      if (blLastRecord) then
        if (((nugAcumFinancing + nuVlrFinanCnc) <> nugVlrFinTotal) and
           (abs(nugAcumFinancing + nuVlrFinanCnc - nugVlrFinTotal) <
           cnuValorTopeAjuste)) then
          nuVlrFinanCnc := nugVlrFinTotal - nugAcumFinancing;
        end if;
      end if;
      -- Actualiza registro procesado, con el identificador temporal del diferido
      CC_BCFinancing.UpDeferredId(inuNumServ,
                                  rcChargeFin.Account_Number,
                                  rcChargeFin.Financing_Concept_Id,
                                  rcChargeFin.Is_Interest_Concept,
                                  nuIdxDife + 1,
                                  rcChargeFin.Interest_Concept_Id);
    end loop;
    -- Crea diferido para el ultimo concepto de financiacion procesado
    CreateDeferred(nuNextFincCode, -- Cod.Financiacion
                   nugSubscription,
                   nuConcFinanCurr, -- Concepto
                   nuVlrFinanCnc, -- Valor
                   inuNumeroCuotas, -- Cuotas
                   isbDocumento, -- Doc.
                   isbPrograma, -- Programa
                   nugPorIntNominal, -- inuPorIntNominal Lo obtiene valinputdata
                   constants_per.CSBNO, -- ichIVA --
                   NULL, -- inuPorcInteres -- porcentaje de interes
                   NULL, -- inuTasaInte
                   NULL, -- inuSpread
                   nuConcInteres, -- inuConcInteres Lo obtiene a partir del concepto Origen
                   nuFunctionaryId,
                   sbIsInterestConcept,
                   blLastRecord,
                   isbSimulate);
    -- Solo si Cambio de condiciones no simulada
    if (isbChangeConditions = constants_per.CSBSI and
       isbSimulate = constants_per.CSBNO) then
      -- //Crea los diferidos para los conceptos seleccionados
      pkg_traza.Trace('CAMBIO DE CONDICIONES...', pkg_traza.cnuNivelTrzDef);
      for rcDeferToChCond in CC_BCFinancing.cu_defertoChConditions(inuNumServ) loop
        pkg_traza.Trace('Procesando diferido ' || rcDeferToChCond.rownum ||
                       ' de ' || rcDeferToChCond.maxrownum || ' : ' ||
                       rcDeferToChCond.deferToChCondId,
                       pkg_traza.cnuNivelTrzDef);
        bllastRecord := (iblLastProduct) and
                        (rcDeferToChCond.rownum = rcDeferToChCond.maxrownum);
        if (bllastRecord) then
          pkg_traza.Trace('Procesando ultimo diferido', pkg_traza.cnuNivelTrzDef);
        end if;
        -- En el ultimo diferido de la financiacion ajusta el valor
        -- en caso de que tenga una muy pequeña diferencia con el total
        -- financiado.
        nuVlrFinanCnc := rcDeferToChCond.pend_balance_to_finance;
        nuConcFinanCurr := rcDeferToChCond.financing_concept_id;
        -- Si es el ultimo diferido del ultimo producto de la financiacion ajusta
        -- el valor a financiar
        if (ibllastProduct and blLastRecord) then
          pkg_traza.Trace('Verificando Acumulado de Financiacion VS Total Financiacion: ' ||
                         to_char(nugAcumChCond + nuVlrFinanCnc) || ' VS ' ||
                         to_char(nugVlrFinTotal),
                         pkg_traza.cnuNivelTrzDef);
          if (((nugAcumChCond + nuVlrFinanCnc) <> nugVlrFinTotal) and
             (abs(nugAcumChCond + nuVlrFinanCnc - nugVlrFinTotal) <
             cnuValorTopeAjuste)) then
            pkg_traza.Trace('Ajustando ultimo diferido a financiar. Valor antes de ajustar => ' ||
                           nuVlrFinanCnc,
                           pkg_traza.cnuNivelTrzDef);
            nuVlrFinanCnc := nugVlrFinTotal - nugAcumChCond;
            pkg_traza.Trace('Valor de ultimo diferido ajustado => ' ||
                           nuVlrFinanCnc,
                           pkg_traza.cnuNivelTrzDef);
          end if;
        end if;
        nuConcInteres := pktblConcepto.fnuGetInterestConc(nuConcFinanCurr);
        ChangeCondition(rcDeferToChCond.deferToChCondId,
                        rcDeferToChCond.product_id,
                        nuNextFincCode,
                        nuVlrFinanCnc,
                        inuNumeroCuotas,
                        isbPrograma,
                        nuConcInteres, --Lo obtiene a partir de conccore
                        nugTasaInte, -- tasa de interes
                        nugSpread, -- spread
                        nuConcInteres, --Lo obtiene a partir de conccore
                        nuFunctionaryId,
                        blLastRecord);
        nuVlrFinanCnc := pkBillConst.CERO;
      end loop;
      pkg_traza.Trace('FIN CAMBIO DE CONDICIONES...', pkg_traza.cnuNivelTrzDef);
    end if;
    /* Se verifica que el proceso no sea simulado y no corresponda a un cambio
    de condiciones de financiacion */
    if (not (isbSimulate = constants_per.CSBSI or
        isbChangeConditions = constants_per.CSBSI)) then
      -- Se adicionan los cargos de cancelacion de deuda por financiacion
      AddCancelCharges(inuNumServ);
      /* Se adicionan los cargos de descuento por acuerdo de pago */
      AddDiscounts(inuNumServ);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
       pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END FinanDebtProcess;

  PROCEDURE PrInsertCocoSesu(inuPlandife    in diferido.difepldi%type,
                             inuFinancingId in diferido.difecofi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'PrInsertCocoSesu'; --Nombre del método en la traza
    nuExpAccSusp  plandife.pldincvs%type;
    sbLang        varchar2(3);
    sbObservation cocosesu.ccssobse%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Obtiene el numero de cuentas para suspension del plan de diferido
    nuExpAccSusp := pktblPlanDife.fnuGetExpAccNumForSusp(inuPlandife);
    -- Si hay numero de cuentas vencidas en el plan inserta en cocosesu
    if (nvl(nuExpAccSusp, 0) > 0) then
      sbObservation := pki18nmgr.fsbGetText('OBSE_COCOSESU_FINAN');
      sbObservation := sbObservation || inuPlandife;
      for rc in cc_bcfinancing.cu_products loop
        pkSuspConnSetupByServsuscMgr.InsSuspConnSetupByProd(rc.product_id,
                                                            nuExpAccSusp,
                                                            inuFinancingId,
                                                            sbObservation);
      END loop;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
       pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END PrInsertCocoSesu;

  PROCEDURE GenFinancialPlanRest(inuPlandife diferido.difepldi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GenFinancialPlanRest'; --Nombre del método en la traza
    nuErrCode ge_error_log.error_log_id%type;
    sbErrMess ge_error_log.description%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    for rc in cc_bcfinancing.cu_products loop
      -- Llama al proceso que ejecuta las restricciones
      pkBSGenFinancialPlanRest.GenFinancialPlanRest(inuPlandife,
                                                    rc.product_id,
                                                    nuErrCode,
                                                    sbErrMess);
      if (nuErrCode <> pkConstante.EXITO) then
        raise PKG_ERROR.CONTROLLED_ERROR;
      end if;
    end loop;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GenFinancialPlanRest;

  PROCEDURE FinancingDebt(inuNumServ            in diferido.difenuse%type,
                          inuPlan               in diferido.difepldi%type,
                          inuMetodoCuota        in diferido.difemeca%type,
                          idtCollectDate        in diferido.difefein%type,
                          inuPorcInteres        in diferido.difeinte%type,
                          inuSpread             in diferido.difespre%type,
                          inuNumeroCuotas       in diferido.difenucu%type,
                          isbDocumento          in diferido.difenudo%type,
                          inuPorcAFinanciar     in number,
                          inuVlrDeudaDiferir    in diferido.difevatd%type,
                          inuVlrIvaDiferir      in diferido.difevatd%type,
                          ichIVAUnaCuota        in char,
                          isbPrograma           in procesos.proccodi%type,
                          inuFinanceCode        in diferido.difecofi%type,
                          isbSimulate           in varchar2, -- Simular (S|N)
                          isbChangeConditions   in varchar2,
                          iblLastProduct        in boolean,
                          isbIgnoreClaimRequest in varchar2,
                          onuAcumCuota          out number,
                          onuSaldo              out number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'FinancingDebt'; --Nombre del método en la traza
    sbFunciona funciona.funccodi%type;
    /* ***************************************************************** */
    /* ********           Procedimientos Encapsulados           ******** */
    /* ***************************************************************** */
    /* -------------------------------------------------------------- */
    /*
    Procedure : Initialize
    Descripcion : Inicializa variables del package
          Initialize
      */
    PROCEDURE Initialize IS
       csbSubmtd   CONSTANT VARCHAR2(100) := csbMetodo||'.Initialize';
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      nugSimulate := isbSimulate;
      -- Fija salida default
      onuAcumCuota := pkBillConst.CERO;
      onuSaldo     := pkBillConst.CERO;
      nugAcumCuota := pkBillConst.CERO;
      -- Variables de entrada que se pueden modificar
      nugMetodo      := inuMetodoCuota;
      nugPlan        := inuPlan;
      dtgFecha       := idtCollectDate;
      nugSpread      := inuSpread;
      nugPorcInteres := inuPorcInteres;
      dtgProceso := sysdate;
      -- Obtiene totales de cuotas extras del producto que se esta
      -- procesando
      GetExtraPayTotals(nugNumCuotaExt, nugTotCuotaExt);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END Initialize;
    /* -------------------------------------------------------------- */
    /*
    Procedure : SetOutVar
    Descripcion : Fija las variables de Salida
          Set Out Variables
      */
    PROCEDURE SetOutVar IS
        csbSubmtd   CONSTANT VARCHAR2(100) := csbMetodo||'.SetOutVar';
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      onuAcumCuota := nugAcumCuota;
      -- Obtiene el saldo pendiente actualizado
      onuSaldo := fnuGetProductBalance(inuNumServ);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        pkg_error.setError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END SetOutVar;

    PROCEDURE GetOverChargePercent(inuPlandife         in plandife.pldicodi%type,
                                   onuPercenOverCharge out number) IS
        csbSubmtd   CONSTANT VARCHAR2(100) := csbMetodo||'.GetOverChargePercent';
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      onuPercenOverCharge := pktblPlandife.fnuPercOverCharge(inuPlandife,
                                                             pkConstante.NOCACHE);
      onuPercenOverCharge := nvl(onuPercenOverCharge, 0);
      if onuPercenOverCharge not between 0 AND 100 then
        -- El porcentaje de mora configurado en el plan de financiacion (%s1) no es correcto
        pkg_error.setErrorMessage(cnuBadOverChargePercent, inuPlandife );

      END if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END GetOverChargePercent;
    /*
    Procedure : fsbGetFuncionaDataBase
    Descripcion : Obtiene el funcionario asociado al usuario de la base de
                      datos indicado.
      */
    FUNCTION fsbGetFuncionaDataBase RETURN funciona.funccodi%type IS
      csbSubmtd   CONSTANT VARCHAR2(100) := csbMetodo||'.GetOverChargePercent';
      sbUserDataBase funciona.funcusba%type;
      rcFunciona     funciona%rowtype;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      --Obtiene usuario de base de datos
      sbUserDataBase := pkgeneralservices.fsbGetUserName;
      --Obtiene record del funcionario asociado al usuario de la base de datos
      rcFunciona := pkbcfunciona.frcFunciona(sbUserDataBase);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return rcFunciona.funccodi;
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END fsbGetFuncionaDataBase;
    /* ********************************************************************** */
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Inicializa variables
    Initialize;
    -- Limpia memoria cache
    ClearMemory;
    -- Valida parametros necesarios para creacion de nuevo diferido
    ValidateParam;
    -- Valida datos de entrada
    ValInputData(inuNumServ,
                 inuPlan,
                 inuPorcInteres,
                 inuNumeroCuotas,
                 isbDocumento,
                 inuPorcAFinanciar,
                 ichIVAUnaCuota,
                 inuSpread,
                 isbPrograma,
                 isbSimulate,
                 isbIgnoreClaimRequest);
    -- Obtiene el Porcentaje de Recargo por Mora del plan
    GetOverChargePercent(inuPlan, nugPorcMora);
    --Obtiene el funcionario asociado al usuario de la base de datos
    sbFunciona := fsbGetFuncionaDataBase;
    -- Ejecuta proceso de financiacion
    FinanDebtProcess(inuNumServ,
                     inuNumeroCuotas,
                     isbDocumento,
                     inuPorcAFinanciar,
                     ichIVAUnaCuota,
                     isbPrograma,
                     inuFinanceCode,
                     sbFunciona,
                     isbSimulate,
                     isbChangeConditions,
                     iblLastProduct);
    -- Fija variables de salida
    SetOutVar;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END FinancingDebt;

  PROCEDURE ValConfCose(inuPlandife diferido.difepldi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValConfCose'; --Nombre del método en la traza
    cnuErrConfSesu constant parametr.pamenume%type := 16140;
    csbErrConfSesu CONSTANT VARCHAR2(180) := 'El número de cuentas vencidas para suspensión del plan de financiación no puede ser mayor que el número de cuentas vencidas para suspensión del tipo de producto.';
    nuServicio       servsusc.sesuserv%type;
    nuMaxNumCuentas  confcose.cocsncdx%type;
    nuMaxCuentasPlan plandife.pldincvs%type;
    procedure ValProduct(inuProductId servsusc.sesunuse%type) is
        csbSubmtd   CONSTANT VARCHAR2(100) := csbMetodo||'.ValProduct';
    begin
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Obtiene el Servicio
      nuServicio := pkg_bcproducto.fnuTipoProducto(inuProductId);
      -- Obtiene el tope de cuentas en la configuracion de corte para el
      -- servicio.
      nuMaxNumCuentas := pktblConfcose.fnuGetMaxNumSusAcc(nuServicio);
      if (nuMaxCuentasPlan > nvl(nuMaxNumCuentas, 0)) then
          pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,cnuErrConfSesu||'-'||csbErrConfSesu);
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Obtiene el numero de cuentas del plan de financiacion
    nuMaxCuentasPlan := pktblPlandife.fnuGetExpAccNumForSusp(inuPlandife);
    if (nvl(nuMaxCuentasPlan, 0) > 0) then
      for rc in cc_bcfinancing.cu_products loop
        ValProduct(rc.product_Id);
      end loop;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValConfCose;

  PROCEDURE AdjustValueToFinance(inuSubscriptionId in suscripc.susccodi%type,
                                 inuValueToPay     in cc_financing_request.initial_payment%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AdjustValueToFinance'; --Nombre del método en la traza
    -- Valor de pago inicial ajustado
    nuAdjValueToPay cc_financing_request.initial_payment%type;
    -- Valor del ajuste correspondiente a una cuenta de cobro
    nuAdjustValue cargos.cargvalo%type;
    -- Signo del ajuste correspondiente a una cuenta de cobro
    sbAdjustSign cargos.cargsign%type;
    -- Saldo pendiente de una cuenta de cobro
    nuAccPendBal cuencobr.cucosacu%type;
    -- Saldo pendiente de la financiacion teniendo en cuenta el valor a financiar
    -- para cada cuenta de cobro y el ajuste correspondiente
    nuFinanPendBal cc_financing_request.initial_payment%type := 0;
    -- Diferencia entre el saldo pendiente de la financiacion y el valor de
    -- pago inicial
    nuPendBalDiff cuencobr.cucosacu%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Se calcula el ajuste sobre el valor de pago inicial especificado
    pkAccountMgr.CalcSuscAdjustValue(inuSubscriptionId,
                                     inuValueToPay,
                                     nuAdjustValue,
                                     sbAdjustSign);
    /* Se ajusta el valor de pago inicial */
    if (nuAdjustValue > pkBillConst.CERO) then
      if (sbAdjustSign = pkBillConst.DEBITO) then
        nuAdjValueToPay := inuValueToPay + nuAdjustValue;
      else
        nuAdjValueToPay := inuValueToPay - nuAdjustValue;
      end if;
      pkg_traza.Trace('Ajustando valor a pagar -> Valor a Pagar: [' ||
                     to_char(inuValueToPay) ||
                     '] Valor a Pagar Ajustado: [' ||
                     to_char(nuAdjValueToPay) || ']',
                     pkg_traza.cnuNivelTrzDef);
    else
      /* Se establece como valor a pagar ajustado, el valor a pagar especificado
      debido a que no hay que realizar ajuste */
      nuAdjValueToPay := inuValueToPay;
    end if;
    /* Se recorren los productos con saldo que se encuentran en la tabla
    temporal de saldos por concepto */
    for rcFinancProduct in CC_BCFinancing.cuProdsFromBalByConcTable loop
      -- Se recorren las cuentas de cobro de los productos seleccionados
      for rcPendBalToFinByAcc in CC_BCFinancing.cuPendBalToFinByAcc(rcFinancProduct.product_id) loop
        -- Se calcula el saldo pendiente teniendo en cuenta el valor a
        -- financiar
        nuAccPendBal := nvl(rcPendBalToFinByAcc.s_pending_balance, 0) -
                        nvl(rcPendBalToFinByAcc.s_pend_balance_to_finance,
                            0);
        -- Se calcula el ajuste correspondiente
        pkAccountMgr.CalcAdjustValue(rcFinancProduct.product_id,
                                     nuAccPendBal,
                                     nuAdjustValue,
                                     sbAdjustSign);
        -- Se adiciona el valor del ajuste al saldo pendiente de la cuenta
        -- de cobro
        if (nuAdjustValue > pkBillConst.CERO) then
          if (sbAdjustSign = pkBillConst.DEBITO) then
            nuAccPendBal := nuAccPendBal + nuAdjustValue;
          else
            nuAccPendBal := nuAccPendBal - nuAdjustValue;
          end if;
        end if;
        pkg_traza.Trace('Saldo pendiente de la cuenta de cobro [' ||
                       to_char(rcPendBalToFinByAcc.account_number) ||
                       '] despues de financiar -> ' ||
                       to_char(nuAccPendBal),
                       pkg_traza.cnuNivelTrzDef);
        -- Se acumula el saldo pendiente de la financiacion
        nuFinanPendBal := nuFinanPendBal + nuAccPendBal;
      end loop;
    end loop;
    -- Se calcula la diferencia entre el saldo pendiente de la financiacion
    -- y el valor de pago inicial
    nuPendBalDiff := nuFinanPendBal - nuAdjValueToPay;
    pkg_traza.Trace('Diferencia entre el saldo pendiente despues de financiar y el valor a pagar ajustado -> ' ||
                   to_char(nuPendBalDiff),
                   pkg_traza.cnuNivelTrzDef);
    -- Se ajusta el valor a financiar distribuyendo el valor calculado para
    -- la diferencia del saldo pendiente entre los conceptos a financiar
    if (nuPendBalDiff <> pkBillConst.CERO) then
      pkg_traza.Trace('Debe ajustar valor a financiar en coleccion de saldos por concepto',
                     pkg_traza.cnuNivelTrzDef);
      nugVlrFinTotal := nugVlrFinTotal + nuPendBalDiff;
      CC_BCFinancing.AdjustValueToFinance(nuPendBalDiff);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END AdjustValueToFinance;

  PROCEDURE changRetiredFinan(inuServSusc servsusc.sesunuse%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'changRetiredFinan'; --Nombre del método en la traza
    -- Flag que indica si un producto esta retirado por no pago
    blIsRetiredByNoPay boolean;
    -- Flag que indica si un producto esta retirado voluntariamente por peticion
    -- del cliente
    blIsRetiredByRequest boolean;
    nuErrorCode          number;
    sbErrorMsg           ge_error_log.description%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Se verifica si el producto se encuentra retirado por no pago
    blIsRetiredByNoPay := pkServNumberMgr.fboServNumverSuspendNoPay(inuServSusc);
    -- Se verifica si el producto se encuentra retirado voluntariamente por
    -- peticion del cliente
    blIsRetiredByRequest := pkWithDrawServNumber.fblIsRetiredByRequest(inuServSusc);
    -- Actualiza estado de corte a retirado post-financiacion y
    -- plan de facturacion a -1
    if (blIsRetiredByNoPay or blIsRetiredByRequest) then
      pkBSFinancingServ.ChangeBillingServSuspend(inuServSusc,
                                                 blIsRetiredByRequest,
                                                 nuErrorCode,
                                                 sbErrorMsg);
      if (nuErrorCode <> pkConstante.EXITO) then
        pkg_error.setErrorMessage(cnuFinancingException, sbErrorMsg);
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  end changRetiredFinan;

  PROCEDURE ClearMemoryFinancing IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ClearMemoryFinancing'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Limpia memoria cache de los paquetes de primer nivel
    ClearMemory;
    tbgAcumExtraPay.delete;
    tbgAcumExtraPay1.delete;
    if tbgDeferred IS null then
      tbgDeferred := mo_tytbDeferred();
    else
      tbgDeferred.delete;
    END if;
    if tbgExtraPayments IS null then
      tbgExtraPayments := mo_tytbextrapayments();
    else
      tbgExtraPayments.delete;
    END if;
    if tbgCharges IS null then
      tbgCharges := mo_tytbCharges();
    else
      tbgCharges.delete;
    END if;
    tbCuenta.delete;
    tbMoDi.delete;
    tbNoteSesu.delete;
    pkExtendedHash.SetInitVar(TRUE);
    nuIdxDife := 0;
    nuIdxCarg := 1;
    nuIdxExtr := 1;
    -- Se asume por defecto que el valor a financiar es mayor a cero(0)
    gblValToFinGreaterZero := TRUE;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ClearMemoryFinancing;

  PROCEDURE SetFinToSimulate(idtCollectDate       in diferido.difefein%type,
                             iotbDeferred         in out nocopy mo_tytbdeferred,
                             iotbExtraPayments    in out nocopy mo_tytbextrapayments,
                             iotbQuotaSimulate    in out nocopy mo_tytbQuotaSimulate,
                             onuTotalAcumCapital  out number,
                             onuTotalAcumCuotExtr out number,
                             onuTotalAcumInteres  out number) IS
     csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'SetFinToSimulate'; --Nombre del método en la traza
    ------------------------------------------------------------------------
    --  Tipos
    ------------------------------------------------------------------------
    TYPE tyrcDeferred IS RECORD(
      nuConcept Concepto.ConcCodi%Type,
      nuValue   Cargos.CargValo%Type);
    TYPE tytbDeferred IS TABLE OF tyrcDeferred INDEX BY BINARY_INTEGER;
    TYPE tytbQuotaNum IS TABLE OF tytbDeferred INDEX BY BINARY_INTEGER;
    ------------------------------------------------------------------------
    --  Variables
    ------------------------------------------------------------------------
    rcCuotas pkDeferredMgr.tyrcCuotas; -- Tabla con las cuotas del diferido
    -- Constantes utilizadas en simulacion de flujo de cuotas
    cnuSimulating number(1) := -1;
    csbCuexcobr   varchar2(1) := 'N';
    -- Registro de Cuota Extra para enviar a pkAditionalpaymentmgr
    rcCuotExtr  cuotextr%rowtype;
    rcQuotaFlow mo_tyobQuotaSimulate;
    nuQuotaIdx number;
    nuIdx        binary_integer; -- Indice de la tabla
    nuIdxCuoExtr binary_integer;
    nuSigno number;
    nuExtraValues  number;
    nuAcumCapital  number;
    nuAcumCuotExt  number;
    nuCapitalValue number;
    nuAcumInterest number;
    -- Numero de cuotas en el diferido
    nuDeferQuotNum number;
    nuQuotaFlow    number;
    nuDif number;
    nuIndex number;
    tbTaxDeferred tytbQuotaNum;
    nuProduct     ServSusc.SesuNuse%Type;
    ------------------------------------------------------------------------
    --  Metodos encapsulados
    ------------------------------------------------------------------------
    PROCEDURE LiquidateTax IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'LiquidateTax'; --Nombre del método en la traza
      rcProduct  servsusc%rowtype;
      nuIdxQuota binary_integer;
      nuIdxDefer binary_integer;
      nuTaxValue cargos.cargvalo%type;
      tbCharges  pkBORatingMemoryMgr.tytbLiqCharges;
      nuConcept  concepto.conccodi%type;
      nuValue    cargos.cargvalo%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      /* Se obtiene la informacion del producto */
      rcProduct := pktblServSusc.frcGetRecord(nuProduct);
      /* Se procesan las cuotas */
      nuIdxQuota := tbTaxDeferred.first;
      while (nuIdxQuota is not null) loop
        /* Se limpia la coleccion de cargos base para liquidacion de
        impuestos */
        tbCharges.delete;
        nuIdxDefer := tbTaxDeferred(nuIdxQuota).first;
        /* Se procesan los diferidos */
        while (nuIdxDefer is not null) loop
          nuConcept := tbTaxDeferred(nuIdxQuota)(nuIdxDefer).nuConcept;
          nuValue   := tbTaxDeferred(nuIdxQuota)(nuIdxDefer).nuValue;
          pkg_traza.Trace('tbTaxDeferred( ' || to_char(nuIdxQuota) ||
                         ' )( ' || to_char(nuIdxDefer) ||
                         ' ).nuConcept -> [' ||
                         to_char(tbTaxDeferred(nuIdxQuota)(nuIdxDefer)
                                 .nuConcept) || ']',
                         pkg_traza.cnuNivelTrzDef);
          pkg_traza.Trace('tbTaxDeferred( ' || to_char(nuIdxQuota) ||
                         ' )( ' || to_char(nuIdxDefer) ||
                         ' ).nuValue -> [' ||
                         to_char(tbTaxDeferred(nuIdxQuota)(nuIdxDefer)
                                 .nuValue) || ']',
                         pkg_traza.cnuNivelTrzDef);
          /* Se verifica que el valor del impuesto del diferido sea
          diferente de cero(0) */
          if (nuValue <> pkBillConst.CERO) then
            /* Se verifica si ya existe un cargo para el concepto */
            if (tbCharges.exists(nuConcept)) then
              /* Se acumula el valor del concepto */
              tbCharges(nuConcept).nuValue := tbCharges(nuConcept)
                                              .nuValue + nuValue;
            else
              -- Establece el valor del concepto */
              tbCharges(nuConcept).nuConcept := nuConcept;
              tbCharges(nuConcept).nuValue := nuValue;
            end if;
          end if;
          /* Se obtiene el indice del siguiente diferido */
          nuIdxDefer := tbTaxDeferred(nuIdxQuota).next(nuIdxDefer);
        end loop;
        /* Valida que la coleccion de cargos base para calculo de impuestos
        no se encuentre vacia */
        if (tbCharges.count > pkBillConst.CERO) then
          /* Se liquida el impuesto para la cuota */
          nuTaxValue := pkTaxesMgr.fnuGetTaxValue(rcProduct,
                                                  null,
                                                  tbCharges,
                                                  FALSE);
          /* Se aplica la politica de redondeo sobre el valor de impuestos
          calculado */
          FA_BOPoliticaRedondeo.AplicaPolitica(rcProduct.sesunuse,
                                               nuTaxValue);
        end if;
        --  Asigna el impuesto del interes
        iotbquotasimulate(nuIdxQuota).Interest_Tax := nvl(nuTaxValue,
                                                          pkBillConst.CERO);
        --  Calcula el total de la cuota
        iotbquotasimulate(nuIdxQuota).Total := nvl(iotbquotasimulate(nuIdxQuota)
                                                   .Capital,
                                                   pkBillConst.CERO) +
                                               nvl(iotbquotasimulate(nuIdxQuota)
                                                   .Interests,
                                                   pkBillConst.CERO) +
                                               nvl(iotbquotasimulate(nuIdxQuota)
                                                   .Interest_Tax,
                                                   pkBillConst.CERO) +
                                               nvl(iotbquotasimulate(nuIdxQuota)
                                                   .Extra_Payment,
                                                   pkBillConst.CERO);
        -- Se obtiene el indice de la siguiente cuota */
        nuIdxQuota := tbTaxDeferred.next(nuIdxQuota);
      end loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END LiquidateTax;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.Trace('Generando flujo de cuotas ...', pkg_traza.cnuNivelTrzDef);
    nuDeferQuotNum := pkBillConst.CERO;
    nuQuotaFlow    := pkBillConst.CERO;
    /* Si no hay diferidos, no se realiza ninguna accion */
    if (iotbDeferred.count = pkBillConst.CERO) then
      pkg_traza.Trace('Fin: [CC_BOFinancing.SetFinToSimulate]',
                     pkg_traza.cnuNivelTrzDef);
      return;
    end if;
    /* Se inializan las variables de acumulados */
    onuTotalAcumCapital  := pkBillConst.CERO;
    onuTotalAcumCuotExtr := pkBillConst.CERO;
    onuTotalAcumInteres  := pkBillConst.CERO;
    /* Se procesan los diferidos */
    nuIndex := iotbDeferred.first;
    while (nuIndex is not null) loop
      /* Se obtiene el producto asociado al diferido */
      nuProduct := iotbDeferred(nuIndex).product_id;
      /* Se obtiene el numero de cuotas definida en los diferidos */
      if (iotbDeferred(nuIndex).quotas_number > nuDeferQuotNum) then
        nuDeferQuotNum := iotbDeferred(nuIndex).quotas_number;
      end if;
      /* Se establece el signo del diferido */
      nuSigno := pkBillConst.cnuSUMA_CARGO;
      if (iotbDeferred(nuIndex).deferred_sign = pkBillConst.CREDITO) then
        nuSigno := pkBillConst.cnuRESTA_CARGO;
      end if;
      -- Arma las cuotas extras del grupo de diferidos
      pkAditionalPaymentMgr.ClearMemory;
      nuExtraValues := pkBillConst.CERO;
      /* Se procesan las cuotas extra del diferido */
      for rcGroupExtraPayments in CC_BCFinancing.cuDeferExtraPayment(iotbDeferred(nuIndex)
                                                                     .deferred_id,
                                                                     iotbExtraPayments) loop
        /* Se establece la informacion de la cuota extra */
        rcCuotExtr.cuexdife := cnuSimulating;
        rcCuotExtr.cuexnume := rcGroupExtraPayments.quota_number;
        rcCuotExtr.cuexvalo := rcGroupExtraPayments.s_quota_value;
        rcCuotExtr.cuexcobr := csbCuexcobr;
        -- Se adiciona la cuota extra a la memoria global
        pkAditionalPaymentMgr.AddRecord(rcCuotExtr);
        /* Se acumula el valor total de cuota extra para el diferido */
        nuExtraValues := nuExtraValues + rcCuotExtr.cuexvalo;
      end loop;
      nuExtraValues := nuExtraValues * nuSigno;
      /* Se calcula el valor de capital como la diferencia entre el valor
      total del diferido y el valor total de las cuotas extra */
      nuCapitalValue := iotbDeferred(nuIndex)
                        .deferred_value - abs(nuExtraValues);
      nuCapitalValue := nuCapitalValue * nuSigno;
      /* Simula el flujo de cuotas del diferido */
      pkDeferredMgr.StoreInstallments(iotbDeferred  (nuIndex).product_id,
                                      idtCollectDate,
                                      iotbDeferred  (nuIndex).deferred_value, /* Saldo del diferido */
                                      iotbDeferred  (nuIndex)
                                      .interest_percent,
                                      iotbDeferred  (nuIndex).spread,
                                      iotbDeferred  (nuIndex)
                                      .finan_compute_method,
                                      iotbDeferred  (nuIndex).quota_value,
                                      iotbDeferred  (nuIndex).quotas_number,
                                      iotbDeferred  (nuIndex).deferred_sign,
                                      iotbDeferred  (nuIndex).deferred_value, /* Valor total del diferido */
                                      iotbDeferred  (nuIndex)
                                      .gradient_factor);
      -- Inicializa contador de cuotas para el flujo
      nuQuotaIdx := pkBillConst.CERO;
      -- Acumula valores del flujo de cuotas para la financiacion
      nuIdx := null;
      nuAcumCapital  := pkBillConst.CERO;
      nuAcumCuotExt  := pkBillConst.CERO;
      nuAcumInterest := pkBillConst.CERO;
      /* Se procesan las cuotas del diferido */
      loop
        pkDeferredMgr.PopulateInstallments(nuIdx, -- Indice de la siguiente cuota a la ya leida
                                           rcCuotas);
        /* Verifica que haya cuota para procesar */
        if (rcCuotas.sbPeriodo is not null) then
          nuQuotaIdx := nuQuotaIdx + 1;
          /* Ajusta el numero maximo de cuotas del flujo */
          if (nuQuotaIdx > nuQuotaFlow) then
            nuQuotaFlow := nuQuotaIdx;
          end if;
          -- Acumula las Cuotas de los distintos diferidos
          rcCuotas.nuVlrCuoExtr := nvl(nuSigno * rcCuotas.nuVlrCuoExtr,
                                       pkBillConst.CERO);
          rcCuotas.nuVlrCapital := nvl(nuSigno * rcCuotas.nuVlrCapital,
                                       pkBillConst.CERO);
          rcCuotas.nuVlrInteres := nvl(nuSigno * rcCuotas.nuVlrInteres,
                                       pkBillConst.CERO);
          -- Toma un indice valido para ajuste de cuota extra
          if (rcCuotas.nuVlrCuoExtr <> pkBillConst.CERO) then
            nuIdxCuoExtr := nuIdx;
          end if;
          --  En la posicion Nro Cuota - Nro Diferido
          tbTaxDeferred(nuQuotaIdx)(nuIndex).nuConcept := iotbDeferred(nuIndex)
                                                          .interest_concept_id;
          tbTaxDeferred(nuQuotaIdx)(nuIndex).nuValue := rcCuotas.nuVlrInteres;
          if (iotbquotasimulate.exists(nuQuotaIdx)) then
            /* Se acumula el valor de cuota extra */
            iotbquotasimulate(nuQuotaIdx).extra_payment := iotbquotasimulate(nuQuotaIdx)
                                                           .extra_payment +
                                                            rcCuotas.nuVlrCuoExtr;
            /* Se acumula el valor de capital */
            iotbquotasimulate(nuQuotaIdx).capital := iotbquotasimulate(nuQuotaIdx)
                                                     .capital +
                                                      rcCuotas.nuVlrCapital;
            /* Se acumula el valor de intereses */
            iotbquotasimulate(nuQuotaIdx).interests := iotbquotasimulate(nuQuotaIdx)
                                                       .interests +
                                                        rcCuotas.nuVlrInteres;
          else
            /* Crea una nueva cuota */
            rcQuotaFlow := mo_tyobQuotaSimulate(nuQuotaIdx, -- sequence_id
                                                rcCuotas.sbPeriodo, -- period
                                                rcCuotas.nuVlrCuoExtr, -- extrapayment
                                                rcCuotas.nuVlrCapital, -- capital
                                                rcCuotas.nuVlrInteres, -- interests
                                                pkBillConst.CERO, -- total
                                                pkBillConst.CERO -- IVA interes
                                                );
            /* Se adiciona la cuota a la coleccion del flujo de cuotas */
            iotbquotasimulate.extend;
            iotbquotasimulate(nuQuotaIdx) := rcQuotaFlow;
          end if;
          nuAcumInterest := nuAcumInterest + rcCuotas.nuVlrInteres;
          nuAcumCapital  := nuAcumCapital + rcCuotas.nuVlrCapital;
          nuAcumCuotExt  := nuAcumCuotExt + rcCuotas.nuVlrCuoExtr;
        end if;
        /* Condicion de salida del bucle */
        exit when nuIdx is null;
      end loop;
      --Ajuste Visual
      if ((nuAcumCuotExt <> nuExtraValues) AND
         (abs(nuAcumCuotExt - nuExtraValues) < cnuValorTopeAjuste)) then
        nuDif := nuAcumCuotExt - nuExtraValues;
        pkg_traza.trace('Ajustando cuota extra en flujo para diferido nuIndex=' ||
                       nuIndex || ' valor=' ||
                       to_char(nuAcumCuotExt - nuExtraValues),
                       pkg_traza.cnuNivelTrzDef);
        iotbquotasimulate(nuIdxCuoExtr).extra_payment := iotbquotasimulate(nuIdxCuoExtr)
                                                         .extra_payment -
                                                          nuDif;
        iotbquotasimulate(nuQuotaIdx).capital := iotbquotasimulate(nuQuotaIdx)
                                                 .capital - nuDif;
        nuAcumCuotExt := nuAcumCuotExt - nuDif;
      end if;
      if ((nuAcumCapital <> nuCapitalValue) AND
         (abs(nuAcumCapital - nuCapitalValue) < cnuValorTopeAjuste)) then
        pkg_traza.trace('Ajustando capital en flujo para diferido nuIndex=' ||
                       nuIndex || ' valor=' ||
                       to_char(nuAcumCapital - nuCapitalValue),
                       pkg_traza.cnuNivelTrzDef);
        nuDif := nuAcumCapital - nuCapitalValue;
        iotbquotasimulate(nuQuotaIdx).capital := iotbquotasimulate(nuQuotaIdx)
                                                 .capital - nuDif;
        nuAcumCapital := nuAcumCapital - nuDif;
      end if;
      onuTotalAcumCapital  := onuTotalAcumCapital + nuAcumCapital;
      onuTotalAcumCuotExtr := onuTotalAcumCuotExtr + nuAcumCuotExt;
      onuTotalAcumInteres  := onuTotalAcumInteres + nuAcumInterest;
      /* Se obtiene el indice del siguiente diferido */
      nuIndex := iotbDeferred.next(nuIndex);
    end loop;
    -- Calcula el valor de impuestos sobre los intereses de financiacion
    LiquidateTax;
    if (nuDeferQuotNum > nuQuotaFlow) then
      /* Error: Error en la configuracion de la cuota normal del diferido       */
      pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,cnuERROR_CUOTA||'-'||csbERROR_CUOTA);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END SetFinToSimulate;

  PROCEDURE ExecDebtFinanc(inuPlan               in diferido.difepldi%type,
                           inuMetodoCuota        in diferido.difemeca%type,
                           idtCollectDate        in diferido.difefein%type,
                           inuPorcInteres        in diferido.difeinte%type,
                           inuSpread             in diferido.difespre%type,
                           inuNumeroCuotas       in diferido.difenucu%type,
                           isbDocumento          in diferido.difenudo%type,
                           inuPorcAFinanciar     in number,
                           inuVlrPagoIni         in number,
                           ichIVAUnaCuota        in char,
                           isbPrograma           in procesos.proccodi%type,
                           isbSimulate           in varchar2,
                           isbChangeConditions   in varchar2,
                           inuFinanCode          in diferido.difecofi%type,
                           onuAcumCuota          out number,
                           onuSaldo              out number,
                           onuTotalAcumCapital   out number,
                           onuTotalAcumCuotExtr  out number,
                           onuTotalAcumInteres   out number,
                           osbSignRequired       out varchar2, -- Requiere visado (S|N)
                           isbIgnoreClaimRequest in varchar2 default 'N' -- Ignorar reclamos en tramite (S|N)
                           ) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ExecDebtFinanc'; --Nombre del método en la traza
    /* Porcentaje a financiar */
    nuPorcFinanc number;
    /* Identificador de la suscripcion cuya deuda esta siendo financiada */
    nuSubscriptionId suscripc.susccodi%type;
    /* Datos de la suscripcion cuya deuda esta siendo procesada */
    rcSubscription suscripc%rowtype;
    /* Factor de redondeo de cobros configurado para la suscripcion cuya
    deuda esta siendo financiada */
    nuRoundFactor timoempr.tmemfare%type;
    /* Flag para indicar si el funcionario tiene valor de monto tope superior
    al valor a financiar segun su perfil financiero */
    boValidLimit boolean;
    /* Flag que indica si se esta procesando el ultimo producto */
    blLastProduct boolean;
    /* Acumulados para los N servicios suscritos seleccionados */
    nuAcumCuota diferido.difevacu%type;
    nuSaldo     diferido.difesape%type;
    /* Codigo de la financiacion */
    nuFinancode diferido.difecofi%type;
    /* Programa con el cual seran asociados los diferidos y cargos generados
    por el proceso de financiacion */
    sbProgram                 procesos.proccodi%type;
    nugVlrNoFinanciableCargos cc_tmp_bal_by_conc.not_financing_balance%type;

    function fnugetTotalValue return number is
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'fnugetTotalValue'; --Nombre del método en la traza
        nuretorno number := 0;
        cursor cuTotalValue is
        SELECT nvl(sum(deferred_value), 0)
          FROM table(cast(tbgDeferred AS mo_tytbdeferred));

    begin
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
        open cuTotalValue;
             fetch cuTotalValue into nuretorno;
        close cuTotalValue;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
       return nuretorno;
    end fnugetTotalValue;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    SAVEPOINT Financing;
    pkg_traza.trace('inuPlan               = ' || to_char(inuPlan), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuMetodoCuota        = ' || to_char(inuMetodoCuota), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('idtCollectDate        = ' || idtCollectDate, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuPorcInteres        = ' || to_char(inuPorcInteres), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuSpread             = ' || to_char(inuSpread), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuNumeroCuotas       = ' || to_char(inuNumeroCuotas), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbDocumento          = ' || isbDocumento, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuPorcAFinanciar     = ' || to_char(inuPorcAFinanciar), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuVlrPagoIni         = ' || to_char(inuVlrPagoIni), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('ichIVAUnaCuota        = ' || ichIVAUnaCuota, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbPrograma           = ' || isbPrograma, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbSimulate           = ' || isbSimulate, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbChangeConditions   = ' || isbChangeConditions, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuFinanCode          = ' || to_char(inuFinanCode), pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('isbIgnoreClaimRequest = ' || isbIgnoreClaimRequest, pkg_traza.cnuNivelTrzDef);

    -- Se asigna el flag que indica que el proceso corresponde a una simulacion
    nugSimulate := isbSimulate;
    /* Establece el nombre del programa especificado */
    sbProgram := isbPrograma;
    -- Inicializa colecciones y tablas pl/sql globales
    ClearMemoryFinancing;
    -- Obtiene totales de saldos por concepto
    CC_BCFinancing.GetTotalFinancingDebt(nugVlrFinCargos,
                                         nugVlrFinIVACargos,
                                         nugVlrFinanciable,
                                         nugVlrNoFinanciableCargos);
    -- Se verifica que el valor a financiar sea mayor a cero(0) y que el valor
    -- de pago inicial no sea superior al valor no financiable mas el valor
    -- total a financiar
    if (nugVlrFinanciable <= pkBillConst.CERO OR
       (nugVlrNoFinanciableCargos + nugVlrFinanciable) <= inuVlrPagoIni) then
      -- Se asigna el flag que indica si el valor a financiar es mayor a cero(0)
      gblValToFinGreaterZero := FALSE;
      return;
    end if;
    -- Se recalcula el porcentaje a financiar
    nuPorcFinanc := pkBillConst.CIENPORCIEN -
                    ((inuVlrPagoIni - nugVlrNoFinanciableCargos) *
                    pkBillConst.CIENPORCIEN / nugVlrFinanciable);
    -- Se asegura que el porcentaje a financiar no sea mayor a cien por ciento
    if (nuPorcFinanc > pkBillConst.CIENPORCIEN) then
      nuPorcFinanc := pkBillConst.CIENPORCIEN;
    end if;
    /* Se obtiene la suscripcion cuya deuda se esta financiando */
    nuSubscriptionId := CC_BCFinancing.fnuGetSubsFromDebtToFin;
    rcSubscription   := pktblSuscripc.frcGetRecord(nuSubscriptionId);
    /* Se obtiene el factor de redondeo configurado para la suscripcion */
    FA_BOPoliticaRedondeo.ObtFactorRedondeo(nuSubscriptionId,
                                            nuRoundFactor);
    pkg_traza.Trace('Porcentaje a financiar [' || nuPorcFinanc || ']',
                   pkg_traza.cnuNivelTrzDef);
    nugVlrFinTotal := round((nugVlrFinanciable) * nuPorcFinanc /
                            pkBillConst.CIENPORCIEN,
                            nuRoundFactor);
    nugVlrFinIva   := round((nugVlrFinIVACargos) * nuPorcFinanc /
                            pkBillConst.CIENPORCIEN,
                            nuRoundFactor);
    -- Calcula el valor financiable del cargo y del iva
    CC_BCFinancing.UpValueToFinancing(nuPorcFinanc,
                                      nugVlrFinTotal,
                                      nuRoundFactor);
    -- Si el valor de pago inicial es mayor a cero(0) y dicho valor es mayor
    -- o igual al valor no financiable, Se ajusta el valor a financiar de
    -- manera que luego de generar los cargos de la financiacion, la sumatoria del
    -- saldo de los productos sea exactamente igual al valor de pago inicial
    if (inuVlrPagoIni > 0 and inuVlrPagoIni >= nugVlrNoFinanciableCargos) then
      AdjustValueToFinance(nuSubscriptionId, inuVlrPagoIni);
    end if;
    /* Se verifica si el proceso corresponde a un cambio de condiciones de
    financiacion, en cuyo caso no se valida tope por perfil financiero y
    la solicitud por defecto no requiere visado */
    if (isbChangeConditions = constants_per.CSBNO) then
      /* Se verifica si el funcionario actual tiene un valor de monto tope superior
      al valor a financiar segun su perfil financiero */
      GE_BOFinancialProfile.VerifyUserMaxBudget(pkg_session.getuserid,
                                                FI_BOFinanDebtProcess.cnuACTION_AMOUNT_ID,
                                                nugVlrFinTotal,
                                                rcSubscription.susctimo,
                                                boValidLimit);
      /* Si el funcionario tiene un valor de monto tope superior al valor a
      financiar, la financiacion no requiere visado */
      if (boValidLimit) then
        osbSignRequired := constants_per.CSBNO;
      else
        osbSignRequired := constants_per.CSBSI;
      end if;
      /* Se verifica si la financiacion sera realizada sobre cartera vencida,
      en cuyo caso se establece el nombre de la aplicacion CUSTOMER */
      if (CC_BCFinancing.fboIsFinanOverExpDebt) then
        /* Se establece como nombre de programa, la aplicacion CUSTOMER */
        sbProgram := CC_BOConstants.csbCUSTOMERCARE;
      end if;
    else
      /* Los procesos de cambio de condiciones de financiacion no aplican
      para visado */
      osbSignRequired := constants_per.CSBNO;
    end if;
    /* Se establece el nombre de la aplicacion */
    pkg_error.SetApplication(sbProgram);
    -- Inicializa acumulador de diferidos funanciados
    nugAcumFinancing := pkBillConst.CERO;
    nugAcumChCond := pkBillConst.CERO;
    -- Inicializa acumuladores
    onuAcumCuota := pkBillConst.CERO;
    onuSaldo     := pkBillConst.CERO;
    -- Obtiene codigo de siguiente financiacion si no esta en modo
    -- simulacion
    if (isbSimulate = constants_per.CSBNO) then
      if (inuFinanCode is NULL) then
        pkDeferredMgr.nuGetNextFincCode(nuFinanCode);
      else
        nuFinanCode := inuFinanCode;
      end if;
    end if;
    -- Se asigna el codigo de la financiacion
    nugFinanCode := nuFinanCode;
    -- Se verifica si el proceso corresponde a cambio de condiciones
    if (isbChangeConditions = constants_per.CSBNO) then
      -- Valida el numero de cuentas para corte del plan contra
      -- el numero de cuentas para corte del tipo de producto
      ValConfCose(inuPlan);
    end if;
    -- Se recorren los productos seleccionados de la financiacion
    for rcProduct in CC_BCFinancing.cu_Products_To_Finance loop
      nugSubscription := rcProduct.subscription_Id;
      pkg_traza.Trace('-----------------------------------------------------------------------',
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.Trace('Procesando Suscripcion [' || nugSubscription ||
                     '] producto [' || rcProduct.product_id || ']',
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.Trace('-----------------------------------------------------------------------',
                     pkg_traza.cnuNivelTrzDef);
      nuAcumCuota := pkBillConst.CERO;
      nuSaldo     := pkBillConst.CERO;
      -- Se verifica si se esta procesando el ultimo producto
      blLastProduct := (rcProduct.rownum = rcProduct.maxrownum);
      if (blLastProduct) then
        pkg_traza.Trace('Procesando ultimo producto de la financiacion [' ||
                       rcProduct.product_id || '] ...',
                       pkg_traza.cnuNivelTrzDef);
      end if;
      -- Se obtiene el valor del producto a financiar
      nugFinancingBalance := rcProduct.s_pend_balance_to_finance;
      -- Se ejecuta el proceso de financiacion para el producto
      FinancingDebt(rcProduct.product_id,
                    inuPlan,
                    inuMetodoCuota,
                    idtCollectDate,
                    inuPorcInteres,
                    inuSpread,
                    inuNumeroCuotas,
                    isbDocumento,
                    nuPorcFinanc,
                    nugFinancingBalance,
                    pkBillConst.CERO,
                    ichIVAUnaCuota,
                    sbProgram,
                    nuFinanCode,
                    isbSimulate,
                    isbChangeConditions,
                    blLastProduct,
                    isbIgnoreClaimRequest,
                    nuAcumCuota,
                    nuSaldo);
      -- Validar que el saldo por producto no quede negativo, si esto ocurre deshacer la financiacion
      if (nuSaldo < pkBillConst.CERO) then
        --  Saldo Actual: %s1. A financiar: %s2, Cuota: %s3,
        --  Servicio suscrito: %s4.
        --  El saldo despues de financiar quedara negativo.
        --  La financiacion no se realizara
        pkg_error.setErrorMessage(cnuSALDO_NEGATIVO_SERV,
                        nuSaldo || '|' || nugFinancingBalance || '|' ||
                        nuAcumCuota || '|' || rcProduct.product_id);
      end if;
      -- Acumula valores que retorna el API
      onuAcumCuota := onuAcumCuota + nuAcumCuota; -- Cuota
      onuSaldo     := onuSaldo + nuSaldo;
      pkg_traza.Trace('Saldo acumulado de productos luego de financiar ' ||
                     nuSaldo,
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.Trace('-----------------------------------------------------------------------',
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.Trace('Fin proceso Suscripcion [' || nugSubscription ||
                     '] producto [' || rcProduct.product_id || ']',
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.Trace('-----------------------------------------------------------------------',
                     pkg_traza.cnuNivelTrzDef);
    end loop;
    -- amendezSAO85070 Tiene en cuenta el saldo de productos no financiados
    -- para generar el cupon de financiacion
    for rcProduct in CC_BCFinancing.cu_products_not_finance loop
      -- Se obtiene el saldo pendiente del producto
      nuSaldo := fnuGetProductBalance(rcProduct.product_id);
      pkg_traza.Trace('Acumulando saldo de producto [' ||
                     rcProduct.product_id || '] no financiado ' || nuSaldo,
                     pkg_traza.cnuNivelTrzDef);
      -- Se acumula el saldo pendiente del producto al total
      onuSaldo := onuSaldo + nuSaldo;
      pkg_traza.Trace('Saldo acumulado de productos ' || onuSaldo,
                     pkg_traza.cnuNivelTrzDef);

    end loop;
    -- Validar que el saldo de los productos no quede negativo, si esto ocurre deshacer la financiacion
    if (onuSaldo < pkBillConst.CERO) then
      -- Saldo Actual: %s1. A financiar: %s2, Cuota: %s3.
      --  El saldo despues de financiar quedara negativo.
      --  La financiacion no se realizara
      pkg_error.setErrorMessage(cnuSALDO_NEGATIVO,
                                onuSaldo || '|' || nugFinancingBalance || '|' ||
                                nuAcumCuota);
    end if;
    pkg_traza.Trace('Actualizando tabla de simulacion de cuotas', pkg_traza.cnuNivelTrzDef);
    -- Simular Siempre para que valide flujo de cuotas.
    tbgQuotaSimulate := mo_tytbQuotaSimulate();
    SetFinToSimulate(idtCollectDate,
                     tbgDeferred,
                     tbgExtraPayments,
                     tbgQuotaSimulate,
                     onuTotalAcumCapital,
                     onuTotalAcumCuotExtr,
                     onuTotalAcumInteres);
    --  Calcula el total de los diferidos
    gnuTotalValue := fnugetTotalValue;

    -- Si el flujo no registro cuotas extras y hay cuotas extras configuradas
    -- error.
    if ((onuTotalAcumCuotExtr = pkBillConst.CERO) and
       (tbExtraPayment.count > pkBillConst.CERO)) then
        -- Error en la configuracion de cuotas extras.
        pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,cnuERROR_CUOTA||'-'||csbERROR_CUOTA);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      -- Inicializa data de financiacion
      ClearMemoryFinancing;
      ROLLBACK TO SAVEPOINT Financing;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      -- Inicializa data de financiacion
      ClearMemoryFinancing;
      pkg_error.setError;
      ROLLBACK TO SAVEPOINT Financing;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ExecDebtFinanc;

  FUNCTION fnuSignDeferred(isbSigno in cargos.cargsign%type)
    return cargos.cargvalo%type IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnuSignDeferred'; --Nombre del método en la traza
    nuValor number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuValor := pkBillConst.CERO;
    if isbSigno = pkBillConst.DEBITO then
      nuValor := pkBillConst.cnuSUMA_CARGO;
    end if;
    if isbSigno = pkBillConst.CREDITO then
      nuValor := pkBillConst.cnuRESTA_CARGO;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return(nuValor);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fnuSignDeferred;


  PROCEDURE CommitFinanc(iboGenLateCharges in boolean default FALSE) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'CommitFinanc'; --Nombre del método en la traza
    ------------------------------------------------------------------------
    --  Tipos
    ------------------------------------------------------------------------
    /* Record de mora */
    type tyrcArrear is record(
      tbCharges  pkBCCargos.tytbrcCargos,
      tbInfoMora FA_BOLiqLateConcepts.tytbLateData);
    -- Tipo de tabla de conceptos
    type tytbrcArrear is table of tyrcArrear index by varchar(10);
    ------------------------------------------------------------------------
    --  Variables
    ------------------------------------------------------------------------
    -- Numero del Diferido
    nuNumDife diferido.difecodi%type;
    -- Valor total a Diferir
    nugVlrDifer pkBCServsusc.stysesusape;
    /* Coleccion de productos asociados a los diferidos a crear */
    tbProducts pkBCServsusc.tytbSesunuse;
    /* Indice para acceder a la coleccion de productos */
    sbProdIdx pkBCServsusc.stysbIdxSeSu;
    /* Documento de soporte asociado a los diferidos */
    sbSupportDoc diferido.difenudo%type;
    /* Registro para almacenar los datos de la solicitud de financiacion */
    rcFinanReq    DACC_Financing_Request.styCC_financing_request;
    rcDebtNegot   gc_debt_negotiation%rowtype;
    nuFinancingId cc_financing_request.financing_id%type;
    /* Fecha de liquidacion */
    dtCurrentDate date;
    /* Tabla para guardar los registros de mora */
    tbArrearsAll tytbrcArrear;
    /* ------------------------------------------------------------------ */
    /*                    Procedimientos Encapsulados                     */
    /* ------------------------------------------------------------------ */
    /***********************************************************************
        Propiedad Intelectual de Open Systems International (c).
        Procedimiento:  FillAccReceivProc
        Descripcion : Calcula el valor que se esta financiado para aplicarlo
                  en el estado de cartera de gestion de cobro
        Parametros  : Descripcion
          inuVlrConc  Valor del Cargo
          isbSigno    Signo del Cargo
        Autor : mgutierrez
        Fecha : 03-Oct-2001
        Historia de Modificaciones
        Fecha Autor Modificacion
      --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG
          por GE_ERROR_LOG.
        24-Dic-2001 mgutierrezOP8954
        se utiliza la funcion fnuSignDeferred
        03-Oct-2001 mgutierrezOP8553
        Creacion del Metodo
    ***********************************************************************/
    PROCEDURE FillAccReceivProc(inuVlrConc in cargos.cargvalo%type,
                                isbSigno   in cargos.cargsign%type) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.FillAccReceivProc'; --Nombre del método en la traza
      -- Variables Locales
      nuVlrConc pkBCServsusc.stysesusape;
      sbSigno   cargos.cargsign%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      nuVlrConc := inuVlrConc;
      sbSigno   := isbSigno;
      -- Carga los valores de los cargos a financiar
      nugVlrDifer := nugVlrDifer + nuVlrConc * fnuSignDeferred(sbSigno);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR  then
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END FillAccReceivProc;
    /***********************************************************************
    Procedure : AddDeferred
    Descripcion : Adiciona el diferido
              Add Deferred
    Parametros
        inuIdx  Indice del record en la Tabla en memoria
          Historia de Modificaciones
          Fecha     Autor          Modificacion
          15-May-2008 amendezSAO75544  Por cambio en la estructura de
                                       tbgDeferred se obtiene el contrato
                                       de la variable global
      ***********************************************************************/
    PROCEDURE AddDeferred(inuIdx in number) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.AddDeferred'; --Nombre del método en la traza
      csbREG_TYPE_DEFER constant varchar2(1) := 'D';
      rcDiferido diferido%rowtype; -- Record tabla diferido
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Acumula los valores de los conceptos que se difieren
      FillAccReceivProc(tbgDeferred(inuIdx).deferred_value,
                        tbgDeferred(inuIdx).deferred_sign);
      pkg_traza.trace('Armando registro para diferido ' || tbgDeferred(inuIdx)
                     .deferred_id,
                     pkg_traza.cnuNivelTrzDef);
      -- Arma record diferido
      rcDiferido.difecodi := tbgDeferred(inuIdx).deferred_id;
      rcDiferido.difesusc := nugSubscription;
      rcDiferido.difeconc := tbgDeferred(inuIdx).concept_id;
      rcDiferido.difevatd := tbgDeferred(inuIdx).deferred_value;
      rcDiferido.difevacu := tbgDeferred(inuIdx).quota_value;
      rcDiferido.difecupa := tbgDeferred(inuIdx).count_caused_quotas;
      rcDiferido.difenucu := tbgDeferred(inuIdx).quotas_number;
      rcDiferido.difesape := tbgDeferred(inuIdx).pending_balance;
      rcDiferido.difenudo := tbgDeferred(inuIdx).document_support;
      rcDiferido.difeinte := tbgDeferred(inuIdx).interest_percent;
      rcDiferido.difeinac := tbgDeferred(inuIdx).accumulated_interest;
      rcDiferido.difeusua := tbgDeferred(inuIdx).username;
      rcDiferido.difeterm := tbgDeferred(inuIdx).terminal;
      rcDiferido.difesign := tbgDeferred(inuIdx).deferred_sign;
      rcDiferido.difenuse := tbgDeferred(inuIdx).product_id;
      rcDiferido.difemeca := tbgDeferred(inuIdx).finan_compute_method;
      rcDiferido.difecoin := tbgDeferred(inuIdx).interest_concept_id;
      rcDiferido.difeprog := tbgDeferred(inuIdx).program;
      rcDiferido.difepldi := tbgDeferred(inuIdx).deferred_plan_id;
      rcDiferido.difetain := tbgDeferred(inuIdx).interest_rate_id;
      rcDiferido.difespre := tbgDeferred(inuIdx).spread;
      rcDiferido.difefumo := tbgDeferred(inuIdx).last_movement_date;
      rcDiferido.difefein := tbgDeferred(inuIdx).sys_register_date;
      rcDiferido.difefagr := tbgDeferred(inuIdx).gradient_factor;
      rcDiferido.difecofi := tbgDeferred(inuIdx).financing_id;
      rcDiferido.difelure := tbgDeferred(inuIdx).reception_site;
      rcDiferido.difefunc := tbgDeferred(inuIdx).functionary_id;
      rcDiferido.difetire := csbREG_TYPE_DEFER;
      -- Adiciona diferido
      pktblDiferido.InsRecord(rcDiferido);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END AddDeferred;
    /* -------------------------------------------------------------- */
    /************************************************************************
    Procedure : AddTransDef
    Descripcion : Adiciona movimiento del diferido
              Add Transaction Deferred
    Parametros
        inuIdx  Indice del record en la Tabla en memoria
      ************************************************************************/
    PROCEDURE AddTransDef(inuIdx in number) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.AddTransDef'; --Nombre del método en la traza
      rcMoviDife movidife%rowtype; -- Record tabla movidife
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Arma record de movimiento de diferido
      pkg_traza.trace('Armando registro de movimiento para el diferido ' ||
                     nuNumDife,
                     pkg_traza.cnuNivelTrzDef);
      rcMoviDife.modidife := tbgDeferred(inuIdx).deferred_id;
      rcMoviDife.modisusc := tbModi(inuIdx).modisusc;
      rcMoviDife.modisign := tbModi(inuIdx).modisign;
      rcMoviDife.modifeca := tbModi(inuIdx).modifeca;
      rcMoviDife.modicuap := tbModi(inuIdx).modicuap;
      rcMoviDife.modivacu := tbModi(inuIdx).modivacu;
      rcMoviDife.modidoso := tbModi(inuIdx).modidoso;
      rcMoviDife.modicaca := tbModi(inuIdx).modicaca;
      rcMoviDife.modifech := tbModi(inuIdx).modifech;
      rcMoviDife.modiusua := tbModi(inuIdx).modiusua;
      rcMoviDife.moditerm := tbModi(inuIdx).moditerm;
      rcMoviDife.modiprog := tbModi(inuIdx).modiprog;
      rcMoviDife.modinuse := tbModi(inuIdx).modinuse;
      rcMoviDife.modidiin := tbModi(inuIdx).modidiin;
      rcMoviDife.modipoin := tbModi(inuIdx).modipoin;
      rcMoviDife.modivain := tbModi(inuIdx).modivain;
      -- Adiciona movimiento diferido
      pktblMoviDife.InsRecord(rcMoviDife);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END AddTransDef;
    /* -------------------------------------------------------------- */
    /***********************************************************************
    Procedure : AddAditionalIntlmnt
    Descripcion : Adicion de las Cuotas Extras
              Add Aditional Instalment
    Parametros
        inuDifeMem  Indice del record del Diferido en la Tabla en memoria
      ***********************************************************************/
    procedure AddAditionalIntlmnt(inuDifeMem in number) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.AddAditionalIntlmnt'; --Nombre del método en la traza
      nuIdxCuo   number; -- Indice records a borrar
      rcCuotExtr cuotextr%rowtype; -- Record tabla cuotextr
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      nuIdxCuo := tbgExtraPayments.first;
      loop
        exit when nuIdxCuo is null;
        -- Valida que las Cuotas Extras esten relacionados con el diferido
        if (to_number(tbgExtraPayments(nuIdxCuo).deferred_id) != inuDifeMem) then
          goto CONTINUE;
        end if;
        rcCuotExtr.cuexdife := tbgDeferred(inuDifeMem).deferred_id;
        rcCuotExtr.cuexnume := tbgExtraPayments(nuIdxCuo).quota_number;
        rcCuotExtr.cuexvalo := tbgExtraPayments(nuIdxCuo).quota_value;
        rcCuotExtr.cuexcobr := 'N';
        pkg_traza.trace('Insertando cuota extra #' || rcCuotExtr.cuexnume ||
                       'valor:' || rcCuotExtr.cuexvalo || ' diferido:' ||
                       rcCuotExtr.cuexdife,
                       pkg_traza.cnuNivelTrzDef);
        -- Adiciona Cargo
        pktblCuotExtr.InsRecord(rcCuotExtr);
        <<CONTINUE>>
        -- Pasa a proximo registro en la tabla
        nuIdxCuo := tbgExtraPayments.next(nuIdxCuo);
      end loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END AddAditionalIntlmnt;
    /***********************************************************************
      Propiedad Intelectual de Open Systems International (c).
    Procedure :    BuiltRecordCharge
    Descripcion :  Llena un registro de cargo a partir de un
                       objeto
    Parametros
      iobjCharge       Objeto de tipo Cargo
      orcChargeRecord  Registro para insertar en la tabla de cargos
      Historia de Modificaciones
      Fecha        Autor           Observacion
      ===========  =============== ======================================
      18-Oct-2013  jllanoSAO220733
      Se calcula la base del cargo para creacion de la nota con el metodo de BSS
      pkBOLiquidateTax.GetTaxBaseValue
      14-01-2009  aframirezSAO88760   Se obtienen los ID de usuario y programa
                                      ya que los datos que se obtiene desde la
                                      coleccion de cargos corresponden a sus
                                      valores alfanumericos y no los NUMBER que
                                      son requeridos. Ademas se agrega la
                                      asignacion de peridodo de facturacion ya
                                      que es un campo requerido.
      11-11-2008  mgutierrSAO44793
      Se modifica por cambio en modelo de datos
      02-Jul-2008 amendezSAO77863  Creacion
      ***********************************************************************/
    PROCEDURE BuiltRecordCharge(iobjCharge      in out nocopy mo_tyobCharges,
                                orcChargeRecord out nocopy cargos%rowtype) IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.BuiltRecordCharge'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Calcular la base del cargo
      pkBOLiquidateTax.GetTaxBaseValue(pktblservsusc.frcGetRecord(iobjCharge.PRODUCT_ID),
                                       iobjCharge.BILLING_PERIOD,
                                       iobjCharge.CONCEPT_ID,
                                       iobjCharge.CHARGE_VALUE,
                                       orcChargeRecord.cargvabl);
      orcChargeRecord.cargcuco := iobjCharge.BILL_ACCOUNT_ID;
      orcChargeRecord.cargnuse := iobjCharge.PRODUCT_ID;
      orcChargeRecord.cargconc := iobjCharge.CONCEPT_ID;
      orcChargeRecord.cargcaca := iobjCharge.CHARGE_CAUSE;
      orcChargeRecord.cargsign := iobjCharge.SIGN_;
      orcChargeRecord.cargpefa := iobjCharge.BILLING_PERIOD;
      orcChargeRecord.cargvalo := iobjCharge.CHARGE_VALUE;
      orcChargeRecord.cargdoso := iobjCharge.DOCUMENT_SUPPORT;
      orcChargeRecord.cargcodo := iobjCharge.DOCUMENT_ID;
      orcChargeRecord.cargtipr := iobjCharge.PROCESS_TYPE;
      orcChargeRecord.cargunid := iobjCharge.UNITS;
      orcChargeRecord.cargusua := sa_bosystem.getSystemUserID;
      orcChargeRecord.cargfecr := iobjCharge.CREATION_DATE;
      orcChargeRecord.cargprog := ge_bcProcesos.frcprograma(iobjCharge.PROGRAM)
                                  .proccons;
      pkg_traza.trace('Armo registro de cargo para la cuenta ' ||
                     orcChargeRecord.cargcuco || ' - Concepto:' ||
                     orcChargeRecord.cargconc || ' - valor:' ||
                     orcChargeRecord.cargvalo || ' - signo:' ||
                     orcChargeRecord.cargsign || ' Base: ' ||
                     orcChargeRecord.cargvabl || pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END BuiltRecordCharge;
    /***********************************************************************
     Propiedad intelectual de Open International Systems (c).
     Unidad      :  GenerateDiscountNotes
     Descripcion :  Metodo que crea las notas de descuento de la financiacion.
     Autor       :  Sandra Milena Quintero Polanco
     Fecha       :  28-02-2013
     Parametros  :  itbDiscCharges   Coleccion de cargos de descuento.
     Historia de Modificaciones
     Fecha      Autor                Modificacion
     =========  ===================  ==============================
    05-09-2014  AEcheverry.4769     Se modifica par no actualizar el flag
                                    de actualizable en base de datos a FALSE
     28-02-2013 squintero.SAO203050 Creacion
    ***********************************************************************/
    PROCEDURE GenerateDiscountNotes(itbDiscCharges in mo_tytbCharges) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.GenerateDiscountNotes'; --Nombre del método en la traza
      sbNotaObse notas.notaobse%type;
      -- Informacion de un cargo generico
      rcCharge     pkBCCharges.tyrcNoteCharge;
      nuIdxNoteChg number := 0;
      -- Coleccion de cargos de descuento
      tbDiscountCharges pkBCCharges.tytbNoteCharges;
      -- Causa de cargo para descuentos de acuerdos de pago
      nuCargCaca cargos.cargcaca%type;
      -- Coleccion de notas generadas
      tbGeneratedNotes pkBillingNoteMgr.tytbNotaMem;
      -- Indice para acceder a la coleccion de descuentos
      nuIndex binary_integer;
      -- Indice para acceder a la coleccion de diferidos
      nuDefIdx number;
      -- Contrato
      nuContract cc_financing_request.subscription_id%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Establece el indice para acceder a la coleccion de diferidos
      nuDefIdx := tbgDeferred.first;
      -- Se define la observacion de la nota ->  FD-#Financiacion
      sbNotaObse := sbTokenFD ||
                    to_char(tbgDeferred(nuDefIdx).financing_id);
      pkg_traza.Trace('sbNotaObse: ' || sbNotaObse, pkg_traza.cnuNivelTrzDef);
      -- Establece el indice para acceder a la coleccion de descuentos
      nuIndex := itbDiscCharges.first;
      -- Obtiene el contrato
      nuContract := pkg_bcproducto.fnucontrato(itbDiscCharges(nuIndex)
                                                    .product_id);
      pkg_traza.Trace('Contrato: ' || nuContract, pkg_traza.cnuNivelTrzDef);
      loop
        exit when nuIndex is null;
        /* Se obtiene la Causa de cargo para descuentos de acuerdos de pago */
        nuCargCaca := FA_BOChargeCauses.fnuSpecialFinChCause(itbDiscCharges(nuIndex)
                                                             .product_id);
        /* Crea un cargo generico */
        rcCharge.cargiden := nuIdxNoteChg;
        rcCharge.cargcuco := itbDiscCharges(nuIndex).bill_account_id;
        rcCharge.cargnuse := itbDiscCharges(nuIndex).product_id;
        rcCharge.cargconc := itbDiscCharges(nuIndex).concept_id;
        rcCharge.cargcaca := nuCargCaca;
        rcCharge.cargsign := itbDiscCharges(nuIndex).sign_;
        rcCharge.cargdoso := itbDiscCharges(nuIndex).document_support;
        rcCharge.cargvaco := itbDiscCharges(nuIndex).charge_value;
        nuIdxNoteChg := nuIdxNoteChg + 1;
        /* Agrega el cargo generico a la coleccion */
        tbDiscountCharges(rcCharge.cargiden) := rcCharge;
        nuIndex := itbDiscCharges.next(nuIndex);
      end loop;
      pkg_traza.Trace('Se crearan ' || tbDiscountCharges.count ||
                     ' notas de descuento',
                     pkg_traza.cnuNivelTrzDef);
      /* Setea la variable blUpdateDB para que registre los cargos en BD */
      FA_BOBillingNotes.SetUpdateDataBaseFlag;
      /* Crea las notas a partir de la coleccion de cargos genericos */
      FA_BOBillingNotes.CreateNotesFromMemory(inuSusccodi       => nuContract,
                                              isbNotaobse       => sbNotaObse,
                                              iotbCharges       => tbDiscountCharges,
                                              isbNotatino       => FA_BOBillingNotes.csbCREDIT_NOTE_TYPE, --NC
                                              otbGeneratedNotes => tbGeneratedNotes);
      -- Se valida la creacion de notas
      if (tbGeneratedNotes.count > 0) then
        -- Se recorren las notas generadas
        for nuInd IN tbGeneratedNotes.first .. tbGeneratedNotes.last loop
          -- Se numeran fiscalmente la nota
          pkBillingNoteMgr.ProcesoNumeracionFiscal(tbGeneratedNotes(nuInd)
                                                   .notanume);
        end loop;
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        pkg_error.setError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END GenerateDiscountNotes;
    /***********************************************************************
    Propiedad intelectual de Open International Systems (c).
    Unidad      :  CommitCharges
    Descripcion :  Crea los cargos de cancelacion de deuda por financiacion
                   y descuentos por acuerdo de pago.
    Autor       :  Diego Alejandro Ruiz Tabares
    Fecha       :  05-09-2012
    Historia de Modificaciones
    Fecha        Autor              Modificacion
    =========    =========          ====================
    21-03-2013     squintero.SAO205105
    Se reversan los cambios hechos en el SAO204734.
    21-03-2013   squintero.SAO205096
    Se setea el cargdoso en cero y se modifica la condicion para que permita
    crear los cargos que cancelen la deuda por financiacion para las facturas
    liquidadas en el proceso.
    20-03-2013   squintero.SAO204734
    Se valida que las facturas no hayan sido creadas durante el proceso para
    crear notas.
    01-03-2013   squintero.SAO203536
    Se limpia el tipo de nota para que la deje de Reclasificacion.
    28-02-2013   squintero.SAO203050
    Se sacan aparte los cargos de descuento para generar notas fiscales.
    14-11-2012   squintero.SAO196016
    Se crea la variable sbNotaObse para diferenciar la observacion de la
    nota del documento soporte.
    26-10-2012   squintero.SAO194758
    Se modifica el dato almacenado en NotaObse para que sea el toquen FD +
    el id de la financiacion y no el id del diferido (Se corrige error del
    sao 194758 - ref. druiz).
    05-09-2012   druiz.SAO181112    Creacion
    ***********************************************************************/
    PROCEDURE CommitCharges IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.CommitCharges'; --Nombre del método en la traza
      -- Indice para acceder a la coleccion de cargos
      nuIdxCarg number;
      -- Documento de soporte del cargo a crear
      sbSupporDoc cargos.cargdoso%type;
      sbNotaObse notas.notaobse%type;

      obCharge mo_tyobCharges;
      -- Coleccion de cargos de descuento
      tbDiscCharges mo_tytbCharges;
      -- Numero de la nota de facturacion que soporta el cargo
      nuBillNoteId     notas.notanume%type;

      -- Cadena que representa el codigo de la factura
      sbBillAccId varchar2(20);
      -- Indice para acceder a la coleccion de diferidos
      nuDefIdx number;
      --Tipos de datos usados en el registro de las notas
       rcNota       pkg_bcnotasrecord.tyrcNota;
       tbCargos     pkg_bcnotasrecord.tytbCargos;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Inicializa
      tbDiscCharges := mo_tytbCharges();
      -- Procesa la coleccion de cargos
      nuIdxCarg := tbgCharges.first;
      while (nuIdxCarg is not null) loop
        -- Se verifica que el cargo no corresponda a un descuento
        if (tbgCharges(nuIdxCarg).is_discount = csbNO) then
          -- Establece el indice para acceder a la coleccion de diferidos
          nuDefIdx := to_number(tbgCharges(nuIdxCarg).document_support);
          /* Establece el documento de soporte para cancelacion de deuda
          por financiacion */
          sbSupporDoc := sbTokenFD ||
                         to_char(tbgDeferred(nuDefIdx).deferred_id);
          sbNotaObse := sbTokenFD ||
                        to_char(tbgDeferred(nuDefIdx).financing_id);
          -- Obtiene una copia del objeto cargos
          obCharge := tbgCharges(nuIdxCarg);
          -- Se obtiene la factura asociada a la cuenta de cobro
          sbBillAccId := to_char(pktblCuencobr.fnuGetAccountStatus(obCharge.bill_account_id));
          pkg_traza.Trace('Factura ' || sbBillAccId ||
                         '- asociada a la cuenta de cobro: ' ||
                         obCharge.bill_account_id,
                         pkg_traza.cnuNivelTrzDef);
          -- Se verifica si ya existe una nota creada para la factura
          if (tbNoteSesu.exists(sbBillAccId)) then
            nuBillNoteId     := tbNoteSesu(sbBillAccId).nuNotanume;
          else
            --Informacíon de la nota
            rcNota.sbPrograma :=csbFINANCING_PROGRAM;
            rcNota.nuProducto := obCharge.product_id;
            rcNota.nuCuencobr := obCharge.bill_account_id;
            rcNota.nuNotacons := GE_BOConstants.fnuGetDocTypeCreNote;
            rcNota.dtNotafeco := obCharge.creation_date;
            rcNota.sbNotaobse := sbNotaObse;
            rcNota.sbNotaToken:= pkBillConst.csbTOKEN_NOTA_CREDITO;

            --Información detalle de la nota
            tbCargos(1).nuProducto  := obCharge.product_id;
            tbCargos(1).nuContrato  :=  PKG_BCPRODUCTO.FNUCONTRATO(obCharge.product_id);
            tbCargos(1).nuCuencobr  := obCharge.bill_account_id;
            tbCargos(1).nuConcepto  := obCharge.CONCEPT_ID;
            tbCargos(1).NuCausaCargo:= obCharge.CHARGE_CAUSE;
            tbCargos(1).nuValor     := obCharge.CHARGE_VALUE;
            tbCargos(1).nuValorBase := null;
            tbCargos(1).sbSigno     := obCharge.SIGN_;
            tbCargos(1).sbAjustaCuenta := constants_per.CSBSI;
            tbCargos(1).sbCargdoso  := sbSupporDoc;
            tbCargos(1).sbBalancePostivo := constants_per.CSBNO;
            tbCargos(1).boApruebaBal := FALSE;

            --Crea la nota con su detalle.
            api_registranotaydetalle(ircNota           => rcNota,
                                     itbCargos         => tbCargos,
                                     onuNote           => nuBillNoteId,--nota creada
                                     onuCodigoError    => nuCodMenErro,
                                     osbMensajeError   => sbMensaError
                                    );

            tbNoteSesu(sbBillAccId).nuNotanume := nuBillNoteId;

          end if;

        else
          -- Se cargan los descuento para procesarlos aparte
          tbDiscCharges.extend;
          tbDiscCharges(tbDiscCharges.last) := tbgCharges(nuIdxCarg);
        end if;
        -- Obtiene el indice del siguiente cargo
        nuIdxCarg := tbgCharges.next(nuIdxCarg);
      end loop;
      -- Genera cargos y crea notas de descuento
      if (tbDiscCharges.count > 0) then
        GenerateDiscountNotes(tbDiscCharges);
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        pkg_error.SetError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END CommitCharges;
    /***********************************************************************
        Propiedad Intelectual de Open Systems International (c).
        Procedimiento:  ProcAccountReceive
        Descripcion : Procesa Gestion de Cobro
        Autor : mgutierrez
        Fecha : 03-Oct-2001
        Historia de Modificaciones
        Fecha Autor Modificacion
        09/04/2010  lfernandezSAO115741
        Se elimina llamado a fblInAccoCollection de pkAdvaAccoCollProgMgr
      --14-MAY-05 cnaviaSAO37720  Se reemplazan las referencias a ERRORLOG por GE_ERROR_LOG.
        16-Oct-2001 mgutierrSAE6603
        Se corrige llamada de pkPayPastDue.Payment a pkFinancingPastDue.Financing
        01-Oct-2001 mgutierrezOP8553
        Creacion
    ***********************************************************************/
    PROCEDURE ProcAccountReceive IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.ProcAccountReceive'; --Nombre del método en la traza
      NUERRCOD GE_ERROR_LOG.ERROR_LOG_ID%TYPE; -- NUMERO DEL ERROR
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      pkFinancingPastDue.Financing(nugNumServ,
                                   nugVlrDeuda,
                                   nugVlrDifer,
                                   nuErrCod,
                                   sbErrMsg);
      if (nuErrCod <> pkBillConst.CERO) then
        RAISE PKG_ERROR.CONTROLLED_ERROR;
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END ProcAccountReceive;
    /***********************************************************************
     Propiedad intelectual de Open International Systems (c).
     Unidad      :  CommitAdjustsCharges
     Descripcion :  Crea lo cargos de Ajustes
     Autor       :
     Fecha       :
     Historia de Modificaciones
     Fecha      Autor                Modificacion
     =========  ===================  ==============================
     29-01-2024 Epenao               OSF-1835:
                                     Se elimina la lógica de creación del ajuste
                                     ya que en el método CommitCharges al llamar al
                                     api_registranotaydetalle se está haciendo el ajuste
                                     se deja la lógica para validar el saldo de las cuentas.
     28-04-2014 eurbano.SAO238926
     Se modifica para generar la nota sobre la cual se debe asociar
     el cargo de ajuste en caso de que esta no exista.
     26-03-2014 acanizales.SAO236528
     Se modifica la actualizacion de la variable global <cc_bofinancing.gboIsAdjust>
     25-03-2014 eurbano.SAO236416   se modifica para que cuando se
     encuentre generando ajustes por valor menor a 100 no realice la
     validacion por porcentaje de pago.
     27-02-2014  eurbano.SAO234394  Se modifica  <CommitAdjustsCharges>
     Se modifica el proceso para validar si saldo de la cuenta es menor
     al  valor fijo cnuAJUSTE y no con respecto al factor de ajuste
     definido en tipo moneda por empresa.
     19-02-2014  hjgomez.SAO233696  Se modifica <CommitAdjustsCharges>
     21-03-2013     squintero.SAO205105
     Se reversan los cambios hechos en el SAO204734.
     21-03-2013   squintero.SAO205096
     Se setea el cargdoso en cero y se modifica la condicion para que permita
     crear los cargos de ajuste para las facturas liquidadas en el proceso.
     20-03-2013   squintero.SAO204734
     Se valida que las facturas no hayan sido creadas durante el proceso para
     crear notas.
    ***********************************************************************/
    PROCEDURE CommitAdjustsCharges IS
      /* Error: La cuenta de cobro CUENTA queda con saldo SALDO despues de financiar.
      El saldo despues de financiar es negativo. La financiacion no se realizara. */
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.CommitAdjustsCharges'; --Nombre del método en la traza

      cnuNEG_ACC_BAL_ERR constant mensaje.menscodi%type := 11001;

      sbIdxCta       varchar2(20);
       --Saldo de la cuenta de cobro despues de generar ajuste
      nuAccountBal cuencobr.cucocodi%type;
      rcTimoEmpr timoempr%rowtype;
      nuFactorAjusteCta number;
BEGIN
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      if tbCuenta.first IS not null then
        -- Obtiene validacion ajuste a la cuenta
        FA_BOPoliticaRedondeo.ObtienePoliticaAjuste(tbCuenta(tbCuenta.first).cuconuse,
                                                    rcTimoEmpr);
        nuFactorAjusteCta := rcTimoEmpr.tmemfaaj;
        pkg_traza.trace('Factor de ajuste: ' || nuFactorAjusteCta, 10);
      END if;
      -- Se procesan las cuentas de cobro a ajustar
      sbIdxCta := tbCuenta.first;
      while (sbIdxCta is not null) loop
        -- Obtiene el saldo de la cuenta de cobro
        nuAccountBal := pktblCuencobr.fnuGetBalance(tbCuenta(sbIdxCta).cucocodi,pkConstante.NOCACHE);
        pkg_traza.Trace('Saldo de cuenta de cobro despues de financiar' ||to_char(nuAccountBal), pkg_traza.cnuNivelTrzDef);
        if (nuAccountBal < 0) then
          -- Error: La cuenta de cobro CUENTA queda con saldo SALDO despues
          --   de financiar. El saldo despues de financiar es negativo. La
          --   financiacion no se realizara.
          pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,cnuNEG_ACC_BAL_ERR||'-'||
                                    REPLACE (
                                             REPLACE('La cuenta de cobro CUENTA queda con saldo SALDO después de financiar. El saldo después de financiar es negativo. La financiación no se realizará.',
                                             'CUENTA','[' ||to_char(tbCuenta(sbIdxCta).cucocodi) || ']'),
                                             'SALDO',
                                             '[' || to_char(nuAccountBal) || ']'
                                             )
                                    );
        end if;
        -- Se obtiene el indice para la siguiente cuenta
        sbIdxCta := tbCuenta.next(sbIdxCta);
      end loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
	  EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
          pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
          raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
          pkg_error.SetError;
          pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
          raise PKG_ERROR.CONTROLLED_ERROR;
    END CommitAdjustsCharges;
    /***********************************************************************
    Propiedad intelectual de Open International Systems (c).
    Unidad      :  CalLateCharges
    Descripcion :  Calcula los cargos de recargo por mora para la deuda a
                   financiar.
    Autor       :  Adolfo Leon Canizales Murcia
    Fecha       :  16-05-2013
    Parametros  :
    Historia de Modificaciones
    Fecha        Autor              Modificacion
    =========    =========          ====================
    16-05-2013   acanizales.SAO207710
    Creacion
    ***********************************************************************/
    PROCEDURE CalLateCharges IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.FillAccReceivProc'; --Nombre del método en la traza
      /*Tabla de cargos */
      tbCharges pkBCCargos.tytbrcCargos;
      /* Tabla de mora */
      tbInfoMora FA_BOLiqLateConcepts.tytbLateData;
      /* Record de mora */
      rcArrear tyrcArrear;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      /* Procesa la coleccion de productos */
      sbProdIdx := tbProducts.first;
      /* Limpia */
      tbArrearsAll.delete;
      while (sbProdIdx is not null) loop
        pkg_traza.Trace('Calculando producto [' || sbProdIdx || ']', pkg_traza.cnuNivelTrzDef);
        -- liquida conceptos (recargo por mora)
        FA_BOLiqLateConcepts.LiqConcepts(tbProducts(sbProdIdx),
                                         dtCurrentDate,
                                         FA_BOLiqLateConcepts.csbFinancingMode,
                                         tbCharges,
                                         tbInfoMora);
        pkg_traza.Trace('No. cargos: ' || tbCharges.count, pkg_traza.cnuNivelTrzDef);
        pkg_traza.Trace('No. moras: ' || tbInfoMora.count, pkg_traza.cnuNivelTrzDef);
        -- Guarda las tablas de mora
        rcArrear.tbCharges  := tbCharges;
        rcArrear.tbInfoMora := tbInfoMora;
        /* Guarda la mora */
        tbArrearsAll(to_char(tbProducts(sbProdIdx))) := rcArrear;
        /* Obtiene el indice del siguiente producto */
        sbProdIdx := tbProducts.next(sbProdIdx);
      end loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END CalLateCharges;
    /***********************************************************************
    Propiedad intelectual de Open International Systems (c).
    Unidad      :  LiqLateCharges
    Descripcion :  Liquida los cargos de recargo por mora para la deuda a
                   financiar.
    Autor       :  Diego Alejandro Ruiz Tabares
    Fecha       :  05-09-2012
    Parametros  :
    Historia de Modificaciones
    Fecha        Autor              Modificacion
    =========    =========          ====================
    07-05-2013   acanizales.SAO207710
    Se modifica procedimiento en la generacion de cargos por concepto por mora.
    05-09-2012   druiz.SAO181112    Creacion
    ***********************************************************************/
    PROCEDURE LiqLateCharges IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.LiqLateCharges'; --Nombre del método en la traza
      /* tipo de tabla de conceptos */
      type tytbrcConceptos is table of concepto%rowtype index by binary_integer;
      sbProdArrearIdx pkBCServsusc.stysbIdxSeSu;
      /* Tipo de producto asociado a un producto */
      nuProdTypeId servicio.servcodi%type;
      /* Causa de cargo */
      nuChargeCause causcarg.cacacodi%type;
      /* Indice de cargos */
      nuChargeIdx number;
      /* Documento de soporte*/
      sbDocuSopo cargos.cargdoso%type;
      /* Tabla de cargos */
      tbCharges pkBCCargos.tytbrcCargos;
      -- tabla de conceptos
      tbrcConceptos tytbrcConceptos;
      /* concepto */
      rcConcepto concepto%rowtype;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      /* Procesa la coleccion de productos */
      sbProdArrearIdx := tbArrearsAll.first;
      -----------------------------------------------------------------
      -- El documento de soporte es la constante de documento para
      -- recargo por mora de financiaciones junto al numero de documento
      -- del diferido
      -----------------------------------------------------------------
      sbDocuSopo := pkBillConst.csbDOC_RECAMORA_FINAN || sbSupportDoc;
      while (sbProdArrearIdx is not null) loop
        pkg_traza.Trace('Procesando producto [' || sbProdArrearIdx || ']',
                       pkg_traza.cnuNivelTrzDef);
        /* Si el producto se encuentra en un estado de corte no facturable,
        se actualiza su estado a "Facturable con Convenio de Pago" */
        changRetiredFinan(sbProdArrearIdx);
        /* Obtiene tipo de producto asociado al producto */
        nuProdTypeId := pkg_bcproducto.fnuTipoProducto(sbProdArrearIdx);
        /* Se obtiene la causa de cargo con la cual quedaran los cargos de
        recargo por mora */
        nuChargeCause := FA_BOChargeCauses.fnuDeferredChCause(nuProdTypeId);
        /* Limpia concepto */
        tbrcConceptos.delete;
        /* Obtiene los cargos */
        tbCharges := tbArrearsAll(sbProdArrearIdx).tbCharges;
        /* Obtiene el indice del siguiente producto */
        nuChargeIdx := tbCharges.first;
        /* Itera por cargos */
        while (nuChargeIdx is not null) loop
          pkg_traza.Trace('Cargo[' || tbCharges(nuChargeIdx).cargnuse ||
                         '], ' || 'Valor [' || tbCharges(nuChargeIdx)
                         .cargvalo || ']',
                         pkg_traza.cnuNivelTrzDef);
          -- Si el valor del cargo es cero no crea cargo
          if (tbCharges(nuChargeIdx).cargvalo <= pkBillConst.CERO) then
            continue;
          else
            -----------------------------------------------------------------
            -- Crea el cargo
            -----------------------------------------------------------------
            pkChargeMgr.GenerateCharge(tbCharges    (nuChargeIdx).cargnuse,
                                       tbCharges    (nuChargeIdx).cargcuco,
                                       tbCharges    (nuChargeIdx).cargconc,
                                       nuChargeCause,
                                       tbCharges    (nuChargeIdx).cargvalo,
                                       tbCharges    (nuChargeIdx).cargsign,
                                       sbDocuSopo,
                                       tbCharges    (nuChargeIdx).cargtipr,
                                       tbCharges    (nuChargeIdx).cargcodo,
                                       tbCharges    (nuChargeIdx).cargunid);
          end if;
          /* Valida si ya no se proceso el concepto*/
          if (not tbrcConceptos.exists(tbCharges(nuChargeIdx).cargconc)) then
            pkg_traza.Trace('Se actualiza feullico Concepto[' || tbCharges(nuChargeIdx)
                           .cargconc || ']',
                           pkg_traza.cnuNivelTrzDef);
            /* Obtiene el record del concepto*/
            rcConcepto := pktblconcepto.frcGetRecord(tbCharges(nuChargeIdx)
                                                     .cargconc);
            tbrcConceptos(tbCharges(nuChargeIdx).cargconc) := rcConcepto;
            /* Actualiza fechas */
            FA_BCFeullico.UpdLastBillDateByConc(rcConcepto,
                                                sbProdArrearIdx,
                                                dtCurrentDate);
          end if;
          /* Obtiene el indice del siguiente producto */
          nuChargeIdx := tbCharges.next(nuChargeIdx);
        end loop;
        /* Obtiene el indice del siguiente producto */
        sbProdArrearIdx := tbArrearsAll.next(sbProdArrearIdx);
      end loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END LiqLateCharges;
    /* ********************************************************************** */
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (not CC_BOFinancing.gblValToFinGreaterZero) then
      pkg_traza.Trace('El valor a financiar es menor a cero. Fin.',
                     pkg_traza.cnuNivelTrzDef);
      return;
    end if;
    SAVEPOINT spCommitFinanc;
    /* Obtiene fecha actual */
    dtCurrentDate := sysdate;
    -- Recorre los diferidos que se encuentran en memoria
    nuIdxDife := tbgDeferred.first;
    /* Se verifica si hay diferidos a generar para la financiacion */
    if (nuIdxDife is not null) then
      -- Establece el documento de soporte asociado a los diferidos */
      sbSupportDoc := tbgDeferred(nuIdxDife).document_support;
      -- Inserta registros de configuracion de corte por producto
      PrInsertCocoSesu(tbgDeferred(nuIdxDife).deferred_plan_id,
                       tbgDeferred(nuIdxDife).financing_id);
      /* Genera restricciones por plan de diferido a los productos seleccionados */
      GenFinancialPlanRest(tbgDeferred(nuIdxDife).deferred_plan_id);
    end if;
    -- Se obtiene el id de la financiacion.
    nuFinancingId := tbgDeferred(nuIdxDife).financing_id;
    -- Inicializa valores para Gestion de Cobro
    nugVlrDifer := 0;
    while (nuIdxDife is not null) loop
      -- Obtiene proximo numero de diferido
      pkDeferredMgr.GetNewDefNumber(nuNumDife);
      -- Asigna el codigo definitivo al diferido
      tbgDeferred(nuIdxDife).deferred_id := nuNumDife;
      -- Adiciona Diferido
      AddDeferred(nuIdxDife);
      -- Adiciona movimiento inicial del diferido
      AddTransDef(nuIdxDife);
      -- Adiciona las Cuotas extras del Diferido
      AddAditionalIntlmnt(nuIdxDife);
      -- Adiciona el periodo de gracia del diferido
      pkDeferred.AddGracePeriod(tbgDeferred(nuIdxDife).deferred_plan_id,
                                tbgDeferred(nuIdxDife).deferred_id,
                                tbgDeferred(nuIdxDife).program,
                                dtgFecha - 1,
                                gnuPersonId);
      sbProdIdx := to_char(tbgDeferred(nuIdxDife).product_id);
      /* Se adiciona el producto asociado al diferido a la coleccion de
      productos procesados */
      if (not tbProducts.exists(sbProdIdx)) then
        tbProducts(sbProdIdx) := tbgDeferred(nuIdxDife).product_id;
      end if;
      -- Obtiene proximo diferido
      nuIdxDife := tbgDeferred.next(nuIdxDife);
    end loop;
    /*Verifica si se calculan los cargos por mora*/
    if (iboGenLateCharges) then
      /* Calcula cargos de mora  */
      CalLateCharges;
    end if;
    /* Crea los cargos de cancelacion de deuda por financiacion y descuentos
    por acuerdo de pago */
    CommitCharges;
    -- Crea Cargos de Ajuste de Cuentas
    CommitAdjustsCharges;
    -- Se obtienen los datos de la solicitud de financiacion
    CC_BCFinancing_Request.GetFinanReqByFinanId(nuFinancingId,
                                                rcFinanReq,
                                                false);
    /* Valida si obtuvo datos de la financiacion */
    if (rcFinanReq.financing_request_id is not null) then
      /* Valida si existe solicitud de negociacion de deuda asociada a la financiacion */
      GC_BCDebtNegotiation.GetAssocNegotingReq(rcFinanReq.Financing_Request_Id,
                                               rcDebtNegot);
    end if;
    --Si se calcularon se liquidan los cargos por mora
    if (iboGenLateCharges) then
      /*Liquida los cargos por mora*/
      LiqLateCharges;
    end if;
    nuIdxDife := tbgDeferred.first;
    if (nuIdxDife IS not null) then
      -- Se ejecuta proceso de Gestion de Cobro
      ProcAccountReceive;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      ROLLBACK TO SAVEPOINT spCommitFinanc;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      ROLLBACK TO SAVEPOINT spCommitFinanc;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END CommitFinanc;
  /**************************************************************/
  -- FIN CAMBIO 3504
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcSaleByJob
  Descripcion    : Objeto de negocio para la ejecucion por job llamando al proceso de
                 ProcSaleByFile
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  ******************************************************************/
  PROCEDURE ProcSaleByJob IS
  BEGIN
    pkg_traza.Trace('INICIO: Ld_BoSecureManagement.ProcSaleByJob', pkg_traza.cnuNivelTrzDef);
    ProcSaleByFile;
    pkg_traza.Trace('FIN: Ld_BoSecureManagement.ProcSaleByJob', pkg_traza.cnuNivelTrzDef);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcSaleByJob;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fnuGetActivityVisit
  Descripcion    : Obtiene la actividad de visita
  Autor          : jcarrillo
  Fecha          : 02-09-2013
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor               Modificacion
  =========       =========        ====================
  27-08-2013  jcastro.SAO211267       1 - Creacion
  ******************************************************************/
  FUNCTION fnuGetActivityVisit RETURN number IS
    nuActVisit number;
    rcActVisit dald_parameter.styLD_parameter;
  BEGIN
    pkg_traza.Trace('INICIO: Ld_BoSecureManagement.LoadActivityVisit', pkg_traza.cnuNivelTrzDef);
    if (not dald_parameter.fblexist(ld_boconstans.csbActivityVisit)) then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'Falta la configuracion del parametro "NUM_ACT_VISIT" que identifica el codigo de la actividad de visita.');
    end if;
    rcActVisit := dald_parameter.frcGetRecord(ld_boconstans.csbActivityVisit);
    if (rcActVisit.numeric_value IS not null) then
      nuActVisit := rcActVisit.numeric_value;
    else
      nuActVisit := to_number(rcActVisit.value_chain);
    end if;
    /* Se validan que los parametros esten configurados */
    if (nuActVisit IS null) then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'Falta la configuracion del parametro "NUM_ACT_VISIT" que identifica el codigo de la actividad de visita.');
    end if;
    pkg_traza.Trace('FIN: Ld_BoSecureManagement.fnuGetActivityVisit', pkg_traza.cnuNivelTrzDef);
    return nuActVisit;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fnuGetActivityVisit;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ValidateCreateVisit
  Descripcion    : Valida si exite una orden con la actividad de visita, en
                      caso de que no exista la crea. Y legaliza la orden.
  Autor          : jcarrillo
  Fecha          : 02-09-2013
  Parametros         Descripcion
  ============  ===================
  inuSubscriber   Cliente
  inuSuscription  Contrato
  inuActVisit     Actividad de Visita
  inuAddressId    Direccion
  inuContrator    Aseguradora
  inuCausal       Causal
  Historia de Modificaciones
  Fecha             Autor               Modificacion
  =========       =========        ====================
  22/03/2024      pacosta       Cambio DAOR_ORDER.FRCGETRECORD por PKG_BCORDENES.FRCGETRECORD
                                Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
  27-08-2013      jcastro       SAO211267 1 - Creacion
  ******************************************************************/
  PROCEDURE ValidateCreateVisit(inuSubscriber  in ge_subscriber.subscriber_id%type,
                                inuSuscription in suscripc.susccodi%type,
                                inuActVisit    in or_order_activity.activity_id%type,
                                inuAddressId   in ab_address.address_id%type,
                                inuContrator   in ge_contratista.id_contratista%type,
                                isbComment     in mo_packages.comment_%type,
                                inuCausal      in Or_Order.Causal_Id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValidateCreateVisit'; --Nombre del método en la traza
    /* Actividad de Orden */
    nuOrderActivityId or_order_activity.order_activity_id%type;
    rcActOrder        daor_order_activity.styOR_order_activity;
    /* Orden */
    nuOrderId or_order.order_id%type;
    rcOrder   daor_order.styor_order;
    /* Unidad Operativa */
    rcUnit daor_operating_unit.styor_operating_unit;
    /* Error */
    nuError        number;
    sbMessage      varchar2(2000);
    nuPackagevisit mo_packages.package_id%type;
    sbLineFile     varchar2(1000); -- SAO[334174]
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Se consulta si existe la orden con la actividad de visita */
    ld_bcsecuremanagement.GetOrderByActSubscrib(PKG_BCCONTRATO.FNUIDCLIENTE(inuSuscription),
                                                inuActVisit,
                                                rcActOrder);
    nuOrderId := rcActOrder.order_id;
    pkg_traza.trace('Order_id: ' || nuOrderId, pkg_traza.cnuNivelTrzDef);
    IF (nuOrderId IS not null) then
      -- se obtiene el paquete de la solicitud de visita
      nuPackagevisit := or_bcorderactivities.fnugetpackidinfirstact(nuOrderId);
      -- si el tipo de solicitud no es de microseguro , no procesamos esa solicitud
      if (nvl(dald_sales_visit.fnuGetVisit_Type_Id(nuPackagevisit, 0), -1) <>
         ld_boflowfnbpack.cnuMicroInsuranceType) then
        nuorderId := null;
        pkg_traza.trace('Diferente orden de visita: ', pkg_traza.cnuNivelTrzDef);
      END if;
    END if;
    /* si no existe la orden se crea */
    IF (nuOrderId IS null) THEN

              api_createorder(inuItemsid         => inuActVisit,
                              inuPackageid       => null,
                              inuMotiveid        => null,
                              inuComponentid     => null,
                              inuInstanceid      => null,
                              inuAddressid       => inuAddressId,
                              inuElementid       => null,
                              inuSubscriberid    => inuSubscriber,
                              inuSubscriptionid  => inuSuscription,
                              inuProductid       => null,
                              inuOperunitid      => null,
                              idtExecestimdate   => null,
                              inuProcessid       => null,
                              isbComment         => isbComment,
                              iblProcessorder    => null,
                              inuPriorityid      => null,
                              inuOrdertemplateid => null,
                              isbCompensate      => null,
                              inuConsecutive     => null,
                              inuRouteid         => null,
                              inuRouteConsecutive=> null,
                              inuLegalizetrytimes=> null,
                              isbTagname         => null,
                              iblIsacttoGroup    => null,
                              inuRefvalue        => null,
                              inuActionid        => null,
                              ionuOrderid        => nuOrderId,
                              ionuOrderactivityid=> nuorderactivityid,
                              onuErrorCode       => nuCodMenErro,
                              osbErrorMessage    => sbMensaError
                             );
              if nvl(nuCodMenErro,0) != 0 then
                  RAISE PKG_ERROR.CONTROLLED_ERROR;
              end if;

    END if;
    /* Obtiene la Unidad operativa para legalizar */
    Ld_BcSecureManagement.GetOperatingUnit(inuContrator, rcUnit);
    -- se asigna la orden si no esta asignada
    IF (pkg_bcordenes.fnuobtieneestado(nuOrderId) <> 5) THEN
      rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
      -- actualiza sector y fechas basicas de la orden
      OR_boProcessOrder.updBasicData(rcOrder,
                                     rcOrder.operating_sector_id,
                                     null);

      if rcUnit.operating_unit_id is null then
        -- SAO[334174]
        sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                      'ORDEN VISITA' || ';' || nuOrderId || ';' ||
                      'Error al tratar de asignar la unidad operativa [' ||
                      rcUnit.operating_unit_id || '] a la orden de visita' || ';' ||
                      sqlerrm;
        pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'La unidad operativa "' ||
                                  rcUnit.operating_unit_id ||
                                  '" no permite asignar. ' ||
                                  'No se puede asignar la orden "' ||
                                  nuOrderId || '"'
                                 );
      end if;
      nuCodMenErro := null;
      api_assign_order (inuOrder          => nuOrderId,
                        inuOperatingUnit  => rcUnit.operating_unit_id,
                        onuErrorCode      => nuCodMenErro,
                        osbErrorMessage   => sbMensaError
                       );
      if nvl(nuCodMenErro,0) != 0 then
        RAISE PKG_ERROR.CONTROLLED_ERROR;
      end if;

    END IF;

	sbdataorder := NULL;
	sbdataorder :=
	   nuOrderId
	|| '|'
	|| inuCausal
	|| '|'
	|| LD_BOUtilFlow.fnuGetPersonToLegal(pkg_bcordenes.fnuobtieneunidadoperativa(nuOrderId))
	|| '||'
	|| nuorderactivityid
	|| '>'
	|| 1
	|| ';;;;|||1277;Legalizacion de la orden de visita';


    /* Se legaliza la orden */
    api_legalizeOrders(isbDataOrder    => sbdataorder,
                       idtInitDate     => sysdate,
                       idtFinalDate    => sysdate,
                       idtChangeDate   => null,
                       onuErrorCode    => nuError,
                       osbErrorMessage => sbMessage
                      );

    if (nvl(nuError,0) <> 0) then
      -- SAO[334174]
      sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                    'ORDEN VISITA' || ';' || nuOrderId || ';' ||
                    'Error al tratar de legalizar la orden de visita con causal [' ||
                    inuCausal || ']' || ';' || sqlerrm;
      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
       gw_boerrors.checkerror(nuError, sbMessage);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValidateCreateVisit;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcSaleByFile
  Descripcion    : Objeto de negocio para la busqueda del archivo de venta enviado por la aseguradora
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor               Modificacion
  =========       =========        ====================
  19/06/2024  GDGuevara            OSF-2822: Se modifica ProcSaleByFile incluyendo el manejo del proceso en ESTAPROC
                                   y el bloqueo del archivo que se esta leyendo.
  19-04-2024  GDGuevara            OSF-2572: bloqueo en el cargue de ventas de seguros
                                   Se crean restricciones para no permitir la adicion de seguros funerarios cuando
                                   ya exista uno vigente en alguna de las lineas de producto de seguros 91, 131 o 311.
                                   No permite la venta de seguros a productos con plan de facturacion 58-Medidores Prepago.
                                   Se corrige la forma como se lee cada linea del archivo texto
  21-03-2024  pacosta              OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                   Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                   Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                   Cambio PKUTLFILEMGR.FCLOSE por PKG_GESTIONARCHIVOS.PRCCERRARARCHIVO_SMF
                                   Cambio PKUTLFILEMGR.FOPEN por PKG_GESTIONARCHIVOS.FTABRIRARCHIVO_SMF
                                   Cambio PKUTLFILEMGR.FREMOVE por PKG_GESTIONARCHIVOS.PRCBORRARARCHIVO_SMF
                                   Cambio PKUTLFILEMGR.GET_LINE por PKG_GESTIONARCHIVOS.FSBOBTENERLINEA_SMF
                                   Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
                                   Cambio UTL_FILE.FILE_TYPE por PKG_GESTIONARCHIVOS.STYARCHIVO
                                   Cambio UTL_FILE.FRENAME por PKG_GESTIONARCHIVOS.PRCRENOMBRAARCHIVO_SMF
  16/05/2017  KBaquero CA100-35955 Se modifica proceso para que al momento de identificar la categoria y el estrato de la poliza
                                   a crear si no corresponde con el que tiene en el archivo se enviara un mensaje de inconsistencia.
  17-09-2015  Llozada [ARA 8740]   Se comenta la validacion de nombre ARA 6693
  08/07/2015  mgarcia.SAO334174    Se modifica proceso para que genere un
                                   archivo de log de errores en formato csv.
  27-05-2015  Spacheco.Ara6693     se modifica proceso para que valide que el nombre asociado
                                   a la identificacion enviada por archivo plano corresponde o
                                   o no al que tiene asociada esa identificacion en el sistema.
  28-08-2014  KCienfuegos.NC1177   Se modifica para indicar el contrato para cada inconsistencia.
                                   Se elimina el archivo si no procesa ninguna inconsistencia.
  04-08-2014  KCienfuegos.NC1079   Se valida que el valor de la cuota de poliza, no exceda el parametro definido.
  29-01-2014  AEcheverrySAO231292   Se eliminan servicios duplicados para mejorar el rendimiento
  07-11-2013  LDiuza.SAO222745     1 - Se permite crear orden de visita en caso de exito
  29/10/2013  jrobayo.SAO221575    1 - Se modifica la validacion relacionada con la
                                       identificacion del titular de la poliza.
  25/10/2013  jrobayo.SAO221406    1 -Se modifica para encapsular el error generado cuando
                                      el tipo de poliza no se encuentra vigente.
  06/09/2013  jrobayo.SAO213104    1 -Se realizan modificaciones sobre
                                     estructura del archivo interpretado para
                                     realizar la venta.
  05/09/2013   mmeusburgger.SAO213104 1- Se modifica
                                       - <<Sbxcept>> para inicializarla en "N"
  04/09/2013  jrobayo.SAO213381   1 - Se modifica para registrar la fecha de nacimiento
                                      del suscriptor quien adquiere la poliza.
  03/09/2013  jcarrillo.SAO214416 1 - Se modifica para no registra la solicitud
                                      en caso de que la causal sea de fallo.
  02/09/2013  jcarrillo.SAO211267 1 - Se modfica para generar la orden de visita
                                      en caso de que la venta sea no exitosa.
  27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  14/08/2012   AAcuna.SAO147879       Creacion
  ******************************************************************/
  PROCEDURE ProcSaleByFile IS
    csbMetodo            CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcSaleByFile'; --Nombre del método en la traza
    nuCodedepa           ge_geogra_location.geo_loca_father_id%type;
    nuCodedepaGet        ge_geogra_location.geo_loca_father_id%type;
    nuCodeLocaDep        ge_geogra_location.geograp_location_id%type;
    nuCodeLocaPro        ge_geogra_location.geograp_location_id%type;
    nuCodeaseg           ge_contratista.id_contratista%type;
    nuSuscripc           suscripc.susccodi%type;
    dtDatevisi           date;
    sbCauseinc           varchar2(32000);
    sbObservat           varchar2(32000);
    sbIdentase           ge_subscriber.identification%type; -- SAO[334174]
    sbNameaseg           ld_policy.name_insured%type;
    nuCodePolyType       ld_policy_type.contratist_code%type; -- Codigo del Tipo de Poliza de la Aseguradora
    onuCodePolyType      ld_policy_type.policy_type_id%type; -- Codigo del Tipo de Poliza de la Gasera
    sbDescProd           ld_policy_type.description%type;
    nuValuepri           ld_validity_policy_type.share_value%type;
    nuGeo                ge_geogra_location.geograp_location_id%type;
    nuCodeLoca           ge_geogra_location.geograp_location_id%type;
    nuCodeLocaGet        ge_geogra_location.geograp_location_id%type;
    nuadd                ab_address.address%type;
    nuCategory           categori.catecodi%type;
    nuSubcateg           subcateg.sucacodi%type;
    nuPolicy             ld_policy.policy_id%type;
    nuProductLine        ld_product_line.product_line_id%type;
    rcPolicyType         dald_policy_type.styLD_policy_type;
    rcValidityPolicyType dald_validity_policy_type.styLD_validity_policy_type; -- JCASTRO
    nuValPolTypId        ld_validity_policy_type.validity_policy_type_id%TYPE; -- JCASTRO
    -- -------
    sbFileGl             varchar2(100);
    sbOnline             varchar2(32767);
    /* Variables para    conexion*/
    sbFileManagement     pkg_gestionarchivos.styarchivo;
    sbFileManagementd    pkg_gestionarchivos.styarchivo;
    nuLinea              number;
    nuCodigo             number;
    cnuend_of_file       constant number := 1;
    sbPath               varchar2(500);
    sbLog                varchar2(500);
    sbLineLog            varchar2(1000);
    vArray               t_string_table := t_string_table();
    sbL_file             varchar2(500);
    sbL_nom              varchar2(4000);
    sbL_ext              varchar2(50) := '.Ok';
    sbMsg                varchar2(4000);
    nuPos                number;
    sbTimeProc           varchar2(100);
    dtDateBirth          date;
    sbRequestXML         constants_per.TIPO_XML_SOL%type;
    nuErrorCode          number;
    sbErrorMessage       VARCHAR2(8000);
    nuPackageId          mo_packages.package_id%type;
    nuMotiveId           mo_motive.motive_id%type;
    nuSubscriber         ge_subscriber.subscriber_id%type;
    nuSubscriberSec      ge_subscriber.subscriber_id%type;
    nuRecepType          ld_parameter.numeric_value%type;
    nuAnswerId           ld_parameter.numeric_value%type;
    nuFinancingPlan      ld_parameter.numeric_value%type;
    nuPmPlanPrePago      ld_parameter.numeric_value%type;
    nuPlanFact           pr_product.commercial_plan_id%type;
    sbEstaFina           servsusc.sesuesfn%type;
    nuExiste             number;
    sbPmSegFunerario     varchar2(4000);
    sbPmEstFinNoPerm     varchar2(4000);
    Sbxcept              varchar2(1);
    nuQuotaNumber        ld_validity_policy_type.coverage_month%type;
    nuPolicyType         ld_validity_policy_type.validity_policy_type_id%type;
    nuShareValue         ld_validity_policy_type.share_value%type;
    sbFile               varchar2(500);
    sbLineFile           varchar2(1000);
    nuCanTotal           number := 0;
    nuCanValid           number := 0;
    nuProducto           pr_product.product_id%type;
    nuEdad               number;
    nuEdadMax            number;
    sbCodeDepa           varchar2(500);
    sbCodeLoca           varchar2(500);
    sbDatevisi           varchar2(500);
    sbPolicy             varchar2(500);
    sbSuscripc           varchar2(500);
    sbCodeAseg           varchar2(500);
    sbValuepri           varchar2(500);
    sbDatebirth          varchar2(500);
    ---------
    nuActVisit           or_order_activity.activity_id%type;
    sbExiste             varchar2(100);
    sbLockHandle         varchar2(500);
    sbArch               varchar2(500);
    sbProceso            varchar2(100);
    nuExito              number;
    nuContArch           number;
    nuTotReg             number;
    nuTotProc            number;

    -- OSF-2572. Cursor para consultar si el contrato tiene otra poliza activa de seguro funerario
    cursor cuPolizaProd (inuSuscripc in number, isbParametro in varchar2)
    is
        select count(1)
        from ld_policy
        where suscription_id = inuSuscripc
          and isbParametro like '%,'|| product_line_id ||',%'
          and state_policy = 1;   -- Activa
    --
   Procedure prvalProducto (inususcript in pr_product.subscription_id%type) is
    --Se obtiene el producto de gas -- SAO[334174]
       cursor cuproduct_id is
       select p.product_id,
              p.commercial_plan_id,
              s.sesuesfn
         from pr_product p, servsusc s
        where p.subscription_id = inususcript
          and p.product_type_id = LD_BOConstans.cnuGasService
          and s.sesunuse = p.product_id
        order by sesufere desc;

    begin
      nuProducto := null;
      nuPlanFact := null;
      sbEstaFina := null;
        open cuproduct_id;
             fetch cuproduct_id into nuProducto, nuPlanFact, sbEstaFina;
        close cuproduct_id;
   end prvalProducto;
   function fnuedad return number is
       nuRetEdad number;
       cursor cuEdad is
       SELECT FLOOR(months_between(dtDatevisi, dtDateBirth) / 12)
       FROM dual;
   begin
       open cuEdad;
             fetch cuEdad into nuRetEdad;
       close cuEdad;
       RETURN nuRetEdad;
   end fnuedad;

  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

    nuContArch := 0;     
    nuTotReg   := 0;
    nuTotProc  := 0; 

    if ((dald_parameter.fblexist(LD_BOConstans.cnuRecepType)) and
       (dald_parameter.fblexist(LD_BOConstans.cnuAnswerId)) and
       (dald_parameter.fblexist(LD_BOConstans.cnuFinancingPlan)) and
       (dald_parameter.fblexist(LD_BOConstans.csbRutLogs)) and
       (dald_parameter.fblexist(LD_BOConstans.csbCauCumpl))) then
      nuRecepType     := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuRecepType);
      nuAnswerId      := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuAnswerId);
      nuFinancingPlan := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuFinancingPlan);
      sbRutLogs       := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbRutLogs);
      sbPath          := sbRutLogs;
      sbCauCumpl      := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCauCumpl);
      nuActVisit      := fnuGetActivityVisit;
      -- OSF-2572. Ini
      -- Obtiene el plan de medidores prepago
      nuPmPlanPrePago := null;
      if dald_parameter.fblexist('PLAN_FACTU_MEDIDOR_PREPAGO') then
          nuPmPlanPrePago := pkg_bcld_parameter.fnuobtienevalornumerico('PLAN_FACTU_MEDIDOR_PREPAGO');
      end if;
      -- Obtiene las lineas de producto de seguros funerarios y exequiales
      sbPmSegFunerario := null;
      sbPmSegFunerario := pkg_Parametros.fsbGetValorCadena('SEGURO_FUNERARIO');
      sbPmSegFunerario := '%,'||sbPmSegFunerario||',%';
      -- Obtiene los estados financieros permitidos para la venta de seguros
      sbPmEstFinNoPerm := null;
      sbPmEstFinNoPerm := pkg_Parametros.fsbGetValorCadena('ESTAFINA_NOPERM_VENTA_SEGURO');
      sbPmEstFinNoPerm := '%,'||sbPmEstFinNoPerm||',%';
      -- OSF-2572. Fin
      if ((nvl(nuFinancingPlan, LD_BOConstans.cnuCero) <>
         LD_BOConstans.cnuCero) and
         (nvl(nuRecepType, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) and
         (nvl(nuAnswerId, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) then
        sbTimeProc := to_char(sysdate, 'yyyymmdd_hh24miss');

        -- Asigna el nombre del proceso
        sbProceso := 'LDPSF_VEEX_'||sbTimeProc;
        -- Valida si existe un proceso en ejecucion en el mismo dia sin terminar
        sbExiste  := substr(sbProceso, 1, 19);
        -- Valida si ya existe un proceso en ejecucion
        if pkg_estaproc.fblValidaEjecucionProc (sbExiste) then
            pkg_error.setErrorMessage(isbMsgErrr => 'Error: hay un proceso en ejecución, verifique estaproc ['||sbExiste||'] ');
        END IF;
        -- Crea el proceso en estaproc
        pkg_estaproc.prInsertaEstaproc (sbProceso, 0);

        /* Arma nombre del archivo LOG */
        sbLog  := 'VE_' || sbTimeProc || '.LOG';
        sbFile := 'VE_' || sbTimeProc || '.CSV'; -- SAO[334174]
        /* Crea archivo Log */
        sbFileManagementd := pkg_gestionarchivos.ftabrirarchivo_smf(sbPath, sbLog, 'w');
        /* Crea archivo csv */
        sbFileManagementf := pkg_gestionarchivos.ftabrirarchivo_smf(sbPath, sbFile, 'w'); -- SAO[334174]
        sbLineLog := 'INICIO PROCESO DE LECTURAS DE VISITAS POLIZAS ' ||
                     TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS');
        pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
        /* Si archivo es Venta Exitosa, hacemos..*/
        pkg_traza.trace('Si archivo es Venta Exitosa, hacemos..', pkg_traza.cnuNivelTrzDef);
        ld_file_api.ProcGetDirList(sbPath, '.txt', vArray);
        sbLineLog := null;
        for i in 1 .. vArray.count loop
            -- Cuenta los archivo procesados
            nuContArch := nuContArch + 1;
            
            sbL_file := substr(vArray(i),
                             nuPos + 1,
                             length(vArray(i)) - nuPos);
            sbL_nom  := substr(vArray(i), 1, length(vArray(i)) - 4);
          if upper(vArray(i)) like '%VEEX%' then

            -- Crear un bloqueo con un identificador unico para el archivo
            sbArch := sbPath||'/'||vArray(i);
            dbms_lock.allocate_unique
            (
                lockname => sbArch,
                lockhandle => sbLockHandle
            );
            -- Intentar adquirir el bloqueo
            nuExito:= dbms_lock.request
            (
                lockhandle => sbLockHandle,
                lockmode => dbms_lock.x_mode,
                timeout => 0 -- tiempo de espera en segundos
            );
            -- si no puede hacer el bloqueo continua con el siguiente archivo
            if nuExito <> 0 then
                GOTO nextFile;
            end if;
            -- Actualiza en el estado del proceso el archivo que esta procesando
            pkg_estaproc.prActualizaAvance (sbProceso, 'Procesando archivo: '||vArray(i), 0, 0);

            /* Asignamos nombre del archivo...*/
            sbFileGl := sbL_file;
            sbLineLog := ' Inicio el recorrido del archivo ' || vArray(i) ||
                         ' en la ruta' || sbPath || ' ' || sbL_nom || ' ' ||
                         sqlerrm;
            pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
            begin
              sbFileManagement := pkg_gestionarchivos.ftabrirarchivo_smf(sbPath, vArray(i), 'r');
            exception
              when others then
                sbLineLog := '     Error ... No se pudo abrir archivo ' ||
                             sbPath || ' ' || sbFileGl || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                GOTO nextFile;
            end;
            nuLinea := 0;
            sbLineFile := 'NOMBRE ARCHIVO' || ';' || vArray(i); -- SAO[334174]
            pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
            sbLineFile := 'CONTRATO;NUMERO POLIZA;CAMPO;VALOR;MENSAJE;ERROR ORACLE'; -- SAO[334174]
            pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
            loop
                begin
                    sbOnline := pkg_gestionarchivos.fsbobtenerlinea_smf(sbFileManagement);
                exception
                    when no_data_found then
                        exit;
                end;
                if sbOnline is null then
                    GOTO nextLine;
                end if;

                nuTotReg := nuTotReg + 1;
                
              /*SAO[334174]*/
              sbLineFile  := null;
              nuPolicyNum := null;
              nuContrato  := null;
              /* Si pudo leer el archivo de venta */
              /* Departamento*/
              sbCodedepa := substr(sbOnline,
                                   1,
                                   instr(sbOnline, '|', 1, 1) - 1);
              /* Localidad */
              sbCodeLoca := substr(sbOnline,
                                   instr(sbOnline, '|', 1, 1) + 1,
                                   (instr(sbOnline, '|', 1, 2)) -
                                   (instr(sbOnline, '|', 1, 1) + 1));
              /* Aseguradora*/
              sbCodeaseg := substr(sbOnline,
                                   instr(sbOnline, '|', 1, 2) + 1,
                                   (instr(sbOnline, '|', 1, 3)) -
                                   (instr(sbOnline, '|', 1, 2) + 1));
              /* Suscripcion*/
              sbSuscripc := substr(sbOnline,
                                   instr(sbOnline, '|', 1, 3) + 1,
                                   (instr(sbOnline, '|', 1, 4)) -
                                   (instr(sbOnline, '|', 1, 3) + 1));
              /* Causal */
              sbCauseinc := substr(sbOnline,
                                   instr(sbOnline, '|', 1, 4) + 1,
                                   (instr(sbOnline, '|', 1, 5)) -
                                   (instr(sbOnline, '|', 1, 4) + 1));
              /* Fecha de visita*/
              sbDatevisi := substr(sbOnline,
                                   instr(sbOnline, '|', 1, 5) + 1,
                                   (instr(sbOnline, '|', 1, 6)) -
                                   (instr(sbOnline, '|', 1, 5) + 1));
              /* Observacion*/
              sbObservat := substr(sbOnline,
                                   instr(sbOnline, '|', 1, 6) + 1,
                                   (instr(sbOnline, '|', 1, 7)) -
                                   (instr(sbOnline, '|', 1, 6) + 1));
              /* Numero de la poliza  -- SAO[334174]*/
              sbPolicy := substr(sbOnline,
                                 instr(sbOnline, '|', 1, 12) + 1,
                                 (instr(sbOnline, '|', 1, 13)) -
                                 (instr(sbOnline, '|', 1, 12) + 1));
              /* Validaciones de los campos que trae el archivo para que
              no permita registros con datos null*/
              -- Codigo de la poliza
              if sbPolicy is null or not fboGetIsNumber(sbPolicy) then
                sbLineLog := '     Error ... El Codigo de la poliza es nulo o invalido para el contrato ' ||
                             sbSuscripc || '. ' || sbPath || ' ' ||
                             vArray(i) || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := sbSuscripc || ';' || '' || ';' ||
                              'NUMERO POLIZA' || ';' || sbPolicy || ';' ||
                              'El numero de la poliza es nulo o invalido' || ';' ||
                              sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              nuPolicy    := to_number(sbPolicy);
              nuPolicyNum := to_number(sbPolicy);
              -- Suscripcion
              if sbSuscripc is null or not fboGetIsNumber(sbSuscripc) then
                sbLineLog := '     Error ... El contrato es nulo o invalido, linea ' ||
                             nuLinea || '. ' || sbPath || ' ' || vArray(i) || ' ' ||
                             sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := '' || ';' || nuPolicyNum || ';' || 'CONTRATO' || ';' ||
                              sbSuscripc || ';' ||
                              'El contrato es nulo o invalido, linea ' ||
                              (nuLinea + 1) || ';' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              --SAO[334174]
              nuSuscripc := To_number(sbSuscripc);
              nuContrato := To_number(sbSuscripc);
              /* Ubicacion geografica: Departamento*/
              if sbCodedepa is null or not fboGetIsNumber(sbCodedepa) then
                sbLineLog := '     Error ... el codigo del departamento es nulo o invalido para el contrato: ' ||
                             nuSuscripc || ' ' || sbPath || ' ' ||
                             vArray(i) || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                              'DEPARTAMENTO' || ';' || sbCodedepa || ';' ||
                              'El codigo del departamento es nulo o invalido' || ';' ||
                              sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              nuCodedepa := To_number(sbCodedepa);
              /* Ubicacion geografica: Localidad*/
              if sbCodeLoca is null or not fboGetIsNumber(sbCodeLoca) then
                sbLineLog := '     Error ... el codigo de la localidad es nulo o invalido para el contrato: ' ||
                             nuSuscripc || ' ' || sbPath || ' ' ||
                             vArray(i) || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                              'LOCALIDAD' || ';' || sbCodeLoca || ';' ||
                              'El codigo de la localidad es nulo o invalido' || ';' ||
                              sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              nuCodeLoca := To_number(sbCodeLoca);
              -- Aseguradora
              if sbCodeaseg is null or not fboGetIsNumber(sbCodeaseg) then
                sbLineLog := '     Error ... El codigo de la aseguradora es nulo o invalido para el contrato: ' ||
                             nuSuscripc || ' ' || sbPath || ' ' ||
                             vArray(i) || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                              'ASEGURADORA' || ';' || sbCodeaseg || ';' ||
                              'El codigo de la aseguradora es nulo o invalido' || ';' ||
                              sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              nuCodeaseg := To_number(sbCodeaseg);
              -- fecha de visita
              if sbDatevisi is null then
                sbLineLog := '     Error ... La fecha de visita es nula para el contrato ' ||
                             nuSuscripc || '. ' || sbPath || ' ' ||
                             vArray(i) || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                              'FECHA VISITA' || ';' || sbDatevisi || ';' ||
                              'La fecha de visita es nula' || ';' ||
                              sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              begin
                dtDatevisi := to_date(sbDatevisi, 'dd/mm/yyyy');
              exception
                when others then
                  sbLineLog := '     Error ... La fecha de visita no tiene un formato valido para el contrato ' ||
                               nuSuscripc || '. ' || sbPath || ' ' ||
                               vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'FECHA VISITA' || ';' || sbDatevisi || ';' ||
                                'La fecha de visita no tiene formato valido' || ';' ||
                                sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
              end;
              -- Causal de legalizacion
              if sbCauseinc is null or not fboGetIsNumber(sbCauseinc) then
                sbLineLog := '     Error ... La causa de legalizacion es nula o invalida para el contrato ' ||
                             nuSuscripc || '. ' || sbPath || ' ' ||
                             vArray(i) || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                              'CAUSAL' || ';' || sbCauseinc || ';' ||
                              'La causa de legalizacion es nula o invalida' || ';' ||
                              sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              -- Observacion SAO[334174]
              if sbObservat is null then
                sbLineLog := '     Error ... El campo observacion es nulo para el contrato ' ||
                             nuSuscripc || '. ' || sbPath || ' ' ||
                             vArray(i) || ' ' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                              'OBSERVACION' || ';' || sbObservat || ';' ||
                              'El campo observacion es nulo' || ';' ||
                              sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              /*Validar que el contrato exista*/
              if not pktblsuscripc.fblexist(nuSuscripc) then
                sbLineLog := '     Error ... El contrato ' || nuSuscripc ||
                             ' no existe ' || sbPath || ' ' || vArray(i) || ' ' ||
                             sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                              'CONTRATO' || ';' || nuSuscripc || ';' ||
                              'El contrato no existe' || ';' || sqlerrm;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                GOTO nextLine;
              end if;
              /*Se obtiene el producto de gas*/ -- SAO[334174]
              prvalProducto(nuSuscripc);
              if nuproducto is null then
                  sbLineLog := '     Error ... El contrato ' || nuSuscripc ||
                            '  no tiene registrado producto de gas ' ||
                            sbPath || ' ' || vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                            'CONTRATO' || ';' || nuSuscripc || ';' ||
                            'El contrato no tiene registrado producto de gas' || ';' ||
                            sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
              end if;

              /* Validar, que el contrato tenga gas activo */
              begin
                ld_bosecuremanagement.ProcValidateProductparam(nuSuscripc);
              exception
                when others then
                  sbLineLog := '     Error ... El contrato ' || nuSuscripc ||
                               '  ingresado no tiene gas activo, estado definido en el parametro [COD_STATE_PROD_SECURE] ' ||
                               sbPath || ' ' || vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'ESTADO GAS' || ';' ||
                                Pkg_Bcproducto.Fnuestadoproducto(nuProducto) || ';' ||
                                'El contrato no tiene gas activo, estado definido en el parametro [COD_STATE_PROD_SECURE]' || ';' ||
                                replace(replace(sqlerrm, chr(10), ''),
                                        chr(13),
                                        '');
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
              end;
              -- Valida que el contrato tenga definido un producto gas con categoria residencial o comercial
              begin
                ld_bosecuremanagement.ProcValProd(nuSuscripc);
              exception
                when others then
                  sbLineLog := '     Error ... El contrato ' || nuSuscripc ||
                               '  no tiene definido un producto de tipo gas que pertenezca a las categorias establecidas en el parametro [' ||
                               LD_BOConstans.csbCodCategory || ']' ||
                               sbPath || ' ' || vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'CONTRATO' || ';' || nuSuscripc || ';' ||
                                'El contrato no tiene definido un producto de tipo gas que pertenezca a las categorias establecidas en el parametro [' ||
                                LD_BOConstans.csbCodCategory || ']';
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
              end;
              /* Valida que el contrato de gas , el estado sea entre los permitidos para los
              estado de producto de venta de seguros*/
              begin
                ld_bosecuremanagement.ProcValStateProdSal(nuSuscripc);
              exception
                when others then
                  sbLineLog := '     Error ... El  producto de gas no esta definido entre los estados de producto de la venta de seguros, parametro [COD_STATE_PROD_BYSALE], para el contrato:' ||
                               nuSuscripc || '  ingresado  ' || sbPath || ' ' ||
                               vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'ESTADO GAS' || ';' ||
                                Pkg_Bcproducto.Fnuestadoproducto(nuProducto) || ';' ||
                                'El producto de gas no esta definido entre los estados de producto de la venta de seguros, parametro [COD_STATE_PROD_BYSALE]' || ';' ||
                                sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
              end;
              /*Valida que no se debe permitir tener mas de n polizas vigentes por contrato*/
              begin
                ld_bosecuremanagement.ProcValPolyCont(nuSuscripc);
              exception
                when others then
                  sbLineLog := '     Error ... El  contrato ' || nuSuscripc ||
                               ' supero el limite permitido por las aseguradoras ' ||
                               sbPath || ' ' || vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := 'Y';
                  GOTO nextLine;
              end;
              ----------------------------------------------------------------------------------------
              /* Inicio de   caso 200-1106  -
              Valida que no se debe permitir tener mas de n polizas vigentes por contrato*/
              ----------------------------------------------------------------------------------------


                begin

                  ld_bosecuremanagement.proccantpolicontexq(nuSuscripc);

                exception
                  when others then
                    sbLineLog := '     Error ... El  contrato ' ||
                                 nuSuscripc ||
                                 ' supero el limite permitido por las aseguradoras para polizas exequiales' ||
                                 sbPath || ' ' || vArray(i) || ' ' ||
                                 sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := 'Y';
                    GOTO nextLine;
                end;

              if (sbCauseinc = sbCauCumpl) then
                ------------------------------------------------------------
                -- Inio de causal de legalizacion de Exito
                ------------------------------------------------------------
                /* Cedula del asegurado*/  -- SAO[334174]
                sbIdentase := substr(sbOnline,
                                     instr(sbOnline, '|', 1, 7) + 1,
                                     (instr(sbOnline, '|', 1, 8)) -
                                     (instr(sbOnline, '|', 1, 7) + 1));
                /* Nombre del asegurado */
                sbNameaseg := substr(sbOnline,
                                     instr(sbOnline, '|', 1, 8) + 1,
                                     (instr(sbOnline, '|', 1, 9)) -
                                     (instr(sbOnline, '|', 1, 8) + 1));
                /* Codigo del tipo de poliza */
                nuCodePolyType := substr(sbOnline,
                                         instr(sbOnline, '|', 1, 9) + 1,
                                         (instr(sbOnline, '|', 1, 10)) -
                                         (instr(sbOnline, '|', 1, 9) + 1));
                /* Descripcion del producto */
                sbDescProd := substr(sbOnline,
                                     instr(sbOnline, '|', 1, 10) + 1,
                                     (instr(sbOnline, '|', 1, 11)) -
                                     (instr(sbOnline, '|', 1, 10) + 1));
                /* Valor de la prima */
                sbValuepri := substr(sbOnline,
                                     instr(sbOnline, '|', 1, 11) + 1,
                                     (instr(sbOnline, '|', 1, 12)) -
                                     (instr(sbOnline, '|', 1, 11) + 1));
                /* Fecha de nacimiento */
                sbDateBirth := substr(sbOnline,
                                      instr(sbOnline, '|', 1, 13) + 1,
                                      (instr(sbOnline, '|', 1, 14)) -
                                      (instr(sbOnline, '|', 1, 13) + 1));
                -- Cedula del asegurado
                if sbIdentase is null or not fboGetIsNumber(sbIdentase) then
                  sbLineLog := '     Error ... La cedula del asegurado es nula o invalida en el contrato ' ||
                               nuSuscripc || '. ' || sbPath || ' ' ||
                               vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'CEDULA' || ';' || sbIdentase || ';' ||
                                'La cedula del asegurado es nula o invalida' || ';' ||
                                sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
                end if;
                /*17-09-2015 Llozada [ARA 8740]: FIN Se comenta la validacion de nombre*/
                -- codigo del tipo de poliza
                if nuCodePolyType is null or
                   not fboGetIsNumber(nuCodePolyType) then
                  sbLineLog := '     Error ... El codigo del tipo de poliza es nula o invalido para el contrato ' ||
                               nuSuscripc || '. ' || sbPath || ' ' ||
                               vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'TIPO POLIZA' || ';' || nuCodePolyType || ';' ||
                                'El codigo del tipo de poliza es nula o invalido' || ';' ||
                                sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
                end if;
                -- Descripcion del tipo de poliza
                if sbDescProd is null then
                  sbLineLog := '     Error ... La descripcion del tipo de poliza es nula para el contrato ' ||
                               nuSuscripc || '. ' || sbPath || ' ' ||
                               vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'DESC TIPO POLIZA' || ';' || sbDescProd || ';' ||
                                'La descripcion del tipo de poliza es nula' || ';' ||
                                sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
                end if;
                -- Fecha de nacimiento del asegurado
                if sbDateBirth is null then
                  sbLineLog := '     Error ... La fecha de nacimiento del asegurado es nula en el contrato ' ||
                               nuSuscripc || '. ' || sbPath || ' ' ||
                               vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'FECHA NACIMIENTO' || ';' || sbDateBirth || ';' ||
                                'La fecha de nacimiento del asegurado es nula' || ';' ||
                                sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
                end if;
                begin
                  dtDateBirth := to_date(sbDateBirth, 'dd/mm/yyyy');
                exception
                  when others then
                    sbLineLog := '     Error ... La fecha de nacimiento del asegurado no tiene un formato valido en el contrato ' ||
                                 nuSuscripc || '. ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'FECHA NACIMIENTO' || ';' || sbDateBirth || ';' ||
                                  'La fecha de nacimiento del asegurado no tiene un formato valido' || ';' ||
                                  sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end;
                -- SAO[334174]
                -- Calcula la edad del asegurado
                 nuEdad := fnuedad;
                -- Obtiene la edad maxima para asegurar
                nuEdadMax := pkg_bcld_parameter.fnuobtienevalornumerico('COD_DATE_MAX');
                -- Valida que la edad no sea mayor a la almacenada en el parametro
                if nuEdad > nuEdadMax then
                  sbLineLog := '     Error ... La edad del asegurado excede a la almacenada en el parametro [COD_DATE_MAX] en el contrato ' ||
                               nuSuscripc || '. ' || sbPath || ' ' ||
                               vArray(i) || ' ' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'EDAD ASEGURADO' || ';' || nuEdad || ';' ||
                                'La edad del asegurado excede a la almacenada en el parametro [COD_DATE_MAX]' || ';' ||
                                sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  goto nextLine;
                end if;
                /*Se valida que el tipo de poliza de la asegurado corresponda con uno ya registrado*/
                Ld_BcSecureManagement.ProcValPolycontrac(nuCodePolyType,
                                                         nuCodeaseg,
                                                         onuCodePolyType);
                --Validaciones generales
                begin
                  if (not dald_policy_type.fblExist(onuCodePolyType)) then
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                              'No existe un tipo de poliza con el codigo [' ||
                                              nuCodePolyType ||
                                              '] para la aseguradora [' ||
                                              nuCodeaseg || '].');
                  end if;
                exception
                  when others then
                    sbLineLog := '     Error ... No existe un tipo de poliza con el codigo [' ||
                                 nuCodePolyType ||
                                 '] para la aseguradora [' || nuCodeaseg ||
                                 '] para poliza ' || nuPolicy || ' ' ||
                                 sbPath || ' ' || vArray(i) || ' ' ||
                                 sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'TIPO POLIZA' || ';' || nuCodePolyType || ';' ||
                                  'No existe el tipo de poliza para la aseguradora [' ||
                                  nuCodeaseg || '] para poliza [' ||
                                  nuPolicy || ']' || ';' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end;
                BEGIN
                  nuCodedepaGet := ld_BcSecureManagement.GetDepart(nuCodedepa);
                  if nuCodedepaGet is null then
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                              'No existe el codigo del departamento [' ||
                                              nuCodedepa || '].');
                  end if;
                exception
                  when others then
                    sbLineLog := '     Error ... No existe el codigo del departamento [' ||
                                 nuCodedepa || '] del contrato ' ||
                                 nuSuscripc || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'DEPARTAMENTO' || ';' || nuCodedepa || ';' ||
                                  'No existe el codigo del departamento' || ';' ||
                                  replace(replace(sqlerrm, chr(10), ''),
                                          chr(13),
                                          '');
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end;
                -- Validacion Localidad
                BEGIN
                  nuCodeLocaGet := DAGE_geogra_location.fnugetgeograp_location_id(nuCodeLoca);
                  if nuCodeLocaGet is null then
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                              'No existe el codigo de la localidad [' ||
                                              nuCodeLoca || '].');
                  end if;
                exception
                  when others then
                    sbLineLog := '     Error ... No existe el codigo de la localidad [' ||
                                 nuCodeLoca || '] del contrato ' ||
                                 nuSuscripc || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'LOCALIDAD' || ';' || nuCodeLoca || ';' ||
                                  'No existe el codigo de la localidad' || ';' ||
                                  replace(replace(sqlerrm, chr(10), ''),
                                          chr(13),
                                          '');
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end;
                -- Validacion Localidad y departamento
                BEGIN
                  nuCodeLocaDep := ld_BcSecureManagement.GetLocalDepart(nuCodeLocaGet,
                                                                        nuCodedepaGet);
                  if (nuCodeLocaDep < 1) then
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                              'No existe el codigo de localidad [' ||
                                              nuCodeLocaGet ||
                                              '] para el departamento [' ||
                                              nuCodedepaGet || '].');
                  end if;
                exception
                  when others then
                    sbLineLog := '     Error ... No existe el codigo de localidad [' ||
                                 nuCodeLocaGet ||
                                 '] para el departamento [' ||
                                 nuCodedepaGet || '] en el contrato ' ||
                                 nuSuscripc || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'LOCALIDAD' || ';' || nuCodeLocaGet || ';' ||
                                  'No existe la localidad para el departamento [' ||
                                  nuCodedepaGet || ']' || ';' ||
                                  replace(replace(sqlerrm, chr(10), ''),
                                          chr(13),
                                          '');
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end;
                -- Validacion localidad producto
                BEGIN
                  nuCodeLocaPro := ld_BcSecureManagement.ProcValProdLoc(nuSuscripc);
                  if (nuCodeLocaPro <> nuCodeLoca) then
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                              'El producto no pertenece a la localidad [' ||
                                              nuCodeLocaGet ||
                                              '] ni al departamento [' ||
                                              nuCodedepaGet || '].');
                  end if;
                exception
                  when others then
                    sbLineLog := '     Error ... El producto del contrato ' ||
                                 nuSuscripc ||
                                 ' no pertenece a la localidad [' ||
                                 nuCodeLocaGet || '] ni al departamento [' ||
                                 nuCodedepaGet || '] ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'LOCALIDAD' || ';' || nuCodeLoca || ';' ||
                                  'El producto de gas pertenece a la localidad [' ||
                                  nuCodeLocaPro || ']' || ';' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end;
                if (dald_policy_type.fblExist(onuCodePolyType)) THEN
                  ld_bcsecuremanagement.GetValidityPolicyType(onuCodePolyType,
                                                              trunc(sysdate),
                                                              nuPolicyType);
                  if nuPolicyType IS null then
                    sbLineLog := '     Error ... El tipo de poliza [' ||
                                 onuCodePolyType ||
                                 '] no se encuentra vigente. Contrato: ' ||
                                 nuSuscripc || ' ' || sbPath || '' ||
                                 vArray(i) || '' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'TIPO POLIZA' || ';' || nuCodePolyType || ';' ||
                                  'El tipo de poliza no se encuentra vigente' || ';' ||
                                  sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                  END IF;
                  if sbValuepri is null or not fboGetIsNumber(sbValuepri) then
                    sbLineLog := '     Error ... El valor de la prima es nulo o invalido en el contrato ' ||
                                 nuSuscripc || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'VALOR PRIMA' || ';' || sbValuepri || ';' ||
                                  'El valor de la prima es nulo o invalido' || ';' ||
                                  sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                  end if;
                  nuValuepri := To_number(sbValuepri);
                  /*Valor de la prima. Valida si el valor ingresado es diferente al valor
                  correspondiente al tipo de poliza.*/
                  nuShareValue := dald_validity_policy_type.fnuGetSHARE_VALUE(nuPolicyType);
                  if (nuValuepri <> nuShareValue) then
                    sbLineLog := '     Error ... El valor de prima ingresado no corresponde al valor de prima para el tipo de poliza: ' ||
                                 nuPolicyType || '. Contrato: ' ||
                                 nuSuscripc || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'VALOR PRIMA' || ';' || nuValuepri || ';' ||
                                  'El valor de prima ingresado no corresponde al valor de prima real [' ||
                                  nuShareValue ||
                                  '] para el tipo de poliza [' ||
                                  nuCodePolyType || ']' || ';' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                  END IF;
                  /* Valida que el valor de la cuota de poliza, no exceda el parametro definido*/
                  BEGIN
                    ProcValidateShare(nuSuscripc, nuValuepri);
                  EXCEPTION
                    WHEN OTHERS THEN
                      sbLineLog := '     Error ... La cuota de financiacion del contrato ' ||
                                   nuSuscripc ||
                                   ' supero el limite permitido por las aseguradoras ' ||
                                   sbPath || ' ' || vArray(i) || ' ' ||
                                   sqlerrm;
                      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                      -- SAO[334174]
                      sbLineFile := 'Y';
                      GOTO nextLine;
                  END;
                END if;
                --Crea el asegurado si no existe
                ld_bcsecuremanagement.GetSubscriberById(sbIdentase,
                                                        nuSubscriber);
                if nuSubscriber IS null then
                  begin
                    GE_BOSubscriber.CreateContact(nuSubscriber,
                                                  sbNameaseg,
                                                  null,
                                                  null,
                                                  null,
                                                  1,
                                                  sbIdentase,
                                                  GE_BOConstants.cnuSubscriberStaPotential,
                                                  null);
                  exception
                    when others then
                      sbLineLog := '     Error ... al crear el nuevo cliente: ' ||
                                   sbNameaseg ||
                                   ' Con numero de identificacion: ' ||
                                   sbIdentase || ' para la poliza: ' ||
                                   nuPolicy || '.' || sbPath || ' ' ||
                                   vArray(i) || ' ' || sqlerrm;
                      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                      -- SAO[334174]
                      sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                    'CEDULA' || ';' || sbIdentase || ';' ||
                                    'Error al crear el nuevo cliente [' ||
                                    sbNameaseg ||
                                    '] Con numero de identificacion [' ||
                                    sbIdentase || '] para la poliza [' ||
                                    nuPolicy || ']' || ';' || sqlerrm;
                      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                      GOTO nextLine;
                  end;

                END if;
                begin
                  ld_bosecuremanagement.ProcValiPoliType(nuSuscripc,
                                                         sbIdentase,
                                                         onuCodePolyType);
                exception
                  when others then
                    sbLineLog := '  Error ... La cedula ' || sbIdentase ||
                                 ' con el siguiente contrato ' ||
                                 nuSuscripc ||
                                 ' intenta registrar una poliza referenciada a este tipo de poliza ' ||
                                 nuCodePolyType ||
                                 ' y esta cedula ya supero el limite permitido para este tipo de poliza ' ||
                                 sbPath || ' ' || vArray(i) || ' ' ||
                                 sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := 'Y';
                    GOTO nextLine;
                end;

                begin
                  ld_bosecuremanagement.ProcValNumberPol(nuPolicy);
                exception
                  when others then
                    --nuSuscriptor := dald_policy.fnuGetSUSCRIPTION_ID(nuPolicy);
                    sbLineLog := '     Error ... El numero de poliza  ' ||
                                 nuPolicy ||
                                 ' ya se encuentra registrada en otro contrato' ||
                                 sbPath || ' ' || vArray(i) || ' ' ||
                                 sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := 'Y';
                    nuSuscriptor := -1;
                    GOTO nextLine;
                end;
                dald_policy_type.getRecord(onuCodePolyType, rcPolicyType);
                -- Asigna el Id del registro de la Vigencia por Tipo de Poliza
                Ld_BcSecureManagement.GetValidityPolicyType(rcPolicyType.policy_type_id,
                                                            dtDatevisi,
                                                            nuValPolTypId);
                -- Se valida que la poliza sea vigente
                if nuValPolTypId IS null then
                  sbLineLog := '     Error ... El tipo de poliza [' || ' ' ||
                               onuCodePolyType || ' ' ||
                               ' no se encuentra vigente en la fecha [' ||
                               dtDatevisi || '] ' || sbPath || '' ||
                               vArray(i) || '' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                  -- SAO[334174]
                  sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                'TIPO POLIZA' || ';' || nuCodePolyType || ';' ||
                                'El tipo de poliza no se encuentra vigente en la fecha [' ||
                                dtDatevisi || ']' || ';' || sqlerrm;
                  pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                  GOTO nextLine;
                end if;
                -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
                dald_validity_policy_type.getRecord(nuValPolTypId,
                                                    rcValidityPolicyType);
                nuProductLine := rcPolicyType.PRODUCT_LINE_ID;
                ld_bcsecuremanagement.GetSubscriberById(sbIdentase,
                                                        nuSubscriberSec);
                nuQuotaNumber := rcValidityPolicyType.coverage_month; -- JCASTRO
                -- OSF-2572. Ini
                -- Valida que el plan del producto de gas no sea 58 - Medidores Prepago
                if nuPlanFact = nuPmPlanPrePago then
                    sbLineLog := '     Error ... El producto de Gas ' || nuProducto ||
                                 ' con plan '|| nuPlanFact ||
                                 ', no es permitido para la venta de seguros ' ||
                                 sbPath || ' ' || vArray(i) || ' ' ||
                                 sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'CONTRATO' || ';' || nuSuscripc || ';' ||
                                  'El producto de Gas tiene un plan no permitido para la venta de seguros [LD_PARAMETER.PLAN_FACTU_MEDIDOR_PREPAGO]' || ';' ||
                                  sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end if;
                -- Valida si el estado financiero del producto de gas no esta permitido para la venta de seguros (ejemplo los Castigados)
                if sbPmEstFinNoPerm like '%,'||sbEstaFina||',%' then
                    sbLineLog := '     Error ... El producto de Gas ' || nuProducto ||
                                 ' con estado financiero ['|| sbEstaFina ||
                                 '], no es permitido para la venta de seguros ' ||
                                 sbPath || ' ' || vArray(i) || ' ' ||
                                 sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'CONTRATO' || ';' || nuSuscripc || ';' ||
                                  'El producto de Gas tiene un estado financiero no permitido para la venta de seguros [PARAMETROS.ESTAFINA_NOPERM_VENTA_SEGURO]' || ';' ||
                                  sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                end if;
                -- Si la linea nueva del seguro es 91, 131 o 311, valida que el contrato no tenga otra poliza vigente de esas mismas lineas
                if sbPmSegFunerario like '%,'||nuProductLine||',%' then
                    nuExiste := null;
                    open cuPolizaProd (nuSuscripc, sbPmSegFunerario);
                    fetch cuPolizaProd into nuExiste;
                    close cuPolizaProd;
                    if nvl(nuExiste,0) > 0 then
                        sbLineLog := '     Error ... El contrato ' || nuSuscripc ||
                                     ' ya tiene una poliza vigente del mismo tipo '|| nuProductLine ||
                                     ', no es permitido para la venta de seguros dos polizas concurrentes de los tipos '|| trim(',' from sbPmSegFunerario) ||
                                     sbPath || ' ' || vArray(i) || ' ' ||
                                     sqlerrm;
                        pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                        sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                      'CONTRATO' || ';' || nuSuscripc || ';' ||
                                      'El contrato ya tiene una poliza vigente del mismo tipo '|| nuProductLine ||
                                      ' y no esta permitido dos polizas concurrentes de los tipos definidos en [PARAMETROS.SEGURO_FUNERARIO]'|| ';' ||
                                      sqlerrm;
                        pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                        GOTO nextLine;
                    end if;
                end if;
                -- OSF-2572. Fin
                begin
                  ld_bosecuremanagement.ProcValidateClifin(nuSuscripc);
                exception
                  when others then
                    sbLineLog := '     Error ... El dueño de este contrato ' ||
                                 nuSuscripc ||
                                 ' supero el limite de financiacion permitido no puede
                                        asegurar al siguiente beneficiario ' ||
                                 sbIdentase || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' ' || sqlerrm;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := 'Y';
                    GOTO nextLine;
                end;
                begin
                  GetAddressBySusc(nuSuscripc, nuadd, nuGeo);
                  begin
                    -- SAO[334174]
                    GetCatSubBySuscripc(nuSuscripc, nuCategory, nuSubcateg);
                  exception
                    when others then
                      sbLineLog := '     Error ... La categoria no es apta para la venta de seguros, contrato ' ||
                                   nuSuscripc || sbPath || ' ' || vArray(i) || ' ' ||
                                   sqlerrm;
                      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                      sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                    'CATEGORIA' || ';' || nuCategory || ';' ||
                                    'La categoria no es apta para la venta de seguros' || ';' ||
                                    sqlerrm;
                      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                      GOTO nextLine;
                  end;
                  Sbxcept := 'N';

                  --P_TRAMITE_VENTA_SEGUROS_XML_100261 ID_TIPOPAQUETE="100261"
                  sbRequestXML :=
                  pkg_xml_sol_seguros.getSolicitudVentaSeguros(inuContratoId        => nuSuscripc,
                                                               inuMedioRecepcionId  => nuRecepType,
                                                               isbComentario        => sbObservat,
                                                               idtFechaSolicitud    => trunc(dtDatevisi),
                                                               inuDireccionId       => nuadd,
                                                               inuClienteId         => nuSubscriber,
                                                               inuPlanFinanciacionId=> nuFinancingPlan,
                                                               inuCuotas            => nuQuotaNumber,
                                                               inuCategoriaId       => nuCategory,
                                                               inuSubcategId        => nuSubcateg,
                                                               isbExcepcionCom      => Sbxcept,
                                                               inuAseguradoraId     => nuCodeaseg,
                                                               inuIdentificacion    => nuSubscriberSec,
                                                               nuLineaProductoId    => nuProductLine,
                                                               idtFechaNacimiento   => dtDateBirth,
                                                               inuTipoPolizaId      => onuCodePolyType,
                                                               inuNumeroPoliza      => nuPolicy,
                                                               inuValorPoliza       => nuValuepri,
                                                               inuRespuestaId       => nuAnswerId,
                                                               inuCausalIncl        => sbCauseinc,
                                                               inuProductoId        => NULL
                                                              );


                  pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);
                  api_registerrequestbyxml(isbRequestXML    => sbRequestXML,
                                           onuPackageId     => nuPackageId,
                                           onuMotiveId      => nuMotiveId,
                                           onuErrorCode     => nuErrorCode,
                                           osbErrorMessage  => sbErrorMessage
                                          );

                  if (nuPackageId is not null) then
                    commit;

                  else
                    sbLineLog := ' Error creando solicitud de venta de seguros para poliza ' ||
                                 nuPolicy || ' y contrato ' || nuSuscripc ||
                                 ' Error: ' || nuErrorCode || ' Mensaje:' ||
                                 sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'NUMERO POLIZA' || ';' || nuPolicy || ';' ||
                                  'Error creando solicitud de venta de seguros para poliza, Error: ' ||
                                  nuErrorCode || ';' || sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                  end if;
                EXCEPTION
                  when PKG_ERROR.CONTROLLED_ERROR then
                    pkg_error.SetError;
                    pkg_error.getError(nuErrorCode, sbErrorMessage);
                    sbLineLog := '     Error ejecutando el api xml... numero de error ' ||
                                 nuErrorCode || ' Mensaje' ||
                                 sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'ERROR API' || ';' || '' || ';' ||
                                  'Error ejecutando el api xml, Error ' ||
                                  nuErrorCode || ';' || sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                  when OTHERS then
                    pkg_error.SetError;
                    pkg_error.getError(nuErrorCode, sbErrorMessage);
                    sbLineLog := '     Error ejecutando el api xml... numero de error ' ||
                                 nuErrorCode || ' Mensaje' ||
                                 sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    -- SAO[334174]
                    sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                                  'ERROR API' || ';' || '' || ';' ||
                                  'Error ejecutando el api xml, Error ' ||
                                  nuErrorCode || ';' || sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
                    GOTO nextLine;
                END;
                BEGIN
                  ValidateCreateVisit(nuSubscriber, -- inuSubscriber   Cliente
                                      nuSuscripc, -- inuSuscription  Contrato
                                      nuActVisit, -- inuActVisit     Actividad de Visita
                                      nuadd, -- inuAddressId    Direccion
                                      nuCodeaseg, -- inuContrator    Aseguradora
                                      sbObservat, -- isbComment      Cometario
                                      sbCauseinc -- inuCausal       Causal
                                      );
                  COMMIT;
                EXCEPTION
                  when PKG_ERROR.CONTROLLED_ERROR then
                    pkg_error.getError(nuErrorCode, sbErrorMessage);
                    sbLineLog := '     Error ... No se pudo crear la orden de visita para el contrato ' ||
                                 nuSuscripc || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' [' || nuErrorCode || '] ' ||
                                 sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    GOTO nextLine;
                END;
                ------------------------------------------------------------
                -- Fin de causal de legalizacion de Exito
                ------------------------------------------------------------
              else
                ------------------------------------------------------------
                -- Inicio de causal de legalizacion de fallo
                ------------------------------------------------------------
                Ld_BcSecureManagement.GetSubscriberBySusc(nuSuscripc,
                                                          nuSubscriberSec);
                nuSubscriber := nuSubscriberSec;
                nuQuotaNumber := ld_boconstans.cnuonenumber;
                BEGIN
                  GetAddressBySusc(nuSuscripc, nuadd, nuGeo);
                  ValidateCreateVisit(nuSubscriber, -- inuSubscriber   Cliente
                                      nuSuscripc, -- inuSuscription  Contrato
                                      nuActVisit, -- inuActVisit     Actividad de Visita
                                      nuadd, -- inuAddressId    Direccion
                                      nuCodeaseg, -- inuContrator    Aseguradora
                                      sbObservat, -- isbComment      Cometario
                                      sbCauseinc -- inuCausal       Causal
                                      );
                  commit;
                EXCEPTION
                  when PKG_ERROR.CONTROLLED_ERROR then
                    pkg_error.getError(nuErrorCode, sbErrorMessage);
                    sbLineLog := '     Error ... No se pudo crear la orden de visita para el contrato ' ||
                                 nuSuscripc || ' ' || sbPath || ' ' ||
                                 vArray(i) || ' [' || nuErrorCode || '] ' ||
                                 sbErrorMessage;
                    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                    GOTO nextLine;
                END;
                ------------------------------------------------------------
                -- FIN de causal de legalizacion de fallo
                ------------------------------------------------------------
              end if;
              <<nextLine>>
              -- SAO[334174]
              if sbLineFile is null then
                nuCanValid := nuCanValid + 1;
                nuTotProc := nuTotProc + nuLinea;                
              end if;
              nuLinea := nuLinea + 1;
            end loop;

            -- Actualiza el estado del proceso
            pkg_estaproc.prActualizaAvance (sbProceso, 'Termino de procesar el archivo: '||vArray(i), nuTotReg, nuTotProc);

            -- SAO[334174]
            sbLineFile := chr(10) || 'TOTAL PROCESADOS' || ';' || nuLinea;
            pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
            sbLineFile := 'TOTAL VALIDOS' || ';' || nuCanValid;
            pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
            sbLineFile := 'TOTAL INVALIDOS' || ';' ||
                          (nuLinea - nuCanValid) || chr(10);
            pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
            sbL_ext := '.ok';
            Begin
              --sbLineLog := '     El proceso termino verifique los datos ';
              --pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
              pkg_gestionarchivos.prcrenombraarchivo_smf(sbPath,
                               vArray(i),
                               sbPath,
                               sbl_nom || sbL_ext,
                               true);
            exception
              when others then
                sbMsg     := Dbms_Utility.Format_Error_Stack ||
                             Dbms_Utility.Format_Error_Backtrace;
                sbLineLog := '  Error ... No se pudo renombrar archivo ' ||
                             sbPath || '/' || vArray(i) ||
                             ' con la extension ' || sbL_ext || ' ... ' ||
                             'Debe renombrarlo manualmente para que no se procese de nuevo. ' ||
                             'Error= ' || sbMsg;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                -- SAO[334174]
                sbLineFile := 'No se pudo renombrar archivo ' || vArray(i) ||
                              ' con la extension ' || sbL_ext ||
                              'Debe renombrarlo manualmente para que no se procese de nuevo.';
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
            end;
            GOTO nextFile;
          end if;
          <<nextFile>>
          null;

          -- Liberar el bloqueo despues de terminar el trabajo con el archivo
          if (sbLockHandle is not null) then
              nuExito := dbms_lock.release(lockhandle => sbLockHandle);
          end if;

        end loop;
        pkg_gestionarchivos.prccerrararchivo_smf(sbFileManagement);
        pkg_gestionarchivos.prccerrararchivo_smf(sbFileManagementd);
        pkg_gestionarchivos.prccerrararchivo_smf(sbFileManagementf); -- SAO[334174]
        if sbLineLog is null then
          pkg_gestionarchivos.prcborrararchivo_smf(sbPath, sbLog);
        end if;
        -- SAO[334174]
        if sbLineFile is null then
          pkg_gestionarchivos.prcborrararchivo_smf(sbPath, sbFile);
        end if;

        -- Finaliza el proceso de forma normal
        if nuContArch = 0 then
            pkg_estaproc.prActualizaEstaproc (sbProceso, null, 'No existen archivos .txt para procesar');
        else
            pkg_estaproc.prActualizaEstaproc (sbProceso, null, 'Proceso termino OK. Total archivos procesados: '||nuContArch);
        end if;

      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcSaleByFile;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValPoly
  Descripcion    : Obtiene el parametro cantidad de cedula desde la entidad ld_policy_type
                 teniendo en cuenta que el tipo de poliza se debe encontrar vigente.
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
    inuPoly:     Codigo de la poliza
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcValPoly(inuPoly in ld_policy_type.policy_type_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValPoly'; --Nombre del método en la traza
    nuCantId number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.ProcValPoly(inuPoly, nuCantId);
    if (nuCantId = 0) then
      gw_boerrors.checkerror(pkg_Error.CNUGENERIC_MESSAGE,
                                'El tipo de poliza se encuentra vencida');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      pkg_error.SetError;
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValPoly;

  PROCEDURE ValNullNumberValue(inuNumValue      number,
                               isbNameParameter varchar2) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValNullNumberValue'; --Nombre del método en la traza
    /* El atributo %s1 no puede ser nulo */
    cnuNULL_ATTRIBUTE CONSTANT ge_message.message_id%type := 1184;
  BEGIN
   pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (inuNumValue IS null) then
      pkg_error.setErrorMessage(cnuNULL_ATTRIBUTE, isbNameParameter);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValNullNumberValue;

  PROCEDURE ValSubscAndProd(inuSubscriptionId in suscripc.susccodi%type,
                            inuProductId      in servsusc.sesunuse%type,
                            onuFinancingId    out diferido.difecofi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValSubscAndProd'; --Nombre del método en la traza
    blError       boolean := FALSE;
    /* El valor ingresado en el campo %s1 excede  el tamaño  del campo. */
    cnuLENGTH_OUT_RANK CONSTANT ge_message.message_id%type := 7221;
    csbDELIMITER CONSTANT varchar2(1) := '|';
    -- CURSOR Para Obtener financiaciones pendientes
    CURSOR cuPendFinanBySubs(inuSubscriptionId in suscripc.susccodi%type) IS
      SELECT /*+ index( a IDX_CC_FINANCING_REQUEST04 )
                 index( b PK_MO_PACKAGES )
                 use_nl( a b )
             */
       a.*, a.rowid
        FROM cc_financing_request a, /*+ CC_BOFinancingRequest.ValSubscAndProd */
             mo_packages          b
       WHERE b.package_id = a.financing_request_id
         AND a.subscription_id = inuSubscriptionId
         AND b.motive_status_id = MO_BOConstants.cnuSTATUS_REG_PACK;
    -- Valida el tamaño de los parametros
    PROCEDURE ValLengthParams IS
      sbNameParameter  Varchar2(100);
      nuSubscriptionId suscripc.susccodi%type;
      nuProductId      servsusc.sesunuse%type;
    BEGIN
      sbNameParameter  := 'Suscripcion';
      nuSubscriptionId := inuSubscriptionId;
      sbNameParameter := 'Producto';
      nuProductId     := inuSubscriptionId;
    EXCEPTION
      when VALUE_ERROR then
        pkg_error.setErrorMessage(cnuLENGTH_OUT_RANK, sbNameParameter);
      when others then
        pkg_error.SetError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END ValLengthParams;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida longitud de los parametros
    ValLengthParams;
    -- Suscripcion
    ValNullNumberValue(inuSubscriptionId, 'Suscripcion');
    cc_bofinancingClientMig.ValidateSubscription(inuSubscriptionId);
    -- Producto
    if (inuProductId IS not null) then
      pkg_traza.Trace('Valida el Producto [' || inuProductId || ']',
                     pkg_traza.cnuNivelTrzDef);
      ValNullNumberValue(inuProductId, 'Producto');

      /* Valida si el producto tiene impedimentos vigentes para la solicitud de financiacion de deuda */
      CC_BORestriction.valExistRestByProduct(inuProductId,
                                             null,
                                             ps_boProdServManager.frcGetProdMotiByTag(PS_BOProductMotive.csbTagFINANCIACION)
                                             .MOTIVE_TYPE_ID);
    else
      pkg_traza.Trace('Valida el Contrato [' || inuSubscriptionId || ']',
                     pkg_traza.cnuNivelTrzDef);
      /* Se verifica si existen financiaciones pendientes para el contrato */
      for rc in cuPendFinanBySubs(inuSubscriptionId) loop
        blError := TRUE;
        exit;
      end loop;
      /* Si hay financiaciones pendientes para el contrato, se eleva una excepcion */
      if (blError) then
        pkg_error.setErrorMessage(pkg_error.CNUGENERIC_MESSAGE,
                                  'El contrato [' || inuSubscriptionId ||
                                  '] tiene solicitud de financiacion en proceso');

      end if;
      /* Valida si el producto tiene impedimentos vigentes para la solicitud de financiacion de deuda */
      CC_BORestriction.valExistRestBySubscr(inuSubscriptionId,
                                            null,
                                            ps_boProdServManager.frcGetProdMotiByTag(PS_BOProductMotive.csbTagFINANCIACION)
                                            .MOTIVE_TYPE_ID);
    end if;
    /* Se obtiene un nuevo consecutivo de financiacion y se establece en el
    parametro de salida */
    pkDeferredMgr.nuGetNextFincCode(onuFinancingId);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValSubscAndProd;

  PROCEDURE RegChargeFinancing(inuProducto     in servsusc.sesunuse%type,
                               inuAccount      in cuencobr.cucocodi%type,
                               inuPlanDife     in plandife.pldicodi%type,
                               inuDifeNucu     in diferido.difenucu%type,
                               isbDocuSopo     in cargos.cargdoso%type,
                               idtFirstPayDate in diferido.difefein%type,
                               itbCargos       in FI_BOVentasDirectasFinanciadas.tytbCargos) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'RegChargeFinancing'; --Nombre del método en la traza
    ------------------------------------------------------------------------
    --  Variables
    ------------------------------------------------------------------------
    rcPlanDife    plandife%rowtype;
    tbBillAccount mo_tytbBillAccount;
    tbCharges     mo_tytbCharges;
    ------------------------------------------------------------------------
    PROCEDURE LoadConceptBalance(itbBillAccount in mo_tytbBillAccount,
                                 itbCharges     in mo_tytbCharges) IS
      /* PRAGMA para implementacion de transacciones autonomas */
      PRAGMA AUTONOMOUS_TRANSACTION;
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.LoadConceptBalance'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Inicializa la tabla temporal
      DELETE cc_tmp_bal_by_conc;
      INSERT INTO cc_tmp_bal_by_conc
        (tmp_bal_by_concept_id,
         selected,
         subscription_id,
         product_id,
         base_product_id,
         product_type_id,
         concept_id,
         deferrable,
         pending_balance,
         tax_pending_balance,
         financing_balance,
         tax_financing_balance,
         not_financing_balance,
         cancel_serv_estat_id,
         account_number,
         financing_concept_id,
         balance_account,
         amount_account_total,
         payment_date,
         expiration_date,
         company_id,
         is_interest_concept,
         discount_percentage)
        SELECT /*+ leading( charges )
                use_nl( charges concepto )
                use_nl( charges servsusc )
                use_nl( servsusc estacort )
                index( concepto PK_CONCEPTO )
                index( servsusc PK_SERVSUSC )
                index( estacort PK_ESTACORT ) */
         ROWNUM nuIndex, -- Consecutivo para identificar el concepto
         CONSTANTS_PER.CSBYES selected,
         sesususc,
         product_id,
         null,
         sesuserv product_type_id,
         concept_id,
         nvl(concdife, constants_per.CSBNO) deferrable,
         SaldoConc,
         pkBillConst.CERO SaldoIva,
         SaldoConc financing_balance,
         pkBillConst.CERO tax_financing_balance,
         0 not_financing_balance,
         sesuesco,
         bill_account_id, --cargcuco,
         conccore,
         bill_account_balance, --cucosacu,
         bill_acc_total_value, --cucovato,
         payment_date, --cucofepa,
         expiration_date, --cucofeve
         sesusist,
         (SELECT 'Y'
            FROM concepto
           WHERE (conccoin = concept_id and ROWNUM = 1)) SourceConceptIsIntConcept,
         apply_for_discount
          FROM ( /******************************************************************/
                /* Cartera corriente que se encuentra causada                     */
                /******************************************************************/
                SELECT /*+ leading( ba )
                           use_nl( ba g ) */
                 g.product_id,
                  g.concept_id,
                  nvl(sum(g.balance), 0) SaldoConc,
                  g.bill_account_id,
                  bill_account_balance,
                  bill_acc_total_value,
                  payment_date,
                  expiration_date,
                  pkBillConst.CERO apply_for_discount
                  FROM TABLE(CAST(itbCharges AS mo_tytbCharges)) g,
                        TABLE(CAST(itbBillAccount AS mo_tytbBillAccount)) ba
                 WHERE g.bill_account_id = ba.bill_account_id
                   AND charge_value > pkBillConst.CERO HAVING
                 nvl(sum(g.balance), 0) <> 0
                 GROUP BY g.product_id,
                           g.bill_account_id,
                           g.concept_id,
                           bill_account_balance,
                           bill_acc_total_value,
                           payment_date,
                           expiration_date) charges,
               concepto,
               servsusc,
               estacort
         WHERE conccodi = concept_id
           AND sesunuse = product_id
           AND escocodi = sesuesco;
      -- Se verifica si se insertaron registros en la tabla temporal
      pkg_traza.trace('-- Se insertaron ' || sql%rowcount ||
                     ' registros en la tabla temporal',
                     pkg_traza.cnuNivelTrzDef);
      -- Evita dejar nulos
      UPDATE cc_tmp_bal_by_conc
         SET is_interest_concept     = nvl(is_interest_concept,
                                           constants_per.CSBNO),
             pend_balance_to_finance = 0,
             tax_bal_to_finance      = 0;
      /* Se asientan los cambios realizados en la base de datos */
      pkGeneralServices.CommitTransaction;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        /* Se reversan los cambios realizados en la base de datos */
        pkGeneralServices.RollBackTransaction;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        /* Se reversan los cambios realizados en la base de datos */
        pkGeneralServices.RollBackTransaction;
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END LoadConceptBalance;
    ------------------------------------------------------------------------
    PROCEDURE LoadChargesFromBillAcc(otbCharges out nocopy mo_tytbCharges) IS
       csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.LoadChargesFromBillAcc'; --Nombre del método en la traza
       cursor cuCargos is
       SELECT CAST(MULTISET (SELECT inuAccount, -- BILL_ACCOUNT_ID
                          inuProducto, -- PRODUCT_ID
                          pkg_bcproducto.fnuTipoProducto(inuProducto), --sesuserv, -- PRODUCT_TYPE_ID
                          itbCargos(1).cargconc, -- CONCEPT_ID
                          1, -- CHARGE_CAUSE
                          itbCargos(1).cargsign, -- SIGN_
                          1, -- BILLING_PERIOD
                          itbCargos(1).cargvalo, -- CHARGE_VALUE
                          '-', -- DOCUMENT_SUPPORT
                          1, -- DOCUMENT_ID
                          1, -- PROCESS_TYPE
                          1, -- UNITS
                          sysdate, -- CREATION_DATE
                          1, -- PROGRAM
                          1, -- CALL_SEQUENCE
                          1, -- OUTSIDER_MONEY_VALUE
                          itbCargos(1).cargvalo, -- BALANCE   ,
                          0, -- ORIGINAL_BALANCE
                          null, -- LIST_DIST_CREDITS
                          1, -- ROW_NUMBER_
                          constants_per.CSBNO, -- IS_DISCOUNT
                          0, -- DISCOUNT_PERCENTAGE
                          1 -- USERNAME
                     FROM dual) AS mo_tytbCharges)
        FROM dual;
    BEGIN
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
        open cuCargos;
             fetch cuCargos into otbCharges;
        close cuCargos;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END LoadChargesFromBillAcc;
    ------------------------------------------------------------------------
    PROCEDURE LoadBillAccByAccStatus(otbBillAccount out nocopy mo_tytbBillAccount) IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.LoadBillAccByAccStatus'; --Nombre del método en la traza
        cursor cuCucoSesu is
        SELECT CAST(MULTISET (SELECT /*+ ORDERED use_nl (CUENCOBR, SERVSUSC)
                                         index(CUENCOBR PK_CUENCOBR)
                                         index(SERVSUSC PK_SERVSUSC) */
                      CUCOCODI, --BILL_ACCOUNT_ID
                      SESUSUSC, --SUBSCRIBER_ID
                      CUCODEPA, --DEPARTMENT_ID
                      CUCOLOCA, --LOCATE_ID
                      CUCOPLSU, --BILLING_PLAN_ID
                      CUCOCATE, --BILLING_CATEGORY_ID
                      CUCOSUCA, --BILL_SUBCATEGORY_ID
                      CUCOVAAP, --AUTHORIZED_PAY_VALUE
                      CUCOVARE, --CLAIM_VALUE
                      CUCOVAAB, --PARTIAL_PAY_VALUE
                      CUCOVATO, --BILL_ACC_TOTAL_VALUE
                      CUCOFEPA, --PAYMENT_DATE
                      CUCONUSE, --PRODUCT_ID
                      CUCOSACU, --BILL_ACCOUNT_BALANCE
                      CUCOVRAP, --NOT_PAID_CLAIM_VALUE
                      CUCOFACT, --BILL_ID
                      SESUSERV, --PRODUCT_TYPE_ID
                      CUCOFAAG, --BILL_GROUPING_ID
                      CUCOFEVE, --EXPIRATION_DATE
                      CUCOVAFA, --BILLING_VALUE
                      CUCOIMFA, --BILLING_TAX_VALUE
                      CUCOSIST, --COMPANY_ID
                      CUCOGRIM --PRINT_GROUP
                       FROM /*+LD_boflowFNBPack.RegChargeFinancing.LoadBillAccByAccStatus*/
                            CUENCOBR,
                            SERVSUSC
                      WHERE cucocodi = inuAccount
                        AND cucocodi != pkBillConst.NULOSAT
                        AND cuconuse = sesunuse) AS mo_tytbBillAccount)
          FROM dual;

    BEGIN
       pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

        open cuCucoSesu;
             fetch cuCucoSesu into otbBillAccount;
        close cuCucoSesu;
        --si el cursor no obtiene datos se levanta el error
        if    otbBillAccount.count = 0 then
           RAISE PKG_ERROR.CONTROLLED_ERROR;
        end if;

      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END LoadBillAccByAccStatus;
    ------------------------------------------------------------------------
    PROCEDURE SetAccountStatus IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.SetAccountStatus'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      cc_bcfinancing.ClearMemTables;
      CC_BOFinancing.ClearMemoryFinancing;
      -- Inicializa tabla de conceptos y colecciones
      cc_bcfinancing.clearBalByConcept;
      -- Carga de colecciones
      LoadBillAccByAccStatus(tbBillAccount);
      LoadChargesFromBillAcc(tbCharges);
      /* Se carga la coleccion de saldos por concepto con la deuda a financiar
      para la suscripcion */
      LoadConceptBalance(tbBillAccount, tbCharges);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      WHEN PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END SetAccountStatus;
    ------------------------------------------------------------------------
    PROCEDURE FinanciarConceptosFactura IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.FinanciarConceptosFactura'; --Nombre del método en la traza
      -- Numero de productos a financiar
      nuNumProdsFinanc number;
      -- Variables de salida del proceso de financiacion
      onuAcumCuota         number;
      onuSaldo             number;
      onuTotalAcumCapital  number;
      onuTotalAcumCuotExtr number;
      onuTotalAcumInteres  number;
      osbRequiereVisado    varchar2(1);
      nuDifeCofi           diferido.difecofi%type;
      nuQuotaMethod        plandife.pldimccd%type;
      nuTaincodi           plandife.plditain%type;
      nuInteRate           plandife.pldipoin%type;
      boSpread             boolean;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Se asigna el consecutivo de financiacion
      pkDeferredMgr.nuGetNextFincCode(nuDifeCofi);
      -- Se instancian en la tabla temporal de saldos por concepto, los
      -- conceptos de la factura
      SetAccountStatus;
      pkg_error.setapplication('FINAN');
      -- Se actualiza la tabla temporal para que sean procesados solo los conceptos
      -- financiables
      CC_BCFinancing.SelectAllowedProducts(constants_per.CSBSI,
                                           nuNumProdsFinanc);
      -- Obtiene tasa de interes
      pkDeferredPlanMgr.ValPlanConfig(rcPlandife.pldicodi,
                                      ldc_boconsgenerales.fdtgetsysdate,
                                      nuQuotaMethod,
                                      nuTaincodi,
                                      nuInteRate,
                                      boSpread);
      -- Se ejecuta el proceso de financiacion
      ExecDebtFinanc(rcPlandife.pldicodi,
                     rcPlandife.pldimccd,
                     idtFirstPayDate,
                     nuInteRate,
                     pkBillConst.CERO,
                     inuDifeNucu,
                     isbDocuSopo,
                     pkBillConst.CIENPORCIEN,
                     pkBillConst.CERO,
                     constants_per.CSBNO,
                     pkg_error.getApplication,
                     constants_per.CSBNO,
                     constants_per.CSBNO,
                     nuDifeCofi,
                     onuAcumCuota,
                     onuSaldo,
                     onuTotalAcumCapital,
                     onuTotalAcumCuotExtr,
                     onuTotalAcumInteres,
                     osbRequiereVisado);
      -- Se guarda la informacion de la financiacion en la base de datos
      CommitFinanc;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END FinanciarConceptosFactura;
    ------------------------------------------------------------------------
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    --  Obtiene la informacion del plan de financiacion
    rcPlanDife := pktblPlandife.frcGetRecord(inuPlanDife);
    -- Se financia la factura generada
    FinanciarConceptosFactura;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END RegChargeFinancing;

  PROCEDURE CalMinValueToPay(inuSubscriptionId      in suscripc.susccodi%type,
                             inuProductId           in servsusc.sesunuse%type,
                             inuValueToPay          in cc_financing_request.initial_payment%type,
                             inuMaxPorcFin          in plandife.pldipmaf%type,
                             onuPorcFinanc          out number,
                             onuDebtFinanciableBal  out number,
                             onuDebtNotFinanBalance out number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'CalMinValueToPay'; --Nombre del método en la traza
    -- Saldos
    -- Saldo Pendiente
    nuDebtBalance number;
    -- Saldo de Pendinete por Intereses
    nuTaxDebtBalance number;
    -- Valor Minimo a pagar Calculado
    nuValueMinToPay number := 0;
    --  Indicador que define si para la suscripcion se debe ajustar cuentas
    blAdjustAccount boolean := TRUE;
    --  Factor de ajuste
    nuAdjustFactor timoempr.tmemfaaj%type;
    -- Valor de ajuste segun la politica de redondeo para la suscripcion
    nuAdjustedValue cargos.cargvalo%type;
    -- Signo de ajuste segun la politica de redondeo para la suscripcion
    sbAdjustSign cargos.cargsign%type;
    /* El campo %s1 debe ser mayor o igual a %s2 */
    cnuVAL_GREATER_EQUAL CONSTANT ge_message.message_id%type := 110542;
    csbDELIMITER         CONSTANT varchar2(1) := '|';
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Se obtienen los saldos estos ya incluyen los valores de descuentos
    cc_bcfinancing.GetTotalFinancingDebt(nuDebtBalance,
                                         nuTaxDebtBalance,
                                         onuDebtFinanciableBal,
                                         onuDebtNotFinanBalance);
    -- Calculo el valor minimo a pagar
    nuValueMinToPay := onuDebtNotFinanBalance +
                       (onuDebtNotFinanBalance *
                       ((100 - inuMaxPorcFin) / 100));
    FA_BOPoliticaRedondeo.AplicaPolitica(nvl(inuProductId,
                                             pr_boproduct.fnuFirstProdByContract(inuSubscriptionId)),
                                         nuValueMinToPay);
    -- Se obtiene el Factor de Ajuste
    FA_BOPoliticaRedondeo.ObtienePoliticaAjuste(inuSubscriptionId,
                                                blAdjustAccount,
                                                nuAdjustFactor);
    -- Valida si se debe generar ajuste
    if (blAdjustAccount) then
      pkAccountMgr.CalcValorAjuste(nuAdjustFactor,
                                   nuValueMinToPay,
                                   nuAdjustedValue,
                                   sbAdjustSign);
      if (sbAdjustSign = pkbillconst.CREDITO) then
        nuValueMinToPay := nuValueMinToPay +
                           (nuAdjustFactor - nuAdjustedValue);
      else
        nuValueMinToPay := nuValueMinToPay + nuAdjustedValue;
      end if;
    end if;
    if (inuValueToPay < nuValueMinToPay) then
      pkg_error.setErrorMessage(cnuVAL_GREATER_EQUAL,
                                'Valor a pagar' || csbDELIMITER ||
                                nuValueMinToPay);
    end if;
    -- Se calula el procentaje
    onuPorcFinanc := pkBillConst.CIENPORCIEN -
                     ((inuValueToPay - onuDebtNotFinanBalance) *
                     pkBillConst.CIENPORCIEN / onuDebtFinanciableBal);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END CalMinValueToPay;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcDeffereadCreate
  Descripcion    : Creacion de diferidos a partir del numero del producto
  Autor          : AAcuna
  Fecha          : 30/10/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuPackage    :  Numero del paquete
  Historia de Modificaciones
  Fecha        Autor        Modificacion
  =========   ========= ====================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
  28-01-2014  ggamarra Cambio 6005  Se agrega el parametro SEGURO_DIAS_ADICIONALES cuyos dias se suman al
                                    periodo de gracia del diferido
  15-12-2014  Llozada [NC 4230]   El policy_number de la Solicitud corresponde al policy_id de la poliza
  10-11-2014  llarrarte.RQ1146    Se modifica para que asocie el diferido al campo
                                  policy_number en lugar del policy_id
  26-09-2014  llarrarte.RQ1719    Se adiciona periodo de gracia en el caso de
                                  la renovacion
  01/09/2014  KCienfuegos.NC962   Se modifica para actualizar los saldos de la
                                  cuenta luego de crear el cargo correspondiente
                                  al cobro de la poliza de doble cupon
  08/08/2014  AEcheverry.4152     Se modifica para generar el cargo de la poliza
                                  en este punto, pero antes de generar el diferido.
                                  Cuando los cargos son por doble cupon se generan
                                  solo por el valor de la poliza menos una cuota,
                                  que corresponde a la cuota inicial cancelada en
                                  el doble cupon.
  01/07/2014  AEcheverry.4031     se modifica para que al tratarse de una renovacion
                                  no se envie a actualiar informacion de producto,
                                  ni generar nuevos componentes.
  22/12/2013  JCarmona.SAO227979  Se modifica para que cree una nueva financiacion
                                  para la poliza renovada
  01/11/2013  jrobayo.SAO222285   Se modifica el procedimiento para utilizar el numero
                                  de la poliza para la creacion de diferidos.
  17/10/2013  JCarmona.SAO220105  Se modifica el procedimiento que obtiene el
                                  numero del diferido <Ld_BcSecureManagement.GetDefferedByPol>,
                                  por lo tanto se modifica el llamado a este metodo para
                                  enviarle el id del producto y no de la poliza.
  03/09/2013  jcarrillo.SAO214425 1 - Se modifica para atender la solicitud de
                                      financiacion
  31-08-2013  jcarrillo.SAO213976 1 - Se modifica para antender la solicitud
                                      y  realizar la activacion del producto
  27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  ******************************************************************/
  PROCEDURE ProcDeffereadCreate(inuPackage mo_packages.package_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcDeffereadCreate'; --Nombre del método en la traza
    nuPolicyId    ld_policy.policy_id%type;
    rcMotive      damo_motive.styMO_motive;
    nuMotive      mo_motive.motive_id%type;
    rcMopackage   damo_packages.styMO_packages;
    rcSalesFinanc dacc_sales_financ_cond.styCC_sales_financ_cond;
    nuDeffered    diferido.difecodi%type;
    nuError       number;
    sbMessage     varchar2(2000);
    sbHashPol     varchar2(200);
    nuvalor       number;
    rcSecure_Sale dald_secure_sale.styLD_secure_sale;
    rcPolicyType  dald_policy_type.styLD_policy_type;
    rcValidityPolicyType dald_validity_policy_type.styLD_validity_policy_type; -- JCASTRO
    nuValPolTypId        ld_validity_policy_type.validity_policy_type_id%TYPE; -- JCASTRO
    rcAccount cuencobr%rowtype;
    tbCargos  FI_BOVentasDirectasFinanciadas.tytbCargos;
    -- Codigo de la Financiacion
    nuFinancingId diferido.difecofi%type := null;
    rcPlanDife    plandife%rowtype;
    nuDifecodi    diferido.difecodi%type;
    nuFinancPerc  number;
    nuInteresPerc diferido.difeinte%type;
    nuQuotaMethod diferido.difemeca%type; -- Metodo de calculo de la cuota del diferido
    nuTaincodi    plandife.plditain%type; -- Codigo Tasa Interes
    boSpread      boolean;
    -- Saldo financiable
    nuDebtFinanciableBal number;
    -- Saldo no financiable
    nuDebtNotFinanBalance number;
    -- numero de cuotas
    nuShares number;
    -- numero de polizas asociadas
    nuCountPolicies number;
    nuCause          number;
    nuConcept        number;
    nuCuentaDC       cuencobr.cucocodi%type;
    nuProductLineId  ld_policy.PRODUCT_LINE_ID%type;
    nuBalanceInvoice pkbcfactura.styfactspfa;
    nuFactcodi       factura.factcodi%type;
    nuCucocodi       cuencobr.cucocodi%type;
    rfDeferreds   CONSTANTS_PER.TYREFCURSOR;
    nuDeferredId  diferido.difecodi%type;
    dtEndDate     perifact.pefaffmo%type;
    rcGracePeriod dacc_grace_peri_defe.stycc_grace_peri_defe;
    nuMaxDiasFact number := pkg_bcld_parameter.fnuobtienevalornumerico('SEGURO_DIAS_ADICIONALES');
    -- Se obtiene el cargo asociado a la cuenta de cobro
    CURSOR cuLastDeferred(nuDifenuse diferido.difenuse%type) IS
      SELECT difecodi
        FROM diferido
       WHERE difenuse = nuDifenuse
       ORDER BY difecodi desc;
    --  Obtiene la ultima cuenta de cobro del producto
    CURSOR cuProdLastAcc(nuProductBrilla cuencobr.cuconuse%type) IS
      SELECT *
        FROM cuencobr
       WHERE cuconuse = nuProductBrilla
       ORDER BY cucocodi desc;
    CURSOR cuGetPolicies(inuProductId in pr_product.product_id%type) IS
      SELECT count(1) FROM ld_policy WHERE product_id = inuProductId;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuMotive := mo_bopackages.fnuGetInitialMotive(inuPackage);
    damo_motive.getRecord(nuMotive, rcMotive);
    dald_secure_sale.getRecord(inuPackage, rcSecure_Sale);
    dacc_sales_financ_cond.getRecord(inuPackage, rcSalesFinanc);
    dald_policy_type.getRecord(rcSecure_Sale.policy_type_id, rcPolicyType);
    rcMopackage := pkg_bcsolicitudes.frcgetrecord(inuPackage);
    pkg_traza.Trace('-- RN 500. rcMotive.product_id: ' ||
                   rcMotive.product_id, pkg_traza.cnuNivelTrzDef);
    --  Cuenta la cantidad de polizas asociadss
    open cuGetPolicies(rcMotive.product_id);
    fetch cuGetPolicies
      INTO nuCountPolicies;
    close cuGetPolicies;
    nuCountPolicies := nvl(nuCountPolicies, 0);
    pkg_traza.Trace('-- RN 501. nuCountPolicies: ' || nuCountPolicies,pkg_traza.cnuNivelTrzDef);
    -- Asigna el Id del registro de la Vigencia por Tipo de Poliza
    Ld_BcSecureManagement.GetValidityPolicyType(rcPolicyType.policy_type_id,
                                                rcMopackage.request_date,
                                                nuValPolTypId);
    -- Se valida que la poliza sea vigente
    if (nuValPolTypId IS null) then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'El tipo de poliza [' ||
                                rcPolicyType.policy_type_id ||
                                '] no se encuentra vigente' ||
                                ' en la fecha [' ||
                                rcMopackage.request_date || ']'
                               );
    end if;
    -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
    dald_validity_policy_type.getRecord(nuValPolTypId,
                                        rcValidityPolicyType);
    /**********************
    Generacion de cargos=> cambio4152
    **********************/
    nuCause := pkg_bcld_parameter.fnuobtienevalornumerico('COD_CAUSE_CARG_SALE');
    --Obtiene el policy_id para consultar la linea de producto - RQ1146
    --15-12-2014 Llozada [NC 4230]: El policy_number de la Solicitud corresponde al policy_id de la poliza
    nuPolicyId := rcSecure_Sale.policy_number; --ld_bcsecuremanagement.fnuGetIdByPolicyNumber(rcSecure_Sale.policy_number);
    nuProductLineId := dald_policy.fnuGetPRODUCT_LINE_ID(nuPolicyId);
    -- RQ1146
    nuConcept := dald_product_line.fnuGetConcept_Id(nuProductLineId, null);
    nuvalor := rcValidityPolicyType.policy_value;
    pkg_error.setapplication(cc_boconstants.csbCUSTOMERCARE);

    if (nuCountPolicies > 1) then
      -- renovacion
      /* Se crea el cargo */
      pkChargeMgr.GenerateCharge(rcMotive.product_id,
                                 -1,
                                 nuConcept,
                                 nuCause,
                                 nuvalor, --rcPolicyType.share_value,
                                 'DB',
                                 'PP-' || rcSecure_Sale.policy_number,
                                 'A',
                                 0,
                                 null,
                                 null,
                                 null,
                                 false,
                                 sysdate);

      -- se utiliza este servicio que no aplica el saldo a favor para que no se vaya aborar a deuda vieja de la poliza (producto)
      GenerateBySuppDoc(rcMotive.subscription_id,
                        rcMotive.product_id,
                        'PP-' || rcSecure_Sale.policy_number,
                        nuFactcodi,
                        nuCucocodi,
                        nuBalanceInvoice,
                        nuerror,
                        sbmessage);
       gw_boerrors.checkerror(nuerror, sbmessage);
    else
      --venta
      /* Se genera el cargo con el producto generado por el servicio de producto, se asocia
      al concepto y a la causa configurada por el parametro de la solicitud,se inicializa con cargo
      DB*/
      -- si es por doble cupon el valor es menos la cuota inicial
      IF rcMopackage.COMM_EXCEPTION = 'Y' THEN
        nuvalor := nuvalor - nvl(rcValidityPolicyType.share_value, 0);
        --  Obtiene la ultima cuenta de cobro del producto
        open cuProdLastAcc(rcMotive.product_id);
        fetch cuProdLastAcc
          INTO rcAccount;
        close cuProdLastAcc;
        -- se consulta la cuenta generada en el pago del doble cupon
        nuCuentaDC := rcAccount.cucocodi;
      END if;
      nuCuentaDC := nvl(nuCuentaDC, -1);
      pkChargeMgr.GenerateCharge(rcMotive.product_id,
                                 nuCuentaDC, -- cuenta de cobro del pago de doble cupon o -1
                                 nuConcept,
                                 nuCause,
                                 nuvalor,
                                 'DB',
                                 'PP-' || inuPackage,
                                 'A',
                                 0,
                                 null,
                                 null,
                                 null,
                                 false,
                                 sysdate);
      IF (nuCuentaDC <> -1) THEN
        pkUpdAccoReceiv.UpdAccoRec(pkBillConst.cnuSUMA_CARGO,
                                   nuCuentaDC,
                                   pkg_bcproducto.fnucontrato(rcMotive.product_id),
                                   rcMotive.product_id,
                                   nuConcept,
                                   'DB',
                                   nuvalor,
                                   pkBillConst.cnuUPDATE_DB);
      END IF;
      /*Creacion de factura*/
      cc_boaccounts.GenerateAccountByPack(inuPackage);
    END IF;
    /*********************
    <=Generacion de cargos cambio4152
    *********************/
    nuvalor := null;
    IF rcMopackage.COMM_EXCEPTION = 'Y' THEN
      -- Obtiene el Valor de la Cuota Inicial de la Prima del Seguro (modificado segun comentario de Sandra blanco)
      nuvalor  := 0;
      nuShares := rcValidityPolicyType.coverage_month - 1;
    ELSIF rcMopackage.COMM_EXCEPTION = 'N' OR
          rcMopackage.COMM_EXCEPTION IS NULL THEN
      Ld_BoSecureManagement.GetSecureInitialValue(rcMotive.subscription_id,
                                                  nuvalor,
                                                  rcMopackage.request_date);
      nuShares := rcValidityPolicyType.coverage_month;
    END IF;
    sbHashPol := DBMS_UTILITY.GET_HASH_VALUE('' ||
                                             rcSecure_Sale.policy_number,
                                             2,
                                             9999999);
    pkg_traza.trace('rcMotive.subscription_id[' || rcMotive.subscription_id ||
                   ']product_id=' || rcMotive.product_id,
                   pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('rcValidityPolicyType.coverage_month[' || nuShares ||
                   ']sbHashPol=' || sbHashPol,
                   pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('rcSalesFinanc.financing_plan_id=' ||
                   rcSalesFinanc.financing_plan_id,
                   pkg_traza.cnuNivelTrzDef);
    --  Obtiene la informacion del plan de financiacion
    rcPlanDife := pktblPlandife.frcGetRecord(rcSalesFinanc.financing_plan_id);
    --  Obtiene la ultima cuenta de cobro del producto
    open cuProdLastAcc(rcMotive.product_id);
    fetch cuProdLastAcc
      INTO rcAccount;
    close cuProdLastAcc;
    -- Valida Contrato y Producto
    ValSubscAndProd(rcMotive.subscription_id,
                    rcMotive.product_id,
                    nuFinancingId);
    -- cargo a diferir
    tbCargos(1).cargconc := nuConcept;
    tbCargos(1).cargsign := pkBillConst.DEBITO;
    -- se cambia para financiar solo el saldo de la cuenta y no el valor del cargo generado
    tbCargos(1).cargvalo := rcAccount.cucosacu;
    RegChargeFinancing(rcMotive.product_id,
                       rcAccount.cucocodi,
                       rcSalesFinanc.financing_plan_id,
                       nuShares,
                       sbHashPol,
                       sysdate,
                       tbCargos);
    -- Se obtiene el ultimo diferido del producto
    open cuLastDeferred(rcMotive.product_id);
    fetch cuLastDeferred
      INTO nuDifecodi;
    close cuLastDeferred;
    -- Se actualiza el id de la financiacion
    pktbldiferido.upddifecofi(nuDifecodi, nuFinancingId);
    -- Calcula y valida el valor minimo a pagar
    CalMinValueToPay(rcMotive.subscription_id,
                     rcMotive.product_id,
                     0,
                     rcPlanDife.pldipmaf,
                     nuFinancPerc,
                     nuDebtFinanciableBal,
                     nuDebtNotFinanBalance);
    -- Obtiene tasa de interes
    pkDeferredPlanMgr.ValPlanConfig(rcPlandife.pldicodi,
                                    ldc_boconsgenerales.fdtgetsysdate,
                                    nuQuotaMethod,
                                    nuTaincodi,
                                    nuInteresPerc,
                                    boSpread);
    -- Se inicializa la coleccion de diferidos
    CC_BOFinancing.LoadDefWithBalByFinan(nuFinancingId);
    -- Se registra el cc_financing_request
    CC_BCWaitForPayment.SaveFinancing(inuPackage, --nuPackages,
                                      rcMotive.subscription_id, --inuSubscriptionId,
                                      nuFinancingId, --nuFinancingId,
                                      CC_BCWaitForPayment.csbFinRequirement,
                                      rcSalesFinanc.financing_plan_id, --rcPlanDife.pldicodi,
                                      rcPlanDife.pldimccd, --metodo de calculo
                                      rcPlanDife.plditain,
                                      sysdate, -- dtInitPayDate,
                                      0, -- inuValueToPay,
                                      nuFinancPerc,
                                      nuInteresPerc,
                                      0, -- inuSpread,
                                      nuShares, -- inuQuotesNumber,
                                      nuvalor, --nuAcumCuota,
                                      constants_per.CSBNO,
                                      sbHashPol, --isbSupportDocument,
                                      constants_per.CSBNO,
                                      constants_per.CSBNO, --sbWaitByPayment,
                                      pkg_bopersonal.fnugetpersonaid, --nuPersonId,
                                      'FINAN', --csbFINANCING_APP,
                                      null,
                                      constants_per.CSBNO --isbOnlyExpiredAcc
                                      );
    -- si hay mas de una poliza asociada al producto es una renovacion, de lo contrario es una venta
    if (nuCountPolicies > 1) then
      rfDeferreds := ld_bcsecuremanagement.frfgetDeferredByFinan(nuFinancingId);
      dtEndDate   := ld_bosecuremanagement.fdtGetEndDatePeriod(rcMotive.product_id);
      -- Cambio 6005, adicion de dias
      dtEndDate := dtEndDate + NVL(nuMaxDiasFact, 0);
      fetch rfDeferreds
        INTO nuDeferredId;
      loop
        fetch rfDeferreds
          INTO nuDeferredId;
        rcGracePeriod.grace_peri_defe_id := SEQ_CC_Grace_Peri_D_185489.nextval;
        rcGracePeriod.grace_period_id    := pkg_bcld_parameter.fnuobtienevalornumerico(ld_boconstans.csbRenPolicyPeriGrace);
        rcGracePeriod.deferred_id        := nuDeferredId;
        rcGracePeriod.initial_date       := trunc(sysdate);
        rcGracePeriod.END_date           := dtEndDate;
        rcGracePeriod.program            := 309;
        rcGracePeriod.person_id          := pkg_bopersonal.fnugetpersonaid;
        dacc_grace_peri_defe.insrecord(rcGracePeriod);
        exit when rfDeferreds%notfound;
      END loop;
      Mo_Boattention.attendpackage(inuPackage, 60, true);
    else
      /*Activacion y atencion del producto*/
      Mo_Boattention.Attendcreationprodbypackmass(inuPackage, 60, 1);
    END if;
    ld_bcsecuremanagement.GetDefferedByPol(rcMotive.product_id,
                                           rcSecure_Sale.policy_number,
                                           nuDeffered);
    dald_policy.updDeferred_Policy_Id(nuPolicyId, nuDeffered);
    pkg_traza.Trace('FIN Ld_BoSecureManagement.ProcDeffereadCreate',pkg_traza.cnuNivelTrzDef);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcDeffereadCreate;
  FUNCTION fdtGetEndDatePeriod(inuProductId in servsusc.sesunuse%type)
    return date IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fdtGetEndDatePeriod'; --Nombre del método en la traza
    nuFact          factura.factcodi%type;
    dtEndDate       date;
    nuPerifact      perifact.pefacodi%type;
    rcPerifact      perifact%rowtype;
    dtEndDatePeriod perifact.pefaffmo%type;
    nuPendQuot      number;
    nuCiclo         number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Obtiene la factura generada para el periodo de facturacion actual */
    nuFact := ld_bcsecuremanagement.fnuGetCurrentBillByProduct(inuProductId);
    pkg_traza.trace('--RN 1. nuFact ' || nuFact, pkg_traza.cnuNivelTrzDef);
    /* Cuotas pendientes de diferidos */
    nuPendQuot := ld_bcsecuremanagement.fnuGetPenDeferrQuot(inuProductId);
    pkg_traza.trace('--RN 2. nuPendQuot ' || nuPendQuot, pkg_traza.cnuNivelTrzDef);
    if (nufact IS not null) then
      /* Periodo de facturacion */
      nuPerifact := pktblfactura.fnugetperiod(nufact);
      pkg_traza.trace('--RN 100. nuPerifact ' || nuPerifact, pkg_traza.cnuNivelTrzDef);
      /* Fecha fin del periodo de facturacion */
      dtEndDatePeriod := pktblperifact.fdtgetenddate(nuPerifact);
      pkg_traza.trace('--RN 101. dtEndDatePeriod ' || dtEndDatePeriod, pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace('--RN 102. nuPendQuot ' || nuPendQuot, pkg_traza.cnuNivelTrzDef);
      if nvl(nuPendQuot, 0) = 0 then
        dtEndDate := to_date(to_char(ldc_boconsgenerales.fdtgetsysdate, 'DD/MM/YYYY') ||
                             '23:59:59',
                             'DD/MM/YYYY hh24:mi:ss');
      else
        dtEndDate := add_months(dtEndDatePeriod, nuPendQuot);
      end if;
    else
      nuCiclo := PKG_BCCONTRATO.FNUCICLOFACTURACION(pkg_bcproducto.fnucontrato(inuProductId));
      pkg_traza.trace('--RN 3. nuCiclo ' || nuCiclo, pkg_traza.cnuNivelTrzDef);
      rcPerifact := pkbcperifact.frcgetcurrbilperbycyc(nuCiclo);
      nuPerifact := rcPerifact.pefacodi;
      pkg_traza.trace('--RN 4. nuPerifact ' || nuPerifact, pkg_traza.cnuNivelTrzDef);
      if nuPerifact is null then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'No existe el periodo de facturacion para el ciclo ' ||
                                  nuCiclo
                                 );
      end if;
      /* Fecha fin del periodo de facturacion */
      dtEndDatePeriod := pktblperifact.fdtgetenddate(nuPerifact);
      pkg_traza.trace('--RN 5. dtEndDatePeriod ' || dtEndDatePeriod, pkg_traza.cnuNivelTrzDef);
      /*KCienfuegos ARA.7920 24-06-2015 Se agrega la validacion si la variable nuPendQuot es mayor que cero,
      ya que en caso que lo sea, a la fecha final del periodo de gracia le resta un mes, con lo cual esta
      queda menor a la fecha inicial del periodo de gracia.*/
        if nvl(nuPendQuot, 0) > 0 then
          dtEndDate := add_months(dtEndDatePeriod, nuPendQuot - 1);
        else
          dtEndDate := to_date(to_char(ldc_boconsgenerales.fdtgetsysdate, 'DD/MM/YYYY') ||
                               '23:59:59',
                               'DD/MM/YYYY hh24:mi:ss');
        end if;
      pkg_traza.trace('--RN 6. dtEndDate ' || dtEndDate, pkg_traza.cnuNivelTrzDef);
    END if;
    /*KCienfuegos ARA.7920 Se valida si la fecha final es menor a la del sistema, en tal caso se coloca la fecha del sistema
    para que no se superpongan la fecha inicial con la fecha final*/
      if (trunc(dtEndDate) < trunc(ldc_boconsgenerales.fdtgetsysdate)) then
        dtEndDate := to_date(to_char(ldc_boconsgenerales.fdtgetsysdate, 'DD/MM/YYYY') ||
                             '23:59:59',
                             'DD/MM/YYYY hh24:mi:ss');
      end if;
    pkg_traza.trace('--RN 10. nuFact ' || dtEndDate, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return dtEndDate;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fdtGetEndDatePeriod;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValiNoRenew
  Descripcion    : Realiza validaciones de la solicitud de no renovacion
  Autor          : kbaquero
  Fecha          : 26/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuSubscriptionId    Identificador del contrato
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========     =========         ====================
  22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  ******************************************************************/
  PROCEDURE ProcValiNoRenew(inuSubscriptionId IN suscripc.susccodi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValiNoRenew'; --Nombre del método en la traza
    nuCant      number;
    nuPackageId ld_parameter.numeric_value%type;
    nuStapack   ld_parameter.numeric_value%type;
    nuCero      ld_parameter.numeric_value%type;
    nuState ld_parameter.value_chain%type;
    nuValue ld_parameter.numeric_value%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /*Valida solicitud de no renovacion activa*/
    if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStatePolicy)) then
      nuState := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      /* Validar, que el suscriptor tenga una poliza activa*/
      ld_bcsecuremanagement.ProcValPolyActiSusc(inuSubscriptionId,
                                                nuState,
                                                nuValue);
      if (nuValue = 0) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'El suscritor no tiene una poliza activa');
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValiNoRenew;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValiNoRenewpoli
  Descripcion    : Realiza validaciones de la solicitud de no renovacion
                 en cuanto a la poliza
  Autor          : kbaquero
  Fecha          : 04/07/2013 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuSubscriptionId    Identificador del contrato
  inupoli              Identificador de la poliza
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========     =========         ====================
  21-03-2024    pacosta           OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
  ******************************************************************/

  PROCEDURE ProcValiNoRenewpoli(inupoli in ld_policy.policy_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValiNoRenewpoli'; --Nombre del método en la traza
    nuCant      number;
    nuPackageId ld_parameter.numeric_value%type;
    nuStapack   ld_parameter.numeric_value%type;
    nuCero      ld_parameter.numeric_value%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /*Valida solicitud de no renovacion activa*/
    if ((DALD_PARAMETER.fblexist(LD_BOConstans.cnuCodTypePackageNoRe))) then
      nuPackageId := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuCodTypePackageNoRe);
      nuStapack   := LD_BOConstans.cnuStapack;
      nuCero      := LD_BOConstans.cnuCero_Value;
      if ((nvl(nupackageid, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) and
         ((nvl(nuStapack, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) then
        ld_bcsecuremanagement.ProcSoliActpoli(nupackageid,
                                              nuStapack,
                                              inupoli,
                                              nuCant);
        if nuCant <> nuCero then
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'Este suscriptor Tiene Solicitudes por este tipo de paquete y esta poliza Activas');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValiNoRenewpoli;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValBornDate
  Descripcion    : Valida que el suscritor no pase del parametro de la edad maxima y minima para tomar el seguro.
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  idtDateBorn:    Fecha de nacimiento
  Historia de Modificaciones
  Fecha          Autor       Modificacion
  =========      =========   ====================
  21-03-2024     pacosta     OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                             Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
  ******************************************************************/

  PROCEDURE ProcValBornDate(idtDateBorn in ld_secure_sale.born_date%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValBornDate'; --Nombre del método en la traza
    nuDateInsured number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if ((DALD_PARAMETER.fblexist(LD_BOConstans.cdtCodDateMin)) and
       (DALD_PARAMETER.fblexist(LD_BOConstans.cdtCodDateMax))) then

      nuDateMin := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cdtCodDateMin);
      nuDateMax := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cdtCodDateMax);

      if ((nvl(nuDateMin, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) and
         (nvl(nuDateMax, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) then
        nuDateInsured := floor(months_between(to_date(sysdate), idtDateBorn) / 12);

        if ((nuDateInsured < nuDateMin) or (nuDateInsured > nuDateMax)) then
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'El asegurado no tiene la edad permitida para obtener un seguro');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValBornDate;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancel
  Descripcion    : Objeto de negocio con los procedimientos para realizar  la cancelacion de seguros
  Autor          : AAcuna
  Fecha          : 13/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuPackage    :  Numero de la solicitud
  Historia de Modificaciones
  Fecha       Autor               Modificacion
  =========   =========           ====================
  14/04/2014  JCarmona.3404       Se modica para que deje la solicitud para
                                  reenvio manual (MOPWP o MOPWD), cuado el
                                  producto tenga valores en reclamo.
  ******************************************************************/
  PROCEDURE ProcCancel(inuPackage in mo_packages.package_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||''; --Nombre del método en la traza
    nuPolicy        ld_policy.policy_id%type;
    rcSecure_Cancel dald_secure_cancella.styLD_secure_cancella;
    nuProductId     ld_policy.product_id%type;
    nuStateId       number;
    nuValClaim      cuencobr.cucovare%type;
    nuErrorCode     number;
    sbErrorMessage  VARCHAR2(4000);
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    dald_secure_cancella.getRecord(inuPackage, rcSecure_Cancel);
    nuPolicy := rcSecure_Cancel.policy_id;
    -- Se obtiene el producto de la poliza
    nuProductId := dald_policy.fnuGetPRODUCT_ID(nuPolicy, 0);
    -- Valida si el Servicio Suscrito tiene un valor en Reclamo
    pkServNumberInquiry.ValidateWithClaim(nuProductId,
                                          nuStateId,
                                          nuValClaim,
                                          nuErrorCode,
                                          sbErrorMessage);
    pkg_traza.Trace('Estado [0 sin reclamo, 1 con reclamo]: ' || nuStateId, pkg_traza.cnuNivelTrzDef);
    pkg_traza.Trace('Valor en Reclamo: ' || nuValClaim, pkg_traza.cnuNivelTrzDef);
    -- Si el producto tiene un valor en reclamo, se deja un error para reenvio manual (MOPWP o MOPWD)
    if nuStateId = ld_boconstans.cnuonenumber then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'No se atendera la Cancelacion de Seguros. El producto tiene un valor en reclamo');
    else
      ld_bosecuremanagement.ProcCancelPolicy(inuPackage, nuPolicy);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcCancel;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : TraslateDefer
  Descripcion    : Realiza el traslado de diferido a corriente
  Autor          : jcarrillo
  Fecha          : 06/09/2013
  Parametros               Descripcion
  ============         ===================
  inuDeferId          Diferido
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========   =================== ==========
  03/09/2013  jcarrillo.SAO214516 1 - Creacion
  ******************************************************************/
  PROCEDURE TraslateDefer(inuDeferId in diferido.difecodi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'TraslateDefer'; --Nombre del método en la traza
    /* Variables de Error */
    nuError   number;
    sbMessage varchar2(2000);
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Se realiza el traslado de Diferido a Corriente */
    pkg_error.setapplication(cc_boconstants.csbCUSTOMERCARE);
    CC_BODefToCurTransfer.GlobalInitialize;
    CC_BODefToCurTransfer.AddDeferToCollect(inuDeferId);
    CC_BODefToCurTransfer.TransferDebt('FINAN',
                                       nuError,
                                       sbMessage,
                                       FALSE,
                                       0,
                                       sysdate);
    if (nuError <> ge_boconstants.cnuSUCCESS) then
       gw_boerrors.checkerror(nuError, sbMessage);
    end if;
    CC_BODefToCurTransfer.GlobalInitialize;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END TraslateDefer;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : CreateNoteCR
  Descripcion    : Crea la nota credito
  Autor          : jcarrillo
  Fecha          : 06/09/2013
  Parametros               Descripcion
  ============         ===================
  inuProduct          Producto
  inuSusccodi         Contrato
  inuFactcodi         Factura
  inuCuencobr         Cuenta de Cobro
  inuConcept          Concepto
  inuCharCause        Causa del Cargo
  inuDocType          Tipo de Concepto
  isbNotaobse         Observacion
  isbNotadoso         Documento de Soporte
  inuValueNote        Valor de la Nota
  inuPackage          Solicitud
  Historia de Modificaciones
  Fecha         Autor                   Modificacion
  =========     ===================     ==========
  22/03/2024    pacosta                 OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                        Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  14-10-2014    Llozada RQ 1217         Se adiciona la validacion de la cuenta de cobro
                                        para que tome la ultima sin saldo
  05-09-2014    AEcheverry.4769         Se modifica par no actualizar el flag
                                        de actualizable en base de datos a FALSE
  19-12-2013    lfernandez.SAO227670    Se modifica para que no cree una sola nota
                                        en una cuenta del producto del seguro sino
                                        una nota por cada cuenta con saldo del
                                        producto
  19-12-2013    lfernandez.SAO228280    Si el valor de la nota a crear es mayor al
                                        saldo del producto del seguro se crea una
                                        nota por el saldo del seguro para el
                                        producto del seguro y el resto va para el
                                        producto de gas
  26/11/2013    jrobayo.SAO224855       1 - Se cambia la constante enviada para realizar la
                                        cancelacion de seguros con balance positivo.
  03/09/2013    jcarrillo.SAO214516     1 - Creacion
  ******************************************************************/
  PROCEDURE CreateNoteCR(inuProduct   in servsusc.sesunuse%type,
                         inuSusccodi  in suscripc.susccodi%type,
                         inuFactcodi  in factura.factcodi%type,
                         inuCuencobr  in cuencobr.cucocodi%type,
                         inuConcept   in concepto.conccodi%type,
                         inuCharCause in cargos.cargcaca%type,
                         inuDocType   in notas.notacons%type,
                         isbNotaobse  in notas.notaobse%type,
                         isbNotadoso  in notas.notadoso%type,
                         inuValueNote in cargos.cargvalo%type,
                         inuPackage   in mo_packages.package_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'CreateNoteCR'; --Nombre del método en la traza
    ------------------------------------------------------------------------
    --  Tipos
    ------------------------------------------------------------------------
    type tytbBillNote IS table of notas.notanume%type index BY varchar2(20);
    ------------------------------------------------------------------------
    --  Variables
    ------------------------------------------------------------------------
    tbBillNote  tytbBillNote;
    nuSecureBal cuencobr.cucosacu%type;
    nuNoteValue cuencobr.cucosacu%type;
    ------------------------------------------------------------------------
    --  Metodos encapsulados
    ------------------------------------------------------------------------
    PROCEDURE CreateSecureNote(inuNoteBalance in cuencobr.cucosacu%type) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.CreateSecureNote'; --Nombre del método en la traza
      rcNote      notas%rowtype;
      nuNoteBal   cuencobr.cucosacu%type;
      nuNoteValue cuencobr.cucosacu%type;
      --  Obtiene las cuentas con saldo del producto del seguro
      CURSOR cuProdAccounts IS
        SELECT *
          FROM cuencobr
         WHERE cuconuse = inuProduct
           AND cucosacu > 0
         ORDER BY cucocodi;
      --Tipos de datos usados en el registro de las notas
       rcNota       pkg_bcnotasrecord.tyrcNota;
       tbCargos     pkg_bcnotasrecord.tytbCargos;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      --  Inicializa el saldo para generacion de notas
      nuNoteBal := inuNoteBalance;
      --  Recorre las cuentas con saldo del producto
      for rcAccount in cuProdAccounts loop
        --  Si el valor por el que se genera la nota es mayor al saldo de la cuenta
        if (nuNoteBal > rcAccount.cucosacu) then
          --  El valor de la nota es el saldo de la cuenta
          nuNoteValue := rcAccount.cucosacu;
        else
          --  El valor de la nota es el saldo para la generacion de notas
          nuNoteValue := nuNoteBal;
        end if;
        --  Disminuye el saldo para generacion de notas
        nuNoteBal := nuNoteBal - nuNoteValue;
        FA_BOBillingNotes.SetUpdateDataBaseFlag;
        --  Si no se ha creado nota para la factura
        if (not tbBillNote.exists(to_char(rcAccount.cucofact))) then

        rcNota.sbPrograma :=csbFINANCING_PROGRAM;
        rcNota.nuProducto := inuProduct;
        rcNota.nuCuencobr := rcAccount.cucocodi;
        rcNota.nuNotacons := inuDocType;
        rcNota.dtNotafeco := ldc_boconsgenerales.fdtgetsysdate;
        rcNota.sbNotaobse := isbNotaobse;
        rcNota.sbNotaToken:= pkBillConst.csbTOKEN_NOTA_CREDITO;

        --Información detalle de la nota
        tbCargos(1).nuProducto       := inuProduct;
        tbCargos(1).nuContrato       := inuSusccodi;
        tbCargos(1).nuCuencobr       := rcAccount.cucocodi;
        tbCargos(1).nuConcepto       := inuConcept;
        tbCargos(1).NuCausaCargo     := inuCharCause;
        tbCargos(1).nuValor          := nuNoteValue;
        tbCargos(1).nuValorBase      := null;
   	    tbCargos(1).sbSigno          := pkBillConst.CREDITO;
        tbCargos(1).sbAjustaCuenta   := constants_per.CSBSI;
        tbCargos(1).sbCargdoso       := pkBillConst.csbTOKEN_NOTA_CREDITO || inuPackage;
       	tbCargos(1).sbBalancePostivo := constants_per.CSBSI;
      	tbCargos(1).boApruebaBal     := FALSE;

        --Crea la nota con su detalle.
        api_registranotaydetalle(ircNota           => rcNota,
                                 itbCargos         => tbCargos,
                                 onuNote           => rcNote.notanume,--nota creada
                                 onuCodigoError    => nuCodMenErro,
                                 osbMensajeError   => sbMensaError
                                );

          --  Adiciona la nota a la coleccion de notas
          tbBillNote(to_char(rcAccount.cucofact)) := rcNote.notanume;
        END if;

			 ajustaCuenta(rcAccount.cucocodi);
        --  Si se queda sin valor por distribuir entre las cuentas
        if (nuNoteBal = 0) then
          exit;
        end if;
      END loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END CreateSecureNote;
    ------------------------------------------------------------------------
    PROCEDURE CreateGasNote(inuNoteBalance in cuencobr.cucosacu%type) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.CreateGasNote'; --Nombre del método en la traza
      rcNote    notas%rowtype;
      rcAccount cuencobr%rowtype;
      nuGasProd pr_product.product_id%type;
      sbStates  ld_parameter.value_chain%type;
      --  Obtiene el producto de gas de la suscripcion
      CURSOR cuGasProduct IS
        SELECT product_id
          FROM pr_product
         WHERE subscription_id = inuSusccodi
           AND product_type_id = LD_BOConstans.cnuGASSERVICE
           AND rownum = 1;
      --  Obtiene la ultima cuenta de cobro del producto de gas
      CURSOR cuProdLastAcc(inuGasProd cuencobr.cuconuse%type) IS
        SELECT *
          FROM cuencobr
         WHERE cuconuse = inuGasProd
         ORDER BY cucocodi desc;
      --13-10-2014 Llozada [RQ 1217]: Se trae la última cuenta de cobro sin saldo del
      --producto de gas
      CURSOR cuUltimaCuentaSinSaldo(inuProductId diferido.difenuse%type) IS
        select *
          from cuencobr
         where cuconuse = inuProductId
           and (cucosacu is null OR cucosacu = 0)
         order by cucofeve desc;
       --Tipos para el registro de la nota
        rcNota       pkg_bcnotasrecord.tyrcNota;
        tbCargos     pkg_bcnotasrecord.tytbCargos;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      --  Obtiene los estados validos
      sbStates := pkg_bcld_parameter.fsbobtienevalorcadena('COD_STATE_PROD_SECURE');
      --  Obtiene el producto de gas de la suscripcion
      open cuGasProduct;
      fetch cuGasProduct
        INTO nuGasProd;
      close cuGasProduct;
      --14-10-2014 Llozada [RQ 1217]: Se trae la ultima cuenta de cobro sin saldo del producto
      --de Gas.
      open cuUltimaCuentaSinSaldo(nuGasProd);
      fetch cuUltimaCuentaSinSaldo
        INTO rcAccount;
      close cuUltimaCuentaSinSaldo;
      --14-10-2014 Llozada [RQ 1217]: Si no obtiene la ultima cuenta de cobro sin saldo,
      --entonces la ultima cuenta de cobro.
      if rcAccount.cucocodi IS null then
        --  Obtiene la ultima cuenta de cobro del producto
        open cuProdLastAcc(nuGasProd);
        fetch cuProdLastAcc
          INTO rcAccount;
        close cuProdLastAcc;
      END if;
      if rcAccount.cucocodi IS null then
        pkg_error.setErrorMessage(2741,
                                  'El producto de Gas debe tener como minimo una cuenta de cobro.');
      END if;
      FA_BOBillingNotes.SetUpdateDataBaseFlag;
      --  Si no se ha creado nota para la factura
      if (not tbBillNote.exists(to_char(rcAccount.cucofact))) then

          --Informacíon de la nota
          rcNota.sbPrograma :=csbFINANCING_PROGRAM;
          rcNota.nuProducto := nuGasProd;
          rcNota.nuCuencobr := rcAccount.cucocodi;
          rcNota.nuNotacons := inuDocType;
          rcNota.dtNotafeco := ldc_boconsgenerales.fdtgetsysdate;
          rcNota.sbNotaobse := isbNotaobse;
          rcNota.sbNotaToken:= pkBillConst.csbTOKEN_NOTA_CREDITO;

          --Información detalle de la nota
          tbCargos(1).nuProducto  := nuGasProd;
          tbCargos(1).nuContrato  := inuSusccodi;
          tbCargos(1).nuCuencobr  := rcAccount.cucocodi;
          tbCargos(1).nuConcepto  := inuConcept;
          tbCargos(1).NuCausaCargo:= inuCharCause;
          tbCargos(1).nuValor := inuNoteBalance;
          tbCargos(1).nuValorBase := null;
          tbCargos(1).sbSigno := pkBillConst.CREDITO;
          tbCargos(1).sbAjustaCuenta := constants_per.CSBSI;
          tbCargos(1).sbCargdoso := pkBillConst.csbTOKEN_NOTA_CREDITO || inuPackage;
          tbCargos(1).sbBalancePostivo := constants_per.CSBSI;
          tbCargos(1).boApruebaBal := FALSE;

          --Crea la nota con su detalle.
          api_registranotaydetalle(ircNota           => rcNota,
                                  itbCargos         => tbCargos,
                                  onuNote           => rcNote.notanume,--Nota creaca
                                  onuCodigoError    => nuCodMenErro,
                                  osbMensajeError   => sbMensaError
                                  );

          --  Adiciona la nota a la coleccion de notas
          tbBillNote(to_char(rcAccount.cucofact)) := rcNote.notanume;
      END if;

		ajustaCuenta(rcAccount.cucocodi);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
        pkg_error.SetError;
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END CreateGasNote;
    ------------------------------------------------------------------------
    FUNCTION fnuGetSaldoProducto(inuProducto diferido.difenuse%type)
      return number IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.fnuGetSaldoProducto'; --Nombre del método en la traza
      nuSaldoProducto number := 0;
      CURSOR CuGetValueProd IS
        SELECT sum(cucosacu)
          FROM cuencobr
         WHERE cuconuse = inuProducto
           AND cucosacu > 0;
    BEGIN
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      open CuGetValueProd;
      fetch CuGetValueProd
        INTO nuSaldoProducto;
      close CuGetValueProd;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return nvl(nuSaldoProducto, 0);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END fnuGetSaldoProducto;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    --  Obtiene el saldo del producto del seguro
    nuSecureBal := fnuGetSaldoProducto(inuProduct);
    --  Si el saldo del producto del seguro es mayor o igual al valor de la
    --  nota solo se genera nota para el producto del seguro
    --  (Este caso no se deberia presentar)
    if (nuSecureBal = inuValueNote) then
      --  Crea la nota para el producto del seguro
      CreateSecureNote(inuValueNote);
      --  Si el producto del seguro no tiene saldo
    else
      --  El valor de la nota para el seguro es por el saldo del seguro
      nuNoteValue := nuSecureBal;
      --  Crea la nota para el producto del seguro
      CreateSecureNote(nuNoteValue);
      --  El valor de la nota para el gas es por el valor enviado menos el
      --  saldo del seguro
      nuNoteValue := inuValueNote - nuSecureBal;
      --  Crea la nota para el producto de gas
      CreateGasNote(nuNoteValue);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END CreateNoteCR;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValueCancelByAge
  Descripcion    : Obtiene el Valor del Cupon Cuando la Cancelacion es por edad
  Autor          : jcarrillo
  Fecha          : 06/09/2013
  Parametros               Descripcion
  ============         ===================
  ircPolicy           Registro de la Poliza
  ircSecCancell       Registro de ld_secure_cancella
  onuValue            Valor a devolver
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========   =================== ==========
  03/09/2013  jcarrillo.SAO214516 1 - Creacion
  ******************************************************************/
  PROCEDURE GetValueCancelByAge(ircPolicy     in dald_policy.styLD_policy,
                                ircSecCancell in dald_secure_cancella.styLD_secure_cancella,
                                onuValue      out number,
                                onuFees       out number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetValueCancelByAge'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Se obtiene el valor total de todas las polizas del Cliente (Activas y Renovadas) */
    ld_bcsecuremanagement.GetValuesPolicyByProd(ircPolicy.product_id,
                                                onuValue,
                                                onuFees);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetValueCancelByAge;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValueCancelByContr
  Descripcion    : Obtiene el Valor del Cupon Cuando la Cancelacion es por solicitud
                   de la aseguradora u otros
  Autor          : jcarrillo
  Fecha          : 06/09/2013
  Parametros               Descripcion
  ============         ===================
  ircPolicy           Registro de la Poliza
  ircSecCancell       Registro de ld_secure_cancella
  onuValue            Valor a devolver
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========   =================== ==========
  03/09/2013  jcarrillo.SAO214516 1 - Creacion
  ******************************************************************/
  PROCEDURE GetValueCancelByContr(ircPolicy     in dald_policy.styLD_policy,
                                  ircSecCancell in dald_secure_cancella.styLD_secure_cancella,
                                  onuValue      out number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetValueCancelByContr'; --Nombre del método en la traza
    /* Valor de la nota */
    nuValue number;
    /* Tipo de Liquidacion */
    nuTypeLiq ld_cancel_causal.liquidation_type_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Se valida el Tipo de Liquidacion */
    nuTypeLiq := dald_cancel_causal.fnuGetLiquidation_Type_Id(ircSecCancell.cancel_causal_id);
    /* Si el tipo de liquidacion es pago total */
    if (nuTypeLiq = nuTypeLiqDt) then
      /* Valor total de la poliza */
      nuValue := ircPolicy.value_policy;
    end if;
    /* Si el tipo de liquidacion es pago parcial */
    if (nuTypeLiq = nuTypeLiqDp) then
      /* Valor total de la poliza */
      nuValue := pkBCCuencobr.fnuGetProductTotalValue(ircPolicy.product_id);
    end if;
    onuValue := nuValue;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetValueCancelByContr;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValueCancelBySubsc
  Descripcion    : Obtiene el Valor del Cupon Cuando la Cancelacion es por solicitud
                   del Cliente
  Autor          : jcarrillo
  Fecha          : 06/09/2013
  Parametros               Descripcion
  ============         ===================
  ircPolicy           Registro de la Poliza
  ircSecCancell       Registro de ld_secure_cancella
  onuValue            Valor a devolver
  Historia de Modificaciones
  Fecha         Autor               Modificacion
  =========   ===================   ==========
  21-03-2024  pacosta               OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                    Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                    Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  09/09/2013  jcarrillo.SAO214516   1 - Se modifica para que se devuelva el valor
                                    total si el tiempo que ha pasado es menor o igual
                                    al numero de meses configurados.
  03/09/2013  jcarrillo.SAO214516   1 - Creacion
  ******************************************************************/

  PROCEDURE GetValueCancelBySubsc(ircPolicy     in dald_policy.styLD_policy,
                                  ircSecCancell in dald_secure_cancella.styLD_secure_cancella,
                                  inuSaldoDif   in diferido.difesape%type,
                                  onuValue      out number) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetValueCancelBySubsc'; --Nombre del método en la traza
    /* Parametro de el numero de meses para cancelar */
    nuMoCancel ld_parameter.numeric_value%type;
    /* Parametro de las lineas de doble cupon */
    sbNumDobCup ld_parameter.value_chain%type;
    /* Valor de la nota */
    nuValue number;
    PROCEDURE GetParatemers IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.GetParatemers'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      if ((DALD_PARAMETER.fblexist(LD_BOConstans.CnuNumMoCancel)) AND
         (DALD_PARAMETER.fblexist(LD_BOConstans.CnuNumDobCup))) then
        pkg_traza.Trace('Existen los parametros', pkg_traza.cnuNivelTrzDef);
        nuMoCancel  := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.CnuNumMoCancel);
        sbNumDobCup := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CnuNumDobCup);
        /* Se valida que los parametros sean diferente de cero*/
        if (nuMoCancel IS null OR sbNumDobCup IS null) then
           gw_boerrors.checkerror(pkg_Error.CNUGENERIC_MESSAGE,
                                     'Los valores de los parametros para la cancelacion de seguros no contiene datos.');
        end if;
      else
        pkg_traza.Trace('No existen los parametros', pkg_traza.cnuNivelTrzDef);
         gw_boerrors.checkerror(pkg_Error.CNUGENERIC_MESSAGE,
                                   'Los parametros para la cancelacion de seguros no existen.');
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END GetParatemers;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    GetParatemers;
    if (instr(csbPIPE || sbNumDobCup || csbPIPE,
              csbPIPE || ircPolicy.product_line_id || csbPIPE) > 0) then
      /* Se valida el tiempo estipulado para la cancelacion y determinar el valor a devolver */
      if (MONTHS_BETWEEN(ldc_boconsgenerales.fdtgetsysdate, ircPolicy.dt_in_policy) <=
         nuMoCancel) then
        /* Valor total de la poliza */
        nuValue := ircPolicy.value_policy;
      else
        -- Valor igual al saldo pendiente del diferido
        nuValue := inuSaldoDif;
      end if;
    else
      Ld_BoSecureManagement.GetValueCancelByContr(ircPolicy,
                                                  ircSecCancell,
                                                  nuValue);
    end if;
    onuValue := nuValue;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetValueCancelBySubsc;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancelPolicy
  Descripcion    : Objeto de negocio con los procedimientos para realizar  la cancelacion de seguros
  Autor          : AAcuna
  Fecha          : 13/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuPackage:    Numero del paquete
  inuPolicy:     Numero de la poliza
  Historia de Modificaciones
  Fecha            Autor                Modificacion
  ==========  ===================       =======================
  21-03-2024    pacosta                 OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                        Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                        Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                        Cambio DAOR_ORDER.FRCGETRECORD por PKG_BCORDENES.FRCGETRECORD
  30-03-2021    Olsoftware              ca 718 Entrega 1 se excluye los alivios cuando la poliza no ha sido migrada y se corrige la causal de a
                                        anulacion cuando la poliza a sido migrada a Alfa a 1- Anulacion.
                                        si se escoge la causal 208 - "CANCELACION POR JOB/ FACTURAS VENCIDAS¿,
                                        el sistema solo acredite la deuda diferida pendiente por facturar del seguro a anular,
                                        dejando viva la deuda en corriente y la deuda que tenga el producto en diferidos de Alivios COVID.
  19-02-2021    Olsoftware              ca 651 se agrega logica para cambiar fecha de retiro a las polizas que tengan saldo en corriente
  12-02-2020    Horbath                 CA 277 Se agrego la validacion para el cambio de estado de la nueva causal de cancelacion de supencion de cobro
  21-12-2016    FCastro                 CA 200-336 Se modifica el metodo <<ProcCancelPolicy>> para que si la causal
                                        de anulacion es por edad cree la nota CR por el valor del saldo
                                        pendiente de la poliza (diferido y corriente) y no genere saldo
                                        a favor al usuario por las cuotas canceladas
  22-10-2016    KBaquero                [CA 200-746] Se le actualiza la fecha de retiro, la causal de cancelacion y las observaciones
                                        a las pólizas renovadas con saldo pendiente
                                        y que se está anulando desde una póliza activa.
  01-04-2015    Llozada                 [NC 4038] Se realiza el calculo de las cuotas a devolver tomando el valor de cuotas pagadas
                                        menos las cuotas pagadas por el usuario.
  19-03-2015    Spacheco                nc 4416 Se actualiza para redondear valores de liquidacion de las ordenes
                                        de comision de a contraista y pago a contratista de seguro
  21-01-2015    Llozada                 NC 4038 Se realiza el calculo de las cuotas a devolver tomando el valor de cuotas pagadas
                                        menos las cuotas pagadas por el usuario.
  21-01-2015    Llozada                 NC 4038 Se modifica la logica para que se realice el calculo de las
                                        cuotas a devolver por cada poliza asociada al producto.
  05-10-2014    Llozada                 RQ 1217 Se valida que la causal sea de tipo de liquidacion parcial
                                        para que le cree notas a todos los diferidos.
  30-09-2014    llarrarte.              RQ1834 El estado de la poliza debe ser 2 si la solicitud
                                        se registro por no renovacion
  12-02-2014    AEcheverry              SAO232542 Se modifica la atencion de la solicitud para
                                        que esta se realice correctamente.
  11-12-2013    hjgomez.                SAO227078 Se pone el estado de la poliza en 4 si es por JOB
  01/11/2013    jrobayo.                SAO222260 Se elimina el prefijo para la descripcion de
                                        documento de soporte al generar la nota credito.
  31/10/2013    JCarmona.               SAO221798 Se modifica para que actualice el estado de la
                                        poliza a 3 cuando la cancelacion se realice
                                        por archivo plano.
  25/10/2013    jrobayo.                SAO221296 Se modifica para guardar el costo en la orden
                                        de trabajo creada.
  18/10/2013    jrobayo                 Se modifica para actualizar el estado de las
                                        polizas canceladas por reporte de siniestro.
  03/09/2013    jcarrillo.              SAO214516 Se modifica para genera correctamente
                                        los valores de las notas credito.
  03-09-2013    mmeusburgger.           SAO214423  Se modificael campo  <<Value_Chain>>
                                        Asociado al parametro <<NUM_DOB_CUP>>
  27-08-2013    jcarrillo.              SAO214742 Se modifica por borrado de la constante
                                        <LD_BOConstans.CnuStateOrder>
  14/08/2013    hvera.                  SAO213138 Se adiciona traza para seguimiento
  13/09/2012    AAcuna.                 SAO147879 Creacion
  ******************************************************************/
  PROCEDURE ProcCancelPolicy(inuPackage in mo_packages.package_id%type,
                             inuPolicy  ld_policy.policy_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcCancelPolicy'; --Nombre del método en la traza
    /* Parametros */
    nuOrderPay    ld_parameter.numeric_value%type;
    nuOrderCharge ld_parameter.numeric_value%type;
    nuCauseCarg   ld_parameter.numeric_value%type;
    nuDocTypeId   ld_parameter.numeric_value%type;
    sbStateCanc   ld_parameter.value_chain%type;
    sbState       ld_parameter.value_chain%type;
    -- Causal de Cancelacion por Edad
    nuCausCancelAge ld_parameter.numeric_value%type;
    sbCausCancelSub ld_parameter.value_chain%type;
    /* Informacion de la solicitud y la poliza */
    rcSecCan          dald_secure_cancella.styLD_secure_cancella;
    rcPolicy          dald_policy.styLD_policy;
    rcMoPackage       damo_packages.styMO_packages;
    nuMotive          mo_motive.motive_id%type;
    nuAddress         mo_packages.address_id%type;
    nuStateCancBySol  ld_policy.state_policy%type;
    nuStateCancByFile ld_policy.state_policy%type;
    /* Informacion de la cuenta de cobro */
    nuCuencobr cuencobr.cucocodi%type;
    nuFactura  factura.factcodi%type;
    /* Informacion de la linea de producto */
    nuConcept concepto.conccodi%type;
    /* Valor para la Nota */
    nuValueNote number;
    nuFees      number;
    -- Variables de Error
    nuError   number;
    sbMessage varchar2(2000);
    /* Datos de La Orden */
    nuOrderId         or_order.order_id%type;
    rcOrder           daor_order.styor_order;
    nuOrderActivityId or_order_activity.order_activity_id%type;
    nuUnitOper        number;
    frfOperating      CONSTANTS_PER.TYREFCURSOR;
    recOrope          or_operating_unit%ROWTYPE;
    /*Variable del valor de la orden*/
    nuValue ld_validity_policy_type.policy_value%type;
    --05-10-2014 Llozada [RQ 1217]: Tipo de liquidacion Parcial
    nuTipoLiquidacion number(4) := pkg_bcld_parameter.fnuobtienevalornumerico('FNB_TIPO_LIQUIDACION');
    --- 23/10/2016 Kbaquero [CA 200-746]: estado pólizas renovadas
    nuStateRenew number(4) := pkg_bcld_parameter.fnuobtienevalornumerico('COD_PROG_RENEW');
    sbcommetpoli ld_policy.comments%type;
    --13-10-2014 Llozada[RQ 1217]: Retorna tipo servicio 7014 gas
    nuTipoServicioGas servsusc.sesuserv%type := pkg_bcld_parameter.fnuobtienevalornumerico('COD_SERV_GAS');
	nuParCausalCan number; -- caso:277
	nuParStateCanc number; -- caso:277
    --05-10-2014 Llozada [RQ 1217]: Diferidos del producto
 --Inicio ca 718 Entrega 1 valida que el diferido que no sea un alivio.
    CURSOR cuDiferidos(nuProductId diferido.difenuse%type) IS
      Select d.difecodi, d.difesape
        from diferido d
       where d.difenuse = nuProductId
         and d.difesape > 0;
 --Fin ca 718 Entrega 1 valida que el diferido que no sea un alivio.
    --13-10-2014 Llozada [RQ 1217]: Retorna el producto de gas
    CURSOR cuProdGas(inuContrato servsusc.sesususc%type) IS
      select sesunuse
        from servsusc
       where sesususc = inuContrato
         and sesuserv = nuTipoServicioGas;
    --21-01-2015 Llozada [NC 4038]: Se traen todas las polizas asociadas
    CURSOR cuPolizasAsociadas(nuPolicy_number ld_policy.policy_number%type) IS
      Select policy_id, deferred_policy_id, prem_policy, share_policy
        from ld_policy
       where policy_number = nuPolicy_number;
    --21-01-2015 Llozada [NC 4038]: Cuentas de cobro asociadas al diferido que NO han sido pagadas
    Cursor cuCuentasCobro(sbDife       cargos.cargdoso%type,
                          nuValorCuota ld_policy.prem_policy%type) IS
      select distinct cucocodi, cucosacu, CEIL(cucosacu / nuValorCuota)
        from cargos, cuencobr
       where cargdoso = sbDife
         and cargcuco = cucocodi
         and cucosacu > 0;
    --- 23/10/2016 Kbaquero [CA 200-746]: consulta de póliza renovada con saldo pendiente
    cursor cupolicyrenovactdtret(inuproduct   ld_policy.product_id%type,
                                 inususcripc  ld_policy.suscription_id%type,
                                 inucauslreno ld_policy.state_policy%type) is
      select *
        from ld_policy d
       where d.state_policy in (inucauslreno)
         and d.dtret_policy is null
         and d.product_id = inuproduct --60032781
         and d.suscription_id = inususcripc
         and (d.deferred_policy_id in
             (select i.difecodi
                from diferido i
               where i.difesusc = d.suscription_id
                 and i.difecodi = d.deferred_policy_id
                 and i.difesape > 0)
				 --ca 651 -- se agrega condicion de poliza con saldo en corriente
				 or exists ( select 1
							  from cargos, cuencobr
							  where cargnuse = d.PRODUCT_ID
							  and cargdoso = 'DF-'||d.DEFERRED_POLICY_ID
							  and cargcuco = cucocodi
							  and nvl(cucosacu,0) > 0));

    --22-01-2015 Llozada [NC 4038]: Record para la tabla PL  tbPolizasCuota
    type tyrcPolizasCuota is record(
      PolicyId    ld_policy.policy_id%type,
      Diferido    ld_policy.deferred_policy_id%type,
      Cuotas      ld_policy.fees_to_return%type,
      SaldoCuenta cuencobr.cucosacu%type,
      CuentaCobro cuencobr.cucocodi%type);
    type tytbPolizasCuota is table of tyrcPolizasCuota index by varchar2(100);
    tbPolizasCuota  tytbPolizasCuota;
    nuNumeroCuota   ld_policy.fees_to_return%type;
    nuCuentaCobro   cuencobr.cucocodi%type;
    nuSaldoCuenta   cuencobr.cucosacu%type;
    sbHash          varchar2(100);
    sbCargdoso      varchar2(100);
    nuSaldoAnt      cuencobr.cucosacu%type := 0;
   /* VARIABLES Y CURSORES CASO 539    */
   nuSaldoFavor		number;
   sw				boolean := false;
   nuValorAcred NUMBER;

   -- se obtiene el valor de la deuda diferida apartir del producto
   --Inicio ca 718 Entrega 1 valida que el diferido sea el de la poliza y que no sea un alivio.
   Cursor CugetDifeProd (nuProductId	 pr_product.product_id%type,
                         nuPolicy_number ld_policy.policy_number%type) is
		select  /* index(diferido ix_dife_nuse)*/
               df.difecodi
		from open.diferido df,open.ld_policy p
		where df.difenuse = nuProductId
          and p.policy_id = nuPolicy_number -->parametro de entrada al ProcCancelPolicy
          and df.difecodi = p.deferred_policy_id
         AND  df.difetire = 'D';

	Cursor CuGetProductAliCovid (nuProductId	 pr_product.product_id%type) is
		SELECT /*+ index (diferido IX_DIFE_NUSE) */
		   nvl(max(difenucu - difecupa), 0)
			FROM diferido
		   WHERE difenuse = nuProductId
		     AND difenucu - difecupa <> 0;
     nuAlivio number:=0;
    --Fin ca 718 Entrega 1 valida que el diferido sea el de la poliza y que no sea un alivio.
   -- se obtiene el valor de la deuda corriente apartir del producto
   Cursor CugetCorrProd (nuProductId	pr_product.product_id%type) is
		SELECT sum(cu.cucovato)
		FROM cuencobr cu
		WHERE cu.cuconuse = nuProductId
        and   cu.cucosacu > 0
        order by cu.cucocodi;
	-- se obtiene el saldo a favor del producto
	Cursor CugetSaldoFavorProd (nuProductId	pr_product.product_id%type) is
		SELECT sesusafa
		FROM servsusc
		WHERE sesunuse = nuProductId;
	-- se valida en la tabla de migracion
	Cursor CuvalPoliMigra (nuPolicy		ld_policy.policy_id%type) is
		select count(*)
		from LDC_MIGRAPOLIZA
		where poliza_renov = nuPolicy;
   	/* FIN  VARIABLES Y CURSORES CASO 539  */

    PROCEDURE GetParatemersCancel IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.GetParatemersCancel'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      if ((DALD_PARAMETER.fblexist('COD_ACT_PAYMENT_CANC')) AND
         (DALD_PARAMETER.fblexist('COD_ACT_CHARGE_CANC')) AND
         (DALD_PARAMETER.fblexist(LD_BOConstans.cnuCauseCarg)) AND
         (DALD_PARAMETER.fblexist(LD_BOConstans.cnuDocTypeId)) AND
         (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStateCanc)) AND
         (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStatePolicy)) AND
         (DALD_PARAMETER.fblexist(LD_BOConstans.Cnucancau)) AND
         (DALD_PARAMETER.fblexist('CAUS_CANC_BY_SUBS'))) then
        pkg_traza.Trace('Existen los parametros', pkg_traza.cnuNivelTrzDef);
        nuOrderPay      := to_number(pkg_bcld_parameter.fsbobtienevalorcadena('COD_ACT_PAYMENT_CANC'));
        nuOrderCharge   := to_number(pkg_bcld_parameter.fsbobtienevalorcadena('COD_ACT_CHARGE_CANC'));
        nuCauseCarg     := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuCauseCarg);
        nuDocTypeId     := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuDocTypeId);
        sbStateCanc     := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStateCanc);
        sbState         := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
        nuCausCancelAge := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.Cnucancau);
        sbCausCancelSub := pkg_bcld_parameter.fsbobtienevalorcadena('CAUS_CANC_BY_SUBS');
        /* Se valida que los parametros sean diferente de cero*/
        if ((nvl(nuOrderPay, LD_BOConstans.cnuCero) = LD_BOConstans.cnuCero) OR
           (nvl(nuOrderCharge, LD_BOConstans.cnuCero) =
           LD_BOConstans.cnuCero) OR
           (nvl(nuCauseCarg, LD_BOConstans.cnuCero) =
           LD_BOConstans.cnuCero) OR
           (nvl(nuDocTypeId, LD_BOConstans.cnuCero) =
           LD_BOConstans.cnuCero) OR
           (nvl(nuCausCancelAge, LD_BOConstans.cnuCero) =
           LD_BOConstans.cnuCero) OR sbState is null OR
           sbStateCanc is null OR sbCausCancelSub IS null) then
           gw_boerrors.checkerror(pkg_Error.CNUGENERIC_MESSAGE,
                                     'Los valores de los parametros para la cancelacion de seguros no contiene datos.');
        end if;
      else
        pkg_traza.Trace('No existen los parametros', pkg_traza.cnuNivelTrzDef);
         gw_boerrors.checkerror(pkg_Error.CNUGENERIC_MESSAGE,
                                   'Los parametros para la cancelacion de seguros no existen.');
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.SetError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
    END GetParatemersCancel;
    -- saldo corriente
    FUNCTION fnuGetCuotaValue(inuProductId diferido.difenuse%type,
                              inuDifecodi  in diferido.difecodi%type)
      return number IS
      sbToken          varchar2(30);
      nuSaldoCorriente number := 0;
      CURSOR CuGetValue IS
        SELECT sum(cucosacu)
          FROM cargos, cuencobr
         WHERE cargnuse = inuProductId
           AND cargdoso = sbToken
           AND cargos.cargcuco = cuencobr.cucocodi
           AND cucosacu > 0;
    BEGIN
      sbToken := 'DF-' || inuDifecodi;
      open CuGetValue;
      fetch CuGetValue
        INTO nuSaldoCorriente;
      close CuGetValue;
      return nvl(nuSaldoCorriente, 0);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.SetError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END fnuGetCuotaValue;
    FUNCTION fnuGetSaldoProducto(inuProducto diferido.difenuse%type)
      return number IS
      nuSaldoProducto number := 0;
      CURSOR CuGetValueProd IS
        SELECT sum(cucosacu)
          FROM cuencobr
         WHERE cuconuse = inuProducto
           AND cucosacu > 0;
    BEGIN
      open CuGetValueProd;
      fetch CuGetValueProd
        INTO nuSaldoProducto;
      close CuGetValueProd;
      return nvl(nuSaldoProducto, 0);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        raise PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.SetError;
        raise PKG_ERROR.CONTROLLED_ERROR;
    END fnuGetSaldoProducto;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuPackage ' || inuPackage || ' inuPolicy ' ||
                   inuPolicy,pkg_traza.cnuNivelTrzDef);

    pkg_error.setapplication(cc_boconstants.csbCUSTOMERCARE);
    /* Se obtienen los parametros*/
    GetParatemersCancel;
    nuFees := null;
    dald_secure_cancella.getRecord(inuPackage, rcSecCan);
    dald_policy.getRecord(inuPolicy, rcPolicy);
    nuCuencobr := ld_bcsecuremanagement.FnuCuenCobr(rcPolicy.deferred_policy_id,
                                                    rcPolicy.product_id);
    nuFactura  := pktblcuencobr.fnugetcucofact(nuCuencobr);
    nuConcept  := dald_product_line.fnuGetConcept_Id(rcPolicy.PRODUCT_LINE_ID,
                                                     0);
    /*23/10/2016  Kbaquero [CA 200-746] se actualiza la fecha de retiro para las pólizas renovadas que
    tengan saldo pendiente*/
    /* Actualiza la fecha y causa de cancelacion de la poliza */
    nuStateCancBySol := to_number(substr(sbStateCanc,
                                         1,
                                         instr(sbStateCanc, '|', 1, 1) - 1));
    /* Se obtiene el estado de cancelacion por archivo plano */
    nuStateCancByFile := to_number(substr(sbStateCanc,
                                          6,
                                          instr(sbStateCanc, '|', 1, 1) - 1));
    pkg_traza.trace('nuStateCancBySol: ' || nuStateCancBySol, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('nuStateCancByFile: ' || nuStateCancByFile, pkg_traza.cnuNivelTrzDef);
    rcMopackage := pkg_bcsolicitudes.frcgetrecord(inupackage);
    FOR rgpolire in cupolicyrenovactdtret(rcPolicy.product_id, -- inuProduct
                                          rcPolicy.suscription_id,
                                          nuStateRenew) LOOP

      pkg_traza.trace('nuStateCancBySol: ' || nuStateCancBySol, pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace('nuStateCancByFile: ' || nuStateCancByFile, pkg_traza.cnuNivelTrzDef);

	  nuValorAcred := 0;

      --Si la solicitud fue registrada por JOB se pone el estado 4
      if (rcMopackage.comment_ = 'CANCELACION DE SEGUROS POR NO PAGO JOB') then
        nuStateCancByFile := 4;
      end if;
      pkg_traza.trace('rcMopackage.tag_name: ' || rcMopackage.tag_name, pkg_traza.cnuNivelTrzDef);
      /* Si la cancelacion es recibida por la solicitud de cancelacion se le actualiza
      el estado configurado en el parametro sbStateCanc, en este caso 2 que es el estado
      para la cancelacion por solicitud*/
      if (rcMopackage.tag_name = 'P_TRAMITE_SALE_100231') then
        dald_policy.updState_Policy(rgpolire.policy_id, nuStateCancBySol);
      end if;
      /* Si la cancelacion es recibida por Archivo Plano se le actualiza
      el estado configurado en el parametro sbStateCanc, en este caso 3 que es el estado
      para la cancelacion por Archivo Plano */
      if (rcMopackage.tag_name = 'P_CANCELACION_DE_SEGUROS_XML_100266') then
        /*Si se utilizo el tramite por XML para registrar la cancelacion por no
        renovacion se actualiza a 2 que es estado de cancelacion por solicitud*/
        if (rcMopackage.comment_ =
           'CANCELADA POR SOLICITUD DE NO RENOVACION') then
          dald_policy.updState_Policy(rgpolire.policy_id, nuStateCancBySol);
        elsif (rcMopackage.comment_ = 'CANCELACION POR LIMITE DE EDAD') THEN
          dald_policy.updState_Policy(rgpolire.policy_id, 6);
        ELSE
          dald_policy.updState_Policy(rgpolire.policy_id,
                                      nuStateCancByFile);
        END if;
      end if;
      /*Se actualiza la fecha de retiro de la poliza*/
      dald_policy.updDtret_Policy(rgpolire.policy_id, sysdate);
      /*Se actualiza la causal de cancelacion de la poliza*/
      dald_policy.updCancel_Causal_Id(rgpolire.policy_id,
                                      rcSecCan.cancel_causal_id);
      sbcommetpoli := dald_policy.fsbGetCOMMENTS(rgpolire.policy_id);
      /*Se actualiza el comentario de la poliza*/
      dald_policy.updComments(rgpolire.policy_id,
                              sbcommetpoli || ' // ' ||
                              'Poliza cancelada por causal [' ||
                              rcSecCan.cancel_causal_id || '].');
	--INICIO CA 651
	--se actualiza valor acreditado
	nuValorAcred := FNUGETSALPENPOL(rgpolire.deferred_policy_id,rgpolire.product_id );
	dald_policy.updvalueacr_policy(rgpolire.policy_id, nuValorAcred);
	--FIN CA 651
    END LOOP;

	nuValorAcred := 0;
   --INICIO CA 651

    nuValorAcred := FNUGETSALPENPOL(rcPolicy.deferred_policy_id,rcPolicy.product_id );
    dald_policy.updvalueacr_policy(rcPolicy.policy_id, nuValorAcred);


	FOR rc IN cuDiferidos(rcPolicy.product_id) LOOP
		TraslateDefer(rc.difecodi);
	END LOOP;


    /* Se valida si la causal es edad */
    if (rcSecCan.cancel_causal_id = nuCausCancelAge) then
      -- Causal es por Edad
      /*Caso 200-336. El valor de la nota cuando la causal es por edad se hallara de la misma manera
      que las demas causales, es decir, no se tiene en cuenta las cuotas ya canceladas sino
      el saldo pendiente de diferidos y corriente*/
      nuValueNote := fnuGetSaldoProducto(rcPolicy.product_id);
      /*Caso 200-336. Se coloca fboAge = false para que la nota se haga de la misma manera
      que las demas causales*/
      ld_bosecuremanagement.fboAge := false;
    else
      --Se valida que la causal sea de tipo Parcial
      IF dald_cancel_causal.fnuGetLiquidation_Type_Id(rcSecCan.cancel_causal_id) =
         nuTipoLiquidacion THEN
        nuValueNote := fnuGetSaldoProducto(rcPolicy.product_id);
      ELSE
        pkg_error.setErrorMessage(2741,
                                  'No se atendera la cancelacion debido a que la causal ' ||
                                  rcSecCan.cancel_causal_id ||
                                  ' es de tipo TOTAL, Se debe configurar esta causal como parcial.');
      END if;
    END if;
		CreateNoteCR(rcPolicy.product_id, -- inuProduct
			           rcPolicy.suscription_id, -- inuSusccodi
			           nuFactura, -- inuFactcodi
			           nuCuencobr, -- inuCuencobr
			           nuConcept, -- inuConcept
			           nuCauseCarg, -- inuCharCause
			           nuDocTypeId, -- inuDocType
			           'Se creo la nota asociada a la poliza [' ||
			           rcPolicy.policy_id || '].', -- isbNotaobse
			           rcPolicy.policy_id, -- isbNotadoso
			           nuValueNote, -- inuValueNote
			           inuPackage -- inuPackage
			           );

    nuMotive  := mo_bopackages.fnuGetInitialMotive(inupackage);
    nuAddress := mo_bopackages.fnuFindAddressId(inupackage);
    pkg_traza.Trace('rcPolicy.policy_type_id ' || rcPolicy.policy_type_id,pkg_traza.cnuNivelTrzDef);
    frfOperating := ld_bcsecuremanagement.frfGetOperating(rcPolicy.policy_type_id);
    FETCH frfOperating
      INTO recOrope;
    CLOSE frfOperating;
    nuUnitOper := recOrope.operating_unit_id;
    pkg_traza.Trace('Unidad Operativa ' || nuUnitOper, pkg_traza.cnuNivelTrzDef);


		/* Retirar el producto  */
		MO_BORetire.retireProdAttention(nuMotive);

    --Si la solicitud fue registrada por JOB se pone el estado 4
    if (rcMopackage.comment_ = 'CANCELACION DE SEGUROS POR NO PAGO JOB') then
      nuStateCancByFile := 4;
    end if;
    pkg_traza.trace('rcMopackage.tag_name: ' || rcMopackage.tag_name, pkg_traza.cnuNivelTrzDef);
    /* Si la cancelacion es recibida por la solicitud de cancelacion se le actualiza
    el estado configurado en el parametro sbStateCanc, en este caso 2 que es el estado
    para la cancelacion por solicitud*/
    if (rcMopackage.tag_name = 'P_TRAMITE_SALE_100231') then
      dald_policy.updState_Policy(inuPolicy, nuStateCancBySol);
    end if;
    /* Si la cancelacion es recibida por Archivo Plano se le actualiza
    el estado configurado en el parametro sbStateCanc, en este caso 3 que es el estado
    para la cancelacion por Archivo Plano */
    if (rcMopackage.tag_name = 'P_CANCELACION_DE_SEGUROS_XML_100266') then
      /*Si se utilizo el tramite por XML para registrar la cancelacion por no
      renovacion se actualiza a 2 que es estado de cancelacion por solicitud*/
      if (rcMopackage.comment_ = 'CANCELADA POR SOLICITUD DE NO RENOVACION') then
        dald_policy.updState_Policy(inuPolicy, nuStateCancBySol);
      elsif (rcMopackage.comment_ = 'CANCELACION POR LIMITE DE EDAD') THEN
        dald_policy.updState_Policy(inuPolicy, 6);
      ELSE
        dald_policy.updState_Policy(inuPolicy, nuStateCancByFile);
      END if;
    end if;
  --inicio caso:277
	nuParCausalCan:= pkg_bcld_parameter.fnuobtienevalornumerico('CAUSAL_POLIZA_SUSPEN_COBRO');--caso: 277
	nuParStateCanc:= pkg_bcld_parameter.fnuobtienevalornumerico('ESTADO_POLIZA_SUSPEN_COBRO');--caso: 277
	if (rcMopackage.tag_name = 'P_TRAMITE_SALE_100231'
	    and rcSecCan.cancel_causal_id = nuParCausalCan	) then
	  dald_policy.updState_Policy(inuPolicy, nuParStateCanc );
	end if;
	--fin caso:277
    --Se actualiza la fecha de retiro de la poliza
    dald_policy.updDtret_Policy(inuPolicy, sysdate);
    /*Se actualiza la causal de cancelacion de la poliza*/
    dald_policy.updCancel_Causal_Id(inuPolicy, rcSecCan.cancel_causal_id);
    /*Se actualiza el comentario de la poliza*/
    dald_policy.updComments(inuPolicy,
                            'Poliza cancelada por causal [' ||
                            rcSecCan.cancel_causal_id || '].');
    /*24-02-2015 Llozada [NC 4038]: Se calculan las cuotas a devolver tomando las cuotas pagadas menos el
    total de las cuotas pactadas en la poliza*/
    FOR rc in cuPolizasAsociadas(rcPolicy.policy_number) LOOP
      /*
      /*24/10/2016 KBaquero [Caso 200-492]: se calculan las cuotas pagadas contando las cuotas y
      sumandolas, se crea un nuevo servicio con el que se retorna este valor*/
      dald_policy.updFees_To_Return(rc.policy_id,
                                    (rc.share_policy -
                                    LD_BCSecureManagement.FNUCUOTASPAGADASBS(rc.policy_id)));
    END LOOP;
    --21-01-2015 Llozada [NC 4038]: Se comenta porque se debe actualizar cada poliza del producto.
    -- Se crea la orden de cobro
    nuOrderId         := null;
    nuOrderActivityId := null;
    nuCodMenErro := null;
    api_createorder(inuItemsid         => nuOrderPay,
                    inuPackageid       => inuPackage,
                    inuMotiveid        => nuMotive,
                    inuComponentid     => null,
                    inuInstanceid      => null,
                    inuAddressid       => nuAddress,
                    inuElementid       => null,
                    inuSubscriberid    => null,
                    inuSubscriptionid  => rcPolicy.suscription_id,
                    inuProductid       => rcPolicy.product_id,
                    inuOperunitid      => null,
                    idtExecestimdate   => null,
                    inuProcessid       => null,
                    isbComment         => 'Orden de pago para la aseguradora',
                    iblProcessorder    => null,
                    inuPriorityid      => null,
                    inuOrdertemplateid => null,
                    isbCompensate      => null,
                    inuConsecutive     => null,
                    inuRouteid         => null,
                    inuRouteConsecutive=> null,
                    inuLegalizetrytimes=> null,
                    isbTagname         => null,
                    iblIsacttoGroup    => null,
                    inuRefvalue        => null,
                    inuActionid        => null,
                    ionuOrderid        => nuOrderId,
                    ionuOrderactivityid=> nuorderactivityid,
                    onuErrorCode       => nuCodMenErro,
                    osbErrorMessage    => sbMensaError
                   );

    if nvl(nuCodMenErro,0) != 0 then
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    end if;


    /*Se asigna la orden a la unidad operativa asociada al tipo de poliza*/
    rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
    OR_boProcessOrder.updBasicData(rcOrder,
                                   rcOrder.operating_sector_id,
                                   null);


    if nuUnitOper is null then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                               'La unidad operativa [' ||
                               nuUnitOper ||
                               '] no permite asignar la orden [' ||
                               nuOrderId || '].');
    end if;
    nuCodMenErro := null;
    api_assign_order (inuOrder          => nuOrderId,
                      inuOperatingUnit  => nuUnitOper,
                      onuErrorCode      => nuCodMenErro,
                      osbErrorMessage   => sbMensaError
                    );
    if nvl(nuCodMenErro,0) != 0 then
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    end if;

	sbdataorder := NULL;
	sbdataorder :=
	   nuOrderId
	|| '|'
	|| pkg_gestionordenes.cnucausalexito
	|| '|'
	|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
	|| '||'
	|| nuorderactivityid
	|| '>'
	|| 1
	|| ';;;;|||1277;Legalizacion de la orden de cobro';

    -- Se legaliza la orden de cobro con causal de exito
    api_legalizeOrders(isbDataOrder    => sbdataorder,
                       idtInitDate     => sysdate,
                       idtFinalDate    => sysdate,
                       idtChangeDate   => null,
                       onuErrorCode    => nuError,
                       osbErrorMessage => sbMessage
                      );

    if (nvl(nuError,0) <> 0) then
       gw_boerrors.checkerror(nuError, sbMessage);
    end if;
    -- actualizar valor de liquidacion de la actividad
    GETLIQUIDATIONSECUREVALUE(nuOrderId, nuValue, nuValueNote);
    nuValue := ROUND(nuValue, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
    daor_order_items.updvalue(daor_order_activity.fnugetorder_item_id(nuorderactivityid),
                              nuValue);
    daor_order.updorder_value(nuOrderId, nuValue);
    /*  Crea orden de pago */
    nuOrderId         := null;
    nuOrderActivityId := null;
    nuCodMenErro := null;
    api_createorder(inuItemsid         => nuOrderCharge,
                    inuPackageid       => inuPackage,
                    inuMotiveid        => nuMotive,
                    inuComponentid     => null,
                    inuInstanceid      => null,
                    inuAddressid       => nuAddress,
                    inuElementid       => null,
                    inuSubscriberid    => null,
                    inuSubscriptionid  => rcPolicy.suscription_id,
                    inuProductid       => rcPolicy.product_id,
                    inuOperunitid      => null,
                    idtExecestimdate   => null,
                    inuProcessid       => null,
                    isbComment         => 'Orden de pago para la aseguradora',
                    iblProcessorder    => null,
                    inuPriorityid      => null,
                    inuOrdertemplateid => null,
                    isbCompensate      => null,
                    inuConsecutive     => null,
                    inuRouteid         => null,
                    inuRouteConsecutive=> null,
                    inuLegalizetrytimes=> null,
                    isbTagname         => null,
                    iblIsacttoGroup    => null,
                    inuRefvalue        => null,
                    inuActionid        => null,
                    ionuOrderid        => nuOrderId,
                    ionuOrderactivityid=> nuorderactivityid,
                    onuErrorCode       => nuCodMenErro,
                    osbErrorMessage    => sbMensaError
                    );


    if nvl(nuCodMenErro,0) != 0 then
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    end if;
    --Se asigna la orden  a la unidad operativa de la poliza
    rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
    OR_boProcessOrder.updBasicData(rcOrder,
                                   rcOrder.operating_sector_id,
                                   null);


    if nuUnitOper is null then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'La unidad operativa no permite asignar' ||
                                nuUnitOper || ' ' || nuOrderId);
    end if;
    nuCodMenErro := null;
    api_assign_order (inuOrder          => nuOrderId,
                      inuOperatingUnit  => nuUnitOper,
                      onuErrorCode      => nuCodMenErro,
                      osbErrorMessage   => sbMensaError
                    );
    if nvl(nuCodMenErro,0) != 0 then
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    end if;

	sbdataorder := NULL;
	sbdataorder :=
	   nuOrderId
	|| '|'
	|| pkg_gestionordenes.cnucausalexito
	|| '|'
	|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
	|| '||'
	|| nuorderactivityid
	|| '>'
	|| 1
	|| ';;;;|||1277;Legalizacion de la orden de pago';

    -- Se legaliza la orden de pago con causal de exito
    api_legalizeOrders(isbDataOrder    => sbdataorder,
                       idtInitDate     => sysdate,
                       idtFinalDate    => sysdate,
                       idtChangeDate   => null,
                       onuErrorCode    => nuError,
                       osbErrorMessage => sbMessage
                      );

    if (nvl(nuError,0) <> 0) then
       gw_boerrors.checkerror(nuError, sbMessage);
    end if;
    -- actualizar valor de liquidacion de la actividad
    GETLIQUIDATIONSECUREVALUE(nuOrderId, nuValue, nuValueNote);
    nuValue := ROUND(nuValue, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
    daor_order_items.updvalue(daor_order_activity.fnugetorder_item_id(nuorderactivityid),
                              nuValue);
    daor_order.updorder_value(pkg_bcordenes.fnuobtieneordendeactividad(nuorderactivityid),
                              nuValue);
    --Se realiza la atencion de solicitud
		Mo_Boattention.Attendcreationprodbypackmass(inuPackage, cnuActionId);

    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcCancelPolicy;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ValidateDataCancel
  Descripcion    : Valida los parametros ingresados en el proceso de cancelacion
  Autor          : jcarrillo
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuCodedepa     Departamento
  inuCodeLoca     Localidad
  inuCodeaseg     Aseguradora
  inuCauseinc     Constante de anulacion
  inuSesunuse     Producto
  inuFeeds        Cuotas
  idtDateCancel   Fecha de Cancelacion
  inuCause        Causa
  isbNameaseg     Nombre de Asegurado
  inuIdentase     Identificacion
  inuCodePolyType Tipo de Poliza
  onuErrorMessage Mensaje de Error
  Historia de Modificaciones
  Fecha         Autor                 Modificacion
  =========   =========               ====================
  07/06/2013  jcarrillo.SAO216575     1 - Creacion
  ******************************************************************/
  PROCEDURE ValidateDataCancel(inuCodedepa     in ge_geogra_location.geograp_location_id%type,
                               inuCodeLoca     in ge_geogra_location.geograp_location_id%type,
                               inuCodeaseg     in Ge_Contratista.Id_Contratista%type,
                               inuCauseinc     in varchar2,
                               inuSesunuse     in servsusc.sesunuse%type,
                               inuFeeds        in number,
                               idtDateCancel   in date,
                               inuCause        in ld_cancel_causal.cancel_causal_id%type,
                               isbNameaseg     in ld_policy.name_insured%type,
                               inuIdentase     in ld_policy.identification_id%type,
                               inuCodePolyType in ld_policy_type.policy_type_id%type,
                               onuErrorMessage out varchar2) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValidateDataCancel'; --Nombre del método en la traza
    nuSubscriber ge_subscriber.subscriber_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    onuErrorMessage := null;
    -- Departamento
    if ((onuErrorMessage IS null) AND
       (not dage_geogra_location.fblexist(inuCodedepa))) then
      onuErrorMessage := ' Error ... El departamento [' || inuCodedepa ||
                         '] no existe. ';
    end if;
    -- Localidad
    if ((onuErrorMessage IS null) AND
       (not dage_geogra_location.fblexist(inuCodeLoca))) then
      onuErrorMessage := ' Error ... La localidad [' || inuCodeLoca ||
                         '] no existe. ';
    end if;
    -- Aseguradora
    if ((onuErrorMessage IS null) AND
       (not dage_contratista.fblexist(inuCodeaseg))) then
      onuErrorMessage := ' Error ... La aseguradora [' || inuCodeaseg ||
                         '] no existe. ';
    end if;
    -- Constante de anulacion
    if ((onuErrorMessage IS null) AND (inuCauseinc IS null)) then
      onuErrorMessage := ' Error ... No se ingreso la causa de anulacion. ';
    end if;
    -- Servicio
    if ((onuErrorMessage IS null) AND
       (not dapr_product.fblexist(inuSesunuse))) then
      onuErrorMessage := ' Error ... El producto [' || inuSesunuse ||
                         '] no existe. ';
    end if;
    -- Constante de anulacion
    if ((onuErrorMessage IS null) AND (inuCauseinc IS null)) then
      onuErrorMessage := ' Error ... No se ingreso la causa de anulacion. ';
    end if;
    -- Cuotas a devolver
    if ((onuErrorMessage IS null) AND (inuFeeds IS null OR inuFeeds < 0)) then
      onuErrorMessage := ' Error ... No se ingreso el numero de cuotas a devolver o se ingreso un valor menor a cero. ';
    end if;
    -- Fecha de visita
    if ((onuErrorMessage IS null) AND (idtDateCancel IS null)) then
      onuErrorMessage := ' Error ... No se ingreso la fecha de cancelacion. ';
    end if;
    -- Cedula del asegurado
    ld_bcsecuremanagement.GetSubscriberById(inuIdentase, nuSubscriber);
    if ((onuErrorMessage IS null) AND (nuSubscriber IS null)) then
      onuErrorMessage := ' Error ... No existe un cliente con la identificacion [' ||
                         inuIdentase || '] . ';
    end if;
    -- Codigo del tipo de poliza
    if ((onuErrorMessage IS null) AND
       (not dald_policy_type.fblExist(inuCodePolyType))) then
      onuErrorMessage := ' Error ... No se ingreso el codigo del tipo de poliza. ';
    end if;
    -- Causal
    if ((onuErrorMessage IS null) AND
       (not dald_cancel_causal.fblExist(inuCause))) then
      onuErrorMessage := ' Error ... La causal de cancelacion [' ||
                         inuCause || '] no existe. ';
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValidateDataCancel;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancelByFile
  Descripcion    : Proceso que busca los archivos de cancelacion montados por la aseguradaora
                 con extension .txt y empiezen con ANUL para su respectiva cancelacion de polizas
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha         Autor                 Modificacion
  =========   =========               ====================
  21-03-2024  pacosta                OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                     Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                     Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                     Cambio LD_BOPACKAGEFNB.PROSENDEMAIL por PKG_CORREO.PRCENVIACORREO
                                     Cambio PKUTLFILEMGR.FCLOSE por PKG_GESTIONARCHIVOS.PRCCERRARARCHIVO_SMF
                                     Cambio PKUTLFILEMGR.FOPEN por PKG_GESTIONARCHIVOS.FTABRIRARCHIVO_SMF
                                     Cambio PKUTLFILEMGR.GET_LINE por PKG_GESTIONARCHIVOS.FSBOBTENERLINEA_SMF
                                     Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
                                     Cambio UTL_FILE.FILE_TYPE por PKG_GESTIONARCHIVOS.STYARCHIVO
                                     Cambio UTL_FILE.FRENAME por PKG_GESTIONARCHIVOS.PRCRENOMBRAARCHIVO_SMF
  12/03/2015 SPacheco (ARA 6165)      se mejora log de RESULTADO
  29-01-2014  AEcheverrySAO231292     Se adiciona el campo PERSON_ID(ID) al
                                      tramite de cancelacion de seguros por XML
  07/06/2013  jcarrillo.SAO216575     - Se modifica para realizar validaciones
                                        completas
  06/09/2013  mmeusburgger.SAO214427 - Se impacta por entrega SAO213248
  06/09/2013  jcarrillo.SAO213248    - Se modifica para ejecutar el
                                        proceso de renombramiento
  04/09/2013   mmeusburgger.SAO213279 - Se modifica para solucionar error
                                      a causa de perdida de indices. Se
                                      implementea bloque While.
  14/08/2012   AAcuna                 Creacion
  ******************************************************************/
  PROCEDURE ProcCancelByFile IS
    csbMetodo         CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcCancelByFile'; --Nombre del método en la traza
    -- Variables para campos del archivo.txt de cancelacion que envia la aseguradora
    nuCodedepa        ge_geogra_location.geograp_location_id%type;
    nuCodeaseg        Ge_Contratista.Id_Contratista%type;
    nuSesunuse        servsusc.sesunuse%type;
    nuFeeds           number;
    dtDatevisi        date;
    nuCause           number;
    nuCauseinc        varchar2(150);
    nuIdentase        ld_policy.identification_id%type;
    sbNameaseg        ld_policy.name_insured%type;
    nuCodePolyType    ld_policy_type.policy_type_id%type;
    nuGeo             ge_geogra_location.geograp_location_id%type;
    nuadd             ab_address.address%type;
    sbparserAddress   mo_address.address%type;
    nuCodeLoca        ge_geogra_location.geograp_location_id%type;
    sbOnline          varchar2(32767);
    sbFileGl          varchar2(100);
    /* Variables para conexion*/
    sbFileManagement  pkg_gestionarchivos.styarchivo;
    sbFileManagementd pkg_gestionarchivos.styarchivo;
    nuCodigo          number;
    cnuend_of_file    constant number := 1;
    sbPath            varchar2(500);
    ----
    sbLog             varchar2(500);
    sbLineLog         varchar2(1000);
    ----
    vArray            t_string_table := t_string_table();
    sbL_file          varchar2(500);
    sbL_nom           varchar2(500);
    sbL_ext           varchar2(50);
    sbMsg             varchar2(50);
    nuPos             number;
    sbTimeProc        varchar2(100);
    -- Valores de retorno para la validacion
    sbRequestXML      constants_per.TIPO_XML_SOL%type;
    nuErrorCode       number;
    sbErrorMessage    VARCHAR2(8000);
    nuPackageId       mo_packages.package_id%type;
    nuMotiveId        mo_motive.motive_id%type;
    rcserv            servsusc%rowtype;
    nuSubscriber      ge_subscriber.subscriber_id%type;
    nuPolicy          ld_policy.policy_id%type;
    nuRecepType       ld_parameter.numeric_value%type;
    nuAnswerId        ld_parameter.numeric_value%type;
    nuFinancingPlan   ld_parameter.numeric_value%type;
    sbState           ld_parameter.value_chain%type;
    nuState           ld_parameter.numeric_value%type;
    sbSol             VARCHAR2(100);
    nuIndexArray      binary_integer;
    -- VAriables para mensaje de error
    nuLinea           number;
    nuErrorMessage    varchar(32000);
    nususcription_id  suscripc.susccodi%type; --identifica codigo de la suscripcion
    nupolinocac       number := 0; --10-03-2015 sPACHECO [ARA 6165]:  CONTADOR POLIZA CANCELADA
    nupolicac         number := 0; --10-03-2015 sPACHECO [ARA 6165]:CONTADOR POLIZA NO CANCELADA
    vsbSendEmail      ld_parameter.value_chain%TYPE; --10-03-2015 sPACHECO [ARA 6165]:Direccion de email quine firma el email
    vsbrecEmail       ld_parameter.value_chain%TYPE; --10-03-2015 sPACHECO [ARA 6165]:Direccion de email que recibe
    vsbmessage        VARCHAR2(2000); --10-03-2015 sPACHECO [ARA 6165]:MENSAJE LOG CORREO
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuRecepType     := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuRecepType);
    nuAnswerId      := pkg_bcld_parameter.fnuobtienevalornumerico('ANSWER_ID_CANCEL');
    nuFinancingPlan := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuFinancingPlan);
    sbRutLogs       := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbRutLogs);
    sbCanByFil      := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCanByFil);
    sbPath          := sbRutLogs;
    sbState         := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
    sbTimeProc := TO_CHAR(SYSDATE, 'yyyymmdd_hh24miss');
    -- Arma nombre del archivo LOG
    sbLog := 'AN_' || sbTimeProc || '.LOG';
    /*Crea archivo Log */
    sbFileManagementd := pkg_gestionarchivos.ftabrirarchivo_smf(sbPath, sbLog, 'w');
    sbLineLog         := 'INICIO PROCESO DE LECTURAS DE CANCELACION DE POLIZAS ' ||
                         TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS');
    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    if ((nvl(nuFinancingPlan, LD_BOConstans.cnuCero) <>
       LD_BOConstans.cnuCero) AND
       (nvl(nuRecepType, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) AND
       (nvl(nuAnswerId, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) AND
       sbState is not null) then
      ------------------------------------------------------------------------
      -- Hay Configuracion de Parametros
      ------------------------------------------------------------------------
      -- Si archivo es de tipo Cancelacion, hacemos..
      ld_file_api.ProcGetDirList(sbPath, '.txt', vArray);
      nuIndexArray := vArray.first;
      while nuIndexArray IS not null loop
        --------------------------------------------------------------------
        -- Inicia Ciclo de Archivos
        --------------------------------------------------------------------
        sbL_file := substr(vArray(nuIndexArray),
                           nuPos + 1,
                           length(vArray(nuIndexArray)) - nuPos);
        sbL_nom  := substr(vArray(nuIndexArray),
                           1,
                           length(vArray(nuIndexArray)) - 4);
        if (upper(vArray(nuIndexArray)) like '%ANUL%') then
          ----------------------------------------------------------------
          -- Inicia Proceso de Archivos de Anulacion
          ----------------------------------------------------------------
          -- Asignamos nombre del archivo...
          sbFileGl := sbL_file;
          pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, ' ');
          pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, ' ');
          sbLineLog := 'Procesando ARCHIVO [' || vArray(nuIndexArray) || '].';
          pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
          BEGIN
            pkg_traza.trace('Abriendo Ruta:[' || sbPath || '] Archivo[' ||
                           vArray(nuIndexArray) || ']',
                           pkg_traza.cnuNivelTrzDef);
            sbFileManagement := pkg_gestionarchivos.ftabrirarchivo_smf(sbPath, -- Ruta del Archivo
                                                   vArray(nuIndexArray), -- Nombre del Archivo
                                                   'r' -- [Read]
                                                   );
          EXCEPTION
            when others then
              sbLineLog := '     Error ... No se pudo abrir archivo ' ||
                           sbPath || ' ' || vArray(nuIndexArray) || ' ' ||
                           sqlerrm;
              pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
              GOTO nextFile;
          END;
          nuLinea := 0;
          loop
            ------------------------------------------------------------
            -- Inicia Ciclo de Lineas
            ------------------------------------------------------------
            nuLinea  := nuLinea + 1;
            begin
                sbOnline := pkg_gestionarchivos.fsbobtenerlinea_smf(sbFileManagement);
            exception
                when no_data_found then
                    exit;
            end;
            if sbOnline is null then
                GOTO nextLine;
            end if;
            /* Si pudo leer el archivo de cancelacion se obtiene los
            campos enviados dentro del archivo*/
            -- departamento
            nuCodedepa := to_number(substr(sbOnline,
                                           1,
                                           instr(sbOnline, '|', 1, 1) - 1));
            -- Localidad
            nuCodeLoca := to_number(substr(sbOnline,
                                           instr(sbOnline, '|', 1, 1) + 1,
                                           (instr(sbOnline, '|', 1, 2)) -
                                           (instr(sbOnline, '|', 1, 1) + 1)));
            -- Aseguradora
            nuCodeaseg := to_number(substr(sbOnline,
                                           instr(sbOnline, '|', 1, 2) + 1,
                                           (instr(sbOnline, '|', 1, 3)) -
                                           (instr(sbOnline, '|', 1, 2) + 1)));
            --Causa
            nuCauseinc := substr(sbOnline,
                                 instr(sbOnline, '|', 1, 3) + 1,
                                 (instr(sbOnline, '|', 1, 4)) -
                                 (instr(sbOnline, '|', 1, 3) + 1));
            -- Servicio
            nuSesunuse := to_number(substr(sbOnline,
                                           instr(sbOnline, '|', 1, 4) + 1,
                                           (instr(sbOnline, '|', 1, 5)) -
                                           (instr(sbOnline, '|', 1, 4) + 1)));
            -- Numero de cuotas
            nuFeeds := to_number(substr(sbOnline,
                                        instr(sbOnline, '|', 1, 5) + 1,
                                        (instr(sbOnline, '|', 1, 6)) -
                                        (instr(sbOnline, '|', 1, 5) + 1)));
            -- Fecha de cancelacion
            dtDatevisi := to_date(substr(sbOnline,
                                         instr(sbOnline, '|', 1, 6) + 1,
                                         (instr(sbOnline, '|', 1, 7)) -
                                         (instr(sbOnline, '|', 1, 6) + 1)),
                                  'dd/mm/yyyy');
            -- Causa de cancelacion
            nuCause := to_number(substr(sbOnline,
                                        instr(sbOnline, '|', 1, 7) + 1,
                                        (instr(sbOnline, '|', 1, 8)) -
                                        (instr(sbOnline, '|', 1, 7) + 1)));
            -- Nombre del asegurado
            sbNameaseg := substr(sbOnline,
                                 instr(sbOnline, '|', 1, 8) + 1,
                                 (instr(sbOnline, '|', 1, 9)) -
                                 (instr(sbOnline, '|', 1, 8) + 1));
            -- Identificacion
            nuIdentase := to_number(substr(sbOnline,
                                           instr(sbOnline, '|', 1, 9) + 1,
                                           (instr(sbOnline, '|', 1, 10)) -
                                           (instr(sbOnline, '|', 1, 9) + 1)));
            -- Typo de Poliza
            nuCodePolyType := substr(sbOnline,
                                     instr(sbOnline, '|', 1, 10) + 1,
                                     (instr(sbOnline, '|', 1, 11)) -
                                     (instr(sbOnline, '|', 1, 10) + 1));
            /*Se obtiene el estado de la poliza */
            nuState := to_number(substr(sbState,
                                        1,
                                        instr(sbState, '|', 1, 1) - 1));
            /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene suscripcion para concatenar a log*/
            ld_bcsecuremanagement.GetServsPolicy(nuSesunuse,
                                                 nuState,
                                                 nuPolicy);
            /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene suscripcion para concatenar a log*/
            begin
              nususcription_id := pkg_bcproducto.fnucontrato(nuSesunuse);
            EXCEPTION
              when OTHERS then
                nususcription_id := null;
            end;
            /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
            al mensaje de log para hacerlo mas explicito*/
            sbLineLog := '[Contrato:' || nususcription_id || '- Producto:' ||
                         nuSesunuse || '- Poliza:' || nuPolicy ||
                         '- Colectivo:' ||
                         DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                         'LINEA [' || nuCodedepa || ' ' || nuCodeLoca || ' ' ||
                         nuCodeaseg || ' ' || nuCauseinc || ' ' ||
                         nuSesunuse || ' ' || nuFeeds || ' ' || dtDatevisi || ' ' ||
                         nuCause || ' ' || sbNameaseg || ' ' || nuIdentase || ' ' ||
                         nuCodePolyType || sbPath || ' ' || sbFileGl || ']';
            pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
            BEGIN
              pkg_traza.trace('INICIO Validacion de Datos de Entrada', pkg_traza.cnuNivelTrzDef);
              -- Validaciones de los campos que trae el archivo
              ValidateDataCancel(nuCodedepa,
                                 nuCodeLoca,
                                 nuCodeaseg,
                                 nuCauseinc,
                                 nuSesunuse,
                                 nuFeeds,
                                 dtDatevisi,
                                 nuCause,
                                 sbNameaseg,
                                 nuIdentase,
                                 nuCodePolyType,
                                 nuErrorMessage);
              if (nuErrorMessage IS not null) then
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          nuErrorMessage);
              end if;
              pkg_traza.trace('FIN Validacion de Datos de Entrada', pkg_traza.cnuNivelTrzDef);
            EXCEPTION
              when PKG_ERROR.CONTROLLED_ERROR then
                pkg_error.SetError;
                pkg_error.getError(nuErrorCode, sbErrorMessage);
                /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
                al mensaje de log para hacerlo mas explicito*/
                sbLineLog := '[Contrato:' || nususcription_id ||
                             '- Producto:' || nuSesunuse || '- Poliza:' ||
                             nuPolicy || '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                             '      Error ejecutando validaciones Codigo[' ||
                             nuErrorCode || '] Mensaje [' || sbErrorMessage || '] ';
                sbLineLog := sbLineLog || 'Ruta [' || sbPath ||
                             '] Archivo [' || vArray(nuIndexArray) ||
                             '] Linea [' || nuLinea || ']';
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                nupolinocac := nupolinocac + 1; --10-03-2015 sPACHECO [ARA 6165]:contador de poliza no cancelada
                GOTO nextLine;
              when OTHERS then
                pkg_error.SetError;
                pkg_error.getError(nuErrorCode, sbErrorMessage);
                /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
                al mensaje de log para hacerlo mas explicito*/
                sbLineLog := '[Contrato:' || nususcription_id ||
                             '- Producto:' || nuSesunuse || '- Poliza:' ||
                             nuPolicy || '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                             '      Error ejecutando validaciones Codigo[' ||
                             nuErrorCode || '] Mensaje [' || sbErrorMessage || ']';
                sbLineLog := sbLineLog || 'Ruta [' || sbPath ||
                             '] Archivo [' || vArray(nuIndexArray) ||
                             '] Linea [' || nuLinea || ']';
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                nupolinocac := nupolinocac + 1; --10-03-2015 sPACHECO [ARA 6165]:contador de poliza no cancelada
                GOTO nextLine;
            END;
            BEGIN
              pkg_traza.trace('INICIO Registro de Solicitud', pkg_traza.cnuNivelTrzDef);
              /*Se obtiene el estado de la poliza */
              nuState := to_number(substr(sbState,
                                          1,
                                          instr(sbState, '|', 1, 1) - 1));
              rcserv := pktblservsusc.frcGetRecord(nuSesunuse);
              ld_bcsecuremanagement.GetAddressCancelByFile(rcserv.sesususc,
                                                           nuadd,
                                                           nuGeo,
                                                           sbparserAddress);
              ld_bcsecuremanagement.GetSubscriberById(nuIdentase,
                                                      nuSubscriber);
              ld_bcsecuremanagement.GetServsPolicy(rcserv.sesunuse,
                                                   nuState,
                                                   nuPolicy);
              sbSol := sbCanByFil;

              --<P_CANCELACION_DE_SEGUROS_XML_100266 ID_TIPOPAQUETE="100266">
              sbRequestXML := pkg_xml_sol_seguros.getSolicitudCancelaSeguros(inuPersonaId         => pkg_bopersonal.fnugetpersonaid(),
                                                                             inuMedioRecepcionId  => nuRecepType,
                                                                             isbComentario        => 'Cancelación de seguros por archivo plano.',
                                                                             idtFechaSolicitud    => trunc(sysdate),
                                                                             inuDireccionId       => nuadd,
                                                                             inuClienteId         => nuSubscriber,
                                                                             inuContratoId        => rcserv.sesususc ,
                                                                             inuNumeroPoliza      => nuPolicy,
                                                                             inuRespuestaId       => nuAnswerId,
                                                                             inuCausalCanceId     => nuCause,
                                                                             isbObservacionPoliza => 'Se canceló la poliza.',
                                                                             isbSolicitud         => sbSol
                                                                            );


              pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);
              api_registerrequestbyxml(isbRequestXML    => sbRequestXML,
                                       onuPackageId     => nuPackageId,
                                       onuMotiveId      => nuMotiveId,
                                       onuErrorCode     => nuErrorCode,
                                       osbErrorMessage  => sbErrorMessage
                                      );

              /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo*/
              /*al mensaje de log para hacerlo mas explicito*/
              pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd,
                                    '[Contrato:' || nususcription_id ||
                                    '- Producto:' || nuSesunuse ||
                                    '- Poliza:' || nuPolicy ||
                                    '- Colectivo:' ||
                                    DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                                    'Codigo' || nuErrorCode);
              pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd,
                                    'Mensaje' || sbErrorMessage);
              if (nuPackageId is not null) then
                UpdateStatePolicy(nuPolicy, 3);
                commit;
                /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
                al mensaje de log para hacerlo mas explicito*/
                sbLineLog := '[Contrato:' || nususcription_id ||
                             '- Producto:' || nuSesunuse || '- Poliza:' ||
                             nuPolicy || '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                             '  Se creo la solicitud de cancelacion: ' ||
                             nuPackageId || ' con el numero de motivo: ' ||
                             nuMotiveId || ' la poliza a cancelar es: ' ||
                             nuPolicy;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                nupolicac := nupolicac + 1; --10-03-2015 sPACHECO [ARA 6165]:contador de poliza cancelada
              else
                /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
                al mensaje de log para hacerlo mas explicito*/
                sbLineLog := '[Contrato:' || nususcription_id ||
                             '- Producto:' || nuSesunuse || '- Poliza:' ||
                             nuPolicy || '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                             ' Error creando la solicitud: ' || nuPackageId ||
                             ' con el numero de motivo: ' || nuMotiveId ||
                             ' para el contrato: ' || rcserv.sesususc ||
                             ' y la poliza: ' || nuPolicy || ' Error: ' ||
                             nuErrorCode || ' Mensaje:' || sbErrorMessage;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                nupolinocac := nupolinocac + 1; --10-03-2015 sPACHECO [ARA 6165]:contador de poliza no cancelada
                GOTO nextLine;
              end if;
              pkg_traza.trace('FIN Registro de Solicitud', pkg_traza.cnuNivelTrzDef);
            EXCEPTION
              when PKG_ERROR.CONTROLLED_ERROR then
                pkg_error.SetError;
                pkg_error.getError(nuErrorCode, sbErrorMessage);
                /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
                al mensaje de log para hacerlo mas explicito*/
                sbLineLog := '[Contrato:' || nususcription_id ||
                             '- Producto:' || nuSesunuse || '- Poliza:' ||
                             nuPolicy || '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                             '     Error ejecutando el api xml de cancelacion ... numero de error ' ||
                             nuErrorCode || ' Mensaje' || sbErrorMessage;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                nupolinocac := nupolinocac + 1; --10-03-2015 sPACHECO [ARA 6165]:contador de poliza no cancelada
                GOTO nextLine;
              when OTHERS then
                pkg_error.SetError;
                pkg_error.getError(nuErrorCode, sbErrorMessage);
                /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
                al mensaje de log para hacerlo mas explicito*/
                sbLineLog := '[Contrato:' || nususcription_id ||
                             '- Producto:' || nuSesunuse || '- Poliza:' ||
                             nuPolicy || '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(nuPolicy) || ']' ||
                             '      Error ejecutando el api xml de cancelacion ... numero de error ' ||
                             nuErrorCode || ' Mensaje' || sbErrorMessage;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                nupolinocac := nupolinocac + 1; --10-03-2015 sPACHECO [ARA 6165]:contador de poliza no cancelada
                GOTO nextLine;
            END;
            <<nextLine>>
            null;
            ------------------------------------------------------------
            -- Inicia Ciclo de Lineas
            ------------------------------------------------------------
          end loop;
          sbL_ext := '.ok';
          BEGIN
            pkg_traza.trace('INICIO Renombre de Archivo', pkg_traza.cnuNivelTrzDef);
            pkg_gestionarchivos.prcrenombraarchivo_smf(sbPath,
                             vArray(nuIndexArray),
                             sbPath,
                             sbl_nom || sbL_ext,
                             true);
            pkg_traza.trace('FIN Renombre de Archivo', pkg_traza.cnuNivelTrzDef);
          EXCEPTION
            when others then
              sbLineLog := '  Error ... No se pudo renombrar archivo ' ||
                           sbPath || sbFileGl || vArray(nuIndexArray) ||
                           ' con la extension ' || sbL_ext || ' ... ' ||
                           'Debe renombrarlo manualmente para que no se procese de nuevo. ';
              pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
          END;
          ----------------------------------------------------------------
          -- Finaliza Proceso de Archivos de Anulacion
          ----------------------------------------------------------------
        end If;
        <<nextFile>>
        nuIndexArray := vArray.next(nuIndexArray);
      --------------------------------------------------------------------
      -- Finaliza Ciclo de Archivos
      --------------------------------------------------------------------
      end loop;
    else
      ------------------------------------------------------------------------
      -- No hay Configuracion de Parametros
      ------------------------------------------------------------------------
      sbLineLog := ' Los valores de los parametros para la cancelacion de seguros
            no contiene datos ';
      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    end if;
    sbLineLog := 'Cantidad de polizas canceladas: ' || nupolicac;
    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    sbLineLog := 'Cantidad de polizas No canceladas con exito: ' ||
                 nupolinocac;
    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    pkg_gestionarchivos.prccerrararchivo_smf(sbFileManagement);
    pkg_gestionarchivos.prccerrararchivo_smf(sbFileManagementd);
    vsbmessage := 'Notificacion de finalizacion de proceso de CANCELACION ' ||
                  chr(10) || chr(13) ||
                  ' Cantidad de polizas canceladas con exito: ' ||
                  nupolicac || chr(10) || chr(13) ||
                  'Cantidad de polizas No Canceladas: ' || nupolinocac ||
                  chr(10) || chr(13) ||
                  'Para mayor detalle, dirijase al log generado en la ruta ' ||
                  sbPath;
    --identifica parametro de correo de envio osf
    vsbSendEmail := pkg_bcld_parameter.fsbobtienevalorcadena('LDC_SMTP_SENDER');
    --identifica parametro de correo de recibe notificacion de CANCELACION de seguro
    vsbrecEmail := pkg_bcld_parameter.fsbobtienevalorcadena('EMAIL_RENO_RENSEGU');
    --SE ENVIA CORREO DE NOTIFICACION
    pkg_correo.prcenviacorreo(isbRemitente      => vsbSendEmail,
                              isbDestinatarios  => vsbrecEmail,
                              isbAsunto         => 'Finalizacion de proceso de CANCELACION',
                              isbMensaje        => vsbmessage);
  pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcCancelByFile;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcCancelPolByJob
  Descripcion    : Proceso que verifica los seguros que presenten atraso en sus pagos,
                 teniendo en cuenta el parametro del sistema que contiene el numero de periodo vencidos
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========   ========= ====================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                  Cambio LD_BOPACKAGEFNB.PROSENDEMAIL por PKG_CORREO.PRCENVIACORREO
                                  Cambio PKUTLFILEMGR.FCLOSE por PKG_GESTIONARCHIVOS.PRCCERRARARCHIVO_SMF
                                  Cambio PKUTLFILEMGR.FOPEN por PKG_GESTIONARCHIVOS.FTABRIRARCHIVO_SMF
                                  Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
                                  Cambio PR_BCPRODUCT.FNUGETADDRESSID por PKG_BCPRODUCTO.FNUIDDIRECCINSTALACION
                                  Cambio UTL_FILE.FILE_TYPE por PKG_GESTIONARCHIVOS.STYARCHIVO
  12/03/2015 SPacheco (ARA 6165)      se mejora log de RESULTADO
  01/04/2014  AEcheverrySAO236799     Se modifica para realizar un bloqueo con
                                      semaforos y evitar ejecutar al tiempo el
                                      proceso de cancelacion de polizas por JOB
  29-01-2014  AEcheverrySAO231292     Se adiciona el campo PERSON_ID(ID) al
                                      tramite de cancelacion de seguros por XML
  ******************************************************************/
  PROCEDURE ProcCancelPolByJob IS
    csbMetodo         CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcCancelPolByJob'; --Nombre del método en la traza
    tbAccountcharge   pktblservsusc.tySesunuse;
    tbAccounts        pkbccuencobr.tytbaccounts;
    nuServSus         servsusc.sesunuse%type;
    ionupoli          ld_policy.policy_id%type;
    nuprodsegu        ld_parameter.numeric_value%type;
    sbState           ld_parameter.value_chain%type;
    nuState           ld_parameter.numeric_value%type;
    nuRecepType       ld_parameter.numeric_value%type;
    nuGeo             ge_geogra_location.geograp_location_id%type;
    nuadd             ab_address.address%type;
    nugesubs          ge_subscriber.subscriber_id%type;
    rcGesubcri        dage_subscriber.styge_subscriber;
    nuAnswerId        ld_parameter.numeric_value%type;
    sbSol             VARCHAR2(100);
    sbRequestXML      constants_per.TIPO_XML_SOL%type;
    nuPackageId       mo_packages.package_id%type;
    nuMotiveId        mo_motive.motive_id%type;
    nuErrorCode       number;
    sbErrorMessage    VARCHAR2(8000);
    nuCause           number;
    nususc            number;
    sbCanBySin        ld_parameter.value_chain%type; -- Parametro del tipo de cancelacion
    /*Variables  de conexion*/
    sbFileManagementd pkg_gestionarchivos.styarchivo;
    sbPath            varchar2(500);
    ----
    sbLog             varchar2(500);
    sbLineLog         varchar2(1000);
    sbTimeProc        varchar2(100);
    nuRequestResult   number;
    sbLockHandle      VARCHAR2(2000);
    nupolinocac       number := 0; --10-03-2015 sPACHECO [ARA 6165]:  CONTADOR POLIZA CANCELADA
    nupolicac         number := 0; --10-03-2015 sPACHECO [ARA 6165]:CONTADOR POLIZA NO CANCELADA
    vsbSendEmail      ld_parameter.value_chain%TYPE; --10-03-2015 sPACHECO [ARA 6165]:Direccion de email quine firma el email
    vsbrecEmail       ld_parameter.value_chain%TYPE; --10-03-2015 sPACHECO [ARA 6165]:Direccion de email que recibe
    vsbmessage        VARCHAR2(2000); --10-03-2015 sPACHECO [ARA 6165]:MENSAJE LOG CORREO

    PROCEDURE release_lock IS
    BEGIN
      if (sbLockHandle IS not null) then
        nuRequestResult := dbms_lock.release(lockhandle => sbLockHandle);
      END if;
    EXCEPTION
      when others then
        pkg_traza.Trace('Error inesperado' || sqlerrm, pkg_traza.cnuNivelTrzDef);
    END;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    sbPath := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbRutLogs);
    sbTimeProc := TO_CHAR(SYSDATE, 'yyyymmdd_hh24miss');
    /* Arma nombre del archivo LOG */
    sbLog := 'AN_' || sbTimeProc || '.LOG';
    /* Crea archivo Log */
    sbFileManagementd := pkg_gestionarchivos.ftabrirarchivo_smf(sbPath, sbLog, 'w');
    sbLineLog         := 'INICIO PROCESO DE LECTURAS DE CANCELACION DE POLIZAS ' ||
                         TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS');
    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    if ((dald_parameter.fblexist(LD_BOConstans.cnuCodPerDefeated)) AND
       (dald_parameter.fblexist(LD_BOConstans.cnuCodFactProg)) AND
       (dald_parameter.fblexist(LD_BOConstans.csbCodStatePolicy)) AND
       (dald_parameter.fblexist(LD_BOConstans.cnuCodTypeProduct))) then
      --bloqueo del proceso
      DECLARE
        sbLockName VARCHAR2(100) := 'CANCEL_POLICY_BY_JOB_PROCESS_';
      BEGIN
        pkg_traza.trace('LockName: ' || sbLockName, pkg_traza.cnuNivelTrzDef);
        -- Genera un manejador de bloqueo para el contrato.
        EXECUTE IMMEDIATE 'DECLARE PRAGMA AUTONOMOUS_TRANSACTION; BEGIN dbms_lock.allocate_unique(:sbLockName,:sbLockHandle); END;'
          using sbLockName, out sbLockHandle;
        pkg_traza.trace('LockHandle: ' || sbLockHandle, pkg_traza.cnuNivelTrzDef);
        /* Solicita el bloqueo del contrato, a traves del manejador de bloqueo.
            0 - success
            1 - timeout
            2 - deadlock
            3 - parameter error
            4 - already own lock specified by 'id' or 'lockhandle'
            5 - illegal lockhandle
        */
        nuRequestResult := dbms_lock.request(lockhandle        => sbLockHandle,
                                             timeout           => 0,
                                             release_on_commit => false);
      EXCEPTION
        when others then
          pkg_traza.Trace('WARNING: No Bloqueo proceso [' || sbLockName || ']',
                         pkg_traza.cnuNivelTrzDef);
      END;
      -- ya se encuentra proceso ejecutando (bloqueado)
      IF (nuRequestResult IN (1, 2)) THEN
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Ya se encuentra un proceso de cancelacion de polizas por job en ejecucion');
      END if;
      nuGas_Service := LD_BOConstans.cnuGasService;
      nuprodsegu    := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuCodTypeProduct);
      nuPerVen      := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuCodPerDefeated);
      nuFactProg    := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuCodFactProg);
      sbState       := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      nuRecepType   := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuRecepType);
      nuCause       := pkg_bcld_parameter.fnuobtienevalornumerico('COD_CANCEL_CAUSAL_JOB');
      sbCanBySin    := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCanBySin);
      if ((nvl(nuGas_Service, LD_BOConstans.cnuCero) <>
         LD_BOConstans.cnuCero) AND
         (nvl(nuPerVen, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) AND
         (nvl(nuFactProg, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) AND
         (nvl(nuCause, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) AND
         sbState is not null) then
        /* Busca los servicio suscrito cuya poliza tengan igual o mayor numero de
        periodos vencidos llamando al Ld_BcSecureManagemente.ProcSearchProduct */
        ld_bcsecuremanagement.ProcSearchProduct(nuprodsegu,
                                                sbState,
                                                tbAccountcharge);
        if tbAccountcharge.count > 0 then
          for i in tbAccountcharge.FIRST .. tbAccountcharge.LAST loop
            if tbAccountcharge.EXISTS(i) then
              nuServSus := tbAccountcharge(i);
              /*Se obtiene el estado de la poliza */
              nuState := to_number(substr(sbState,
                                          1,
                                          instr(sbState, '|', 1, 1) - 1));
              nususc := pkg_bcproducto.fnucontrato(nuServSus);
              pkBcCuenCobr.GetAccWithBalOutOfDate(nuServSus, tbAccounts);
              -- if tbaccounts.count >= nuPerVen then
              ld_bcsecuremanagement.GetServsPolicy(nuServSus,
                                                   nuState,
                                                   ionupoli);
              GetAddressBySusc(nususc, nuadd, nuGeo);
              /*Se obtiene la informacion del cliente a raiz del suscriptor*/
              nugesubs := PKG_BCCONTRATO.FNUIDCLIENTE(nususc);
              pkg_traza.Trace('El codigo del cliente' || ' - ' || nugesubs, pkg_traza.cnuNivelTrzDef);
              /*Se obtiene el record del cliente*/
              dage_subscriber.getrecord(nugesubs, rcGesubcri);
              sbSol := sbCanBySin;
              --<P_CANCELACION_DE_SEGUROS_XML_100266 ID_TIPOPAQUETE="100266">
              sbRequestXML := pkg_xml_sol_seguros.getSolicitudCancelaSeguros(inuPersonaId         => pkg_bopersonal.fnugetpersonaid(),
                                                                             inuMedioRecepcionId  => nuRecepType,
                                                                             isbComentario        => 'Cancelacion de seguros por no pago JOB.',
                                                                             idtFechaSolicitud    => trunc(sysdate),
                                                                             inuDireccionId       => nuadd,
                                                                             inuClienteId         => nugesubs,
                                                                             inuContratoId        => nususc,
                                                                             inuNumeroPoliza      => ionupoli,
                                                                             inuRespuestaId       => nuAnswerId,
                                                                             inuCausalCanceId     => nuCause,
                                                                             isbObservacionPoliza => 'Se canceló la poliza.',
                                                                             isbSolicitud         => sbSol
                                                                            );

              pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);
              api_registerrequestbyxml(isbRequestXML    => sbRequestXML,
                                       onuPackageId     => nuPackageId,
                                       onuMotiveId      => nuMotiveId,
                                       onuErrorCode     => nuErrorCode,
                                       osbErrorMessage  => sbErrorMessage
                                      );

              ----------------------------------------
              ------------------------------------------
              /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
              al mensaje de log para hacerlo mas explicito*/
              pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd,
                                    '[Contrato:' || nususc || '- Producto:' ||
                                    nuServSus || '- Poliza:' || ionupoli ||
                                    '- Colectivo:' ||
                                    DAld_policy.fnuGetCOLLECTIVE_NUMBER(ionupoli) || ']' ||
                                    'Codigo ' || nuErrorCode);
              pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd,
                                    'Mensaje ' || sbErrorMessage);
              if (nuPackageId is not null) then
                UpdateStatePolicy(ionupoli, 4);
                commit;
                /*10-03-2015 sPACHECO [ARA 6165]: Se obtiene adiciona Contrato/Producto/Poliza/colectivo
                al mensaje de log para hacerlo mas explicito*/
                sbLineLog := '[Contrato:' || nususc || '- Producto:' ||
                             nuServSus || '- Poliza:' || ionupoli ||
                             '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(ionupoli) || ']' ||
                             '  Se creo la solicitud de cancelacion: ' ||
                             nuPackageId || ' con el numero de motivo: ' ||
                             nuMotiveId || ' la poliza a cancelar es: ' ||
                             ionupoli;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                nupolicac := nupolicac + 1;
              else
                sbLineLog := '[Contrato:' || nususc || '- Producto:' ||
                             nuServSus || '- Poliza:' || ionupoli ||
                             '- Colectivo:' ||
                             DAld_policy.fnuGetCOLLECTIVE_NUMBER(ionupoli) || ']' ||
                             ' Error creando la solicitud: ' || nuPackageId ||
                             ' con el numero de motivo: ' || nuMotiveId ||
                             ' para el contrato: ' || nususc ||
                             ' y la poliza: ' || ionupoli || ' Error: ' ||
                             nuErrorCode || ' Mensaje:' || sbErrorMessage;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
                rollback;
                nupolinocac := nupolinocac + 1;
              end if;
              -- end if;
            end if;
          end loop;
        end if;
      else
        sbLineLog := 'Los parametros necesarios para este proceso no se encuentran configurados.';
        pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
      end if;
    else
      sbLineLog := 'Los parametros necesarios para este proceso se no existen';
      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    end if;
    sbLineLog := 'Cantidad de polizas canceladas: ' || nupolicac;
    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    sbLineLog := 'Cantidad de polizas No canceladas con exito: ' ||
                 nupolinocac;
    pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementd, sbLineLog);
    pkg_gestionarchivos.prccerrararchivo_smf(sbFileManagementd);
    release_lock;
    vsbmessage := 'Notificacion de finalizacion de proceso de CANCELACION ' ||
                  chr(10) || chr(13) ||
                  ' Cantidad de polizas canceladas con exito: ' ||
                  nupolicac || chr(10) || chr(13) ||
                  'Cantidad de polizas No Canceladas: ' || nupolinocac ||
                  chr(10) || chr(13) ||
                  'Para mayor detalle, dirijase al log generado en la ruta ' ||
                  sbPath;
    --identifica parametro de correo de envio osf
    vsbSendEmail := pkg_bcld_parameter.fsbobtienevalorcadena('LDC_SMTP_SENDER');
    --identifica parametro de correo de recibe notificacion de CANCELACION de seguro
    vsbrecEmail := pkg_bcld_parameter.fsbobtienevalorcadena('EMAIL_RENO_RENSEGU');
    --SE ENVIA CORREO DE NOTIFICACION
    pkg_correo.prcenviacorreo(isbRemitente     => vsbSendEmail,
                              isbDestinatarios => vsbrecEmail,
                              isbAsunto        => 'Finalizacion de proceso de CANCELACION',
                              isbMensaje       => vsbmessage);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      release_lock;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      release_lock;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcCancelPolByJob;

  --- Metodos de producto adaptados para que no generen saldo a favor
  FUNCTION fnuGetAdjustValue RETURN number IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnuGetAdjustValue'; --Nombre del método en la traza
    nuVlrAjustes number; -- Valor de los ajustes
    -- Documento de soporte para ajuste de cuenta
    csbAJUSTE constant varchar2(15) := 'AJUSTE';
    -- Documento de soporte para cancelacion de ajuste de cuenta
    csbCANCAJUSTE constant varchar2(15) := 'CANC.AJUSTE';
    -- Cursor para sumar los ajuste de la cuenta
    CURSOR cuAjuste(nuCuenta   cargos.cargcuco%type,
                    nuConcepto cargos.cargconc%type) IS
      SELECT nvl(sum(decode(upper(cargsign),
                            pkBillConst.DEBITO,
                            cargvalo,
                            pkBillConst.CREDITO,
                            -cargvalo,
                            0)),
                 0)
        FROM cargos
       WHERE cargcuco = nuCuenta
         AND cargconc = nuConcepto
         AND cargdoso || '' in (csbAJUSTE, csbCANCAJUSTE);
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Obtiene el valor de los ajustes de la cuenta
    open cuAjuste(nuCuenta, nuConcAjuste);
    fetch cuAjuste
      into nuVlrAjustes;
    close cuAjuste;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return(nuVlrAjustes);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END fnuGetAdjustValue;


  PROCEDURE ValGenerationDate(idtFechaGene in date) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValGenerationDate'; --Nombre del método en la traza
    -- Fecha fuera de rango de fechas de movimientos del periodo de
    -- facturacion current
    cnuDATE_OUT_OF_RANGE constant number := 10116;
    csbDATE_OUT_OF_RANGE CONSTANT VARCHAR2(130) :=
                         'La fecha de generacion de cuentas debe estar dentro del rango de fechas de movimiento del periodo de facturacion actual';
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkGeneralServices.ValDateY2K(idtFechaGene);
    -- Valida que la fecha de generacion de cuentas se encuentre entre las
    -- fechas de movimientos del periodo
    if (trunc(idtFechaGene) < trunc(rcPerifactCurr.pefafimo) or
       trunc(idtFechaGene) > trunc(rcPerifactCurr.pefaffmo)) then
      pkg_error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuDATE_OUT_OF_RANGE||'-'||csbDATE_OUT_OF_RANGE);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValGenerationDate;
  /*
      Propiedad intelectual de Open International Systems. (c).
      Function  : fnuGetAccountNumber
      Descripcion : Obtiene el numero de la cuenta de cobro que
        se va a usar para el servicio suscrito
        Get Account Number
      Parametros  :   Descripcion
      Retorno :
    Numero de la cuenta a usar
      Autor : Carlos Alberto Quintero
      Fecha : Octubre 28 del 2003
      Historia de Modificaciones
      Fecha ID Entrega
      19-Mar-2009 jgtorresSAO91523
      Se aplica un bloque de transaccion autonomo para evitar interbloqueos.
      28-oct-2003 cquinteroSAO25219
      Creacion
  */
  FUNCTION fnuGetAccountNumber RETURN number IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnuGetAccountNumber'; --Nombre del método en la traza
    -- Numero de cuenta
    nuCta cuencobr.cucocodi%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Obtiene el numero de la cuenta del consecutivo
    pkAccountMgr.GetNewAccountNum(nuCta);
    -- Cerramos el bloque autonomo
    pkgeneralservices.CommitTransaction;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return(nuCta);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END fnuGetAccountNumber;


  PROCEDURE CalcAdjustValue(inuFactor      in timoempr.tmemfaaj%type,
                            inuValorCta    in cuencobr.cucovato%type,
                            onuValorAjuste out cargos.cargvalo%type,
                            osbSignoAjuste out cargos.cargsign%type) IS
    csbMetodo     CONSTANT VARCHAR2(100) := csbNOMPKG||'CalcAdjustValue'; --Nombre del método en la traza
    nuValor       cuencobr.cucovato%type; -- Valor absoluto cuenta
    nuVlrAAjustar number; -- Valor que se va a ajustar
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    onuValorAjuste := pkBillConst.CERO;
    osbSignoAjuste := null;
    nuValor        := inuValorCta;
    -- Valida el valor de la cuenta
    if (nuValor = 0.00 or nuValor is null) then
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return;
    end if;
    -- Evalua si el valor de la cuenta es negativo
    if (nuValor < 0.00) then
      nuValor := abs(nuValor);
    end if;
    -- Obtiene residuo del valor de la cuenta vs el factor de ajuste
    nuVlrAAjustar := mod(nuValor, inuFactor);
    -- En caso de que no haya valor desajustado, retorna
    if (nuVlrAAjustar = 0.00) then
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return;
    end if;
    -- Evalua si el ajuste es por encima o por debajo, comparando contra
    -- la mitad del factor de ajuste
    if ((inuFactor - nuVlrAAjustar) > (inuFactor / 2)) then
      onuValorAjuste := nuVlrAAjustar;
      osbSignoAjuste := pkBillConst.CREDITO;
    else
      onuValorAjuste := inuFactor - nuVlrAAjustar;
      osbSignoAjuste := pkBillConst.DEBITO;
    end if;
    -- Verifica si el Valor Total de la Cuenta es Negativo
    -- para invertir el Signo del cargo de Ajuste
    if (inuValorCta < 0.00) then
      if (osbSignoAjuste = pkBillConst.DEBITO) then
        osbSignoAjuste := pkBillConst.CREDITO;
      else
        osbSignoAjuste := pkBillConst.DEBITO;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END CalcAdjustValue;

  PROCEDURE GenerateCharge(inuConcepto  in cargos.cargconc%type,
                           inuVlrCargo  in cargos.cargvalo%type,
                           isbSigno     in cargos.cargsign%type,
                           isbDocumento in cargos.cargdoso%type,
                           isbTipoProc  in cargos.cargtipr%type,
                           inuConsDocu  in cargos.cargcodo%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GenerateCharge'; --Nombre del método en la traza
    -- Record del cargo
    rcCargo cargos%rowtype;
    ------------------------------------------------------------------------
    -- Procedimientos Encapsulados
    ------------------------------------------------------------------------
    PROCEDURE FillRecord IS
      csbSubmtd   CONSTANT VARCHAR2(100) := csbMetodo||'.FillRecord'; --Nombre del método en la traza
      rcCargoNull cargos%rowtype;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      rcCargo := rcCargoNull;
      rcCargo.cargcuco := nuCuenta;
      rcCargo.cargnuse := rcSeSuCurr.sesunuse;
      rcCargo.cargpefa := rcPerifactCurr.pefacodi;
      rcCargo.cargconc := inuConcepto;
      rcCargo.cargcaca := FA_BOChargeCauses.fnuGenericChCause(pkConstante.NULLNUM);
      rcCargo.cargsign := isbSigno;
      rcCargo.cargvalo := inuVlrCargo;
      rcCargo.cargdoso := isbDocumento;
      rcCargo.cargtipr := isbTipoProc;
      rcCargo.cargfecr := dtFechaCurrent;
      rcCargo.cargcodo := inuConsDocu;
      rcCargo.cargunid := null;
      rcCargo.cargcoll := null;
      rcCargo.cargprog := ge_bcProcesos.frcprograma(sbApplication).proccons;
      rcCargo.cargusua := sa_bosystem.getSystemUserID;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when LOGIN_DENIED OR PKG_ERROR.CONTROLLED_ERROR then
          pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
          RAISE PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
          pkg_error.setError;
          pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
          RAISE PKG_ERROR.CONTROLLED_ERROR;
    END FillRecord;
    ------------------------------------------------------------------------
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Prepara record del Cargo
    FillRecord;
    -- Adiciona el Cargo
    pktblCargos.InsRecord(rcCargo);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END GenerateCharge;

  /*
      Propiedad intelectual de Open International Systems. (c).
      Procedure : UpdateAccoRec
      Descripcion : Actualizacion de cartera
        Realiza la actualizacion de cartera, bajando las
        actualizaciones a la base de datos y obtiene los
        valores actualizados en variables de memoria
        [para optimizacion de accesos a base de datos]
        Update Account Receivable
      Parametros  :   Descripcion
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : Noviembre 05 del 2003
      Historia de Modificaciones
      Fecha ID Entrega
      05-nov-2003 cquinteroSAO25352
      Creacion
  */
  PROCEDURE UpdateAccoRec IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'UpdateAccoRec'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Actualiza la cartera
    pkUpdAccoReceiv.UpdateData;
    -- Obtiene valores de la cuenta de cobro
    pkUpdAccoReceiv.GetAccountData(nuCuenta,
                                   nuCart_ValorCta,
                                   nuCart_AbonoCta,
                                   nuCart_SaldoCta);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END UpdateAccoRec;

  PROCEDURE AdjustAccount IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AdjustAccount'; --Nombre del método en la traza
    nuValorCta    cuencobr.cucovato%type; -- Valor total cuenta
    nuVlrAjustes  number; -- Suma ajustes previos Cta
    sbSignoAjuste cargos.cargsign%type; -- Signo ajuste
    nuVlrAjuste   cargos.cargvalo%type; -- Valor ajuste
    sbSignCanc    cargos.cargsign%type; -- Signo de cancelacion ajuste
    -- Evaluacion si se deben o no ajustar las cuentas de acuerdo a la
    -- configuracion realizada en los parametros de facturacion
    boAjustarCuentas boolean;
    -- Factor de ajuste de cuenta
    nuFactorAjusteCta timoempr.tmemfaaj%type;
    -----------------------------------------------------------------------
    -- Procedimientos Encapsulados
    -----------------------------------------------------------------------
    -- --------------------------------------------------------------------
    --  Evalua si el valor necesita o no ajuste
    -- --------------------------------------------------------------------
    FUNCTION fblNeedAdjust(inuValorCta in cuencobr.cucovato%type)
      RETURN boolean IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.fblNeedAdjust'; --Nombre del método en la traza
      nuValor       cuencobr.cucovato%type; -- Valor absoluto cuenta
      nuVlrAAjustar cuencobr.cucovato%type; -- Valor a ajustar
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      nuValor := inuValorCta;
      -- Valida el valor de la cuenta
      if (nuValor = 0.00 or nuValor is null) then
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
        return(FALSE);
      end if;
      -- Obtiene residuo del valor de la cuenta vs el factor de ajuste
      nuVlrAAjustar := mod(abs(nuValor), nuFactorAjusteCta);
      -- En caso de que no haya valor desajustado, retorna
      if (nuVlrAAjustar = 0.00) then
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
        return(FALSE);
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return(TRUE);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        RAISE PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_error.setError;
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        RAISE PKG_ERROR.CONTROLLED_ERROR;
    END fblNeedAdjust;
    -- --------------------------------------------------------------------
    --  Adiciona cargo de ajuste
    -- --------------------------------------------------------------------
    PROCEDURE AddCharge(inuVlrCargo in cargos.cargvalo%type,
                        isbSigno    in cargos.cargsign%type,
                        isbDocSop   in cargos.cargdoso%type) IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.fnuGetSaldoProducto'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Adiciona el Cargo
      GenerateCharge(nuConcAjuste,
                     abs(inuVlrCargo),
                     isbSigno,
                     isbDocSop,
                     pkBillConst.AUTOMATICO,
                     0);
      -- Actualiza cartera
      pkUpdAccoReceiv.UpdAccoRec(pkBillConst.cnuSUMA_CARGO,
                                 nuCuenta,
                                 rcSuscCurr.susccodi,
                                 rcSeSuCurr.sesunuse,
                                 nuConcAjuste,
                                 isbSigno,
                                 abs(inuVlrCargo),
                                 pkBillConst.cnuNO_UPDATE_DB);
      UpdateAccoRec;
      -- Actualiza el acumulado de los valores facturados
      if (isbSigno = pkBillConst.DEBITO) then
        -- Cargo debito
        nuVlrFactCta := nuVlrFactCta + abs(inuVlrCargo);
        nuVlrFactFac := nuVlrFactFac + abs(inuVlrCargo);
      else
        -- Cargo credito
        nuVlrFactCta := nuVlrFactCta - abs(inuVlrCargo);
        nuVlrFactFac := nuVlrFactFac - abs(inuVlrCargo);
      end if;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
         pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
         RAISE PKG_ERROR.CONTROLLED_ERROR;
      when others then
         pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
         RAISE PKG_ERROR.CONTROLLED_ERROR;
    END AddCharge;
    ------------------------------------------------------------------------
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Obtiene validacion ajuste a la cuenta
    FA_BOPoliticaRedondeo.ObtienePoliticaAjuste(rcSeSuCurr.sesususc,
                                                boAjustarCuentas,
                                                nuFactorAjusteCta);
    -- Evalua si se debe realizar ajuste, de acuerdo a los parametros
    if (not boAjustarCuentas) then
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return;
    end if;
    -- Obtiene el valor de la cuenta actualizado
    nuValorCta := nuCart_ValorCta;
    -- Evalua si necesita ajuste
    if (not fblNeedAdjust(nuValorCta)) then
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return;
    end if;
    -- Obtiene el valor de los ajustes realizados a la cuenta
    nuVlrAjustes := fnuGetAdjustValue;
    -- Evalua si debe cancelar ajustes previos
    if (nuVlrAjustes != 0.00) then
      -- Obtiene signo de cancelacion de cargo ajuste
      sbSignCanc := pkChargeMgr.fsbGetCancelSign(nuVlrAjustes);
      -- Crea cargo de cancelacion
      AddCharge(nuVlrAjustes, sbSignCanc, pkBillConst.csbDOC_CANC_AJUSTE);
    end if;
    -- Obtiene el valor de la cuenta actualizado
    nuValorCta := nuCart_ValorCta;
    -- Calcula el valor y signo del nuevo ajuste
    CalcAdjustValue(nuFactorAjusteCta,
                    nuValorCta,
                    nuVlrAjuste,
                    sbSignoAjuste);
    -- Evalua si se debe adicionar cargo
    if (nuVlrAjuste = 0.00) then
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      return;
    end if;
    -- Crea cargo con el nuevo ajuste
    AddCharge(nuVlrAjuste, sbSignoAjuste, pkBillConst.csbDOC_AJUSTE);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END AdjustAccount;


  PROCEDURE AddAccount IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AddAccount'; --Nombre del método en la traza
    rcCuenta cuencobr%rowtype; -- Record de cuenta de cobro
    ----------------------------------------------------------------------
    -- METODOS ENCAPSULADOS
    ----------------------------------------------------------------------
    PROCEDURE FillRecord IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.FillRecord'; --Nombre del método en la traza
      rcCuenCobrNull cuencobr%rowtype; -- Record Nulo Cuenta
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      rcCuenta := rcCuenCobrNull;
      -- Se prepara el registro de la Cuenta de Cobro
      -- Ya se tiene current la cuenta de cobro
      rcCuenta.cucocodi := nuCuenta;
      rcCuenta.cucogrim := 99;
      rcCuenta.cucovaap := pkBillConst.CERO;
      rcCuenta.cucovare := pkBillConst.CERO;
      rcCuenta.cucocate := rcSeSuCurr.sesucate;
      rcCuenta.cucosuca := rcSeSuCurr.sesusuca;
      rcCuenta.cucoplsu := rcSeSuCurr.sesuplfa;
      rcCuenta.cucovato := pkBillConst.CERO;
      rcCuenta.cucovaab := pkBillConst.CERO;
      rcCuenta.cucovafa := pkBillConst.CERO;
      rcCuenta.cucoimfa := pkBillConst.CERO;
      rcCuenta.cucofepa := null;
      rcCuenta.cucosacu := pkBillConst.CERO;
      rcCuenta.cucovrap := pkBillConst.CERO;
      rcCuenta.cuconuse := rcSeSuCurr.sesunuse;
      rcCuenta.cucofact := nuEstadoCuenta;
      rcCuenta.cucofaag := nuEstadoCuenta;
      rcCuenta.cucofeve := pkSubsDateLineMgr.fdtGetDateLine(rcSeSuCurr.sesususc,
                                                            rcPerifactCurr.pefaano,
                                                            rcPerifactCurr.pefames,
                                                            rcPerifactCurr.pefafepa);
      -- Se obtiene la direccion de instalacion del producto
      rcCuenta.cucodiin := pkg_bcproducto.fnuiddireccinstalacion(rcSeSuCurr.sesunuse);
      rcCuenta.cucosist := rcSeSuCurr.sesusist;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
          pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
          RAISE PKG_ERROR.CONTROLLED_ERROR;
      when others then
         pkg_error.setError;
         pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
         RAISE PKG_ERROR.CONTROLLED_ERROR;
    END FillRecord;
    ----------------------------------------------------------------------
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Se prepara el registro de la Cuenta de Cobro
    FillRecord;
    -- Se adiciona el registro a la tabla Cuencobr
    pktblCuencobr.InsRecord(rcCuenta);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END AddAccount;


  PROCEDURE UpdAccoBillValues IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'UpdAccoBillValues'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pktblCuencobr.UpBilledValues(nuCuenta, nuVlrFactCta, nuVlrIvaFactCta);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END UpdAccoBillValues;

  PROCEDURE ProcessGeneratedAcco IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcessGeneratedAcco'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Genera Ajuste de la cuenta
    AdjustAccount;
    -- Genera posible saldo a favor
    pkAccountMgr.GenPositiveBal(nuCuenta);
    -- Aplica saldo a favor
    -- Actualiza acumulados de facturacion por cuenta
    UpdAccoBillValues;
    -- Obtiene saldo pendiente de la factura
    nuSaldoFac := pkBCAccountStatus.fnuGetBalance(nuEstadoCuenta);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ProcessGeneratedAcco;


  PROCEDURE UpdateCharges IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'UpdateCharges'; --Nombre del método en la traza
    -- Colecciones temporales para almacenar la informacion de los cargos que se
    -- estan actualizando
    tbCargnuse pktblCargos.tyCargnuse;
    tbCargconc pktblCargos.tyCargconc;
    tbCargvalo pktblCargos.tyCargvalo;
    tbCargvabl pktblCargos.tyCargvabl;
    tbCargsign pktblCargos.tyCargsign;
    tbCargcaca pktblCargos.tyCargcaca;
    tbCargdoso pktblCargos.tyCargdoso;
    tbCargfecr pktblCargos.tyCargfecr;
    tbCargnuseNull pktblCargos.tyCargnuse;
    tbCargconcNull pktblCargos.tyCargconc;
    tbCargvaloNull pktblCargos.tyCargvalo;
    tbCargvablNull pktblCargos.tyCargvabl;
    tbCargsignNull pktblCargos.tyCargsign;
    tbCargcacaNull pktblCargos.tyCargcaca;
    tbCargdosoNull pktblCargos.tyCargdoso;
    tbCargfecrNull pktblCargos.tyCargfecr;
    PROCEDURE ClearArrays IS
    BEGIN
      tbCargnuse := tbCargnuseNull;
      tbCargconc := tbCargconcNull;
      tbCargvalo := tbCargvaloNull;
      tbCargvabl := tbCargvablNull;
      tbCargcaca := tbCargcacaNull;
      tbCargsign := tbCargsignNull;
      tbCargdoso := tbCargdosoNull;
      tbCargfecr := tbCargfecrNull;
      tbCargnuse.DELETE;
      tbCargconc.DELETE;
      tbCargvalo.DELETE;
      tbCargvabl.DELETE;
      tbCargcaca.DELETE;
      tbCargsign.DELETE;
      tbCargdoso.DELETE;
      tbCargfecr.DELETE;
    END ClearArrays;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Limpia colecciones temporales
    ClearArrays;
    -- Realiza la actualizacion del cargo
    FORALL nuIndex in tbCargfact.FIRST .. tbCargfact.LAST
      UPDATE cargos
         SET --cargfact = tbCargfact (nuIndex),
             cargcuco = tbCargcuco(nuIndex),
             --cargfeco = tbCargfeco (nuIndex),
             cargtipr = tbCargtipr(nuIndex)
       WHERE rowid = tbRowid(nuIndex)
      RETURNING cargnuse, cargconc, cargvalo, cargvabl, cargsign, cargcaca, cargdoso, cargfecr BULK COLLECT INTO tbcargnuse, tbCargconc, tbCargvalo, tbcargvabl, tbCargsign, tbCargcaca, tbCargdoso, tbcargfecr;
    -- Acumula valores facturados
    for nuIdx in tbCargvalo.FIRST .. tbCargvalo.LAST loop
      -- Evalua si se trata de una cuota de capital de diferido o
      -- una cuota extra para no acumularla como valor facturado
      -- Se evalua ademas que la causa de cargo de los cargos no sea la obtenida
      -- del parametro de causa de cargo por traslado de diferido.
      if (substr(tbCargdoso(nuIdx), 1, 3) = pkBillConst.csbTOKEN_DIFERIDO or
         substr(tbCargdoso(nuIdx), 1, 3) =
         pkBillConst.csbTOKEN_CUOTA_EXTRA or
         FA_BOChargeCauses.fboIsDefTransChCause(tbCargcaca(nuIdx))) then
        goto PROXIMO;
      end if;
      -- Acumula valores facturados
      if (tbCargsign(nuIdx) = pkBillConst.DEBITO) then
        -- Se acumula el valor facturado de la cuenta de cobro y la factura
        nuVlrFactCta := nuVlrFactCta + tbCargvalo(nuIdx);
        nuVlrFactFac := nuVlrFactFac + tbCargvalo(nuIdx);
        -- Se obtiene la informacion del concepto para determinar si se trata
        -- de un concepto de impuesto
        if (pkConceptMgr.fblIsTaxesConcept(tbCargconc(nuIdx))) then
          -- Se acumula el valor del IVA facturado para la cuenta de cobro
          nuVlrIvaFactCta := nuVlrIvaFactCta + tbCargvalo(nuIdx);
          -- Se acumula el valor del IVA facturado para la factura
          nuVlrIvaFactFac := nuVlrIvaFactFac + tbCargvalo(nuIdx);
        else
          -- Se acumula el valor del IVA facturado para la cuenta de cobro
          nuVlrIvaFactCta := nuVlrIvaFactCta +
                             FA_BOIVAModeMgr.fnuGetValueIVA(tbCargnuse(nuIdx),
                                                            tbCargconc(nuIdx),
                                                            nvl(tbCargvabl(nuIdx),
                                                                tbCargvalo(nuIdx)),
                                                            tbCargfecr(nuIdx));
          -- Se acumula el valor del IVA facturado para la factura
          nuVlrIvaFactFac := nuVlrIvaFactFac +
                             FA_BOIVAModeMgr.fnuGetValueIVA(tbCargnuse(nuIdx),
                                                            tbCargconc(nuIdx),
                                                            nvl(tbCargvabl(nuIdx),
                                                                tbCargvalo(nuIdx)),
                                                            tbCargfecr(nuIdx));
        end if;
      else
        -- Se acumula el valor facturado de la cuenta de cobro y la factura
        nuVlrFactCta := nuVlrFactCta - tbCargvalo(nuIdx);
        nuVlrFactFac := nuVlrFactFac - tbCargvalo(nuIdx);
        -- Se obtiene la informacion del concepto para determinar si se trata
        -- de un concepto de impuesto
        if (pkConceptMgr.fblIsTaxesConcept(tbCargconc(nuIdx))) then
          -- Se acumula el valor del IVA facturado para la cuenta de cobro
          nuVlrIvaFactCta := nuVlrIvaFactCta - tbCargvalo(nuIdx);
          -- Se acumula el valor del IVA facturado para la factura
          nuVlrIvaFactFac := nuVlrIvaFactFac - tbCargvalo(nuIdx);
        else
          -- Se acumula el valor del IVA facturado para la cuenta de cobro
          nuVlrIvaFactCta := nuVlrIvaFactCta -
                             FA_BOIVAModeMgr.fnuGetValueIVA(tbCargnuse(nuIdx),
                                                            tbCargconc(nuIdx),
                                                            nvl(tbCargvabl(nuIdx),
                                                                tbCargvalo(nuIdx)),
                                                            tbCargfecr(nuIdx));
          -- Se acumula el valor del IVA facturado para la factura
          nuVlrIvaFactFac := nuVlrIvaFactFac -
                             FA_BOIVAModeMgr.fnuGetValueIVA(tbCargnuse(nuIdx),
                                                            tbCargconc(nuIdx),
                                                            nvl(tbCargvabl(nuIdx),
                                                                tbCargvalo(nuIdx)),
                                                            tbCargfecr(nuIdx));
        end if;
      end if;
      <<PROXIMO>>
      null;
    end loop;
    -- Limpia colecciones temporales
    ClearArrays;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END UpdateCharges;


  PROCEDURE GenerateAccount IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GenerateAccount'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Define cuenta para el servicio suscrito
    nuCuenta := fnuGetAccountNumber;
    AddAccount;
    -- Se pudo generar la cuenta
    boCuentaGenerada := TRUE;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      boCuentaGenerada := FALSE;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      boCuentaGenerada := FALSE;
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END GenerateAccount;


  PROCEDURE AddAccountStatus IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AddAccountStatus'; --Nombre del método en la traza
    rcEstadoCta factura%rowtype := NULL; -- Record de Estado de cuenta
    ----------------------------------------------------------------------
    -- METODOS ENCAPSULADOS
    ----------------------------------------------------------------------
    PROCEDURE FillNewRecord IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.fnuGetSaldoProducto'; --Nombre del método en la traza
      rcEstadoCtaNull factura%rowtype := NULL; -- Record Nulo Estado Cuenta
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      rcEstadoCta := rcEstadoCtaNull;
      -- Se prepara el registro del Estado de Cuenta
      -- Estado de cuenta current
      rcEstadoCta.factcodi := nuEstadoCuenta;
      -- Suscripcion current
      rcEstadoCta.factsusc := rcSuscCurr.susccodi;
      rcEstadoCta.factvaap := pkBillConst.CERO;
      rcEstadoCta.factpefa := rcPerifactCurr.pefacodi;
      -- Dejar current sysdate en esta variable
      rcEstadoCta.factfege := dtFechaGene;
      rcEstadoCta.factterm := sbTerminal;
      rcEstadoCta.factusua := sa_bosystem.getSystemUserID;
      -- Se obtiene la direccion de cobro
      rcEstadoCta.factdico := rcSuscCurr.susciddi;
      rcEstadoCta.factprog := ge_bcProcesos.frcprograma(sbApplication)
                              .proccons;
      -- La numeracion fiscal pasa a ser asignada despues de aceptar
      -- y ser creada la factura y todo su proceso
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
          pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
          RAISE PKG_ERROR.CONTROLLED_ERROR;
      when OTHERS then
          pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
          RAISE PKG_ERROR.CONTROLLED_ERROR;
    END FillNewRecord;
    ----------------------------------------------------------------------
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Se prepara el registro del Estado de cuenta
    FillNewRecord;
    -- guarda informacion de la factura generada
    grcEstadoCta := rcEstadoCta;
    -- Se adiciona el registro a la tabla Factura
    pktblFactura.InsRecord(rcEstadoCta);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END AddAccountStatus;

  /*
      Propiedad intelectual de Open International Systems. (c).
      Function  : fnuGetAccountStNumber
      Descripcion : Obtiene el numero del estado de cuenta que se va a
        usar para la suscripcion
        Get Account Status Number
      Parametros  :   Descripcion
      Retorno :
    Numero del estado de cuenta a usar
      Autor : Carlos Alberto Quintero
      Fecha : Octubre 28 del 2003
      Historia de Modificaciones
      Fecha ID Entrega
      19-Mar-2009 jgtorresSAO91523
      Se aplica un bloque de transaccion autonomo para evitar interbloqueos.
      28-oct-2003 cquinteroSAO25219
      Creacion
  */
  FUNCTION fnuGetAccountStNumber RETURN number IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnuGetAccountStNumber'; --Nombre del método en la traza
    nuEstadoCta factura.factcodi%type; -- Numero estado de cuenta
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Obtiene el numero del estado de cuenta del consecutivo
    pkAccountStatusMgr.GetNewAccoStatusNum(nuEstadoCta);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    -- Cerramos el bloque autonomo
    pkgeneralservices.CommitTransaction;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return(nuEstadoCta);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END fnuGetAccountStNumber;

  /*
      Propiedad intelectual de Open International Systems. (c).
      Procedure : GenerateAccountStatus
      Descripcion : Genera estado de cuenta
        Debe validar que se trate del primer servicio suscrito
        y que se trate del primer cargo, para garantizar de
        que se genere solo un estado de cuenta por suscriptor
        Generate Account Status
      Parametros  :   Descripcion
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : Octubre 28 del 2003
      Historia de Modificaciones
      Fecha ID Entrega
      05-nov-2003 cquinteroSAO25352
      Se crea el estado de cuenta de forma local con AddAccountStatus
      28-oct-2003 cquinteroSAO25219
      Creacion
  */
  PROCEDURE GenerateAccountStatus IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GenerateAccountStatus'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Define estado de cuenta para la suscripcion
    nuEstadoCuenta := fnuGetAccountStNumber;
    -- Adiciona el registro del nuevo estado de cuenta
    AddAccountStatus;
    -- Genero estado de cuenta
    boAccountStGenerado := TRUE;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      boAccountStGenerado := FALSE;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      boAccountStGenerado := FALSE;
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END GenerateAccountStatus;

  /*
      Propiedad intelectual de Open International Systems. (c).
      Procedure : ValSubsService
      Descripcion : Valida el servicio suscrito
        Validate Subscribed Service
      Parametros  :   Descripcion
    inuServsusc Numero del servicio suscrito
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : Octubre 28 del 2003
      Historia de Modificaciones
      Fecha Id Entrega
      03-04-2007 mgutierrSAO57902
      Se valida si esta restringida la generacion de facturas directas por estados
      de corte
      28-oct-2003 cquinteroSAO25219
      Creacion
  */
  PROCEDURE ValSubsService(inuServsusc in servsusc.sesunuse%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValSubsService'; --Nombre del método en la traza
    ----------------------------------------------------------------------------
    -- VerifyProdProcessSecurity -- Valida estados del corte Producto
    ----------------------------------------------------------------------------
    PROCEDURE VerifyProdProcessSecurity(inuSesu servsusc.sesunuse%type) IS
      csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.VerifyProdProcessSecurity'; --Nombre del método en la traza
      sbProc procrest.prreproc%type;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      sbProc := pkg_error.getApplication;
      -- Se valida si el producto tiene restriccion de pago por corte
      pkBOProcessSecurity.ValidateProductSecurity(inuSesu, sbProc);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
      when PKG_ERROR.CONTROLLED_ERROR then
        pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        RAISE PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        RAISE PKG_ERROR.CONTROLLED_ERROR;
    END VerifyProdProcessSecurity;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Realiza la validacion basica del servicio suscrito
    pkServNumberMgr.ValBasicData(inuServsusc);
    VerifyProdProcessSecurity(inuServsusc);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValSubsService;


  /*
      Propiedad intelectual de Open International Systems. (c).
      Procedure : ValSubsNServ
      Descripcion : Valida que producto este ASociado al contrato
        Validate Subscription And Service
      Parametros  :   Descripcion
    inuSubscription    Contrato
    inuServNum         Producto
      Retorno :
      Autor : Carlos Andres Jaramillo
      Fecha : 26-10-2005
      Historia de Modificaciones
      Fecha ID Entrega
      26-10-2005 cjaramilloSAO40597
      Creacion
  */
  PROCEDURE ValSubsNServ(inuSubscription in suscripc.susccodi%type,
                         inuServNum      in servsusc.sesunuse%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValSubsNServ'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkServNumberMgr.ValSubscription(inuSubscription, inuServNum);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValSubsNServ;


  PROCEDURE ProcessCharges(isbDocumento  in cargos.cargdoso%type,
                           iblAllCharges in boolean) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcessCharges'; --Nombre del método en la traza
    -- Tabla de cargos a liquidar
    tbCargos              tytbCargos;
    rcCargos              tyrcCargos;
    tbMaxPericoseConcepto tytbMaxPericoseConcepto;
    nuIdxCargos number;
    -- Registro del servicio
    rcServicio servicio%rowtype;
    -- Fecha de retiro del producto
    dtFechRetProd servsusc.sesufere%type;
    -- Definicion del cursor para la seleccion de los cargos del
    -- servicio suscrito
    CURSOR cuCargos(inuNumServ   servsusc.sesunuse%type,
                    isbDocumento cargos.cargdoso%type) IS
      SELECT /*+ index (cargos ix_carg_nuse_cuco_conc) */
       rowid,
       cargconc,
       cargcaca,
       cargsign,
       cargdoso,
       cargvalo,
       cargfecr,
       cargnuse,
       cargpeco
        FROM cargos
       WHERE cargcuco + 0 = -1
         AND cargnuse = inuNumServ
         AND (INSTR(isbDocumento, '|' || trim(cargdoso) || '|') > 0 OR
             cargdoso = nvl(isbDocumento, cargdoso));
    -- Definicion del cursor para la seleccion de todos los cargos del
    -- servicio suscrito
    CURSOR cuAllCargos(inuNumServ servsusc.sesunuse%type) IS
      SELECT /*+ index (cargos ix_carg_nuse_cuco_conc)*/
       rowid,
       cargconc,
       cargcaca,
       cargsign,
       cargdoso,
       cargvalo,
       cargfecr,
       cargnuse,
       cargpeco
        FROM cargos
       WHERE cargcuco + 0 = -1
         AND cargnuse = inuNumServ;
    -- Indice arreglos de cargos procesados
    nuIdx number;
    -----------------------------------------------------------------------
    -- PROCEDIMIENTOS ENCAPSULADOS
    -----------------------------------------------------------------------
    PROCEDURE CleanChargeArrays IS
       csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.CleanChargeArrays'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      tbCargfact.DELETE;
      tbCargcuco.DELETE;
      tbCargfeco.DELETE;
      tbCargtipr.DELETE;
      tbRowid.DELETE;
      tbCargos.DELETE;
      tbMaxPericoseConcepto.DELETE;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    END CleanChargeArrays;

    -- Procedimiento para inicialiar datos del proceso.
    PROCEDURE Initialize IS
    BEGIN
      -- Obtiene el tipo de producto que se esta liquidando para
      -- realizar obtencion del periodo de consumo de acuerdo
      -- al tipo de cobro (anticipado o vencido)
      rcServicio := pktblservicio.frcGetRecord(rcSeSuCurr.sesuserv);
      -- Se obtiene fecha de retiro del producto
      dtFechRetProd := PKG_BCPRODUCTO.FDTFECHARETIRO(rcSeSuCurr.sesunuse);
    END Initialize;

    PROCEDURE CalcularFechaUltLiqConcepto(inuConcepto concepto.conccodi%type,
                                          inuCargPeco cargos.cargpeco%type) IS
      -- Fecha ultima liquidacion
      dtFechaUltLiq feullico.felifeul%type := null;
      -- Tipo de cobro generado por el concepto
      sbTipoCobro concepto.concticc%type;
      -- Datos del proceso
      nuPeriodoConsumoActual pericose.pecscons%type;
      rcPeriodoConsumoActual pericose%rowtype;
      rcPeriodoConsumoCargo pericose%rowtype;
    BEGIN
      if tbMaxPericoseConcepto.EXISTS(inuConcepto) then
        -- Si el periodo de consumo del cargo es nulo, se respeta el
        -- que se exite en la coleccion.
        if inuCargPeco IS null then
          return;
        END if;
        sbTipoCobro            := tbMaxPericoseConcepto(inuConcepto)
                                  .sbTipoCobro;
        rcPeriodoConsumoActual := tbMaxPericoseConcepto(inuConcepto)
                                  .rcPeriodoConsumo;
      else
        -- Se obtiene el tipo de cobro del concepto
        sbTipoCobro := pktblConcepto.fsbObtTipoCobro(inuConcepto);
        -- Obtiene el periodo de consumo current
        pkBCPericose.GetCacheConsPerByBillPer(rcSeSuCurr.sesucico,
                                              rcPerifactCurr.pefacodi,
                                              nuPeriodoConsumoActual,
                                              rcservicio.servtico, -- Tipo Cobro del Servicio (Anticipado/Vencido)
                                              sbTipoCobro -- Tipo Cobro del Concepto (Consumo/Abono)
                                              );
        -- Se obtiene el registro del periodo de consumo
        rcPeriodoConsumoActual := pktblPericose.frcGetRecord(nuPeriodoConsumoActual);
      END if;
      -- Si periodo de consumo del cargo no es nulo, se debe comparar contra el
      -- actual. Debe quedar seteado como periodo actual el mas viejo.
      if inuCargPeco IS not null then
        rcPeriodoConsumoCargo := pktblPericose.frcGetRecord(inuCargPeco);
        -- Evaluar que perido de consumo es mayor, si el actual o del de cargo
        -- Se debe actualizar feullico con el mayor.
        -- Se evalua el tipo de cobro del concepto
        IF sbTipoCobro = 'C' THEN
          -- Concepto de tipo Consumo
          -- Si la fecha de consumo final del periodo del cargo es mayor a la
          -- del periodo actual, se cambia el periodo de consumo actual por
          -- el del cargo.
          IF (rcPeriodoConsumoCargo.pecsfecf >
             rcPeriodoConsumoActual.pecsfecf) THEN
            rcPeriodoConsumoActual := rcPeriodoConsumoCargo;
          END if;
        ELSE
          -- Concepto de tipo Consumo
          -- Si la fecha de cargo basico final del periodo del cargo es mayor a la
          -- del periodo actual, se cambia el periodo de consumo actual por
          -- el del cargo.
          IF (rcPeriodoConsumoCargo.pecsfeaf >
             rcPeriodoConsumoActual.pecsfeaf) THEN
            rcPeriodoConsumoActual := rcPeriodoConsumoCargo;
          END if;
        end if;
      END if;
      -- Se actualiza o inserta los datos a la coleccion en memoria.
      tbMaxPericoseConcepto(inuConcepto).rcPeriodoConsumo := rcPeriodoConsumoActual;
      tbMaxPericoseConcepto(inuConcepto).sbTipoCobro := sbTipoCobro;
      -- Se debe verificar la fecha final del periodo actual, con la fecha
      -- de retiro del producto. Si la fecha de retiro es menor, se debe
      -- actualizar feullico con esta.
      -- Se evalua el tipo de cobro del concepto
      IF sbTipoCobro = 'C' THEN
        -- Concepto de tipo Consumo
        -- Si el producto se retiro en el periodo se establece esta
        -- fecha como la fecha de ultima liquidacion
        IF (dtFechRetProd < rcPeriodoConsumoActual.pecsfecf) THEN
          tbMaxPericoseConcepto(inuConcepto).dtFechaUltLiq := dtFechRetProd;
        ELSE
          -- de lo contrario se establece la fecha final del periodo
          tbMaxPericoseConcepto(inuConcepto).dtFechaUltLiq := rcPeriodoConsumoActual.pecsfecf;
        end if;
      ELSE
        -- Concepto de tipo Abono
        -- Si el producto se retiro en el periodo se establece esta fecha
        -- como la fecha de ultima liquidacion
        IF dtFechRetProd < rcPeriodoConsumoActual.pecsfeaf THEN
          tbMaxPericoseConcepto(inuConcepto).dtFechaUltLiq := dtFechRetProd;
        ELSE
          -- de lo contrario se establece la fecha final del periodo
          tbMaxPericoseConcepto(inuConcepto).dtFechaUltLiq := rcPeriodoConsumoActual.pecsfeaf;
        end if;
      end if;
    EXCEPTION
      when LOGIN_DENIED or pkConstante.exERROR_LEVEL2 then
        RAISE PKG_ERROR.CONTROLLED_ERROR;
      when others then
        pkg_Error.setError;
        RAISE PKG_ERROR.CONTROLLED_ERROR;
    END CalcularFechaUltLiqConcepto;

    PROCEDURE ActFechaUltFactConceptos IS
      csbSubmtd CONSTANT VARCHAR2(100) := csbNOMPKG||'.ActFechaUltFactConceptos';
      nuConcepto concepto.conccodi%type;
      -- Registro Fecha ultima liquidacion
      rcFeullico feullico%rowtype;
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      nuConcepto := tbMaxPericoseConcepto.first;
      loop
        EXIT WHEN(nuConcepto IS NULL);
        pkg_traza.trace('[Concepto] = ' || nuConcepto ||
                       ' - [Fecha Ult Fact] = ' || tbMaxPericoseConcepto(nuConcepto).dtFechaUltLiq,
                       pkg_traza.cnuNivelTrzDef);
        -- Arma registro fecha ultima Facturacion
        rcFeullico.felisesu := rcSeSuCurr.sesunuse;
        rcFeullico.feliconc := nuConcepto;
        rcFeullico.felifeul := tbMaxPericoseConcepto(nuConcepto)
                               .dtFechaUltLiq;
        -- Evalua si existe registro de fecha de ultima liquidacion
        if (pktblFeullico.fblExist(rcSeSuCurr.sesunuse, nuConcepto)) THEN
          -- Se actualiza registro
          pktblFeullico.UpRecord(rcFeullico);
        else
          -- Se inserta registro por ser la primera vez que se actualiza
          -- fecha de ultima liquidacion
          pktblFeullico.InsRecord(rcFeullico);
        end if;
        nuConcepto := tbMaxPericoseConcepto.NEXT(nuConcepto);
      END loop;
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    END ActFechaUltFactConceptos;
    -----------------------------------------------------------------------
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Inicializa flag
    boCuentaGenerada := FALSE;
    -- Inicializa valor facturado de la cuenta en cero
    nuVlrFactCta := 0;
    -- Inicializa valor impuesto facturado de la cuenta en cero
    nuVlrIvaFactCta := 0;
    nuIdx := 1;
    -- Limpia tablas de cargos
    CleanChargeArrays;
    -- Inicializa variables del proceso.
    Initialize;
    -- Verifica si se deben procesar todos los cargos o solo los asociados a
    -- al documento de soporte.
    if iblAllCharges then
      pkg_traza.trace('Procesando todos los cargos asociados al producto: ' ||
                     rcSeSuCurr.sesunuse,
                     pkg_traza.cnuNivelTrzDef);
      OPEN cuAllCargos(rcSeSuCurr.sesunuse);
      FETCH cuAllCargos bulk collect
        INTO tbCargos;
      CLOSE cuAllCargos;
    else
      pkg_traza.trace('Procesando los cargos asociados al documento: ' ||
                     isbDocumento || ' y al producto ' ||
                     rcSeSuCurr.sesunuse,
                     pkg_traza.cnuNivelTrzDef);
      OPEN cuCargos(rcSeSuCurr.sesunuse, isbDocumento);
      FETCH cuCargos bulk collect
        INTO tbCargos;
      CLOSE cuCargos;
    END if;
    if (tbCargos.count > 0) then
      -- Valida que el producto pertenezca al contrato
      ValSubsNServ(rcSuscCurr.susccodi, rcSeSuCurr.sesunuse);
    END if;
    pkg_traza.trace('Periodo de facturacion actual: ' ||
                   rcPerifactCurr.pefacodi,
                   pkg_traza.cnuNivelTrzDef);
    -- Recorrer tabla de cargos.
    nuIdxCargos := tbCargos.first;
    loop
      EXIT WHEN(nuIdxCargos IS NULL);
      rcCargos := tbCargos(nuIdxCargos);
      pkg_traza.trace('Procesando cargo: [Concepto]=' || rcCargos.cargconc ||
                     ' - [Valor] = ' || rcCargos.cargvalo,
                     pkg_traza.cnuNivelTrzDef);
      -- Genera Estado de cuenta cuando se trata del primer servicio suscrito
      if (not (boAccountStGenerado)) then
        GenerateAccountStatus;
      end if;
      -- Genera cuenta si no se ha generado antes
      if (not (boCuentaGenerada)) then
        GenerateAccount;
      end if;
      -- Actualiza Cartera
      pkUpdAccoReceiv.UpdAccoRec(pkBillConst.cnuSUMA_CARGO,
                                 nuCuenta,
                                 pkg_bcproducto.fnucontrato(rcCargos.cargnuse), --  rcCargos.cargsusc,
                                 rcCargos.cargnuse,
                                 rcCargos.cargconc,
                                 rcCargos.cargsign,
                                 rcCargos.cargvalo,
                                 pkBillConst.cnuNO_UPDATE_DB);
      -- Almacena informacion del cargo procesado
      tbCargfact(nuIdx) := nuEstadoCuenta;
      tbCargcuco(nuIdx) := nuCuenta;
      tbCargfeco(nuIdx) := dtFechaContable;
      tbCargtipr(nuIdx) := pkBillConst.AUTOMATICO;
      tbRowid(nuIdx) := rcCargos.sbrowid;
      nuIdx := nuIdx + 1;
      CalcularFechaUltLiqConcepto(rcCargos.cargconc, rcCargos.cargpeco);
      nuIdxCargos := tbCargos.NEXT(nuIdxCargos);
    END loop;
    -- Actualiza los Cargos
    if (nuIdx > 1) then
      -- Actualiza el Cargo current
      UpdateCharges;
      -- Actualiza fecha de ultima facturacion del concepto.
      ActFechaUltFactConceptos;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      IF (cuCargos%isOpen) THEN
        CLOSE cuCargos;
      END IF;
      IF (cuAllCargos%isOpen) THEN
        CLOSE cuAllCargos;
      END IF;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      IF (cuCargos%isOpen) THEN
        CLOSE cuCargos;
      END IF;
      IF (cuAllCargos%isOpen) THEN
        CLOSE cuAllCargos;
      END IF;
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ProcessCharges;


  PROCEDURE AsignaNumeracionFiscal IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'AsignaNumeracionFiscal'; --Nombre del método en la traza
    ------------------------------------------------------------------------
    -- Variables
    ------------------------------------------------------------------------
    -- Tipo de comprobante
    nuTipoComprobante tipocomp.ticocodi%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Se asigna el tipo de documento
    grcEstadoCta.factcons := gnuTipoDocumento;
    -- Se obtiene el numero fiscal
    pkConsecutiveMgr.GetFiscalNumber(pkConsecutiveMgr.gcsbTOKENFACTURA,
                                     grcEstadoCta.factcodi,
                                     null,
                                     grcEstadoCta.factcons,
                                     rcSuscCurr.suscclie,
                                     rcSuscCurr.suscsist,
                                     grcEstadoCta.factnufi,
                                     grcEstadoCta.factpref,
                                     grcEstadoCta.factconf,
                                     nuTipoComprobante);
    -- Se actualiza la factura
    pktblFactura.UpFiscalNumber(grcEstadoCta.factcodi,
                                grcEstadoCta.factnufi,
                                grcEstadoCta.factcons,
                                grcEstadoCta.factconf,
                                grcEstadoCta.factpref);
    -- Se limpia el registro global de factura
    grcEstadoCta := null;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when OTHERS then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END AsignaNumeracionFiscal;

  /*
      Propiedad intelectual de Open International Systems. (c).
      Procedure : ProcessSubsServices
      Descripcion : Procesa los servicios suscritos de la suscripcion
        Process Subscribe Services
      Parametros  :   Descripcion
    inuServsusc Numero del servicio suscrito
    isbDocumento  Documento de soporte
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : Octubre 28 del 2003
      Historia de Modificaciones
      Fecha ID Entrega
      13-09-2012  abermudezSAO190879
      Se elimina la obtencion de la causa de cargo de traslado de diferidos
      10-07-2012  abermudezSAO184484
      Se modifica para obtener la causa configurada para el proceso de traslado
      de diferido.
      02-06-2009  SBlancoSAO93608
      Se modifica para que no se asuma por defecto que no hay estado de cuenta
      generada
      11-12-2007  mriveraSAO69066
      Nivelacion del en branch SAO62251 correspondiente a la implementacion del
      manejo de los impuestos como concepto. Se adiciona la liquidacion del
      impuesto antes de procesar el producto
      29-06-2007  lgarciaSAO62251
      Se adiciona la liquidacion del impuesto antes de procesar el producto.
      05-nov-2003 cquinteroSAO25352
      Cambia la forma de actulizar cartera (obtiene informacion de memoria)
      28-oct-2003 cquinteroSAO25219
      Creacion
  */
  PROCEDURE ProcessSubsServices(inuServsusc   in servsusc.sesunuse%type,
                                isbDocumento  in cargos.cargdoso%type,
                                iblAllCharges in boolean) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcessSubsServices'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Busca informacion del servicio suscrito
    rcSeSuCurr := pktblServsusc.frcGetRecord(inuServsusc);
    -- Liquida el impuesto de cargos a la -1
    pkBOLiquidateTax.LiqTaxValue(rcSeSuCurr, rcPeriFactCurr, isbDocumento);
    -- Procesa los cargos del servicio suscrito
    ProcessCharges(isbDocumento, iblAllCharges);
    -- Verifica si se genero nueva cuenta
    if (boCuentaGenerada) then
      -- Actualiza cartera
      UpdateAccoRec;
      -- Procesa la cuenta generada
      ProcessGeneratedAcco;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ProcessSubsServices;


  /*
      Propiedad intelectual de Open International Systems. (c).
      Procedure : UpdateAccoRec
      Descripcion : Actualizacion de cartera
        Realiza la actualizacion de cartera, bajando las
        actualizaciones a la base de datos y obtiene los
        valores actualizados en variables de memoria
        [para optimizacion de accesos a base de datos]
        Update Account Receivable
      Parametros  :   Descripcion
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : Noviembre 05 del 2003
      Historia de Modificaciones
      Fecha ID Entrega
      05-nov-2003 cquinteroSAO25352
      Creacion
  */
  PROCEDURE GenProcess(inuSuscripcion in suscripc.susccodi%type,
                       inuServsusc    in servsusc.sesunuse%type,
                       isbDocumento   in cargos.cargdoso%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GenProcess'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Inicializa las tablas de memoria en el actualiza cartera,
    -- destruye el cache
    pkUpdAccoReceiv.ClearMemTables;
    -- Por defecto, no se ha generado estado de cuenta
    boAccountStGenerado := FALSE;
    -- Elimina tabla de hash para que sea borrada por cada suscripcion
    pkExtendedHash.SetInitVar(TRUE);
    -- Procesa los servicios suscritos
    ProcessSubsServices(inuServsusc, isbDocumento, FALSE);
    -- Aqui se realiza la numeracion fiscal
    if (boAccountStGenerado) then
      AsignaNumeracionFiscal;
    END if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END GenProcess;

  PROCEDURE ValSubscriber(inuSuscripcion in suscripc.susccodi%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValSubscriber'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Realiza la validacion basica de la suscripcion
    pkSubscriberMgr.ValBasicData(inuSuscripcion);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValSubscriber;

  /*
      Propiedad intelectual de Open International Systems. (c).
      Procedure : ValSupportDoc
      Descripcion : Valida que el documento de soporte no sea nulo
        Validate Support Document
      Parametros  :   Descripcion
    isbDocumento  Documento de soporte
      Retorno :
      Autor : Carlos Alberto Quintero
      Fecha : Octubre 28 del 2003
      Historia de Modificaciones
      Fecha ID Entrega
      28-oct-2003 cquinteroSAO25219
      Creacion
  */
  PROCEDURE ValSupportDoc(isbDocumento in cargos.cargdoso%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValSupportDoc'; --Nombre del método en la traza
    -- Error en el documento soporte
    cnuERROR_DOCSOP constant number := 11517;
    csbERROR_DOCSOP CONSTANT VARCHAR2(100) := 'El documento del cupon no debe estar nulo';

  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (isbDocumento is null) then
        Pkg_Error.setErrorMessage(PKG_ERROR.CNUGENERIC_MESSAGE,cnuERROR_DOCSOP||'-'||csbERROR_DOCSOP);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValSupportDoc;


  PROCEDURE ValInputData(inuSuscripcion in suscripc.susccodi%type,
                         inuServsusc    in servsusc.sesunuse%type,
                         isbDocumento   in cargos.cargdoso%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValInputData'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace('',pkg_traza.cnuNivelTrzDef);
    -- Valida la suscripcion
    ValSubscriber(inuSuscripcion);
    -- Valida el servicio suscrito
    ValSubsService(inuServsusc);
    -- Valida que el producto pertenezca al contrato
    ValSubsNServ(inuSuscripcion, inuServsusc);
    -- Valida el documento soporte
    ValSupportDoc(isbDocumento);
    -- Valida la fecha de generacion
    ValGenerationDate(dtFechaGene);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ValInputData;

  PROCEDURE GetParameters IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetParameters'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Valida Concepto de Ajuste
    pkBillingParamMgr.GetAdjustConcept(nuConcAjuste);
    -- Obtiene concepto de pago
    pkBillingParamMgr.GetPaymentConc(nuConcPago);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_Error.setError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END GetParameters;

  PROCEDURE GenerateBySuppDoc(inuSubscription    IN suscripc.susccodi%type,
                              inuServNumber      IN servsusc.sesunuse%type,
                              isbDocumentSupport IN cargos.cargdoso%type,
                              onuInvoice         OUT factura.factcodi%type,
                              onuAccount         OUT cuencobr.cucocodi%type,
                              onuBalanceInvoice  OUT pkbcfactura.styfactspfa,
                              onuErrorCode       OUT GE_ERROR_LOG.ERROR_LOG_ID%TYPE,
                              osbErrorMessage    OUT GE_ERROR_LOG.DESCRIPTION%TYPE) IS
        csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GenerateBySuppDoc'; --Nombre del método en la traza
    /* ***************************************************************** */
    /* ********           Procedimientos Encapsulados           ******** */
    /* ***************************************************************** */
    PROCEDURE Initialize IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.Initialize'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Fija la Aplicacion en una variable global del paquete
      sbApplication := csbPROGRAMA;
      pkg_error.SetApplication(sbApplication);
      -- Fecha de Generacion de la Cuenta
      dtFechaGene := sysdate;
      dtFechaCurrent := sysdate;
      sbTerminal     := pkGeneralServices.fsbGetTerminal;
      -- Asigna el Cupon de Pago
      gnuCouponPayment := NULL;
      -- Fecha Contable
      dtFechaContable := ldc_boconsgenerales.fdtgetsysdate;
      -- Asigna tipo de documento Tipo de Documento
      gnuTipoDocumento := GE_BOConstants.fnuGetDocTypeCons;
      -- Inicializa Codigos de Documentos
      nuEstadoCuenta := NULL;
      nuCuenta       := NULL;
      -- Inicializa Saldo Pendiente de la Factura
      nuSaldoFac := NULL;
      -- Valores Facturados en la Cuenta de Cobro
      nuVlrFactCta    := 0;
      nuVlrIvaFactCta := 0;
      -- Valores facturados en el Estado de Cuenta
      nuVlrFactFac    := 0;
      nuVlrIvaFactFac := 0;
      -- Inicializa tabla de memoria de parametros
      pkBillFuncParameters.InitMemTable;
      -- Habilita manejo de cache para parametros
      pkGrlParamExtendedMgr.SetCacheOn;
      -- Inicializa parametros de salida
      onuInvoice        := NULL;
      onuAccount        := NULL;
      onuBalanceInvoice := NULL;
      -- Por defecto no se ha generado Estado de Cuenta ni Cuenta de Cobro
      boAccountStGenerado := FALSE;
      boCuentaGenerada    := FALSE;
      -- Inicializa variables de Error
      onuErrorCode    := 0;
      osbErrorMessage := '-';
      -- Obtiene el record de la suscripcion
      rcSuscCurr := pktblSuscripc.frcGetRecord(inuSubscription);
      -- Obtiene record de periodo de facturacion current
      rcPeriFactCurr := pkBillingPeriodMgr.frcGetAccCurrentPeriod(rcSuscCurr.susccicl);
      pkg_traza.trace(csbSubmtd,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    END Initialize;
    /******************************************************************/
    PROCEDURE ClearMemory IS
        csbSubmtd  CONSTANT VARCHAR2(100) := csbMetodo||'.ClearMemory'; --Nombre del método en la traza
    BEGIN
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
      -- Limpia la memoria cache que usa el package
      pktblParafact.ClearMemory;
      pktblSistema.ClearMemory;
      pktblConsecut.ClearMemory;
      pktblCuencobr.ClearMemory;
      pktblFactura.ClearMemory;
      pktblSuscripc.ClearMemory;
      pktblServsusc.ClearMemory;
      pktblConcepto.ClearMemory;
      pktblParametr.ClearMemory;
      pktblMensaje.ClearMemory;
      pktblPerifact.ClearMemory;
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    END ClearMemory;
    /* -------------------------------------------------------------- */
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    -- Inicializa variables
    Initialize;
    -- Limpia memoria
    ClearMemory;
    -- Valida los parametros necesarios para el proceso
    GetParameters;
    -- Validalos datos de entrada
    ValInputData(inuSubscription,
                 inuServNumber,
                 nvl(isbDocumentSupport, '-'));
    -- Ejecuta el proceso de generacion de Factura por Venta Directa
    GenProcess(inuSubscription, inuServNumber, isbDocumentSupport);
    -- Asigna el numero de la Cuenta y el Estado de Cuenta
    onuInvoice := nuEstadoCuenta;
    onuAccount := nuCuenta;
    -- Asigna saldo de la Factura
    onuBalanceInvoice := nuSaldoFac;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when LOGIN_DENIED then
      pkg_error.getError(onuErrorCode,osbErrorMessage);
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
    when others then
      pkg_Error.setError;
      pkg_error.getError(onuErrorCode,osbErrorMessage);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
  END GenerateBySuppDoc;


  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcRenew
  Descripcion    : Proceso que verifica las polizas que hayan cumplido con la
                 fecha de vigencia al momento de ejecucion del proceso y no presenten una solicitud de no renovacion.
  Autor          : AAcuna
  Fecha          : 14/08/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERIC
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                  Cambio DAOR_ORDER.FRCGETRECORD por PKG_BCORDENES.FRCGETRECORD
                                  Cambio PKUTLFILEMGR.FCLOSE por PKG_GESTIONARCHIVOS.PRCCERRARARCHIVO_SMF
                                  Cambio PKUTLFILEMGR.FOPEN por PKG_GESTIONARCHIVOS.FTABRIRARCHIVO_SMF
                                  Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
                                  Cambio UTL_FILE.FILE_TYPE por PKG_GESTIONARCHIVOS.STYARCHIVO
  20/02/2017   KBaquero Caso 200-1054 Se modifica para modificar el campo de comisión para la renovacion
                                      y se ejecuta a travós del proceso GetLiquidationSecurevaluerenew
  12/02/2016    AAcuna SS_100-8096    Se modificara el proceso de renovación de seguros con el fin de evitar que a la hora de ejecución del proceso
                                        no se encuentren productos  que se encuentren en proceso de facturación (cargos con cuenta de cobro -1).
  21-04-2015  KCienfuegos.SAO310516 Se modifica para validar si para la poliza que se va a renovar,
                                    el tipo de poliza esta configurado en LDCTL para la linea de producto.
  26-09-2014  llarrarte.RQ1719    Se elimina validacion de diferidos con saldo
                                  para permitir que la renovacion se ejecute al
                                  termino de la vigencia y no dejar al usuario
                                  sin cobertura hasta el pago de la ultima cuota
                                  antes de la renovacion
                                  Se adiciona numero del colectivo en el XML
  16-09-2014  llarrarte.RQ1178    Se modificar primero el estado de la poliza anterior
                                  para  permitir el registro de la venta de la nueva poliza,
                                  esto debido a que al renovar utilizando la venta
                                  el sistema va a validar la cantidad de polizas activas para la cedula.
                                  Se impacta por adicion de los campos policy_number.
  08/08/2014  AEcheverry.4152     Se elimina la generacion de cargos ya que estos
                                  se registraran en el flujo en la actividad que
                                  genera los diferidos.
  18/07/2014  KCienfuegos.RNP550  Se valida si el tipo de poliza tiene categoria y subcategoria configurada
  01/07/2014  AEcheverry.4031     se valida que el producto no se encuentre en un estdo de retiro voluntario
  27-06-2014  aesguerra.4029      Se incluye validacion para identificar si un producto posee deuda diferida
  01/04/2014  AEcheverrySAO236799 Se modifica para realizar un bloqueo con semaforos
                                  y asi evitar ejecutar al tiempo el proceso
                                  de renovacion de polizas
  28/02/2014  hjgomez.SAO234504   Se modifica para que no genere el saldo a favor y
                                  lo genere luego de crear los diferidos
  21/12/2013  jrobayo.SAO228441   Se modifica para enviar el valor correpondiente a la
                                  poliza para su vigencia actual.
  17/12/2013  JCarmona.SAO227834  Se modifica para enviar en el campo reception_type_id el
                                  medio de recepcion obtenido del parametro COD_REC_TYPE.
  27/11/2013  JCarmona.SAO224868  Se modifica para que genere una solicitud de venta de seguros
                                  para crear la nueva poliza y el registro en ld_secure_sale.
  17/10/2013  JCarmona.SAO220105  Se modifica el procedimiento que obtiene el
                                  numero del diferido <Ld_BcSecureManagement.GetDefferedByPol>,
                                  por lo tanto se modifica el llamado a este metodo para
                                  enviarle el id del producto y no de la poliza.
  06/09/2013  jrobayo.SAO216575   1-  Se modifica para validar si existen solicitudes
                                      de cancelacion de polizas en estado registrado
  03/09/2013  jcarrillo.SAO212983 1 - Se modifica para almacenar el campo que indica
                                      si una poliza es exequial
  03/09/2013  jcarrillo.SAO214425 1 - Se modifica para atender la solicitud de
                                      financiacion
  27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  27-08-2013  jcarrillo.SAO214426 Se modifica por borrado de la constante
                                  <LD_BOConstans.CnuStateOrder>
  ******************************************************************/
  PROCEDURE ProcRenew IS
    csbMetodo            CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcRenew'; --Nombre del método en la traza
    rfCursorPolicy       CONSTANTS_PER.TYREFCURSOR;
    nuNextPolicy         number;
    nuStateRenew         ld_parameter.numeric_value%type;
    nuGeo                ge_geogra_location.geograp_location_id%type;
    nuadd                ab_address.address%type;
    nuOrderPay           ld_parameter.numeric_value%type;
    nuOrderCharge        ld_parameter.numeric_value%type;
    nuorderid            or_order.order_id%type;
    nuorderactivityid    or_order_activity.order_activity_id%type;
    rfPolicy             LD_BOConstans.rfPolicy%type;
    nuPolicy             ld_policy.policy_id%type;
    nuValue              number;
    rcPolicyType         dald_policy_type.styLD_policy_type;
    rcValidityPolicyType dald_validity_policy_type.styLD_validity_policy_type; -- JCASTRO
    nuSolicNoRen         number;
    nuerror              number;
    sbmessage            varchar2(2000);
    /*Variables de archivo de log*/
    sbLog                varchar2(500); -- Log de errores
    sbLineLog            varchar2(1000);
    sbFileManagement     pkg_gestionarchivos.styarchivo;
    sbTimeProc           varchar2(500);
    sbPath               varchar2(500);
    nuSuscripc           suscripc.susccodi%type;
    onuSusc              suscripc.susccodi%type;
    nuServsusc           servsusc.sesunuse%type;
    frfOperating         CONSTANTS_PER.TYREFCURSOR;
    recOrope             or_operating_unit%ROWTYPE;
    nuUnitOper           mo_packages.pos_oper_unit_id%type;
    rcOrder              daor_order.styor_order;
    dtEndpolicy          ld_validity_policy_type.final_date%type;
    dtIniPolicy          ld_validity_policy_type.initial_date%type;
    nugesubs             ge_subscriber.subscriber_id%type;
    nurecptype           ld_parameter.numeric_value%type;
    nuplandif            ld_parameter.numeric_value%type;
    sbState              ld_parameter.value_chain%type;
    nuCategory           ab_segments.category_%type;
    nuSubcategory        ab_segments.subcategory_%type;
    rcSecureSale         dald_secure_sale.styLD_secure_sale;
    nuContactId          suscripc.suscclie%type;
    sbXML                constants_per.TIPO_XML_SOL%type;
    nuPackageId          mo_packages.package_id%type;
    nuMotiveId           mo_motive.motive_id%type;
    nuErrorCode          NUMBER;
    sbErrorMessage       VARCHAR2(4000);
    nuValiPolTyp         number;
    nuordervalue         number;
    -- bloqueo del proceso
    nuRequestResult      number;
    sbLockHandle         VARCHAR2(2000);
    blHasDefBalance      boolean;
    blHasCateg           boolean;
    blSamePolType        boolean;
    nuNewPolicyTyp       ld_policy_type.policy_type_id%type;
    nuCategory_          subcateg.sucacate%type;
    nuSubcategory_       subcateg.sucacodi%type;
    nuSubscriber         ge_subscriber.subscriber_id%type;
    nuProductLine        ld_policy_type.product_line_id%type;
    nuContratista        ld_policy_type.contratista_id%type;
    nuChangePolTyp       number;
    sbCanBySin           ld_parameter.value_chain%type;
    sbCanCausal          ld_parameter.value_chain%type;
    sbRequestXML         constants_per.TIPO_XML_SOL%type;
    nuCurrentBalance     number;
    dtPayLastAccount     date;
    nuMonth              number;
    nuMaxQuotRenew       number;
    nuLastPolicyId       ld_policy.policy_id%type;
    nuCollectiveNumber   number;
    nuCont               number := 0;
    CURSOR CUPOLTYPE_BY_PROD_LINE(NUPRODLINE   LD_POLICY_TYPE.PRODUCT_LINE_ID%TYPE,
                                  NUPOLICYTYPE LD_POLICY_TYPE.POLICY_TYPE_ID%TYPE) IS
      SELECT COUNT(1)
        FROM LD_POLICY_TYPE P
       WHERE P.POLICY_TYPE_ID = NUPOLICYTYPE
         AND P.PRODUCT_LINE_ID = NUPRODLINE;
    PROCEDURE release_lock IS
    BEGIN
      if (sbLockHandle IS not null) then
        nuRequestResult := dbms_lock.release(lockhandle => sbLockHandle);
      END if;
    EXCEPTION
      when others then
        pkg_traza.Trace('Error inesperado' || sqlerrm, pkg_traza.cnuNivelTrzDef);
    END;

    function fnugetPolicy return number is
        nuretpolicy number;
        cursor cuPolicy is
        select collective_number
        from ld_policy
        where policy_id = rfPolicy(nuNextPolicy).policy_id;
    begin
        open cuPolicy;
            fetch cuPolicy into nuretpolicy;
        close cuPolicy;

        return nuretpolicy;

    end fnugetPolicy;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    sbPath := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbRutLogs);
    if (DALD_PARAMETER.fblExist(LD_BOConstans.csbCodStatePolicy) AND
       DALD_PARAMETER.fblExist(LD_BOConstans.cnuCodStateRenew) AND
       dald_parameter.fblexist(LD_BOConstans.CsbActivityPay) AND
       dald_parameter.fblexist(LD_BOConstans.CsbActivityCharge) AND
       dald_parameter.fblexist('FINANCING_PLAN_ID') AND
       dald_parameter.fblexist('COD_REC_TYPE')) then
      --bloqueo del proceso
      DECLARE
        sbLockName VARCHAR2(100) := 'RENEW_POLICY_PROCESS_';
      BEGIN
        pkg_traza.trace('LockName: ' || sbLockName, pkg_traza.cnuNivelTrzDef);
        -- Genera un manejador de bloqueo para el contrato.
        EXECUTE IMMEDIATE 'DECLARE PRAGMA AUTONOMOUS_TRANSACTION; BEGIN dbms_lock.allocate_unique(:sbLockName,:sbLockHandle); END;'
          using sbLockName, out sbLockHandle;
        pkg_traza.trace('LockHandle: ' || sbLockHandle, pkg_traza.cnuNivelTrzDef);
        /* Solicita el bloqueo del contrato, a traves del manejador de bloqueo.
            0 - success
            1 - timeout
            2 - deadlock
            3 - parameter error
            4 - already own lock specified by 'id' or 'lockhandle'
            5 - illegal lockhandle
        */
        nuRequestResult := dbms_lock.request(lockhandle        => sbLockHandle,
                                             timeout           => 0,
                                             release_on_commit => false);
      EXCEPTION
        when others then
          pkg_traza.Trace('WARNING: No Bloqueo proceso [' || sbLockName || ']',
                         pkg_traza.cnuNivelTrzDef);
      END;
      -- ya se encuentra proceso ejecutando (bloqueado)
      IF (nuRequestResult IN (1, 2)) THEN
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Ya se encuentra un proceso de renovacion en ejecucion');
      END if;
      nuOrderPay    := to_number(pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityPay));
      nuOrderCharge := to_number(pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityCharge));
      nurecptype    := pkg_bcld_parameter.fnuobtienevalornumerico('COD_REC_TYPE');
      nuplandif     := pkg_bcld_parameter.fnuobtienevalornumerico('FINANCING_PLAN_ID');
      sbState       := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      nuStateRenew  := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.cnuCodStateRenew);
      sbTimeProc := TO_CHAR(SYSDATE, 'yyyymmdd_hh24miss');
      /* Arma nombre del archivo LOG */
      sbLog := 'RE_' || sbTimeProc || '.LOG';
      /* Crea archivo Log */
      sbFileManagement := pkg_gestionarchivos.ftabrirarchivo_smf(sbPath, sbLog, 'w');
      sbLineLog := ' INICIO PROCESO DE RENOVACION ' ||
                   TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS');
      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagement, sbLineLog);
      if nuStateRenew is not null then
        nuMonth := to_char(add_months(sysdate, 1), 'MM');
        pkg_traza.trace('nuMonth ' || nuMonth, pkg_traza.cnuNivelTrzDef);
        nuMaxQuotRenew := pkg_bcld_parameter.fnuobtienevalornumerico(ld_boconstans.csbMaxQuotRenew);
        pkg_traza.trace('nuMaxQuotRenew ' || nuMaxQuotRenew, pkg_traza.cnuNivelTrzDef);
        ld_bcsecuremanagement.getPolByCollecAndProdLine(nuMonth,
                                                        null,
                                                        rfCursorPolicy);

        loop
          fetch rfCursorPolicy bulk collect
            into rfPolicy limit 10;
          pkg_traza.trace('rfPolicy.count ' || rfPolicy.count, pkg_traza.cnuNivelTrzDef);
          nuNextPolicy := rfPolicy.first;
          while (nuNextPolicy is not null) loop
            SAVEPOINT TEMPPOLICY;
            BEGIN
              if (ld_bcsecuremanagement.fnuGetPendQuotas(rfPolicy(nuNextPolicy)
                                                         .product_id) >
                 nuMaxQuotRenew) then
                sbLineLog := ' La poliza ' || rfPolicy(nuNextPolicy)
                            .policy_number ||
                             ' no tiene la cantidad maxima de cuotas sin cobrar definida para ser renovada ';
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          sbLineLog);
              END if;
              if (LD_BCSecureManagement.fblHasPendSales(rfPolicy(nuNextPolicy)
                                                        .product_id)) then
                sbLineLog := ' El producto ' || rfPolicy(nuNextPolicy)
                            .product_id ||
                             ' tiene solicitudes de ventas de seguros sin atender ';
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          sbLineLog);
              END if;
              nuChangePolTyp := cnuZERO;
              blHasCateg := LD_BCSecureManagement.fblPolicyTypeHasCateg(rfPolicy(nuNextPolicy)
                                                                        .policy_type_id);
              if blHasCateg then
                nuSubscriber   := PKG_BCCONTRATO.FNUIDCLIENTE(rfPolicy(nuNextPolicy)
                                                               .suscription_id);
                nuCategory_    := daab_premise.fnugetcategory_(PKG_BCDIRECCIONES.FNUGETPREDIO(PKG_BCCLIENTE.FNUDIRECCION(nuSubscriber)));
                nuSubcategory_ := daab_premise.fnugetsubcategory_(PKG_BCDIRECCIONES.FNUGETPREDIO(PKG_BCCLIENTE.FNUDIRECCION(nuSubscriber)));
                blSamePolType  := LD_BCSecureManagement.fblSamePolicyType(rfPolicy(nuNextPolicy)
                                                                          .policy_type_id,
                                                                          nuCategory_,
                                                                          nuSubcategory_);
                if not blSamePolType then
                  nuProductLine := dald_policy_type.fnuGetPRODUCT_LINE_ID(rfPolicy(nuNextPolicy)
                                                                          .policy_type_id);
                  nuContratista := dald_policy_type.fnuGetCONTRATISTA_ID(rfPolicy(nuNextPolicy)
                                                                         .policy_type_id);
                  LD_BCSecureManagement.GetNewPolicyType(nuProductLine,
                                                         nuContratista,
                                                         nuCategory_,
                                                         nuSubcategory_,
                                                         nuNewPolicyTyp);
                  if nuNewPolicyTyp is null then
                    sbLineLog := '     Error ... La poliza ' || rfPolicy(nuNextPolicy)
                                .policy_number ||
                                 ' no pudo ser renovada por cambio en la categoria';
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                              sbLineLog);
                  else
                    rfPolicy(nuNextPolicy).policy_type_id := nuNewPolicyTyp;
                    nuChangePolTyp := cnuONE;
                  end if;
                end if;
              end if;
              dald_policy_type.getRecord(rfPolicy(nuNextPolicy)
                                         .policy_type_id,
                                         rcPolicyType);
              ld_bcsecuremanagement.GetValidityPolicyType(rcPolicyType.policy_type_id,
                                                          ldc_boconsgenerales.fdtgetsysdate,
                                                          nuValiPolTyp);
              pkg_traza.Trace('nuValiPolTyp := ' || nuValiPolTyp, pkg_traza.cnuNivelTrzDef);
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              if (nuValiPolTyp IS not null) then
                dald_validity_policy_type.getRecord(nuValiPolTyp,
                                                    rcValidityPolicyType);
              else
                sbLineLog := '     Error ... El tipo ' || rfPolicy(nuNextPolicy)
                            .policy_type_id ||
                             ' correspondiente a la poliza: ' || rfPolicy(nuNextPolicy)
                            .policy_number || ' no se encuentra vigente.';
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          sbLineLog);
              END if;
              --- se valida que el producto no se encuentre en un estdo de retiro voluntario
              if (pkg_bcproducto.fnuestadocorte(rfPolicy(nuNextPolicy).product_id) in (94, 95)) then
                sbLineLog := '     Error ... El producto ' || rfPolicy(nuNextPolicy)
                            .product_id ||
                             ' se encuentra en proceso de retiro voluntario.';
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          sbLineLog);
              END if;
              /*KCienfuegos.SAO310516*/
              OPEN CUPOLTYPE_BY_PROD_LINE(rfPolicy(nuNextPolicy)
                                          .product_line_id,
                                          rfPolicy(nuNextPolicy)
                                          .policy_type_id);
              FETCH CUPOLTYPE_BY_PROD_LINE
                INTO nuCont;
              CLOSE CUPOLTYPE_BY_PROD_LINE;
              IF (nuCont = 0) THEN
                sbLineLog := '     Error ... El tipo de poliza ' || rfPolicy(nuNextPolicy)
                            .policy_type_id ||
                             ' correspondiente a la poliza: ' || rfPolicy(nuNextPolicy)
                            .policy_number ||
                             ' no esta configurado para la linea de producto ' || rfPolicy(nuNextPolicy)
                            .product_line_id;
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,  sbLineLog);
              END IF;
              /*Fin SAO310516*/
              ld_bcsecuremanagement.GetPolicyType(rfPolicy(nuNextPolicy)
                                                  .policy_type_id,
                                                  nuValue);
              pkg_traza.Trace('GetPolicyType := ' || nuValue, pkg_traza.cnuNivelTrzDef);
              dtIniPolicy := dald_policy.fdtGetDT_EN_POLICY(rfPolicy(nuNextPolicy)
                                                            .policy_id);
              if (dtIniPolicy IS null) then
                dtIniPolicy := trunc(sysdate);
              else
                dtIniPolicy := trunc(dtIniPolicy + 1);
              END if;
              dtEndPolicy := Ld_BcSecureManagement.fdtfechendtypoli(rcValidityPolicyType.coverage_month,
                                                                    dtIniPolicy); -- JCASTRO
              pkg_traza.Trace('dtEndPolicy := ' || dtEndPolicy, pkg_traza.cnuNivelTrzDef);
              ld_bcsecuremanagement.GetSuscPol(rfPolicy(nuNextPolicy)
                                               .policy_id,
                                               onuSusc);
              -- se valida si se tiene un producto de gas activo
              ld_bosecuremanagement.ProcValidateProductparam(onuSusc);
              nuSolicNoRen := Ld_BcSecureManagement.GetSolicNoRenewall(rfPolicy(nuNextPolicy)
                                                                       .policy_id);
              /*AAcuna [SS-100-8096]*/
              if (ld_bcsecuremanagement.fnuGetCueCobrPol(rfPolicy(nuNextPolicy)
                                                         .product_id) > 0) then
                /*11-02-2016 AAcuna [SS-100-8096]: Se Verifica si el producto asociado a la póliza contiene cargo a la -1
                si contiene se guarda registro en el log*/
                sbLineLog := '[Contrato:' || rfPolicy(nuNextPolicy)
                            .suscription_id || '- Producto:' || rfPolicy(nuNextPolicy)
                            .product_id || '- Poliza:' || rfPolicy(nuNextPolicy)
                            .policy_number || '- Tipo poliza: ' || rfPolicy(nuNextPolicy)
                            .policy_type_id ||
                             '] El producto de la póliza tiene cargos con cuenta de cobro a la -1 por lo tanto se debe reprocesar. [' ||
                             nuCategory_ || '] o la subcategoria';
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,  sbLineLog);
              end if;
              pkg_traza.Trace('nuSolicNoRen := ' || nuSolicNoRen, pkg_traza.cnuNivelTrzDef);
              if (nuSolicNoRen = 0) then
                if (nuValue = 1) then
                  /* Se obtiene la Categoria y Subcategoria dado el producto */
                  nuCategory    := pkg_bcproducto.fnucategoria(rfPolicy(nuNextPolicy).product_id);
                  nuSubcategory := pkg_bcproducto.fnuSubCategoria(rfPolicy(nuNextPolicy).product_id);
                  --Se obtine el suscriptor del contrato
                  nuContactId := PKG_BCCONTRATO.FNUIDCLIENTE(rfPolicy(nuNextPolicy)
                                                              .suscription_id);
                  /* Actualizar poliza anterior */
                  dald_policy.updComments(rfPolicy(nuNextPolicy).policy_id, 'Esta poliza fue renovada');
                  dald_policy.updState_Policy(rfPolicy(nuNextPolicy).policy_id, nuStateRenew);
                  nuPolicy := ld_bcsecuremanagement.fnuGetRenewPolicyByProduct(rfPolicy(nuNextPolicy).product_id);
                  -- Se obtiene la fecha de nacimiento de la venta de seguros
                  rcSecureSale := Ld_BcSecureManagement.fnuGetSecureSale(nuPolicy);
                  /* Se crea la poliza nueva a traves del tramite de Venta de Seguros por XML */

                  --P_TRAMITE_VENTA_SEGUROS_XML_100261 ID_TIPOPAQUETE="100261"
                  sbRequestXML := pkg_xml_sol_seguros.getSolicitudVentaSeguros(inuContratoId        => rfPolicy(nuNextPolicy).suscription_id,
                                                                               inuMedioRecepcionId  => nurecptype,
                                                                               isbComentario        => 'Poliza creada por proceso de renovacion de seguros.',
                                                                               idtFechaSolicitud    => ldc_boconsgenerales.fdtgetsysdate,
                                                                               inuDireccionId       => null,
                                                                               inuClienteId         => nuContactId,
                                                                               inuPlanFinanciacionId=> pkg_bcld_parameter.fnuobtienevalornumerico('FINANCING_PLAN_ID'),
                                                                               inuCuotas            => rcValidityPolicyType.coverage_month,
                                                                               inuCategoriaId       => nuCategory,
                                                                               inuSubcategId        => nuSubcategory,
                                                                               isbExcepcionCom      => 'N',--Sbxcept,
                                                                               inuAseguradoraId     => rfPolicy(nuNextPolicy).contratist_code,
                                                                               inuIdentificacion    => rcSecureSale.identification_id,
                                                                               nuLineaProductoId    => rfPolicy(nuNextPolicy).product_line_id,
                                                                               idtFechaNacimiento   => rcSecureSale.born_date,
                                                                               inuTipoPolizaId      => rcPolicyType.policy_type_id,
                                                                               inuNumeroPoliza      => nuPolicy,
                                                                               inuValorPoliza       => rcValidityPolicyType.policy_value,
                                                                               inuRespuestaId       => null,
                                                                               inuCausalIncl        => null,
                                                                               inuProductoId        => rfPolicy(nuNextPolicy).product_id
                                                                              );

                  pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);
                  api_registerrequestbyxml(isbRequestXML    => sbXML,
                                           onuPackageId     => nuPackageId,
                                           onuMotiveId      => nuMotiveId,
                                           onuErrorCode     => nuErrorCode,
                                           osbErrorMessage  => sbErrorMessage
                                          );

                  pkg_traza.Trace('nuErrorCode := ' || nuErrorCode ||
                                 ' - sbErrorMessage:  ' || sbErrorMessage, pkg_traza.cnuNivelTrzDef);
                  gw_boerrors.checkerror(nuErrorCode, sbErrorMessage);
                  pkg_traza.trace('Producto Anterior[' || rfPolicy(nuNextPolicy).product_id ||
                                 ']Poliza Anterior[' || rfPolicy(nuNextPolicy).policy_id, pkg_traza.cnuNivelTrzDef);
                  pkg_traza.trace('nuPackageId[' || nuPackageId ||
                                 ']nuMotiveId[' || nuMotiveId, pkg_traza.cnuNivelTrzDef);

                  --Obtiene la poliza creada.
                  nuLastPolicyId := ld_bcsecuremanagement.fnuGetIdByPolicyNumber(nuPolicy);
                  -- se actualiza la nueva poliza con las fechas correspondientes segun la poliza anterior
                  if (dald_policy.fblExist(nuLastPolicyId)) then
                    dald_policy.updDT_IN_POLICY(nuLastPolicyId,
                                                dtIniPolicy);
                    dald_policy.updDT_EN_POLICY(nuLastPolicyId,
                                                dtEndPolicy);
                  END if;
                  nuCollectiveNumber := fnugetPolicy;

                  pkg_traza.trace('-- PASO 200. ANTES DE ACTUALIZAR', pkg_traza.cnuNivelTrzDef);
                  update ld_policy
                     set collective_number = nuCollectiveNumber
                   where policy_id = nuLastPolicyId;
                  /*Se obtiene la unidad operativa del tipo de poliza, esta unidad operativa se usara para la
                  asignacion de ordenes*/
                  frfOperating := ld_bcsecuremanagement.frfGetOperating(rcPolicyType.policy_type_id);
                  FETCH frfOperating
                    INTO recOrope;
                  nuUnitOper := recOrope.operating_unit_id;
                  CLOSE frfOperating;
                  nuSuscripc := rfPolicy(nuNextPolicy).suscription_id;
                  nuServsusc := rfPolicy(nuNextPolicy).product_id;
                  GetAddressBySusc(nuSuscripc, nuadd, nuGeo);
                  /*Se obtiene la informacion del cliente a raiz del suscriptor*/
                  nugesubs := PKG_BCCONTRATO.FNUIDCLIENTE(nuSuscripc);
                  -- Crea orden de facturacion
                  nuorderid         := null;
                  nuorderactivityid := null;
                  nuCodMenErro      := null;
                  pkg_traza.Trace('va a generar orden', pkg_traza.cnuNivelTrzDef);

                  api_createorder(inuItemsid         => nuOrderPay,
                                  inuPackageid       => nuPackageId,
                                  inuMotiveid        => nuMotiveId,
                                  inuComponentid     => null,
                                  inuInstanceid      => null,
                                  inuAddressid       => nuadd,
                                  inuElementid       => null,
                                  inuSubscriberid    => nugesubs,
                                  inuSubscriptionid  => nuSuscripc,
                                  inuProductid       => nuServsusc,
                                  inuOperunitid      => null,
                                  idtExecestimdate   => null,
                                  inuProcessid       => null,
                                  isbComment         => 'Orden de pago para la aseguradora',
                                  iblProcessorder    => false,
                                  inuPriorityid      => null,
                                  inuOrdertemplateid => null,
                                  isbCompensate      => null,
                                  inuConsecutive     => null,
                                  inuRouteid         => null,
                                  inuRouteConsecutive=> null,
                                  inuLegalizetrytimes=> null,
                                  isbTagname         => null,
                                  iblIsacttoGroup    => null,
                                  inuRefvalue        => null,
                                  inuActionid        => null,
                                  ionuOrderid        => nuOrderId,
                                  ionuOrderactivityid=> nuorderactivityid,
                                  onuErrorCode       => nuCodMenErro,
                                  osbErrorMessage    => sbMensaError
                                );

                   if nvl(nuCodMenErro,0) != 0 then
                      RAISE PKG_ERROR.CONTROLLED_ERROR;
                   end if;
                  rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
                  OR_boProcessOrder.updBasicData(rcOrder,
                                                 rcOrder.operating_sector_id,
                                                 null);

                  if nuUnitOper is null then
                    sbLineLog := '     Error ... no se pudo asignar la orden de pago a la aseguradora' ||
                                 nuorderid || 'la poliza ' || nuPolicy ||
                                 'Ruta' || sbPath || ' ' || sbLog || ' ' ||
                                 sbmessage;
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                             sbLineLog);
                  end if;
                  nuCodMenErro := null;
                  api_assign_order (inuOrder          => nuOrderId,
                                    inuOperatingUnit  => nuUnitOper,
                                    onuErrorCode      => nuCodMenErro,
                                    osbErrorMessage   => sbMensaError
                                   );

                  if nvl(nuCodMenErro,0) != 0 then
                      RAISE PKG_ERROR.CONTROLLED_ERROR;
                  end if;

					sbdataorder := NULL;
					sbdataorder :=
					   nuOrderId
					|| '|'
					|| pkg_gestionordenes.cnucausalexito
					|| '|'
					|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
					|| '||'
					|| nuorderactivityid
					|| '>'
					|| 1
					|| ';;;;|||1277;Legalizacion de la orden de cobro';


                  /* Se legaliza la orden de pago con causal de exito*/
                  api_legalizeOrders(isbDataOrder    => sbdataorder,
                                     idtInitDate     => sysdate,
                                     idtFinalDate    => sysdate,
                                     idtChangeDate   => null,
                                     onuErrorCode    => nuError,
                                     osbErrorMessage => sbMessage
                                   );

                  if (nvl(nuError,0) <> 0) then
                     gw_boerrors.checkerror(nuError, sbMessage);
                  end if;
                  -- actualizar valor de liquidacion de la actividad
                  nuordervalue := NULL;
                  /*INICIO  Modificación para el caso 200-1054 campo comision para renovacion*/
				  LD_BOSECUREMANAGEMENT.GetLiquidationSecurevaluerenew(nuOrderId,
                                                                       nuordervalue);

                   /*retorna negativo entonces se borra                    */
                  daor_order_items.updvalue(daor_order_activity.fnugetorder_item_id(nuorderactivityid),
                                            nuordervalue);
                  daor_order.updorder_value(pkg_bcordenes.fnuobtieneordendeactividad(nuorderactivityid),
                                            nuordervalue);
                  -- Crea orden de comision
                  nuorderid         := null;
                  nuorderactivityid := null;
                  nuCodMenErro      := null;
                  api_createorder(inuItemsid         => nuOrderCharge,
                                  inuPackageid       => nuPackageId,
                                  inuMotiveid        => nuMotiveId,
                                  inuComponentid     => null,
                                  inuInstanceid      => null,
                                  inuAddressid       => nuadd,
                                  inuElementid       => null,
                                  inuSubscriberid    => nugesubs,
                                  inuSubscriptionid  => nuSuscripc,
                                  inuProductid       => nuServsusc,
                                  inuOperunitid      => null,
                                  idtExecestimdate   => null,
                                  inuProcessid       => null,
                                  isbComment         => 'Orden de cobro a la aseguradora',
                                  iblProcessorder    => null,
                                  inuPriorityid      => null,
                                  inuOrdertemplateid => null,
                                  isbCompensate      => null,
                                  inuConsecutive     => null,
                                  inuRouteid         => null,
                                  inuRouteConsecutive=> null,
                                  inuLegalizetrytimes=> null,
                                  isbTagname         => null,
                                  iblIsacttoGroup    => null,
                                  inuRefvalue        => null,
                                  inuActionid        => null,
                                  ionuOrderid        => nuOrderId,
                                  ionuOrderactivityid=> nuorderactivityid,
                                  onuErrorCode       => nuCodMenErro,
                                  osbErrorMessage    => sbMensaError
                                 );
                  if nvl(nuCodMenErro,0) != 0 then
                      RAISE PKG_ERROR.CONTROLLED_ERROR;
                  end if;

                  rcOrder := pkg_bcordenes.frcgetrecord(nuOrderId);
                  OR_boProcessOrder.updBasicData(rcOrder,
                                                 rcOrder.operating_sector_id,
                                                 null);

                  if nuUnitOper is null then
                    sbLineLog := '     Error ... no se pudo asignar la orden de pago a la aseguradora' ||
                                 nuorderid || 'la poliza ' || nuPolicy ||
                                 'Ruta' || sbPath || ' ' || sbLog || ' ' ||
                                 sbmessage;
                    pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                              sbLineLog);
                  else
                    nuCodMenErro := null;
                    api_assign_order (inuOrder          => nuOrderId,
                                      inuOperatingUnit  => nuUnitOper,
                                      onuErrorCode      => nuCodMenErro,
                                      osbErrorMessage   => sbMensaError
                                      );
                    if nvl(nuCodMenErro,0) != 0 then
                        RAISE PKG_ERROR.CONTROLLED_ERROR;
                    end if;


					sbdataorder := NULL;
					sbdataorder :=
						   nuOrderId
						|| '|'
						|| pkg_gestionordenes.cnucausalexito
						|| '|'
						|| LD_BOUtilFlow.fnuGetPersonToLegal(nuUnitOper)
						|| '||'
						|| nuorderactivityid
						|| '>'
						|| 1
						|| ';;;;|||1277;Legalizacion de la orden de cobro';


                    --Se legaliza la orden de pago con causal de exito--
                    api_legalizeOrders(isbDataOrder    => sbdataorder,
                                       idtInitDate     => sysdate,
                                       idtFinalDate    => sysdate,
                                       idtChangeDate   => null,
                                       onuErrorCode    => nuError,
                                       osbErrorMessage => sbMessage
                                     );

                    if (nvl(nuError,0) <> 0) then
                       gw_boerrors.checkerror(nuError, sbMessage);
                    end if;
                    -- se actualiza valor de la liquidacion
                    nuordervalue := NULL;

					LD_BOSECUREMANAGEMENT.GetLiquidationSecurevaluerenew(nuOrderId, nuordervalue);
                    daor_order_items.updvalue(daor_order_activity.fnugetorder_item_id(nuorderactivityid),
                                              nuordervalue);
                    daor_order.updorder_value(pkg_bcordenes.fnuobtieneordendeactividad(nuorderactivityid),
                                              nuordervalue);
                  end if;
                ELSE
                  sbLineLog := '     Error ... Las fechas del tipo de poliza asociado a la poliza ' || rfPolicy(nuNextPolicy)
                              .policy_number ||
                               ' no contemplan la fecha actual ' || sbPath;
                  pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                            sbLineLog);
                end if;
              ELSE
                /* Si la poliza tiene registrada una solicitud de no renovacion y su vigencia ya se encuentra vencida,
                se registra una cancelacion */
                /*obtiene saldo pendiente de las cuentas de cobro*/
                open ld_bcsecuremanagement.cuPendBalance(rfPolicy(nuNextPolicy)
                                                         .product_id);
                fetch ld_bcsecuremanagement.cuPendBalance
                  INTO nuCurrentBalance;
                /*valida si la poliza tiene diferidos con saldo pendiente*/
                blHasDefBalance := LD_BCSecureManagement.fblHasDefDebt(rfPolicy(nuNextPolicy)
                                                                       .product_id);
                IF not blHasDefBalance AND nuCurrentBalance = 0 then
                  sbCanBySin  := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCanBySin);
                  sbCanCausal := pkg_bcld_parameter.fsbobtienevalorcadena(ld_boconstans.csbCausCancBySubs);

                  --P_CANCELACION_DE_SEGUROS_XML_100266 ID_TIPOPAQUETE="100266"
                  sbRequestXML := pkg_xml_sol_seguros.getSolicitudCancelaSeguros(inuPersonaId         => pkg_bopersonal.fnugetpersonaid(),
                                                                                 inuMedioRecepcionId  => nurecptype,
                                                                                 isbComentario        => 'CANCELADA POR SOLICITUD DE NO RENOVACION.',
                                                                                 idtFechaSolicitud    => trunc(sysdate),
                                                                                 inuDireccionId       => null,
                                                                                 inuClienteId         => nuContactId,
                                                                                 inuContratoId        => rfPolicy(nuNextPolicy).suscription_id,
                                                                                 inuNumeroPoliza      => rfPolicy(nuNextPolicy).policy_id,
                                                                                 inuRespuestaId       => null,
                                                                                 inuCausalCanceId     => sbCanCausal,
                                                                                 isbObservacionPoliza => 'CANCELADA POR SOLICITUD DE NO RENOVACION.',
                                                                                 isbSolicitud         => sbCanBySin
                                                                                );

                  pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);
                  api_registerrequestbyxml(isbRequestXML    => sbRequestXML,
                                           onuPackageId     => nuPackageId,
                                           onuMotiveId      => nuMotiveId,
                                           onuErrorCode     => nuErrorCode,
                                           osbErrorMessage  => sbErrorMessage
                                          );


                else
                  if nuCurrentBalance > 0 then
                    open ld_bcsecuremanagement.cuLastPayAccountDate(rfPolicy(nuNextPolicy)
                                                                    .product_id);
                    fetch ld_bcsecuremanagement.cuLastPayAccountDate
                      INTO dtPayLastAccount;
                    close ld_bcsecuremanagement.cuLastPayAccountDate;
                    if ((sysdate - dtPayLastAccount) / 30 >
                       ld_boconstans.cnuCodPerDefeated) then
                      sbCanBySin  := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCanBySin);
                      sbCanCausal := pkg_bcld_parameter.fsbobtienevalorcadena(ld_boconstans.csbCausCancBySubs);
                      --P_CANCELACION_DE_SEGUROS_XML_100266 ID_TIPOPAQUETE="100266"
                      sbRequestXML := pkg_xml_sol_seguros.getSolicitudCancelaSeguros(inuPersonaId         => pkg_bopersonal.fnugetpersonaid(),
                                                                                     inuMedioRecepcionId  => nurecptype,
                                                                                     isbComentario        => 'CANCELADA POR SOLICITUD DE NO RENOVACION.',
                                                                                     idtFechaSolicitud    => trunc(sysdate),
                                                                                     inuDireccionId       => null,
                                                                                     inuClienteId         => nuContactId,
                                                                                     inuContratoId        => rfPolicy(nuNextPolicy).suscription_id,
                                                                                     inuNumeroPoliza      => rfPolicy(nuNextPolicy).policy_id,
                                                                                     inuRespuestaId       => null,
                                                                                     inuCausalCanceId     => sbCanCausal,
                                                                                     isbObservacionPoliza => 'CANCELADA POR SOLICITUD DE NO RENOVACION.',
                                                                                     isbSolicitud         => sbCanBySin
                                                                                    );


                      pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);
                      api_registerrequestbyxml(isbRequestXML    => sbRequestXML,
                                               onuPackageId     => nuPackageId,
                                               onuMotiveId      => nuMotiveId,
                                               onuErrorCode     => nuErrorCode,
                                               osbErrorMessage  => sbErrorMessage
                                              );

                    END if;
                  END if;
                END if;
              end if;
              if nuChangePolTyp = cnuZERO then
                sbLineLog := '  La nueva poliza creada es: ' ||
                             nuLastPolicyId || ' para el asegurado: ' || rfPolicy(nuNextPolicy)
                            .name_insured || ' Creada en la fecha: ' ||
                             sysdate ||
                             '. El proceso ha terminado con exito.';
              else
                sbLineLog := '  La nueva poliza creada es: ' ||
                             nuLastPolicyId || ' para el asegurado: ' || rfPolicy(nuNextPolicy)
                            .name_insured || ' Creada en la fecha: ' ||
                             sysdate ||
                             ' con diferente tipo de poliza por cambio de categoria. El proceso ha terminado con exito.';
              end if;
              pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagement, sbLineLog);
            exception
              when PKG_ERROR.CONTROLLED_ERROR then
                pkg_error.getError(nuError, sbMessage);
                sbLineLog := '     Error ... procesando la poliza ' ||
                             nuPolicy || 'Ruta' || sbPath || ' ' || sbLog || ' ' ||
                             sbmessage;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagement, sbLineLog);
                ROLLBACK TO TEMPPOLICY;
              when others then
                pkg_error.SetError;
                pkg_error.getError(nuError, sbMessage);
                sbLineLog := '     Error ... procesando la poliza ' ||
                             nuPolicy || 'Ruta' || sbPath || ' ' || sbLog || ' ' ||
                             sbmessage;
                pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagement, sbLineLog);
                ROLLBACK TO TEMPPOLICY;
            END;
            nuNextPolicy := rfPolicy.next(nuNextPolicy);
            commit;
          end loop;
          EXIT WHEN rfCursorPolicy%NOTFOUND;
        end loop;
        close rfCursorPolicy;
      else
        sbLineLog := '     Error ... Los parametros que se utilizan se encuentran en blanco' ||
                     sbPath;
        pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagement, sbLineLog);
      end if;
    end if;
    pkg_gestionarchivos.prccerrararchivo_smf(sbFileManagement);
    commit;
    release_lock;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      rollback;
      release_lock;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
      rollback;
      release_lock;
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcRenew;


  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcGetValueParameter
  Descripcion    : Retorna el valor del parametro del tramite de venta de seguros
  Autor          : AAcuna
  Fecha          : 23/07/2012 SAO 147879
  Parametros      Descripcion
  ============   ===================
  nuValue:        Valor del parametro
  Historia de Modificaciones
  Fecha               Autor             Modificacion
  =========         =========         ====================
  ******************************************************************/
  PROCEDURE ProcGetValueParameter(nuValue out varchar2) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcGetValueParameter'; --Nombre del método en la traza
  begin
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuValue := PS_BOPACKTYPEPARAM.FSBGETPACKTYPEPARAM(100236, 6000009, TRUE);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcGetValueParameter;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fsbGetValueParameter
  Descripcion    : Retorna el valor del parametro del tramite de venta de seguros
  Autor          : JCarrillo
  Fecha          : 30/08/2013
  Parametros      Descripcion
  ============   ===================
  Historia de Modificaciones
  Fecha       Autor               Modificacion
  ==========  =================== ===========================
  30/08/2013  jcarrillo.SAO213276 1 - Creacion
  ******************************************************************/
  FUNCTION fsbGetValueParameter Return ps_pack_type_param.value%type IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fsbGetValueParameter'; --Nombre del método en la traza
    sbValueParam ps_pack_type_param.value%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    Ld_BoSecureManagement.ProcGetValueParameter(sbValueParam);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return sbValueParam;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fsbGetValueParameter;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fnuGetFirstValueByCon
  Descripcion    : Retorna la primera linea de negocio dde tipo puerta a
                     puerta para el contratista en caso de no tener
                     levanta error
  Autor          : JCarrillo
  Fecha          : 30/08/2013
  Parametros      Descripcion
  ============   ===================
  Historia de Modificaciones
  Fecha       Autor               Modificacion
  ==========  =================== ===========================
  22/03/2024  pacosta             OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  16/06/2017  KBaquero CA200-1225 Se modifica para quitarle el llamdodel parametro del tramite de venta
                                  de seguros y  colocarle el paramtro ID_PRODUCT_LINE, que se encunetra
                                  configurado desde la forma LDPAR.
  30/08/2013  jcarrillo.SAO213276 1 - Creacion
  ******************************************************************/
  FUNCTION fnuGetFirstValueByCon(inuContratist in ld_prod_line_ge_cont.contratistas_id%type)
    RETURN ld_prod_line_ge_cont.product_line_id%type IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnuGetFirstValueByCon'; --Nombre del método en la traza
    sbValueParam  ps_pack_type_param.value%type;
    nuProductLine ld_prod_line_ge_cont.product_line_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    sbValueParam  := pkg_bcld_parameter.fsbobtienevalorcadena('ID_PRODUCT_LINE');
    nuProductLine := Ld_BcSecureManagement.FnuGetValProd(sbValueParam, inuContratist);
    if (nuProductLine IS null) then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'La aseguradora "' || inuContratist ||
                                ' - ' ||
                                dage_contratista.fsbgetnombre_contratista(inuContratist) || '" ' ||
                                'no tiene configurada una linea de producto puerta a puerta.');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return nuProductLine;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fnuGetFirstValueByCon;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValProd
  Descripcion    : Valida si el contrato tiene gas activo y la categoria sea de tipo residencial y comercial.
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros          Descripcion
  ============     ==================
  inuSusc:         Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024     pacosta    OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                            Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  29/08/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcValProd(inuSusc in suscripc.susccodi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValProd'; --Nombre del método en la traza
    nuCategori categori.catecodi%type;
    nuSubcate  subcateg.sucacodi%type;
    nuParCategori  number;
    nuParCategorid number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (inuSusc is not null) then
      if (DALD_PARAMETER.fblExist(LD_BOConstans.csbCodCategory)) then
        nuGas_Service := LD_BOConstans.cnuGasService;
        sbCate        := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodCategory);
        if ((nvl(nuGas_Service, LD_BOConstans.cnuCero) <>
           LD_BOConstans.cnuCero)) then
          ld_bcsecuremanagement.ProcValProd(inuSusc,
                                            sbCate,
                                            nuGas_Service,
                                            nuCategori,
                                            nuSubcate);
          nuParCategori  := to_number(substr(sbCate,
                                             1,
                                             instr(sbCate, '|', 1, 1) - 1));
          nuParCategorid := to_number(substr(sbCate || '|',
                                             instr(sbCate || '|', '|', 1, 1) + 1,
                                             (instr(sbCate || '|', '|', 1, 2)) -
                                             (instr(sbCate || '|', '|', 1, 1) + 1)));
          if ((nuCategori = nuParCategori) OR (nuCategori = nuParCategorid)) then
            return;
          else
            pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                      'El contrato seleccionado no tiene definido un producto de tipo gas con categoria residencial o comercial');
          end if;
        else
          null;
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValProd;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValPolyCont
  Descripcion    : Valida que no se debe permitir tener mas de n polizas vigentes por contrato.
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros          Descripcion
  ============     ==================
  inuSuscripc    : Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  21-03-2024     pacosta          OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                  Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
  29/08/2012     AAcuna           Creacion
  ******************************************************************/
  PROCEDURE ProcValPolyCont(inuSuscripc in suscripc.susccodi%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValPolyCont'; --Nombre del método en la traza
    nuValue    number;
    sbLineFile varchar2(1000); -- SAO[334174]
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStatePolicy)) then
      sbState      := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      nuCantbyCont := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuCodCant_Poly);
      if (nvl(nuCantbyCont, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) then
        ld_bcsecuremanagement.ProcValPolyCont(inuSuscripc,
                                              sbState,
                                              nuValue);
        if (nuValue >= nuCantbyCont) then
          -- SAO[334174]
          sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                        'CANTIDAD POLIZAS' || ';' || nuValue || ';' ||
                        'El contrato supero el limite permitido por las aseguradoras' || ';' ||
                        sqlerrm;
          pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'El contrato supero la cantidad de polizas permitidas');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValPolyCont;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValidateClifin
  Descripcion    : Se obtiene el valor de cuota de financiacion por suscritor.
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:     Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  21-03-2024     pacosta          OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF


  29/08/2012     AAcuna           Creacion
  ******************************************************************/
  PROCEDURE ProcValidateClifin(inuSuscripc in suscripc.susccodi%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValidateClifin'; --Nombre del método en la traza
    nuValueFin number;
    sbLineFile varchar2(1000); -- SAO[334174]
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodShare)) then
      nuCoutaFin := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.csbCodShare);
      if (nvl(nuCoutaFin, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) then
        ld_bcsecuremanagement.ProcValidateClifin(inuSuscripc, nuValueFin);
        if (nuValueFin >= nuCoutaFin) then
          -- SAO[334174]
          sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                        'CUOTA FINANCIACION' || ';' || nuValueFin || ';' ||
                        'El dueno del contrato supero el limite de financiacion permitido, no puede asegurar al beneficiario' || ';' ||
                        sqlerrm;
          pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'La cuota de financiación para este contrato supero el limite permitido');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValidateClifin;
  /*****************************************************************
  Propiedad intelectual de PETI (c).
  Unidad         : ProcValidateShare
  Descripcion    : Se valida que la cuota de la nueva venta seguro, no supere el valor
                   configurado en el parametro COD_CUOTA_FIN
  Autor          : KCienfuegos
  Fecha          : 17/07/2014 - RNP 606
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:     Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  21-03-2024     pacosta          OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
  17/07/2014     KCienfuegos      Creacion
  ******************************************************************/
  PROCEDURE ProcValidateShare(inuSuscripc in suscripc.susccodi%type,
                              inuvalue    in number)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValidateShare'; --Nombre del método en la traza
    nuValueFin number;
    sbLineFile varchar2(1000); -- SAO[334174]
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodShare)) then
      nuCoutaFin := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.csbCodShare);
      if (nvl(nuCoutaFin, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) then
        ld_bcsecuremanagement.ProcValidateClifin(inuSuscripc, nuValueFin);
        if ((nvl(nuValueFin, LD_BOConstans.cnuCero) +
           nvl(inuvalue, LD_BOConstans.cnuCero)) >= nuCoutaFin) then
          -- SAO[334174]
          sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                        'CUOTA FINANCIACION' || ';' ||
                        (nvl(nuValueFin, LD_BOConstans.cnuCero) +
                        nvl(inuvalue, LD_BOConstans.cnuCero)) || ';' ||
                        'La cuota de financiacion para el contrato supero el limite permitido por las aseguradoras' || ';' ||
                        sqlerrm;
          pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'La cuota de financiación para este contrato supera el limite permitido');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValidateShare;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValiPoliType
  Descripcion    : Valida que la cedula del asegurado no pase del limite configurado
                 en la entidad tipo de poliza
  Autor          : AAcuna
  Fecha          : 28/09/2012 SAO 147879
  Parametros         Descripcion
  ============  ===================
  inuSubscriptionId:    Identificador del contrato
  inuIdentification:    Identificador del subscriber
  inuPolicyType:        Tipo de poliza
  Historia de Modificaciones
  Fecha         Autor      Modificacion
  =========   ========= ====================
  22/03/2024  pacosta   OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                        Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                        Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
  28/09/2012  AAcuna    Creacion
  ******************************************************************/
  PROCEDURE ProcValiPoliType(inuSubscriptionId in suscripc.susccodi%type,
                             inuIdentification in ge_subscriber.identification%type,
                             inuPolicyType     in ld_policy_type.policy_type_id%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValiPoliType'; --Nombre del método en la traza
    nuAmmountId number; -- Cantidad de polizas permitidas por asegurado
    nuCantId    number; -- Cantidad de polizas por asegurado
    sbContratos varchar2(200);
    sbLineFile  VARCHAR2(1000);
    CURSOR cuSuscriptions IS
      SELECT p.suscription_id
        FROM ld_policy p
       WHERE instr(sbState, lpad(p.state_policy, 4, '0')) > 0
         AND p.policy_type_id = inuPolicyType
         AND p.identification_id = inuIdentification;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStatePolicy)) then
      sbState := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      nuAmmountId := dald_policy_type.fnuGetAMMOUNT_CEDULA(inuPolicyType, 0);
      nuAmmountId := nvl(nuAmmountId, 0);
      ld_bcsecuremanagement.ProcValCantPoly(inuIdentification,
                                            inuSubscriptionId,
                                            inuPolicyType,
                                            sbState,
                                            nuCantId);
      if (nuCantId >= nuAmmountId) then
        for rgSuscriptions in cuSuscriptions loop
          sbContratos := sbContratos || '|' ||
                         rgSuscriptions.Suscription_Id;
        end loop;
        sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                      'CONTRATOS' || ';' || sbContratos || ';' ||
                      'La cedula [' || inuIdentification ||
                      '] ha pasado el limite de polizas permitidas para el tipo de poliza [' ||
                      inuPolicyType || ']' || ';' || sqlerrm;
        pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Este asegurado ha pasado el limite de polizas permitidas por tipo de poliza');
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValiPoliType;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValPolyActi
  Descripcion    : La cedula no puede tener una poliza activa en otro contrato
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuIdentase:     Numero de identificacion del asegurado
  inuSuscripc:     Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024     pacosta    OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                            Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  29/08/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcValPolyActi(inuIdentase in ld_policy.identification_id%type,
                            inuSuscripc in suscripc.susccodi%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValPolyActi'; --Nombre del método en la traza
    nuValue number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if ((DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStatePolicy))) then
      sbState := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      ld_bcsecuremanagement.ProcValPolyActi(inuIdentase,
                                            inuSuscripc,
                                            sbState,
                                            nuValue);
      if (nuValue <> 0) then
        ld_bcsecuremanagement.GetSuscripPolicy(inuIdentase,
                                               inuSuscripc,
                                               sbState,
                                               nuSuscriptor);
        if nuSuscriptor <> -1 then
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'Este asegurado tiene una poliza vigente en otro contrato');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValPolyActi;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcDataPoli
  Descripcion    : Se obtiene datos de la poliza para el tramite de no renovacion.
  Autor          : kbaquero
  Fecha          : 04/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPoli:         Numero de la poliza
  onupolitype:     Codigo del tipo de poliza
  onuValuep:       Valor de la poliza
  onuPayFeed:      Cuotas pagadas
  onuNumDife:      Numero del diferido
  oNucontra:       Numero del contrato
  onuProline:      Numero de la linea del producto
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  04/10/2012     Kbquero    Creacion
  ******************************************************************/
  PROCEDURE ProcDataPoli(inuPoli     in ld_policy.policy_id%type,
                         onupolitype Out ld_policy.policy_type_id%type,
                         onuValuep   Out ld_policy.value_policy%type,
                         onuPayFeed  Out ld_policy.fees_to_return%type,
                         onuNumDife  Out ld_policy.deferred_policy_id%type,
                         oNucontra   Out ld_policy.contratist_code%type,
                         ONuproline  Out ld_policy.product_line_id%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcDataPoli'; --Nombre del método en la traza
  begin
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.ProcDataPoli(inuPoli,
                                       onupolitype,
                                       onuValuep,
                                       onuPayFeed,
                                       onuNumDife,
                                       oNucontra,
                                       ONuproline);
    if onupolitype is null or onuValuep is null or onuPayFeed is null or
       onuNumDife is null or oNucontra is null or ONuproline is null then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'Este suscriptor No tiene diferido Asociado a la póliza');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  End ProcDataPoli;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcDataPolicy
  Descripcion    : Se obtiene datos de la poliza para el tramite de cancelacion.
  Autor          : kbaquero
  Fecha          : 04/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPoli:         Numero de la poliza
  osbname:         Nombre del asegurado
  onuidenti:       Numero de identificacion del asegurado
  onucontr:        Aseguradora
  onuprodli:       Linea de Producto
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  04/10/2012    AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcDataPolicy(inuPoli   in ld_policy.policy_id%type,
                           osbname   Out ld_policy.name_insured%type,
                           onuidenti Out ld_policy.identification_id%type,
                           onucontr  Out ld_policy.contratist_code%type,
                           onuprodli Out ld_policy.product_line_id%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcDataPolicy'; --Nombre del método en la traza
  begin
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_BcSecureManagement.ProcDataPolicy(inuPoli,
                                         osbname,
                                         onuidenti,
                                         onucontr,
                                         onuprodli);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  End ProcDataPolicy;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValAddressBySusc
  Descripcion    : Valida que la direccion del contrato exista
  Autor          : AAcuna
  Fecha          : 17/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:      Numero del suscritor
  onuValue:         Valor de retorno
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  17/10/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcValAddressBySusc(inuSuscripc in suscripc.susccodi%type,
                                 onuValue    out number) is
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValAddressBySusc'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.ProcValAddressBySusc(inuSuscripc, onuValue);
    if (onuValue = 0) then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'Este contrato no tiene una direccion asociada');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValAddressBySusc;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValNumberPol
  Descripcion    : Validar el numero de poliza ingresado
  Autor          : AAcuna
  Fecha          : 20/12/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPolicy:      Numero de la poliza
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  =========      ================ =============
  22/03/2024      pacosta       OSF-2380: Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
  04/09/2013      jcarrillo.    SAO214549 1 - Se modifica para validar que la poliza
                                no se encuentre en una solicitud.
  20/12/2012      AAcuna        Creacion
  ******************************************************************/
  PROCEDURE ProcValNumberPol(inuPolicy in ld_policy.policy_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValNumberPol'; --Nombre del método en la traza
    nuPackageId  ld_secure_sale.secure_sale_id%type;
    nuPolicyId   ld_policy.policy_id%type;
    sbLineFile   varchar2(1000);
    nuSuscriptor ld_policy.suscription_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuPolicyId := ld_bcsecuremanagement.fnuGetIdByPolicyNumber(inuPolicy);
    if (nuPolicyId <> 0) then
      nuSuscriptor := dald_policy.fnuGetSUSCRIPTION_ID(nuPolicyId);
      -- SAO[334174]
      sbLineFile := nuContrato || ';' || nuPolicyNum || ';' || 'CONTRATO' || ';' ||
                    nuSuscriptor || ';' ||
                    'El numero de poliza ya se encuentra registrada en otro contrato' || ';' ||
                    replace(replace(sqlerrm, chr(10), ''), chr(13), '');
      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'Este numero de poliza ya existe');
    end if;
    Ld_BcSecureManagement.GetPackageByPolSale(inuPolicy, nuPackageId);
    if (nuPackageId IS not null) then
      -- SAO[334174]
      sbLineFile := nuContrato || ';' || nuPolicyNum || ';' || 'SOLICITUD' || ';' ||
                    nuPackageId || ';' ||
                    'El numero de poliza ya se encuentra registrada en una solicitud' || ';' ||
                    replace(replace(sqlerrm, chr(10), ''), chr(13), '');
      pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'La poliza [' || inuPolicy ||
                                '] se encuentra registrada con la solicitud [' ||
                                nuPackageId || '].');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValNumberPol;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcIniCalcMeth
  Descripcion    : Inicializa el calculo de metodo del plan de financiacion para la venta
                 de seguros
  Autor          : AAcuna
  Fecha          : 15/03/2013 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuProductLine:   Numero de la linea de producto
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  ******************************************************************/
  PROCEDURE ProcIniCalcMeth(onuCompute_Method_Id out cc_sales_financ_cond.compute_method_id%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcIniCalcMeth'; --Nombre del método en la traza
    sbFinancingPlan varchar2(32000);
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_boflowfnbpack.GetLdparamater('FINANCING_PLAN_ID',
                                    null,
                                    sbFinancingPlan);
    onuCompute_Method_Id := pktblplandife.fnugetpldimccd(to_number(sbFinancingPlan),
                                                         null);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcIniCalcMeth;


  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValStateProdSal
  Descripcion    : Validar que el estado asociado al servicio de gas del contrato cumpla
                 con el parametro de estado de producto de venta de seguros llamado "COD_STATE_PROD_BYSALE",
                 Si la consulta que busca el servicio asociado al producto gas del contrato contiene que su
                 estado de producto es igual al parametro retorna (1) y puede abrir el tramite en caso
                 contrario mostrara mensaje de error y no dejara continuar con el proceso
  Autor          : AAcuna
  Fecha          : 10/05/2013 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:   : Numero del contrato
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024     pacosta    OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                            Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  10/05/2013     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcValStateProdSal(inuSuscripc in suscripc.susccodi%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValStateProdSal'; --Nombre del método en la traza
    sbStateProdBySale varchar2(32000);
    nuStateProSal     number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Se valida que parametro de estado de product exista*/
    if (DALD_PARAMETER.fblExist('COD_STATE_PROD_BYSALE')) then
      /*Se obtienen los datos del parametro*/
      nuGas_Service     := LD_BOConstans.cnuGasService;
      sbStateProdBySale := pkg_bcld_parameter.fsbobtienevalorcadena('COD_STATE_PROD_BYSALE');
      /* Se valida que la constante de servicio gas tenga dato*/
      if ((nvl(nuGas_Service, LD_BOConstans.cnuCero) <>
         LD_BOConstans.cnuCero)) then
        /*Se valida si el estado del producto del tipo de servicio gas
        concuerde con los parametros configurados*/
        nuStateProSal := ld_bcsecuremanagement.GetStateProdSal(inuSuscripc,
                                                               sbStateProdBySale,
                                                               nuGas_Service);
        /*Si el valor retornado es cero no deja continuar con el proceso de venta de seguros*/
        if (nuStateProSal = 0) then
          /*Lanza mensaje de error al usuario*/
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'No se puede abrir el tramite de venta de seguros
                                    ya que el estado del producto de gas del contrato no esta definido entre los
                                    estado de producto de la venta');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValStateProdSal;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValContractorId
  Descripcion    : Validar que el contratista de la persona conectada
                 tiene configurada al menos un tipo de poliza asociada al contratista.
                 Retorna los siguientes valores:
                 (0) Sino encuentra el contratista dentro del tipo de poliza
                 (1) Si se encuentra el contratista dentro del tipo de poliza
  Autor          : AAcuna
  Fecha          : 07/05/2013 SAO 147879
  Parametros         Descripcion
  ============   ===================
  onuFlag_Val:       Flag_validate
  onuContractorId:   Contratista
  onuErrorCode:      Codigo de error
  osbErrorMessage:   Mensaje de error
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  07/05/2013     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE ProcValContractorId(onuFlag_Val     out number,
                                onuContractorId out or_operating_unit.Contractor_Id%type,
                                onuErrorCode    out ge_message.message_id %type,
                                osbErrorMessage out ge_message.description%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValContractorId'; --Nombre del método en la traza
    tbld_policy_type dald_policy_type.tytbLD_policy_type;
    nuIndex          number;
  BEGIN
     pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /*Obtengo todas las tipo de polizas que se encuentren vigentes */
    dald_policy_type.getRecords(' ld_policy_type.contratista_id is not null',
                                tbld_policy_type);
    /* Si obtengo registro se busca si el contratista de la
    persona conectada se encuentra configurada en alguna tipo de poliza*/
    if (tbld_policy_type.count > 0) then
      nuIndex := tbld_policy_type.first;
      /* Se recorren los tipos de poliza*/
      while nuIndex is not null loop
        /* Se valida si la funcion que me retorna el contratista de la persona conectada
        es igual algun tipo de poliza que tenga configurada ese contratista, si es asi se
        asigna uno(1) y se sale del proceso sino se asigna cero(0)*/
        if (ld_bcsecuremanagement.GetContractorId = tbld_policy_type(nuIndex)
           .contratista_id) then
          onuFlag_Val     := 1;
          onuContractorId := tbld_policy_type(nuIndex).contratista_id;
          exit;
        else
          onuFlag_Val := 0;
        end if;
        nuIndex := tbld_policy_type.next(nuIndex);
      end loop;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(onuErrorCode,osbErrorMessage);
      pkg_traza.trace(csbPrefMerr||onuErrorCode||'-'||osbErrorMessage,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
    when OTHERS then
      pkg_error.SetError;
      pkg_error.getError(onuErrorCode,osbErrorMessage);
      pkg_traza.trace(csbPrefMerr||onuErrorCode||'-'||osbErrorMessage,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
  END ProcValContractorId;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : UpdateStatePolicy
  Descripcion    : Cambia el estado de las polizas dependiendo el proceso de lanzamiento
                 Si el proceso es :
                 1. Cancelacion por archivo plano se le debe de enviar el tipo de proceso (3)
                 para que le cambie el valor del estado a 3 (Proceso de cancelacion por archivo plano)
                 2. Cancelacion por cartera se le debe de enviar el tipo de proceso (4)
                 para que le cambie el valor del estado a 4 (Proceso de anulacion por cartera)
                 3. Cancelacion por siniestros se le debe de enviar el tipo de proceso (6)
                 para que le cambie el valor del estado a 6 (Proceso de cancelacion por siniestros)
  Autor          : AAcuna
  Fecha          : 20/12/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPolicy:     Numero de la poliza
  inuProcess     Tipo de proceso:
               (3) Cancelacion por archivo plano
               (4) Cancelacion por cartera
               (6) Cancelacion por siniestros
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  ******************************************************************/
  PROCEDURE UpdateStatePolicy(inuPolicy  in ld_policy.policy_id%type,
                              inuProcess number)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'UpdateStatePolicy'; --Nombre del método en la traza
    nuStateCancByFile ld_policy.state_policy%type;
    sbStateCanc       ld_parameter.value_chain%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    sbStateCanc := pkg_bcld_parameter.fsbobtienevalorcadena('COD_STATE_CANC');
    if (inuProcess = 3) then
      nuStateCancByFile := to_number(substr(sbStateCanc || '|',
                                            instr(sbStateCanc || '|',
                                                  '|',
                                                  1,
                                                  1) + 1,
                                            (instr(sbStateCanc || '|',
                                                   '|',
                                                   1,
                                                   2)) -
                                            (instr(sbStateCanc || '|',
                                                   '|',
                                                   1,
                                                   1) + 1)));
      dald_policy.updState_Policy(inuPolicy, nuStateCancByFile);
    else
      if (inuProcess = 4) then
        nuStateCancByFile := to_number(substr(sbStateCanc || '|',
                                              instr(sbStateCanc || '|',
                                                    '|',
                                                    1,
                                                    2) + 1,
                                              (instr(sbStateCanc || '|',
                                                     '|',
                                                     1,
                                                     3)) -
                                              (instr(sbStateCanc || '|',
                                                     '|',
                                                     1,
                                                     2) + 1)));
        dald_policy.updState_Policy(inuPolicy, nuStateCancByFile);
      else
        if (inuProcess = 6) then
          nuStateCancByFile := to_number(substr(sbStateCanc || '|',
                                                instr(sbStateCanc || '|',
                                                      '|',
                                                      1,
                                                      4) + 1,
                                                (instr(sbStateCanc || '|',
                                                       '|',
                                                       1,
                                                       5)) -
                                                (instr(sbStateCanc || '|',
                                                       '|',
                                                       1,
                                                       4) + 1)));
          dald_policy.updState_Policy(inuPolicy, nuStateCancByFile);
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END UpdateStatePolicy;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetAddress
  Descripcion    : Se obtiene la direccion de contrato del suscritor
  Autor          : AAcuna
  Fecha          : 06/11/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:      Numero del suscritor
  onuValue:         Direccion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  06/11/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE GetAddress(inuSuscripc in suscripc.susccodi%type,
                       onuValue    out ab_address.address%type) is
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetAddress'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.GetAddress(inuSuscripc, onuValue);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetAddress;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetPlanDifSale
  Descripcion    : Obtiene los datos a partir del plan de financiacion para la venta de seguros
  Autor          : AAcuna
  Fecha          : 06/11/2012 SAO 147879
  Parametros              Descripcion
  ============        ===================
  inuFinancingPlan:      Plan de financiacion
  dtRequestDate:         Fecha de registro
  onuComputeMethod       Metodo de compute
  onuInteresPercent      Porcentaje de interes
  onuInterestRate        Rango de porcentaje
  onuSpread              Spread
  onuPercentFin          Porncentaje de financiacion
  sbDocumentSuppport     Documento de soporte
  dtFitsPay              Fecha de pago
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  06/11/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE GetPlanDifSale(inuFinancingPlan   in cc_sales_financ_cond.financing_plan_id%type,
                           dtRequestDate      in mo_packages.request_date%type,
                           onuComputeMethod   out cc_sales_financ_cond.compute_method_id%type,
                           onuInteresPercent  out cc_sales_financ_cond.interest_percent%type,
                           onuInterestRate    out cc_sales_financ_cond.interest_rate_id%type,
                           onuSpread          out cc_sales_financ_cond.spread%type,
                           onuPercentFin      out cc_sales_financ_cond.percent_to_finance%type,
                           sbDocumentSuppport out cc_sales_financ_cond.document_support%type,
                           dtFitsPay          out cc_sales_financ_cond.first_pay_date%type) is
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetPlanDifSale'; --Nombre del método en la traza
    rcPlandife      plandife%rowtype;
    onuMinGraceDays number;
    onuMaxGraceDays number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    rcPlandife := pktblplandife.frcGetRecord(inuFinancingPlan, 0);
    onuComputeMethod  := rcPlandife.pldimccd;
    onuInteresPercent := nvl(rcPlandife.Pldipoin, 0);
    onuInterestRate   := rcPlandife.Plditain;
    onuSpread         := 0;
    onuPercentFin     := nvl(rcPlandife.Pldipmaf, 0);
    if (rcPlandife.Pldidoso is not null) then
      sbDocumentSuppport := rcPlandife.Pldidoso;
    else
      sbDocumentSuppport := 'DF';
    end if;
    pkdeferredplanmgr.GetPlanMinMaxGraceDays(inuFinancingPlan,
                                             onuMinGraceDays,
                                             onuMaxGraceDays);
    dtFitsPay := ut_date.fdtAddDate(dtRequestDate, onuMaxGraceDays) + 1;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetPlanDifSale;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetUnitOperational
  Descripcion    : Retorna 1 si la unidad operativa fue el mismo que realizo la venta y cancelacion
  Autor          : AAcuna
  Fecha          : 18/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPackage:      Numero del paquete
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024     pacosta    OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                            Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  18/10/2012     AAcuna     Creacion
  30/06/2013     KBaquero   Se busca el contratista de la poliza que se
                            ingresa para cancelar, se
  05/12/2019     ESANTIAGO  Se adiciona validacion por el parametro	VALIDA_CANCELACION_SEGURO
				 (HORBATH)  para permitir o no permitir la cancelacion automanica.
  ******************************************************************/
  FUNCTION GetUnitOperational(inuPackage in mo_packages.package_id%type)
   RETURN NUMBER
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetUnitOperational'; --Nombre del método en la traza
    rcMo_Packages     damo_packages.styMO_packages;
    rcSecure_Cancella dald_secure_cancella.styLD_secure_cancella;
    nuPosOperUnitSale mo_packages.pos_oper_unit_id%type;
    nuPosOperUnitCanc mo_packages.pos_oper_unit_id%type;
    nuPolicy          ld_policy.policy_id%type;
    nucontract        ld_policy.contratist_code%type;
    nuUnitOperational number;
    nutipopoli        ld_policy_type.policy_type_id%type;
    frfOperating      CONSTANTS_PER.TYREFCURSOR;
    recOrope          or_operating_unit%ROWTYPE;
	sbValcancelacio   varchar(1);
  BEGIN
	  pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    sbValcancelacio:= pkg_bcld_parameter.fsbobtienevalorcadena('VALIDA_CANCELACION_SEGURO');
     IF sbValcancelacio = 'N' THEN -- INICIO CASO:155, Se añade validacion del parametro
     nuUnitOperational := 0;
     ELSE
     	rcMo_Packages := pkg_bcsolicitudes.frcgetrecord(inuPackage);
     	nuPosOperUnitcanc := rcMo_Packages.pos_oper_unit_id;
     	dald_secure_cancella.getRecord(inuPackage, rcSecure_Cancella);
     	nuPolicy := rcSecure_Cancella.policy_id;
     	nucontract := dald_policy.fnuGetContratist_Code(nuPolicy, null);
     	nutipopoli := dald_policy.fnuGetPolicy_Type_Id(nuPolicy, null);
     	frfOperating := ld_bcsecuremanagement.frfGetOperating(nutipopoli);
     	FETCH frfOperating
     	  INTO recOrope;
     	nuPosOperUnitsale := recOrope.operating_unit_id;
     	CLOSE frfOperating;

     	if (nuPosOperUnitSale = nuPosOperUnitCanc) then
     	  nuUnitOperational := 1;
     	else
     	  nuUnitOperational := 0;
     	end if;
     END IF; -- FIN CASO:155
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return nuUnitOperational;

  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetUnitOperational;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetProductPolicy
  Descripcion    : Obtiene el producto a partir de la poliza
  Autor          : AAcuna
  Fecha          : 06/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:      Numero del suscritor
  onuProduct:       Numero del producto
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  06/10/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE GetProductPolicy(inuPolicy  in ld_policy.policy_id%type,
                             onuProduct out servsusc.sesunuse%type) is
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetProductPolicy'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.GetProductPolicy(inuPolicy, onuProduct);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetProductPolicy;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetCatSubBySuscripc
  Descripcion    : Obtiene la categoria y la subcategoria del contrato con producto
                 de gas activo.
  Autor          : AAcuna
  Fecha          : 23/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:      Numero del contrato
  onuCategory:      Categoria del contrato
  onuSubcateg:      Subcategoria del contrato
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024     pacosta    OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                            Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  26/06/2013     KBaquero   Se coloco validacion para la categoria
                            y subcategoria
  23/10/2012     AAcuna     Creacion

  ******************************************************************/
  PROCEDURE GetCatSubBySuscripc(inuSuscripc in suscripc.susccodi%type,
                                onuCategory out categori.catecodi%type,
                                onuSubcateg out subcateg.sucacodi%type) is

      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetCatSubBySuscripc'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    sbCate := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodCategory);
    nuGas_Service := LD_BOConstans.cnuGasService;
    ld_bcsecuremanagement.ProcValProd(inuSuscripc,
                                      sbCate,
                                      nuGas_Service,
                                      onuCategory,
                                      onuSubcateg);
    if onuCategory = 0 then
       gw_boerrors.checkerror(2741,
                                 'La categoria no es apta para la venta de seguros');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetCatSubBySuscripc;

  /*****************************************************************
   Propiedad intelectual de Open International Systems (c).
   Unidad         : GetLiquidationSecurevalue
   Descripcion    : Obtiene el valor  a liquidar a partir del numero de la orden
   Autor          : KarBaq
   Fecha          : 23/10/2012 SAO 147879
   Parametros         Descripcion
   ============   ===================
   inuorder:      Numero de la orden
   onuValue:      Valor del tipo de poliza
   Historia de Modificaciones
   Fecha            Autor          Modificacion
   ==========  =================== =======================
   22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                   Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
   08/06/2017  KBaquero.caso 200-1225 Se modifica el metodo para que al momento de activar la estrategia
                                      se calcule valor base de cobro de comision y este sea tomado para
                                      la venta y cancelacion de la misma, teniendo en cuenta el nuevo campo de la tabla
                                      LD_VALIDITY_POLICY_TYPE.
   28/02/2017  KBaquero.caso 200-1121 Se modifica para verificar los pagos realizados a las pólizas ya que
                                      en algunos casos no se paga el valor completo y si se cobra completo aseguradora
   25-08-2015  jhinestroza.SAO334177 Se modifica el metodo GetLiquidationSecurevalue, al cual se le agrega
                                     que impacta el valor de la orden de cobro y pago de contratistas
   19-03-2015  Spacheco nc 4416    Se actualiza para redondear valores de liquidacion de las ordenes
                                   de comision de a contraista y pago a contratista de seguro
   27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                       <ld_policy> y creacion de la entidad
                                       <ld_validity_policy_type>
   23/10/2012  KarBaq              Creacion
   27/08/2015  heiberb Cambio 8540 Se modifica el metodo para que al momento de activar la estrategia
                                   se calcule valor base de cobro de comision y este sea tomado para
                                   la venta y cancelacion de la misma.
   ******************************************************************/
  PROCEDURE GetLiquidationSecurevalue(inuorder     in or_order.order_id%type,
                                      onuValue     out ld_validity_policy_type.policy_value%type,
                                      inuValueNota in number default 0) IS

    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetLiquidationSecurevalue'; --Nombre del método en la traza
    -- Declaracion de variables
    onupoli       ld_policy.policy_id%type;
    rcPolicy      dald_policy.styLD_policy;
    rcMopackage   damo_packages.stymo_packages;
    nuProduct     pr_product.product_id%type;
    nupackge      mo_packages.package_id%type;
    NuActiPay     or_order_activity.activity_id%type;
    NuActiCom     or_order_activity.activity_id%type;
    nuOrderPay    or_order_activity.activity_id%type;
    nuOrderCharge or_order_activity.activity_id%type;
    nuValuepol    ld_validity_policy_type.policy_value%type;
    NucomiPay     float;
    NuPoliType    ld_policy_type.policy_type_id%type;
    NuActiPC      or_order_activity.activity_id%type;
    sbState       ld_parameter.value_chain%type;
    rcPolityp     dald_policy_type.styLD_policy_type;
    nuValorBase    ld_policy.base_value%TYPE := 0;
    nuValorPoliza  ld_policy.value_policy%TYPE := 0;
    nuValorDif     ld_policy.value_policy%TYPE := 0;
    nuPorcentaje   NUMBER(10, 6) := 0;
    nuLinea        ld_policy.product_line_id%TYPE;
    nuPolizAnt     ld_policy.policy_id%TYPE;
    nuValorCuotant ld_policy.prem_policy%TYPE := 0;
    nuporcbaseAnt  ld_policy.porc_base_val%TYPE := 0;
    nuValorAge     ld_policy.base_value%TYPE := 0;
    nuCantidad     NUMBER := 0; --cantidad de polizas
    nuValLinea     NUMBER := 0; --valor para conocer si tiene valor porcentaje
    vaFlagEstr     VARCHAR2(2000); --variable para encender/apagar el desarrollo en cualquier momento
    vaFlagEstr2     VARCHAR2(1); --variable para encender/apagar el desarrollo en cualquier momento caso 200-1225
    nuCODSTATEACT  ld_policy.state_policy%type := 1;
    nuCODSTATEREN  ld_policy.state_policy%type := 5;

	--cambio 8540
    CURSOR cuGetBaseValue(inupolicy_id ld_policy.policy_id%type) IS
      SELECT base_value, product_line_id, value_policy
        FROM ld_policy
       WHERE policy_id = inupolicy_id;
    --cambio 8540
    CURSOR cuValidaLinea(inuproduct_line_id ld_policy.product_line_id%type) IS
      SELECT v.valorbas_perc,COUNT(1)
        FROM ld_policy_type p, LD_VALIDITY_POLICY_TYPE v
       WHERE p.policy_type_id=v.policy_type_id
        AND v.valorbas_perc is not null
         AND product_line_id = inuproduct_line_id
          group by v.valorbas_perc;
    /*cursor para buscar si ya hay una poliza y se renueva*/
    CURSOR cuValidaRenov(inupolicy_id ld_policy.policy_id%type) IS
      SELECT Count(1)
        FROM ld_policy ls
       WHERE ls.policy_number IN
             ((SELECT ld.policy_number
                FROM ld_policy ld
               WHERE ld.policy_id = inupolicy_id));
    --cursor para obteneer la poliza inmediatamente anterior
    CURSOR cuPolizAnt(inupolicy_id ld_policy.policy_id%type) IS
      select lp.policy_id, lp.prem_policy, lp.porc_base_val
        from ld_policy lp
       where lp.dtcreate_policy =
             (select max(dtcreate_policy)
                from ld_policy ld
               where ld.policy_number =
                     (select ldp.policy_number
                        from ld_policy ldp
                       where ldp.policy_id = inupolicy_id)
                 and ld.policy_id <> inupolicy_id)
         and lp.policy_number =
             (select ldp.policy_number
                from ld_policy ldp
               where ldp.policy_id = inupolicy_id)
         AND ROWNUM = 1;
    CURSOR cuValuesPolicyByAge IS
      SELECT sum(ld_policy.base_value) total_value
        FROM /*+ Ld_BCSecureManagement.GetValuesPolicyByProd */ ld_policy
       WHERE ld_policy.product_id = nuProduct
         AND ld_policy.state_policy IN (nuCODSTATEACT, nuCODSTATEREN);
    rcValidityPolicyType dald_validity_policy_type.styLD_validity_policy_type; -- JCASTRO
    /*Cursor para obtener si existe alguna poliza cancelada por menos valor*/
    cursor cuvalopagpoli(nunuse servsusc.sesunuse%type,
                         nudife diferido.difecodi%type) is
      select cargvalo - CUCOvaab
        from cargos c, CUENCOBR u
       where c.cargcuco = u.cucocodi
         and c.cargdoso = 'DF-' || nudife
         and u.cuconuse = nunuse
         and cargvalo <> cucovaab
         and CUCOVAAB <> 0
         and cargvalo - CUCOvaab > 0;
  BEGIN
   pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
   /* cambio 8540 flag para deshabilitar el desarrollo*/
    vaFlagEstr := pkg_bcld_parameter.fsbobtienevalorcadena('ESTRATEGIA');
    /*Estrategia del caso 200-1225*/
    vaFlagEstr2 := pkg_bcld_parameter.fsbobtienevalorcadena('ESTRATEGIA2');
    ld_bcsecuremanagement.ProcProductOrder(inuorder,
                                           nuProduct,
                                           nupackge,
                                           NuActiPC);
    if (nupackge IS not null) then
      rcMopackage := pkg_bcsolicitudes.frcgetrecord(nupackge);
    END if;
    if (DALD_PARAMETER.fblExist(LD_BOConstans.CsbActivityPay)) and
       (DALD_PARAMETER.fblExist(LD_BOConstans.CsbActivityCharge)) then
      NuActiPay     := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityPay);
      NuActiCom     := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityCharge);
      nuOrderPay    := to_number(pkg_bcld_parameter.fsbobtienevalorcadena('COD_ACT_PAYMENT_CANC'));
      nuOrderCharge := to_number(pkg_bcld_parameter.fsbobtienevalorcadena('COD_ACT_CHARGE_CANC'));
      sbState       := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      if ((nvl(NuActiPay, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) and
         ((nvl(NuActiCom, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) then
        pkg_traza.Trace('tag name ' || rcMopackage.tag_name, pkg_traza.cnuNivelTrzDef);
        if NuActiPay = NuActiPC OR nuOrderCharge = NuActiPC then
          -- Orden de pago a la aseguradora en venta, se le paga el valor de la poliza que fue vendida
          if (rcMopackage.tag_name = 'P_TRAMITE_DE_VENTA_100236') or
             (rcMopackage.tag_name = 'P_TRAMITE_VENTA_SEGUROS_XML_100261') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              nuValuepol := ((rcPolicy.prem_policy) * rcPolicy.share_policy);
              --se debe poner parametro general para que valide si pone o no valor base total poliza
              NuPoliType := rcPolicy.policy_type_id;
             dald_policy_type.getRecord(NuPoliType, rcPolityp);
              -- JCASTRO
              -- Con base al Numero de la Poliza (onuPoli) que se esta procesando se debe
              -- obtener el Id de la Vigencia asociada a dicha Poliza
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              dald_validity_policy_type.getRecord(rcPolicy.validity_policy_type_id,
                                                  rcValidityPolicyType);
              -- Realizar el update a la poliza para agregar el Valor Base y el Porcentaje
              /* cambio 8540 obtiene valor base y linea para validar la estrategia*/
              OPEN cuGetBaseValue(onupoli);
              FETCH cuGetBaseValue
                INTO nuValorBase, nuLinea, nuValorPoliza;
              CLOSE cuGetBaseValue;
              OPEN cuValidaLinea(nuLinea);
              FETCH cuValidaLinea
                INTO nuPorcentaje,nuValLinea;
              CLOSE cuValidaLinea;
                nuValorBase  := Round(nuValuepol -(nuValuepol * (nuPorcentaje / 100)), 0);
              OPEN cuValidaRenov(onupoli);
              FETCH cuValidaRenov
                INTO nuCantidad;
              CLOSE cuValidaRenov;
              IF nuCantidad > 1 THEN
                UPDATE ld_policy
                   SET base_value = Round(nuValuepol), porc_base_val = 0
                 WHERE policy_id = onupoli;
              ELSE
                IF vaFlagEstr = 'S' or  vaFlagEstr2 ='S' THEN
                  IF nuValLinea > 0 THEN
                    UPDATE ld_policy
                       SET base_value    = Round(nuValuepol -
                                                 (nuValuepol *
                                                 (nuPorcentaje / 100)),
                                                 0),
                           porc_base_val = nuPorcentaje
                     WHERE policy_id = onupoli;
                  ELSE
                    UPDATE ld_policy
                       SET base_value    = Round(nuValuepol),
                           porc_base_val = 0
                     WHERE policy_id = onupoli;
                  END IF;
                ELSE
                  UPDATE ld_policy
                     SET base_value = Round(nuValuepol), porc_base_val = 0
                   WHERE policy_id = onupoli;
                END IF;
              END IF;
              onuValue := round(nuValuepol, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
            -- Orden de pago a la aseguradora en cancelacion, se le debe descontar las cuotas que no ha pagado el cliente
          elsif (rcMopackage.tag_name = 'P_TRAMITE_SALE_100231') or
                (rcMopackage.tag_name =
                'P_CANCELACION_DE_SEGUROS_XML_100266') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',2,3,4,',
                                                       onupoli);
            pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
              -- FSaldana por aqui entra para obtener el valor de la orden de cobro
              -- Valida si se ingeso valor de la nota
              if (inuValueNota = 0) then
                nuValuepol := ((rcPolicy.prem_policy) *
                              rcPolicy.fees_to_return);
              else
                nuValuepol := inuValueNota;
              END if;
              onuValue := round(nuValuepol, 0) * (-1); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
              pkg_traza.Trace('Valor a cancelar ' || onuValue, pkg_traza.cnuNivelTrzDef);
            END if;
          else
            -- es renovacion
            -- Orden de pago a la aseguradora en renovacion, se le paga el valor de la poliza que fue renovada
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              nuValuepol := ((rcPolicy.prem_policy) * rcPolicy.share_policy);
              onuValue := round(nuValuepol, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
          end if;
        elsif NuActiCom = NuActiPC OR nuOrderPay = NuActiPC then
          -- Orden de cobro de comision a la aseguradora, por la venta
          if (rcMopackage.tag_name = 'P_TRAMITE_DE_VENTA_100236') or
             (rcMopackage.tag_name = 'P_TRAMITE_VENTA_SEGUROS_XML_100261') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);

              OPEN cuGetBaseValue(onupoli);
              FETCH cuGetBaseValue
                INTO nuValorBase, nuLinea, nuValorPoliza;
              CLOSE cuGetBaseValue;
              nuValuepol := nuValorBase;
             NuPoliType := rcPolicy.policy_type_id;
             dald_policy_type.getRecord(NuPoliType, rcPolityp);
              -- JCASTRO
              -- Con base al Numero de la Poliza (onuPoli) que se esta procesando se debe
              -- obtener el Id de la Vigencia asociada a dicha Poliza
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              dald_validity_policy_type.getRecord(rcPolicy.validity_policy_type_id,
                                                  rcValidityPolicyType);
              -- NucomiPay := (rcPolityp.commission_porc) / 100; -- JCASTRO
              NucomiPay := (rcValidityPolicyType.commission_perc) / 100; -- JCASTRO
              onuValue := round((nuValuepol * (NucomiPay)), 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
            -- Orden de devolucion de comision a la aseguradora, por la cancelacion de seguro
          elsif (rcMopackage.tag_name = 'P_TRAMITE_SALE_100231') or
                (rcMopackage.tag_name =
                'P_CANCELACION_DE_SEGUROS_XML_100266') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',2,3,4,',
                                                       onupoli);
            pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
            if (dald_policy.fblExist(onupoli)) then
              pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
              dald_policy.getRecord(onupoli, rcPolicy);
              -- FSaldana Obtiene el valor de la orden de pago
              OPEN cuGetBaseValue(onupoli);
              FETCH cuGetBaseValue
                INTO nuValorBase, nuLinea, nuValorPoliza;
              CLOSE cuGetBaseValue;
              IF (inuValueNota = 0) THEN
                --no hay valor en nota
                nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                              rcPolicy.fees_to_return;
              ELSE
                --hay valor en nota
                IF ld_bosecuremanagement.fboAge THEN
                  --cancelacion por edad
                  OPEN cuValuesPolicyByAge;
                  FETCH cuValuesPolicyByAge
                    INTO nuValorAge;
                  CLOSE cuValuesPolicyByAge;
                  --obtiene el valor de todo
                ELSE
                  --cancelacion parcial
                  IF inuValueNota > nuValorPoliza THEN
                    --es mas de una poliza
                    --obtengo el codigo de la poliza anterior
                    OPEN cuPolizAnt(onupoli);
                    FETCH cuPolizAnt
                      INTO nuPolizAnt, nuValorCuotant, nuporcbaseAnt;
                    CLOSE cuPolizAnt;
                    IF nuporcbaseAnt = 0 THEN
                      nuValorDif := (inuValueNota - nuValorPoliza);
                      nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                                    rcPolicy.fees_to_return;
                    ELSE
                      --obtengo la diferencia, valor a devolver de la poliza anterior, cuotas a devolver.
                      nuValorDif := ((inuValueNota - nuValorPoliza) /
                                    nuValorCuotant) *
                                    (nuValorCuotant -
                                    (nuValorCuotant *
                                    (nuporcbaseAnt / 100)));
                      nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                                    rcPolicy.fees_to_return;
                    END IF;
                  ELSE
                    --solo una poliza
                    nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                                  rcPolicy.fees_to_return;
                  END IF;
                END IF;
              END if;

              nuValuepol := nuValuepol + nuValorDif + nuValorAge;
              NuPoliType := rcPolicy.policy_type_id;
              dald_policy_type.getRecord(NuPoliType, rcPolityp);
              -- JCASTRO
              -- Con base al Numero de la Poliza (onuPoli) que se esta procesando se debe
              -- obtener el Id de la Vigencia asociada a dicha Poliza
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              dald_validity_policy_type.getRecord(rcPolicy.validity_policy_type_id,
                                                  rcValidityPolicyType);
              NucomiPay := (rcValidityPolicyType.commission_perc) / 100; -- JCASTRO
              onuValue := (nuValuepol * (NucomiPay)) * (-1);
              onuValue := round(onuValue, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
          else
            -- Orden de cobro de comision a la aseguradora, por la renovacion
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              nuValuepol := ((rcPolicy.prem_policy) * rcPolicy.share_policy);
              nuValorBase := nuValuepol;
              --Hacer Update de valor Base y el porcentaje = 0
              UPDATE ld_policy
                 SET base_value = nuValorBase, porc_base_val = 0
               WHERE policy_id = onupoli;
              NuPoliType := rcPolicy.policy_type_id;
              dald_policy_type.getRecord(NuPoliType, rcPolityp);
              -- JCASTRO
              -- Con base al Numero de la Poliza (onuPoli) que se esta procesando se debe
              -- obtener el Ide la Vigencia asociada a dicha Poliza
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              dald_validity_policy_type.getRecord(rcPolicy.validity_policy_type_id,
                                                  rcValidityPolicyType);
              NucomiPay := (rcValidityPolicyType.commission_perc) / 100; -- JCASTRO
              onuValue := (nuValuepol * (NucomiPay));
              onuvalue := round(onuValue, 0);
            END if;
          end if;
        end if;
      end if;
    end if;
    onuValue := nvl(round(onuValue, 0), 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetLiquidationSecurevalue;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValuePolicyType
  Descripcion    : Obtiene el valor a financiar y la cantidad de meses a diferir
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPolicyType:     Codigo del tipo de poliza
     onuValue:     Valor a financiar
  onuCoverage_Month: Meses de covertura
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  27-08-2013  jcarrillo.SAO214426 1 - Se valida que la poliza este vigente
                                  2 - Se adiciona el parametro <idtRequestDate>
  29/08/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE GetValuePolicyType(inuPolicyType     in ld_policy_type.policy_type_id%type,
                               idtRequestDate    in mo_packages.request_date%type,
                               onuValue          out ld_validity_policy_type.share_value%type,
                               onuCoverage_Month out ld_validity_policy_type.coverage_month%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetValuePolicyType'; --Nombre del método en la traza
    nuValuePolicy ld_validity_policy_type.policy_value%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.GetValuePolicyType(inuPolicyType,
                                             idtRequestDate,
                                             nuValuePolicy,
                                             onuCoverage_Month);
    if (nuValuePolicy IS null) then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'El tipo de poliza [' ||
                                inuPolicyType ||
                                '] no se encuentra vigente' ||
                                ' en la fecha [' || idtRequestDate || ']');
    end if;
    onuValue := nuValuePolicy - (nuValuePolicy / onuCoverage_Month);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetValuePolicyType;


  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValuePolicy
  Descripcion    : Dependiendo el codigo del tipo de poliza obtiene el valor asociado a ese tipo de poliza
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPolicyType:   Codigo de la poliza
  onuValuePolicy:  Cantidad de cedula por tipo de poliza que se encuentren vigentes.
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  27-08-2013  jcarrillo.SAO214742 1 - Se valida que la poliza este vigente
                                  2 - Se adiciona el parametro <idtRequestDate>
  29/08/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE GetValuePolicy(inuPolicyType  in ld_policy_type.policy_type_id%type,
                           idtRequestDate in mo_packages.request_date%type,
                           onuValuePolicy out ld_validity_policy_type.share_value%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetValuePolicy'; --Nombre del método en la traza
    nuCoverage_Month ld_validity_policy_type.coverage_month%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.GetValuePolicyType(inuPolicyType,
                                             idtRequestDate,
                                             onuValuePolicy,
                                             nuCoverage_Month);
    if (onuValuePolicy IS null) then
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'El tipo de poliza [' ||
                                inuPolicyType ||
                                '] no se encuentra vigente' ||
                                ' en la fecha [' || idtRequestDate || ']');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetValuePolicy;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetPolicyCanBySusc
  Descripcion    : Retorna un dato mayor a cero si tiene una poliza asociada y en estado activa
                 sino retorna cero
  Autor          : AAcuna
  Fecha          : 02/11/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSusc:       Identificador del contrato
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  ******************************************************************/
  PROCEDURE GetPolicyCanBySusc(inuSusc in suscripc.susccodi%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetPolicyCanBySusc'; --Nombre del método en la traza
    nuCant number;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStatePolicy)) then
      sbState := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      ld_bcsecuremanagement.GetPolicyCanBySusc(inuSusc, sbState, nuCant);
      if (nuCant = 0) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Este contrato no tiene polizas asociadas o ninguna activa');
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetPolicyCanBySusc;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetSecureInitialValue
  Descripcion    : Devuelve el valor que debe tener la factura a partir del contrato.
  Autor          : AAcuna
  Fecha          : 29/08/2012 SAO 147879
  Parametros           Descripcion
  ============     ===================
  inuSubscription:   Numero del contrato
    onuValue:      Valor a imprimir
  Historia de Modificaciones
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  27-11-2013  hjgomez.SAO224982   Se obtiene el product_status_id como se venia haciendo
  26-11-2013  jrobayo.SAO224855       Se modifica el tipo de variable para nuPrProduct, ya que estaba siendo
                                      declarada de tipo pr_product_status y generaba error al lanzarse la
                                      solicitud de estado de cuenta.
  22-11-2013  hjgomez.SAO224511       Si el contrato no tiene un producto de gas no realiza el doble cupon
  07/09/2013  mmeusburgger.SAO214427  1 - Se elimina el  bloque While
  06/09/2013  mmeusburgger.SAO214427  1 - Se modifica para validar que la subscripcion
                                         no tenga mas de una poliza vigente del mismo tipo de
                                         poliza.
  05/09/2013  mmeusburgger.SAO213104 1 - se adiciona el parametro <<idtRequestDate>>
  04-09-2013  mmeusburgger.SAO214427 1 - Se modifica para validar que el valor
                                         de la cuota de financiacion no se mayor a
                                          <<COD_CUOTA_FIN>>
  03-09-2013  mmeusburgger.SAO214423 1 - Se modificael campo  <<Value_Chain>>
                                         Asociado al parametro <<NUM_DOB_CUP>>
  27-08-2013  jcastro.SAO214742   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  29/08/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE GetSecureInitialValue(inuSubscription in suscripc.susccodi%type,
                                  nuPremValue     out ld_validity_policy_type.share_value%type,
                                  inuRequestdate  in mo_packages.request_date%type default null) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetSecureInitialValue'; --Nombre del método en la traza
    -- Declaracion de variables
    nuSesuCateg       servsusc.sesucate%type;
    nuSesuSucat       servsusc.sesusuca%type;
    nuSesuEstco       servsusc.sesuesco%type;
    nuPrProduct       pr_product.product_status_id%type;
    nuGeo_Loca        ge_geogra_location.GEOGRAP_LOCATION_ID%type;
    onutypepoli       ld_policy_type.policy_type_id%type;
    nuValPolTypId     ld_validity_policy_type.validity_policy_type_id%TYPE;
    nuCoutaFin        ld_parameter.numeric_value%type;
    nuValueFin        ld_parameter.numeric_value%type;
    dtRequestDate     mo_packages.request_date%type;
    orfValidityPolicy CONSTANTS_PER.TYREFCURSOR;
    otbldPolicy       dald_policy.tytbLD_POLICY;
    orfPolicyId       CONSTANTS_PER.TYREFCURSOR;
    otbPolicyId       dald_policy.tytbPOLICY_ID;
    sbCausalCancel    ld_parameter.value_chain%type;
    sbNumDobCup       ld_parameter.value_chain%type;
    nuIndexPolicy     binary_integer;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (inuRequestdate IS null) then
      dtRequestDate := ldc_boconsgenerales.fdtgetsysdate;
    else
      dtRequestDate := inuRequestdate;
    END if;
    nuGas_Service := LD_BOConstans.cnuGasService;
    --se obtienen los parametros
    sbCausalCancel := pkg_bcld_parameter.fsbobtienevalorcadena('CAUS_CANC_BY_SUBS');
    sbNumDobCup    := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOCONSTANS.CnuNumDobCup);
    if ((nvl(nuGas_Service, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) AND
       (pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOCONSTANS.CnuNumDobCup) IS not null) then
      pkg_traza.trace('inuSubscription: ' || inuSubscription, pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace('nuGas_Service: ' || nuGas_Service, pkg_traza.cnuNivelTrzDef);
      ld_bcsecuremanagement.GetSecureInitialValue(inuSubscription,
                                                  nuGas_Service,
                                                  nuSesuCateg,
                                                  nuSesuSucat,
                                                  nuSesuEstco,
                                                  nuPrProduct,
                                                  nuGeo_Loca);
      pkg_traza.trace('nuGeo_Loca: ' || nuGeo_Loca || ' - nuPrProduct: ' || nuPrProduct,
                     pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace('nuSesuCateg: ' || nuSesuCateg, pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace('nuSesuSucat: ' || nuSesuSucat, pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace('nuSesuEstco: ' || nuSesuEstco, pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace('nuPrProduct: ' || nuPrProduct, pkg_traza.cnuNivelTrzDef);
      if (nuPrProduct IS not null and nuPrProduct <> pkg_traza.cnuNivelTrzDef) then
        onutypepoli := Ld_BcSecureManagement.fnuGetPolicyTypeByConf(sbNumDobCup,
                                                                    nuSesuEstco,
                                                                    nuPrProduct,
                                                                    nuSesuCateg,
                                                                    nuSesuSucat,
                                                                    nuGeo_Loca);
        --Generacion de valor de la factura dependiendo del tipo de poliza encontrado con la configuracion del lanzamiento
        ld_bcsecuremanagement.GetSecureInitialValtipo(onutypepoli, -- ld_policy
                                                      nuPremValue);
        pkg_traza.trace('onutypepoli: ' || onutypepoli ||
                       ' - nuPremValue: ' || nuPremValue,
                       pkg_traza.cnuNivelTrzDef);
        -- se valida si se encontro una configuracion para la linea configurada
        if (onutypepoli IS not null) then
          -- se obtiene la vigencia para el tipo poliza
          Ld_BcSecureManagement.GetValidityPolicyType(onutypepoli,
                                                      dtRequestDate,
                                                      nuValPolTypId);
          -- Se valida la vigencia
          if (nuValPolTypId IS not null) then
            --se Consulta si el contrato tiene una poliza del tipo de poliza vigente
            ld_BcSecureManagement.GetValidityPolicy(inuSubscription,
                                                    onutypepoli,
                                                    ldc_boconsgenerales.fdtgetsysdate,
                                                    orfValidityPolicy);
            fetch orfValidityPolicy bulk collect
              INTO otbldPolicy;
            -- Se consultan las polizas de tipo para el subscriptor
            ld_BcSecureManagement.SearchServPolicyState(inuSubscription,
                                                        onutypepoli,
                                                        orfPolicyId);
            fetch orfPolicyId bulk collect
              INTO otbPolicyId;
            if (otbPolicyId.count > 0) then
              --si existen polizas cancelas por el cliente para el tipo de poliza a facturar
              nuIndexPolicy := otbPolicyId.first;
              while nuIndexPolicy IS not null loop
                -- valida poliza cancelada  por el cliente
                if (ld_BcSecureManagement.ValidatePoliCancel(otbPolicyId(nuIndexPolicy),
                                                             nvl(sbCausalCancel,
                                                                 LD_BOConstans.cnuCero))) then
                  pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                            'Existen polizas canceladas por solicitud del cliente para el contrato [' ||
                                            inuSubscription || ']');
                END if;
                nuIndexPolicy := otbPolicyId.next(nuIndexPolicy);
              END loop;
            END if;
          END if;
          -- Se valida que la cuota no supere el valor del parametro <<COD_CUOTA_FIN>>
          if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodShare)) then
            -- Se obtiene el valor del parametro
            nuCoutaFin := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.csbCodShare);
            -- se valida que seas mayor a Cero(0)
            if (nvl(nuCoutaFin, LD_BOConstans.cnuCero) <>
               LD_BOConstans.cnuCero) then
              -- Obtiene el valor de cuota de financiacion por suscritor.
              ld_bcsecuremanagement.ProcValidateClifin(inuSubscription,
                                                       nuValueFin);
              -- Se valida que no se mayo al Parametro
              if (nuValueFin >= nuCoutaFin) then
                pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                          'La cuota de financiacion para este contrato supero el limite permitido');
              end if;
            end if;
          end if;
        END if;
      END if;
    else
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'Los parametros de linea doble cupon, y producto de gas no estan configurados');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);

      if (not blIsPrinted) then
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
        raise PKG_ERROR.CONTROLLED_ERROR;
      else
        nuPremValue := 0;
        pkg_traza.trace('****NO SE LEVANTA EL ERROR por impresion de facturas****',pkg_traza.cnuNivelTrzDef);
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      end if;
    when others then
      if (not blIsPrinted) then
        pkg_error.SetError;
        pkg_error.getError(nuCodMenErro,sbMensaError);
        pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
        raise PKG_ERROR.CONTROLLED_ERROR;
      else
        nuPremValue := 0;
        pkg_traza.trace('****NO SE LEVANTA EL ERROR por impresion de facturas****',pkg_traza.cnuNivelTrzDef);
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      END if;
  END GetSecureInitialValue;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetAddressBySusc
  Descripcion    : Obtiene la direccion de contrato del suscritor
  Autor          : AAcuna
  Fecha          : 28/10/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:      Numero del suscritor
  onuValue:         Direccion
  onuGeo:           Ubicaciun geografica
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  28/10/2012     AAcuna     Creacion
  ******************************************************************/
  PROCEDURE GetAddressBySusc(inuSuscripc in suscripc.susccodi%type,
                             onuValue    out ab_address.address_id%type,
                             onuGeo      out ge_geogra_location.geograp_location_id%type) is
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetAddressBySusc'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.GetAddressBySusc(inuSuscripc, onuValue, onuGeo);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when no_data_found then
      onuValue := null;
      onuGeo   := null;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetAddressBySusc;


  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : FnuValidateCanc
  Descripcion    : Retorna 1 si la cancelacion viene por un tramite de siniestros o cancelacion por archivo
                 plano y 0 si viene por una solicitud de cancelacion
  Autor          : AAcuna
  Fecha          : 20/12/2012 SAO 147879
  Parametros         Descripcion
  ============   ===================
  inuPackage:      Numero del paquete
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
  20/12/2012     AAcuna     Creacion
  20/12/2012     horbath    Se modifico para validar si el causal de cancelacion es el mismo del parametro CAUSAL_POLIZA_SUSPEN_COBRO
  ******************************************************************/
  FUNCTION FnuValidateCanc(inuPackage in mo_packages.package_id%type)
   RETURN NUMBER
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'FnuValidateCanc'; --Nombre del método en la traza
    rcSecure_Cancella dald_secure_cancella.styLD_secure_cancella;
    sbTypeCancel      ld_secure_cancella.type_cancel%type;
	  nuCauCancel      ld_secure_cancella.cancel_causal_id%type;
    nuType            number;
	  nuCauposusco number; --caso: 277
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    dald_secure_cancella.getRecord(inuPackage, rcSecure_Cancella);
    sbTypeCancel := rcSecure_Cancella.type_cancel;
	  nuCauCancel := rcSecure_Cancella.cancel_causal_id;--caso: 277
	  nuCauposusco := pkg_bcld_parameter.fnuobtienevalornumerico('CAUSAL_POLIZA_SUSPEN_COBRO');--caso: 277
    if (sbTypeCancel = 'SINIESTRO' or sbTypeCancel = 'ARCHIVO_PLANO') then
      nuType := 1;
    else
      nuType := 0;
		--inicio caso: 277
		if (nuCauposusco = nuCauCancel)then
		nuType := 1;
		end if;
		--fin caso: 277
    end if;
    return nuType;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END FnuValidateCanc;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : registerOrderReSale
  Descripcion    : Se crea y se asigna la orden de recuperacion de venta teniendo
                 en cuenta que se asigna la orden a la unidad operativa asociado al tipo de poliza
  Autor          : AAcuna
  Fecha          : 24/04/2013 05:55:27 p.m.
  Parametros              Descripcion
  ============            ===================
  inuPackage              Numero de solicitud
  onuOrderId              Numero de la orden
  onuOrderActivityRet     Numero de actividad de la orden retornada
  onuError                Numero de error
  osbMessage              Mensaje de error
  Historia de Modificaciones
  Fecha             Autor             Modificacion
  =========         =========         ====================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DAOR_ORDER.FRCGETRECORD por PKG_BCORDENES.FRCGETRECORD
  ******************************************************************/

  PROCEDURE registerOrderReSale(inuPackage          IN mo_packages.package_id%type,
                                onuOrderId          OUT or_order.order_id%TYPE,
                                onuOrderActivityRet OUT or_order_activity.order_activity_id%TYPE,
                                onuError            OUT number,
                                osbMessage          OUT varchar2) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'registerOrderReSale'; --Nombre del método en la traza
    nuMotive       mo_motive.motive_id%type;
    rcMotive       damo_motive.styMO_motive;
    rcPackage      damo_packages.styMO_packages;
    rcPackageCanc  dald_secure_cancella.styLD_secure_cancella;
    rcPolicy       dald_policy.styLD_policy;
    nuPolicy       ld_policy.policy_id%type;
    nuAddress      mo_packages.address_id%type;
    nuActivityId   or_order_activity.activity_id%type;
    nuUnitOper     mo_packages.pos_oper_unit_id%type;
    frfOperating   CONSTANTS_PER.TYREFCURSOR;
    recOrope       or_operating_unit%ROWTYPE;
    rcOrder        daor_order.styor_order;
    rfCursorPolicy CONSTANTS_PER.TYREFCURSOR;
    nuNextPolicy   number;
    rfPolicy       LD_BOConstans.rfopoper%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if ((dald_parameter.fblexist('COD_ACTIVITY_REC_SALE'))) then
      /* Se obtienen los parametros*/
      nuActivityId := to_number(pkg_bcld_parameter.fnuobtienevalornumerico('COD_ACTIVITY_REC_SALE'));
      /* Se obtiene los registros de la solicitud*/
      rcPackage := pkg_bcsolicitudes.frcgetrecord(inuPackage);
      nuMotive := mo_bopackages.fnuGetInitialMotive(inuPackage);
      /* Se obtiene los motivos de la solicitud*/
      damo_motive.getRecord(nuMotive, rcMotive);
      nuAddress := mo_bopackages.fnuFindAddressId(inuPackage);
      /* Si la solicitud no existe envia mensaje que la solicitud ingresada no existe*/
      if (damo_packages.fblexist(inuPackage) = false) then
        osbMessage := 'SOLICITUD INGRESADA NO EXISTE';
        onuError   := 2741;
        pkg_error.setErrorMessage(onuError, osbMessage);
      else
        pkg_traza.trace('nuAddress' || nuAddress, pkg_traza.cnuNivelTrzDef);
        pkg_traza.trace('rcPackage.subscriber_id' ||rcPackage.subscriber_id,
                       pkg_traza.cnuNivelTrzDef);
        pkg_traza.trace('rcMotive.subscription_id' ||rcMotive.subscription_id,
                       pkg_traza.cnuNivelTrzDef);
        pkg_traza.trace('nuActivityId' || nuActivityId, pkg_traza.cnuNivelTrzDef);
        if ((nuAddress is not null) AND
           (rcPackage.subscriber_id is not null) AND
           (rcMotive.subscription_id is not null) AND
           --(rcMotive.product_id is not null) AND
           (nuActivityId is not null)) then
          /* Si el tipo de solicitud es de tipo no renovacion*/
          if (rcPackage.package_type_id = 100242) then
            /*Se busca las unidades operativas que se encuentran asociadas a este tipo de poliza*/
            rfCursorPolicy := Ld_BcSecureManagement.frfGetOperatingnorenew(inuPackage);
            loop
              fetch rfCursorPolicy bulk collect
                into rfPolicy limit 10;
              nuNextPolicy := rfPolicy.first;
              while (nuNextPolicy is not null) loop
                /* Se crea orden dependiendo al tipo de actividad */
                onuOrderId   := null;
                nuCodMenErro := null;
                api_createorder(inuItemsid         => nuActivityId,
                                inuPackageid       => inuPackage,
                                inuMotiveid        => nuMotive,
                                inuComponentid     => null,
                                inuInstanceid      => null,
                                inuAddressid       => nuAddress,
                                inuElementid       => null,
                                inuSubscriberid    => rcPackage.subscriber_id,
                                inuSubscriptionid  => rcMotive.subscription_id,
                                inuProductid       => rcMotive.product_id,
                                inuOperunitid      => null,
                                idtExecestimdate   => null,
                                inuProcessid       => null,
                                isbComment         => 'Orden generada',
                                iblProcessorder    => false,
                                inuPriorityid      => null,
                                inuOrdertemplateid => null,
                                isbCompensate      => null,
                                inuConsecutive     => null,
                                inuRouteid         => null,
                                inuRouteConsecutive=> null,
                                inuLegalizetrytimes=> null,
                                isbTagname         => null,
                                iblIsacttoGroup    => null,
                                inuRefvalue        => null,
                                inuActionid        => null,
                                ionuOrderid        => onuOrderId,
                                ionuOrderactivityid=> onuOrderActivityRet,
                                onuErrorCode       => nuCodMenErro,
                                osbErrorMessage    => sbMensaError
                                );

                if nvl(nuCodMenErro,0) != 0 then
                    RAISE PKG_ERROR.CONTROLLED_ERROR;
                end if;

                pkg_traza.trace('Se asigna la orden de origen', pkg_traza.cnuNivelTrzDef);
                if (onuOrderId is not null) then
                  rcOrder := pkg_bcordenes.frcgetrecord(onuOrderId);
                  if rcOrder.order_status_id <> 5 then
                    OR_boProcessOrder.updBasicData(rcOrder,
                                                   rcOrder.operating_sector_id,
                                                   null);

                    nuCodMenErro := null;
                    api_assign_order (inuOrder          => onuOrderId,
                                      inuOperatingUnit  => rfPolicy(nuNextPolicy).operating_unit_id,
                                      onuErrorCode      => nuCodMenErro,
                                      osbErrorMessage   => sbMensaError
                                      );
                    if nvl(nuCodMenErro,0) != 0 then
                        RAISE PKG_ERROR.CONTROLLED_ERROR;
                    end if;

                  END if;
                else
                  onuError := 2741;
                  pkg_error.setErrorMessage(onuError,
                                            'La orden no pudo ser generada');
                end if;
                nuNextPolicy := rfPolicy.NEXT(nuNextPolicy);
              end loop;
              EXIT WHEN rfCursorPolicy%NOTFOUND;
            end loop;
            close rfCursorPolicy;
          else
            /* Si el tipo de solicitud es de tipo cancelacion*/
            dald_secure_cancella.getRecord(inuPackage, rcPackageCanc);
            nuPolicy := rcPackageCanc.policy_id;
            /*Se obtiene el tipo de poliza asociado a la poliza*/
            dald_policy.getRecord(nuPolicy, rcPolicy);
            /*Se obtiene la unidad operativa del tipo de poliza, esta unidad operativa se usara para la
            asignacion de ordenes*/
            frfOperating := ld_bcsecuremanagement.frfGetOperating(rcPolicy.policy_type_id);
            FETCH frfOperating
              INTO recOrope;
            nuUnitOper := recOrope.operating_unit_id;
            CLOSE frfOperating;
            /* Se crea orden dependiendo al tipo de actividad */
            nuCodMenErro := null;
            api_createorder(inuItemsid         => nuActivityId,
                            inuPackageid       => inuPackage,
                            inuMotiveid        => nuMotive,
                            inuComponentid     => null,
                            inuInstanceid      => null,
                            inuAddressid       => nuAddress,
                            inuElementid       => null,
                            inuSubscriberid    => rcPackage.subscriber_id,
                            inuSubscriptionid  => rcMotive.subscription_id,
                            inuProductid       => rcMotive.product_id,
                            inuOperunitid      => null,
                            idtExecestimdate   => null,
                            inuProcessid       => null,
                            isbComment         => 'Orden generada',
                            iblProcessorder    => false,
                            inuPriorityid      => null,
                            inuOrdertemplateid => null,
                            isbCompensate      => null,
                            inuConsecutive     => null,
                            inuRouteid         => null,
                            inuRouteConsecutive=> null,
                            inuLegalizetrytimes=> null,
                            isbTagname         => null,
                            iblIsacttoGroup    => null,
                            inuRefvalue        => null,
                            inuActionid        => null,
                            ionuOrderid        => onuOrderId,
                            ionuOrderactivityid=> onuOrderActivityRet,
                            onuErrorCode       => nuCodMenErro,
                            osbErrorMessage    => sbMensaError
                            );
              if nvl(nuCodMenErro,0) != 0 then
                RAISE PKG_ERROR.CONTROLLED_ERROR;
              end if;

            pkg_traza.trace('Se asigna la orden de origen', pkg_traza.cnuNivelTrzDef);
            if (onuOrderId is not null) then
              rcOrder := pkg_bcordenes.frcgetrecord(onuOrderId);
              OR_boProcessOrder.updBasicData(rcOrder,
                                             rcOrder.operating_sector_id,
                                             null);

              nuCodMenErro := null;
              api_assign_order (inuOrder          => onuOrderId,
                                inuOperatingUnit  => nuUnitOper,
                                onuErrorCode      => nuCodMenErro,
                                osbErrorMessage   => sbMensaError
                               ) ;
              if nvl(nuCodMenErro,0) != 0 then
                 RAISE PKG_ERROR.CONTROLLED_ERROR;
              end if;

            else
              onuError := 2741;
              pkg_error.setErrorMessage(onuError,
                                        'La orden no pudo ser generada');
            end if;
          end if;
        else
          osbMessage := 'Los parametros para esta creacion de la orden se encuentra en null';
          onuError   := 2741;
          pkg_error.setErrorMessage(onuError, osbMessage);
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR THEN
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    WHEN OTHERS THEN
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END registerOrderReSale;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetValuepolitypesusc
  Descripcion    : Se busca el valor de la poliza y el tipo de poliza al que pertenece
                 Para asi enviarsela a el cupon
  Autor          : KBaquero
  Fecha          : 23/06/2013 10:38:27 a.m.
  Parametros              Descripcion
  ============            ===================
  inususc               Numero de suscriptor
  onuvalue              Valor del tipo de poliza
  onupolitype           Id. del tipo de poliza
  onuError              Numero de error
  osbMessage            Mensaje de error
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  ******************************************************************/
  PROCEDURE GetValuepolitypesusc(inususc      IN suscripc.susccodi%type,
                                 onupremValue OUT ld_validity_policy_type.share_value%type,
                                 onupolitype  OUT ld_policy_type.policy_type_id%type,
                                 onuadd       out ab_address.address%type,
                                 onuError     OUT number,
                                 osbMessage   OUT varchar2) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetValuepolitypesusc'; --Nombre del método en la traza

    nuGeo      ge_geogra_location.geograp_location_id%type;
    nuCategory categori.catecodi%type;
    nuSubcateg subcateg.sucacodi%type;
    nuSesuCateg servsusc.sesucate%type;
    nuSesuSucat servsusc.sesusuca%type;
    nuSesuEstco servsusc.sesuesco%type;
    nuPrProduct pr_product.product_status_id%type;
    nuGeo_Loca  ge_geogra_location.GEOGRAP_LOCATION_ID%type;
    onuvalue    ld_validity_policy_type.share_value%type;
    sbParentLocation varchar2(2000);
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /*Se busca la informacion del suscriptor de la ubicacion geografica*/
    GetAddressBySusc(inususc, onuadd, nuGeo);
    /*Se obtiene la categotia y subcateogira*/
    GetCatSubBySuscripc(inususc, nuCategory, nuSubcateg);
    /*El parametro del servico del gas*/
    nuGas_Service := LD_BOConstans.cnuGasService;
    if ((nvl(nuGas_Service, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) then
      /*Se obtiene la informacion que es correspondiente al suscriptor*/
      ld_bcsecuremanagement.GetSecureInitialValue(inususc,
                                                  nuGas_Service,
                                                  nuSesuCateg,
                                                  nuSesuSucat,
                                                  nuSesuEstco,
                                                  nuPrProduct,
                                                  nuGeo_Loca);
      -- con la  ubicacion geografica obtenida se buscan los padres
      ge_bogeogra_location.GetGeograpParents(nuGeo_Loca, sbParentLocation);
      /*Se obtiene el  valor del tipo de poliza y el id. del tipo de poliza*/
      Ld_BcSecureManagement.GetpolitypeSecureInitialVal(nuSesuCateg,
                                                        nuSesuSucat,
                                                        nuSesuEstco,
                                                        nuPrProduct,
                                                        sbParentLocation,
                                                        onupremValue,
                                                        onuvalue,
                                                        onupolitype);
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR THEN
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    WHEN OTHERS THEN
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END GetValuepolitypesusc;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : RC_ApplyOSICoupon
  Descripcion    : Se realiza la venta de seguros de doble cupon
  Autor          : Kbaquero
  Fecha          : 22/06/2013 08:55:27 p.m.
  Parametros              Descripcion
  ============            ===================
  inuCoupon               Identificador del cupon
  onuError                Numero de error
  osbMessage              Mensaje de error
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  05-09-2013  mmeusburgger.SAO213104 1 - Se adiciona la validacion <<Sbxcept = Y>>
  04-09-2013  mmeusburgger.SAO214427 1 - Se elimina la validacion de la
                                         fecha de nacimiento.
                                     2 - Se elimina la validacion de vigencia
                                         esta se hara al momento de generar el Cupon
  27-08-2013  jcastro.SAO214426   1 - Se impacta por modificar la entidad
                                      <ld_policy> y creacion de la entidad
                                      <ld_validity_policy_type>
  ******************************************************************/
  PROCEDURE RC_ApplyOSICoupon(inuCoupon   in cupon.cuponume%type,
                              onuvalue    in ld_validity_policy_type.share_value%type,
                              onupolitype in ld_policy_type.policy_type_id%type,
                              onuadd      in ab_address.address%type,
                              onuError    OUT number,
                              osbMessage  OUT varchar2) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'RC_ApplyOSICoupon'; --Nombre del método en la traza

    nususc               suscripc.susccodi%type;
    nugesubs             ge_subscriber.subscriber_id%type;
    nuRecepType          ld_parameter.numeric_value%type;
    nuCategory           categori.catecodi%type;
    nuSubcateg           subcateg.sucacodi%type;
    rcPolicyType         dald_policy_type.styLD_policy_type;
    rcValidityPolicyType dald_validity_policy_type.styLD_validity_policy_type; -- JCASTRO
    nuValPolTypId        ld_validity_policy_type.validity_policy_type_id%TYPE; -- JCASTRO
    nuProductLine        ld_policy_type.product_line_id%type;
    sbRequestXML         constants_per.TIPO_XML_SOL%type;
    nuFinancingPlan      plandife.pldicodi%type;
    rcGesubcri           dage_subscriber.styge_subscriber;
    dtDateBirth          date;
    nuPolicy             ld_policy.policy_id%type;
    nuPackageId          mo_packages.package_id%type;
    nuMotiveId           mo_motive.motive_id%type;
    nuAnswerId           ld_parameter.numeric_value%type;
    Sbxcept              varchar2(1);
    -- Fecha del Pago
    dtPayDate pagos.pagofepa%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuRecepType     := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuRecepType);
    nuFinancingPlan := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuFinancingPlan);
    nuAnswerId      := pkg_bcld_parameter.fnuobtienevalornumerico(LD_BOConstans.cnuAnswerId);
    sbCauCumpl      := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCauCumpl);
    if nvl(nuRecepType, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero or
       nvl(nuFinancingPlan, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero or
       nvl(nuAnswerId, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero or
       nvl(sbCauCumpl, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero then
      begin
        /*Se obtiene la informacion del suscriptor a raiz del cupon*/
        nususc := pktblcupon.fnuGetCuposusc(inuCoupon);
        pkg_traza.Trace('FIN Ld_BoSecureManagement.ProcValContractorId' ||
                       ' - ' || nususc, pkg_traza.cnuNivelTrzDef);
        /*Se obtiene la categoria y subcategoria del suscriptor*/
        GetCatSubBySuscripc(nususc, nuCategory, nuSubcateg);
        pkg_traza.Trace('Salio de aqui Ld_BoSecureManagement.GetCatSubBySuscripc' ||
                       ' - ' || nuCategory || ' - ' || nuSubcateg, pkg_traza.cnuNivelTrzDef);
        /*Se obtiene la informacion del cliente a raiz del suscriptor*/
        nugesubs := PKG_BCCONTRATO.FNUIDCLIENTE(nususc);
        pkg_traza.Trace('El codigo del cliente' || ' - ' || nugesubs, pkg_traza.cnuNivelTrzDef);
        /*Se obtiene el record del cliente*/
        dage_subscriber.getrecord(nugesubs, rcGesubcri);
        /*Se obtiene el record del tipo de poliza*/
        dald_policy_type.getRecord(onupolitype, rcPolicyType);
        pkg_traza.Trace('El tipo de poliza' || ' - ' || onupolitype, pkg_traza.cnuNivelTrzDef);
        -- JCASTRO// Se debe obtener el Id del registro de la Vigencia por Tipo de Poliza
        -- con base al Tipo de Poliza y para la Fecha real de Pago del Cupon tipo Seguro.
        dtPayDate := sysdate;
        -- Asigna el Id del registro de la Vigencia por Tipo de Poliza
        Ld_BcSecureManagement.GetValidityPolicyType(rcPolicyType.policy_type_id,
                                                    dtPayDate,
                                                    nuValPolTypId);
        -- Se valida que la poliza sea vigente
        if (nuValPolTypId IS null) then
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'El tipo de poliza [' ||
                                    rcPolicyType.policy_type_id ||
                                    '] no se encuentra vigente' ||
                                    ' en la fecha [' || dtPayDate || ']');
        end if;
        -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
        dald_validity_policy_type.getRecord(nuValPolTypId, rcValidityPolicyType);
        --la linea del producto del tipo de poliza
        nuProductLine := rcPolicyType.PRODUCT_LINE_ID;
        /*Busca el consecutivo de la poliza*/
        nuPolicy := Ld_BcSecureManagement.Fnunextldpolicy;
        pkg_traza.Trace('El numero de poliza' || ' - ' || nuPolicy, pkg_traza.cnuNivelTrzDef);
        /*Obtiene la fecha de nacimiento del asegurado*/
        ld_bcsecuremanagement.ProcDateBirthSubs(nuSusc, dtDateBirth);
        Sbxcept := 'Y';
        pkg_traza.Trace('Fecha de nacimiento ' || ' - ' || dtDateBirth, pkg_traza.cnuNivelTrzDef);
        /*registro de la venta*/

        --P_TRAMITE_VENTA_SEGUROS_XML_100261 ID_TIPOPAQUETE="100261"
        sbRequestXML :=
        pkg_xml_sol_seguros.getSolicitudVentaSeguros(inuContratoId        => nuSusc,
                                                     inuMedioRecepcionId  => nuRecepType,
                                                     isbComentario        => 'Venta de poliza de seguros por doble cupón.',
                                                     idtFechaSolicitud    => trunc(dtPayDate),
                                                     inuDireccionId       => onuadd,
                                                     inuClienteId         => nugesubs,
                                                     inuPlanFinanciacionId=> nuFinancingPlan,
                                                     inuCuotas            => rcValidityPolicyType.coverage_month,
                                                     inuCategoriaId       => nuCategory,
                                                     inuSubcategId        => nuSubcateg,
                                                     isbExcepcionCom      => Sbxcept,
                                                     inuAseguradoraId     => rcPolicyType.contratista_id,
                                                     inuIdentificacion    => nugesubs,
                                                     nuLineaProductoId    => nuProductLine,
                                                     idtFechaNacimiento   => dtDateBirth,
                                                     inuTipoPolizaId      => onupolitype,
                                                     inuNumeroPoliza      => nuPolicy,
                                                     inuValorPoliza       => rcValidityPolicyType.share_value,
                                                     inuRespuestaId       => nuAnswerId,
                                                     inuCausalIncl        => sbCauCumpl,
                                                     inuProductoId        => null
                                                    );

        pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);
        api_registerrequestbyxml(isbRequestXML    => sbRequestXML,
                                 onuPackageId     => nuPackageId,
                                 onuMotiveId      => nuMotiveId,
                                 onuErrorCode     => onuError,
                                 osbErrorMessage  => osbMessage
                                );

        pkg_traza.Trace('Registro de la venta llego aqui ' || ' - ' ||nuPackageId,
                       pkg_traza.cnuNivelTrzDef);
        if (onuError != 0) then
           pkg_error.setErrorMessage(onuError, osbMessage);
        end if;
      EXCEPTION
        when PKG_ERROR.CONTROLLED_ERROR then
          pkg_error.SetError;
          pkg_error.getError(onuError, osbMessage);
        when OTHERS then
          pkg_error.SetError;
          pkg_error.getError(onuError, osbMessage);
          pkg_traza.Trace('Salio de la venta llego aqui ' || ' - ' ||nuPackageId, pkg_traza.cnuNivelTrzDef);
      end;
    else
       gw_boerrors.checkerror(onuError,
                                'El parametro de tipo de recepcion o respuesta o causal de cumplimiento o
                                 Plan de financiacion se encuentra en blanco');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR THEN
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    WHEN OTHERS THEN
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END RC_ApplyOSICoupon;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcValidateProductparam
  Descripcion    : Valida que el contrato tenga gas activo
  Autor          : Aacuna
  Fecha          : 09/07/2013 SAO 147879
  Parametros               Descripcion
  ============         ===================
  inuSubscriptionId:     Identificador del contrato
  Historia de Modificaciones
  Fecha         Autor      Modificacion
  =========   ========= ====================
  22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  28/09/2012    AAcuna    Creacion
  ******************************************************************/
  PROCEDURE ProcValidateProductparam(inuSubscriptionId in suscripc.susccodi%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcValidateProductparam'; --Nombre del método en la traza
    nuValue      number;
    sbtate       ld_parameter.value_chain%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuGas_Service := LD_BOConstans.cnuGasService;
    if ((nvl(nuGas_Service, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) then
      sbtate := pkg_bcld_parameter.fsbobtienevalorcadena('COD_STATE_PROD_SECURE');
      ld_bcsecuremanagement.ProcValProdparam(inuSubscriptionId,
                                             nuGas_Service,
                                             sbtate,
                                             nuValue);
      if (nuValue = 0) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Este contrato no tiene producto de GAS en los estados permitidos');
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ProcValidateProductparam;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ValidateProdEstacort
  Descripcion    : Valida que el contrato tenga gas en los estado
                   de corte permitido
  Autor          : jcarrillo
  Fecha          : 03/09/2013
  Parametros               Descripcion
  ============         ===================
  inuSubscriptionId:     Identificador del contrato
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========   =================== ==========
  22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  19/09/2013  mmira.SAO217284     1 - Se modifica el metodo que valida los estados
                                  de corte permitidos.
  03/09/2013  jcarrillo.SAO214416 1 - Creacion
  ******************************************************************/
  PROCEDURE ValidateProdEstacort(inuSubscriptionId in suscripc.susccodi%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ValidateProdEstacort'; --Nombre del método en la traza
    nuValue    number;
    sbtateCort ld_parameter.value_chain%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuGas_Service := LD_BOConstans.cnuGasService;
    if (nuGas_Service IS not null) then
      sbtateCort := pkg_bcld_parameter.fsbobtienevalorcadena(ld_boconstans.csbCodEstacort);
      ld_bcsecuremanagement.ValidateProdEstacort(inuSubscriptionId,
                                                 nuGas_Service,
                                                 sbtateCort,
                                                 nuValue);
      if (nuValue IS null OR nuValue = 0) then
        pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                  'Este contrato no tiene producto de GAS en los estados de corte permitidos.');
      end if;
    else
      pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                'Falta la configuracion del parametro "COD_TIPO_SERV" que identifica el codigo del tipo de servicio GAS.');
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END ValidateProdEstacort;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : ProcGetPackagesByContract
  Descripcion    : Valida si existen solicitudes para la cancelacion
                   de Seguros en estado registrado
  Autor          : jrobayo
  Fecha          : 31/08/2013 SAO 147879
  Parametros               Descripcion
  ============         ===================
  inuSusccodi:     Codigo del contrato
  Historia de Modificaciones
  Fecha         Autor             Modificacion
  =========   =========           ====================
  31/08/2013  jrobayo.SAO213977   Creacion
  ******************************************************************/
  PROCEDURE ProcGetPackagesByContract(inuSusccodi IN suscripc.susccodi%TYPE)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'ProcGetPackagesByContract'; --Nombre del método en la traza
    CURSOR cuPackagesByContract IS
      SELECT /*+ INDEX ( p IDX_MO_PACKAGES_03)*/
       count(1) contPackages
        FROM mo_packages p
       WHERE p.subscription_pend_id = inuSusccodi
         AND PACKAGE_TYPE_ID IN (100231, 100266)
         AND motive_status_id = 13;
    rcPackageByContract cuPackagesByContract%ROWTYPE;
    PROCEDURE CloseCursor IS
    BEGIN
      IF (cuPackagesByContract%ISOPEN) THEN
        CLOSE cuPackagesByContract;
      END IF;
    END CloseCursor;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuSusccodi:'||inuSusccodi,pkg_traza.cnuNivelTrzDef);

    CloseCursor;
    /*Validacion de Solicitudes de tipo 100231 y 100266 para la suscripcion sobre la cual se registra la solicitud*/
    IF (pktblsuscripc.fblexist(inuSusccodi)) THEN
      OPEN cuPackagesByContract;
      FETCH cuPackagesByContract
        INTO rcPackageByContract;
      CloseCursor;
      /*Validacion de numero de solicitudes en estado registrado para el contrato*/
      if (rcPackageByContract.contPackages > 0) THEN
        pkg_error.setErrorMessage(2741,
                                  'El contrato cuenta con solicitudes de Cancelacion de Seguros en estado registrado.');
      END if;
    END IF;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    WHEN PKG_ERROR.CONTROLLED_ERROR THEN
      CloseCursor;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
    WHEN others THEN
      CloseCursor;
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      RAISE PKG_ERROR.CONTROLLED_ERROR;
  END ProcGetPackagesByContract;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetAddressFromSinister
  Descripcion    : Obtiene la direccion parseada y la ubicacion
                   geografica de ab_address para el reporte de siniestros
  Autor          : Jorge Alejandro Carmona Duque
  Fecha          : 24/10/2013
  Parametros         Descripcion
  ============   ===================
  inuSuscripc:        Numero del suscritor
  inuProductTypeId:   Tipo de Producto Registrado
  onuAddress:         Direccion Parseada
  onuParserAddress:   Identificador de la direccion
  onuGeo:             Ubicacion Geografica
  Historia de Modificaciones
  Fecha            Autor                  Modificacion
  =========       =========               ====================
  24-10-2013      JCarmona.SAO221126      Creacion.
  ******************************************************************/
  PROCEDURE GetAddressFromSinister(inuSuscripc      in suscripc.susccodi%type,
                                   inuProductTypeId in mo_motive.product_type_id%type,
                                   onuAddress       out mo_address.address%type,
                                   onuParserAddress out mo_address.parser_address_id%type,
                                   onuGeograpLoc    out mo_address.geograp_location_id%type) IS
      csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetAddressFromSinister'; --Nombre del método en la traza
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    ld_bcsecuremanagement.GetAddressFromSinister(inuSuscripc,
                                                 inuProductTypeId,
                                                 onuAddress,
                                                 onuParserAddress,
                                                 onuGeograpLoc);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetAddressFromSinister;
  /*****************************************************************
  Propiedad intelectual de PETI (c).
  Unidad         : valPolicyAmount
  Descripcion    : Valida la cantidad de polizas asociadas a una cedula
  Autor          : llarrarte
  Fecha          : 16-09-2014
  Parametros         Descripcion
  ============   ===================
  inuProductLine  linea de producto
  inuCardNumber   cedula
  inuPolicyType   tipo de poliza
  inuPolicyNumber numero de la poliza
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  16-09-2014  llarrarte.RQ1178  Creacion
  ******************************************************************/
  PROCEDURE valPolicyAmount(inuProductLine  in ld_product_line.product_line_id%type,
                            inuSubscriberId in ge_subscriber.subscriber_id%type,
                            inuPolicyType   in ld_policy_type.policy_type_id%type,
                            inuPolicyNumber in ld_policy.policy_number%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'valPolicyAmount'; --Nombre del método en la traza
    sbLinesParameter   ld_parameter.value_chain%type;
    nuPermitAmount     number;
    nuPermitTypeAmount number;
    nuhavingTypeAmount number;
    nuHavingAmount     number;
    nuHavingExeqAmount number;
    sbCardNumber       ge_subscriber.identification%type;
    nuPolicyId         ld_policy.policy_id%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    pkg_traza.trace('inuProductLine ' || inuProductLine, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuSubscriberId ' || inuSubscriberId, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuPolicyType ' || inuPolicyType, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('inuPolicyNumber ' || inuPolicyNumber, pkg_traza.cnuNivelTrzDef);
    nuPolicyId := ld_bcsecuremanagement.fnuGetIdByPolicyNumber(inuPolicyNumber);
    if (nuPolicyId = 0) then
      sbLinesParameter := pkg_bcld_parameter.fsbobtienevalorcadena(ld_boconstans.CnuNumDobCup);
      pkg_traza.trace('sbLinesParameter ' || sbLinesParameter, pkg_traza.cnuNivelTrzDef);
      /*Cedula del suscriptor*/
      sbCardNumber := PKG_BCCLIENTE.FSBIDENTIFICACION(inuSubscriberId);
      /* Validacion para polizas exequiales */
      if (dald_policy_type.fsbGetIS_EXQ(inuPolicyType) =
         ld_boconstans.csbokFlag) then
        --Obtiene la cantidad de polizas exequiales que tiene asociadas la cedula
        nuHavingExeqAmount := ld_bcsecuremanagement.fnuGetExqPolciesBySuscripc(sbCardNumber);
        pkg_traza.trace('nuHavingExeqAmount ' || nuHavingExeqAmount, pkg_traza.cnuNivelTrzDef);
        if (nuHavingExeqAmount = 1) then
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'El usuario ya tiene una poliza exequial');
        END if;
      END if;
      /* Validacion para puerta a puerta */
      if (instr('|' || sbLinesParameter || '|',
                '|' || inuProductLine || '|') = 0) then
        nuPermitAmount := pkg_bcld_parameter.fnuobtienevalornumerico(ld_boconstans.csbMaxPolizasCedula);
        nuHavingAmount := ld_bcsecuremanagement.fnuGetPoliciesByCard(sbCardNumber);
        pkg_traza.trace('nuPermitAmount ' || nuPermitAmount, pkg_traza.cnuNivelTrzDef);
        pkg_traza.trace('nuHavingAmount ' || nuHavingAmount, pkg_traza.cnuNivelTrzDef);
        if (nuHavingAmount + 1 <= nuPermitAmount) then
          nuPermitTypeAmount := dald_policy_type.fnuGetAMMOUNT_CEDULA(inuPolicyType);
          nuhavingTypeAmount := ld_bcsecuremanagement.fnuGetPoliciesForTypeByCard(inuPolicyType,
                                                                                  sbCardNumber);
          pkg_traza.trace('nuPermitTypeAmount ' || nuPermitTypeAmount, pkg_traza.cnuNivelTrzDef);
          pkg_traza.trace('nuhavingTypeAmount ' || nuhavingTypeAmount, pkg_traza.cnuNivelTrzDef);
          if (nuhavingTypeAmount + 1 > nuPermitTypeAmount) then
            pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                      'El usuario ya tiene la cantidad maxima de polizas de tipo ' ||
                                      inuPolicyType || '-' ||
                                      dald_policy_type.fsbGetDESCRIPTION(inuPolicyType));
          END if;
        else
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'El usuario ya tiene la cantidad maxima de polizas permitida');
        END if;
      END if;
    END if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END valPolicyAmount;

  /*****************************************************************
  Propiedad intelectual de PETI (c).
  Unidad         : fnuGetCollectiveNumber
  Descripcion    : Obtiene el numero del colectivo  de acuerdo a la linea de
                   producto de la poliza: para puerta a puerta se obtienen los
                   4 primeros digitos del numero de la poliza. Para doble cupon
                   se forma a partir de la fecha de creacion de la fecha de
                   creacion de la poliza
  Autor          : llarrarte
  Fecha          : 30-09-2014
  Parametros         Descripcion
  ============   ===================
  inuProductLine  Identificador de la linea de producto
  inuPolicyNumber Numero de la poliza (ld_policy.policy_number)
  idtCreationDate Fecha de creacion de la poliza
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  22/03/2024    pacosta           OSF-2380 Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  30-09-2014  llarrarte.RQ1834  Creacion
  ******************************************************************/
  FUNCTION fnuGetCollectiveNumber(inuProductLine  ld_product_line.product_line_id%type,
                                  inuPolicyNumber ld_policy.policy_number%type,
                                  idtCreationDate ld_policy.dtcreate_policy%type)
    return ld_policy.collective_number%type IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fnuGetCollectiveNumber'; --Nombre del método en la traza
    nuCollective ld_policy.collective_number%type;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* Para puerta a puerta */
    if (instr('|' ||
              pkg_bcld_parameter.fsbobtienevalorcadena(ld_boconstans.CnuNumDobCup) || '|',
              '|' || inuProductLine || '|') = 0) then
      nuCollective := substr(inuPolicyNumber, 1, 4);
    else
      nuCollective := to_char(idtCreationDate, 'YY') ||
                      to_char(idtCreationDate, 'MM');
    END if;
    pkg_traza.trace('nuCollective ' || nuCollective,pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    return nuCollective;
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END fnuGetCollectiveNumber;
  /*****************************************************************
  Propiedad intelectual de PETI (c).
  Unidad         : cancelPolicyByAge
  Descripcion    : Cancela las polizas por limite de edad de cobertura
  Autor          : llarrarte
  Fecha          : 08-10-2014
  Parametros         Descripcion
  ============   ===================
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  =========      =========        ====================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  08-10-2014     llarrarte.RQ2172 Creacion
  ******************************************************************/
  PROCEDURE cancelPolicyByAge IS
    csbMetodo       CONSTANT VARCHAR2(100) := csbNOMPKG||'cancelPolicyByAge'; --Nombre del método en la traza
    nuOrderId       or_order.order_id%type;
    nuPolicyId      ld_policy.policy_id%type;
    nurecptype      number;
    nuContactId     number;
    nuCanCausal     number;
    sbCanBySin      ld_parameter.value_chain%type;
    sbRequestXML    constants_per.TIPO_XML_SOL%type;
    nuPackageId     mo_packages.package_id%type;
    nuMotiveId      mo_motive.motive_id%type;
    onuError        number;
    osbMessage      varchar2(4000);

    CURSOR cuProdByOrder(inuOrderId in or_order.order_id%type) IS
      SELECT PRODUCT_ID
        FROM OR_order o, or_order_activity oa
       WHERE o.order_id = oa.order_id
         AND o.order_id = inuOrderId;

    nuProductId    servsusc.sesunuse%type;
    nuPolicyNumber ld_policy.policy_number%type;
    nuSuscripc     suscripc.susccodi%type;

    CURSOR cuPolicyToCancel(inuProductId in ld_policy.product_id%type) IS
      SELECT policy_id
        FROM (SELECT policy_id
                FROM ld_policy
               WHERE product_id = inuProductId
               ORDER BY DTCREATE_POLICY desc)
       WHERE rownum = 1;
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    nuOrderId := pkg_bcordenes.fnuobtenerotinstancialegal;
    pkg_traza.trace('nuOrderId ' || nuOrderId, pkg_traza.cnuNivelTrzDef);

    open cuProdByOrder(nuOrderId);
    fetch cuProdByOrder
      into nuProductId;
    close cuProdByOrder;

    pkg_traza.trace('nuProductId ' || nuProductId, pkg_traza.cnuNivelTrzDef);
    nuSuscripc := pkg_bcproducto.fnucontrato(nuProductId);
    pkg_traza.trace('nuSuscripc ' || nuSuscripc, pkg_traza.cnuNivelTrzDef);

    open cuPolicyToCancel(nuProductId);
    fetch cuPolicyToCancel
      INTO nuPolicyId;

    nuPolicyNumber := dald_policy.fnuGetPOLICY_NUMBER(nuPolicyId);
    pkg_traza.trace('nuPolicyNumber ' || nuPolicyNumber, pkg_traza.cnuNivelTrzDef);

    nurecptype := pkg_bcld_parameter.fnuobtienevalornumerico('COD_REC_TYPE');
    pkg_traza.trace('nurecptype ' || nurecptype, pkg_traza.cnuNivelTrzDef);

    nuContactId := PKG_BCCONTRATO.FNUIDCLIENTE(nuSuscripc);
    pkg_traza.trace('nuContactId ' || nuContactId, pkg_traza.cnuNivelTrzDef);

    nuCanCausal := pkg_bcld_parameter.fnuobtienevalornumerico(ld_boconstans.cnuCausCancelAge);
    pkg_traza.trace('nuCanCausal ' || nuCanCausal, pkg_traza.cnuNivelTrzDef);

    sbCanBySin := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCanByFil);
    pkg_traza.trace('sbCanBySin ' || sbCanBySin, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('nuPolicyId ' || nuPolicyId, pkg_traza.cnuNivelTrzDef);

    --P_CANCELACION_DE_SEGUROS_XML_100266 ID_TIPOPAQUETE="100266"
    sbRequestXML := pkg_xml_sol_seguros.getSolicitudCancelaSeguros(inuPersonaId         => pkg_bopersonal.fnugetpersonaid(),
                                                                   inuMedioRecepcionId  => nurecptype,
                                                                   isbComentario        => 'Cancelación por limite de edad.',
                                                                   idtFechaSolicitud    => trunc(sysdate),
                                                                   inuDireccionId       => null,
                                                                   inuClienteId         => nuContactId,
                                                                   inuContratoId        => nuSuscripc,
                                                                   inuNumeroPoliza      => nuPolicyId,
                                                                   inuRespuestaId       => null,
                                                                   inuCausalCanceId     => nuCanCausal,
                                                                   isbObservacionPoliza => 'Cancelación por limite de edad.',
                                                                   isbSolicitud         => sbCanBySin
                                                                  );


    pkg_traza.trace('sbRequestXML:'||sbRequestXML,pkg_traza.cnuNivelTrzDef);

    api_registerrequestbyxml(isbRequestXML    => sbRequestXML,
                             onuPackageId     => nuPackageId,
                             onuMotiveId      => nuMotiveId,
                             onuErrorCode     => onuError,
                             osbErrorMessage  => osbMessage
                            );

    pkg_traza.trace('onuError ' || onuError, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('osbMessage ' || osbMessage, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('nuPackageId ' || nuPackageId, pkg_traza.cnuNivelTrzDef);
    pkg_traza.trace('nuMotiveId ' || nuMotiveId, pkg_traza.cnuNivelTrzDef);

    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END cancelPolicyByAge;

  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : fboGetIsNumber
  Descripcion    : Valida si un variable esta compuesta unicamente de
                   caracteres numericos
  Autor          : Manuel Fernando Garcia
  Fecha          : 31/08/2014
  Parametros         Descripcion
  ============   ===================
  isbValue:      Variable a validar
  Historia de Modificaciones
  Fecha            Autor                  Modificacion
  =========       =========               ====================
  31-08-2015      MGarcia.SAO334174      Creacion.
  ******************************************************************/
  FUNCTION fboGetIsNumber(isbValue VARCHAR2) RETURN BOOLEAN IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'fboGetIsNumber'; --Nombre del método en la traza
    sbResultado VARCHAR2(100);
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    SELECT nvl(translate(isbValue, 'T 0123456789', 'T'), 0)
      INTO sbResultado
      FROM dual;
    IF sbResultado = '0' THEN
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      RETURN(TRUE);
    ELSE
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
      RETURN(FALSE);
    END IF;
  END fboGetIsNumber;
  --
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : proccantpolicontexq
  Descripcion    : Valida que no se debe permitir tener mas de n polizas vigentes exequiales
                    por contrato.
  Autor          : KBaquero
  Fecha          :  17/02/2017 caso 200-1106
  Parametros          Descripcion
  ============     ==================
  inuSuscripc    : Numero de suscripcion
  Historia de Modificaciones
  Fecha            Autor       Modificacion
  =========      =========  ====================
  21-03-2024     pacosta          OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
                                  Cambio PKUTLFILEMGR.PUT_LINE por PKG_GESTIONARCHIVOS.PRCESCRIBIRLINEA_SMF
  17/02/2017     KBaquero         Creacion
  ******************************************************************/
  PROCEDURE proccantpolicontexq(inuSuscripc in suscripc.susccodi%type)
   IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'proccantpolicontexq'; --Nombre del método en la traza
    nuValue    number;
    sbLineFile varchar2(1000); -- SAO[334174]
    cursor cucantpoliexqcont(sbStat in ld_parameter.value_chain%type) is
      SELECT /*+ index (p PK_LD_POLICY) index (p IDX_LD_POLICY_05)*/
       count(*)
        FROM ld_policy p
       WHERE p.suscription_id = inuSuscripc
         AND regexp_instr(lpad(p.state_policy, 4, '0'), sbState /*'001|'*/) > 0
         AND p.policy_type_id in
             (select t.policy_type_id
                from ld_policy_type t
               where t.policy_type_id = p.policy_type_id
                 and t.is_exq = 'S');
  BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    if (DALD_PARAMETER.fblexist(LD_BOConstans.csbCodStatePolicy)) then
      sbState      := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      nuCantbyCont := pkg_bcld_parameter.fnuobtienevalornumerico('COD_CANT_POLY_EXEQ');
      if (nvl(nuCantbyCont, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero) then
        OPEN cucantpoliexqcont(sbState);
        FETCH cucantpoliexqcont
          INTO nuValue;
        CLOSE cucantpoliexqcont;
        if (nuValue >= nuCantbyCont) then
          -- SAO[334174]
          sbLineFile := nuContrato || ';' || nuPolicyNum || ';' ||
                        'CANTIDAD POLIZAS' || ';' || nuValue || ';' ||
                        'El contrato supero el limite permitido para las pólizas exequiales' || ';' ||
                        sqlerrm;
          pkg_gestionarchivos.prcescribirlinea_smf(sbFileManagementf, sbLineFile);
          pkg_error.setErrorMessage(pkg_Error.CNUGENERIC_MESSAGE,
                                    'El contrato supero la cantidad de polizas exequiales permitidas');
        end if;
      end if;
    end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END proccantpolicontexq;
  /*****************************************************************
  Propiedad intelectual de Open International Systems (c).
  Unidad         : GetLiquidationSecurevaluerenew
  Descripcion    : Obtiene el valor  a liquidar a partir del numero de la orden
  Autor          : KBaquero - JMGestion informatica
  Fecha          : 20/02/2017 caso 200-1054
  Parametros         Descripcion
  ============   ===================
  inuorder:      Numero de la orden
  onuValue:      Valor del tipo de poliza
  Historia de Modificaciones
  Fecha            Autor          Modificacion
  ==========  =================== =======================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
                                  Cambio DALD_PARAMETER.FSBGETVALUE_CHAIN por PKG_BCLD_PARAMETER.FSBOBTIENEVALORCADENA
  28/02/2017  KBaquero.caso 200-1121 Se modifica para verificar los pagos realizados a las pólizas ya que
                                     en algunos casos no se paga el valor completo y si se cobra completo aseguradora
  20/02/2017  KBaquero            Creacion
  ******************************************************************/
  PROCEDURE GetLiquidationSecurevaluerenew(inuorder     in or_order.order_id%type,
                                           onuValue     out ld_validity_policy_type.policy_value%type,
                                           inuValueNota in number default 0) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'GetLiquidationSecurevaluerenew'; --Nombre del método en la traza
    -- Declaracion de variables
    onupoli       ld_policy.policy_id%type;
    rcPolicy      dald_policy.styLD_policy;
    rcMopackage   damo_packages.stymo_packages;
    nuProduct     pr_product.product_id%type;
    nupackge      mo_packages.package_id%type;
    NuActiPay     or_order_activity.activity_id%type;
    NuActiCom     or_order_activity.activity_id%type;
    nuOrderPay    or_order_activity.activity_id%type;
    nuOrderCharge or_order_activity.activity_id%type;
    nuValuepol    ld_validity_policy_type.policy_value%type;
    NucomiPay     float;
    NuPoliType    ld_policy_type.policy_type_id%type;
    NuActiPC      or_order_activity.activity_id%type;
    sbState       ld_parameter.value_chain%type;
    rcPolityp     dald_policy_type.styLD_policy_type;
    nuValorBase    ld_policy.base_value%TYPE := 0;
    nuValorPoliza  ld_policy.value_policy%TYPE := 0;
    nuValorDif     ld_policy.value_policy%TYPE := 0;
    nuValorAnt     ld_policy.value_policy%TYPE := 0;
    nuPorcentaje   NUMBER(10, 2) := 0;
    nuLinea        ld_policy.product_line_id%TYPE;
    nuPolizAnt     ld_policy.policy_id%TYPE;
    nuValorCuotant ld_policy.prem_policy%TYPE := 0;
    nuporcbaseAnt  ld_policy.porc_base_val%TYPE := 0;
    nuValorAge     ld_policy.base_value%TYPE := 0;
    nuCantidad     NUMBER := 0; --cantidad de polizas
    nuValLinea     NUMBER := 0; --valor para conocer si es linea doble cupon
    vaFlagEstr     VARCHAR2(2000); --variable para encender/apagar el desarrollo en cualquier momento
    nuCODSTATEACT  ld_policy.state_policy%type := 1;
    nuCODSTATEREN  ld_policy.state_policy%type := 5;
    nuvalor        number := 0;

    /* cambio 8540*/
    CURSOR cuGetBaseValue(inupolicy_id ld_policy.policy_id%type) IS
      SELECT base_value, product_line_id, value_policy
        FROM ld_policy
       WHERE policy_id = inupolicy_id;
    /* cambio 8540*/
     CURSOR cuValidaLinea(inuproduct_line_id ld_policy.product_line_id%type) IS
      SELECT v.valorbas_perc,COUNT(1)
        FROM ld_policy_type p, LD_VALIDITY_POLICY_TYPE v
       WHERE p.policy_type_id=v.policy_type_id
        AND v.valorbas_perc is not null
         AND product_line_id = inuproduct_line_id
          group by v.valorbas_perc;
    /*cursor para buscar si ya hay una poliza y se renueva*/
    CURSOR cuValidaRenov(inupolicy_id ld_policy.policy_id%type) IS
      SELECT Count(1)
        FROM ld_policy ls
       WHERE ls.policy_number IN
             ((SELECT ld.policy_number
                FROM ld_policy ld
               WHERE ld.policy_id = inupolicy_id));
    --cursor para obteneer la poliza inmediatamente anterior
    CURSOR cuPolizAnt(inupolicy_id ld_policy.policy_id%type) IS
      select lp.policy_id, lp.prem_policy, lp.porc_base_val
        from ld_policy lp
       where lp.dtcreate_policy =
             (select max(dtcreate_policy)
                from ld_policy ld
               where ld.policy_number =
                     (select ldp.policy_number
                        from ld_policy ldp
                       where ldp.policy_id = inupolicy_id)
                 and ld.policy_id <> inupolicy_id)
         and lp.policy_number =
             (select ldp.policy_number
                from ld_policy ldp
               where ldp.policy_id = inupolicy_id)
         AND ROWNUM = 1;
    CURSOR cuValuesPolicyByAge IS
      SELECT sum(ld_policy.base_value) total_value
        FROM /*+ Ld_BCSecureManagement.GetValuesPolicyByProd */ ld_policy
       WHERE ld_policy.product_id = nuProduct
         AND ld_policy.state_policy IN (nuCODSTATEACT, nuCODSTATEREN);
    rcValidityPolicyType dald_validity_policy_type.styLD_validity_policy_type; -- JCASTRO
    /*Cursor para obtener si existe alguna poliza cancelada por menos valor*/
    cursor cuvalopagpoli(nunuse servsusc.sesunuse%type,
                         nudife diferido.difecodi%type) is
      select cargvalo - CUCOvaab
        from cargos c, CUENCOBR u
       where c.cargcuco = u.cucocodi
         and c.cargdoso = 'DF-' || nudife
         and u.cuconuse = nunuse
         and cargvalo <> cucovaab
         and CUCOVAAB <> 0
         and cargvalo - CUCOvaab > 0;
  BEGIN
   pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
    /* cambio 8540 flag para deshabilitar el desarrollo*/
    vaFlagEstr := pkg_bcld_parameter.fsbobtienevalorcadena('ESTRATEGIA');

    ld_bcsecuremanagement.ProcProductOrder(inuorder,
                                           nuProduct,
                                           nupackge,
                                           NuActiPC);
    if (nupackge IS not null) then
      rcMopackage := pkg_bcsolicitudes.frcgetrecord(nupackge);
    END if;

    if (DALD_PARAMETER.fblExist(LD_BOConstans.CsbActivityPay)) and
       (DALD_PARAMETER.fblExist(LD_BOConstans.CsbActivityCharge)) then
      NuActiPay     := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityPay);
      NuActiCom     := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.CsbActivityCharge);
      nuOrderPay    := to_number(pkg_bcld_parameter.fsbobtienevalorcadena('COD_ACT_PAYMENT_CANC'));
      nuOrderCharge := to_number(pkg_bcld_parameter.fsbobtienevalorcadena('COD_ACT_CHARGE_CANC'));
      sbState       := pkg_bcld_parameter.fsbobtienevalorcadena(LD_BOConstans.csbCodStatePolicy);
      if ((nvl(NuActiPay, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) and
         ((nvl(NuActiCom, LD_BOConstans.cnuCero) <> LD_BOConstans.cnuCero)) then
        pkg_traza.Trace('tag name ' || rcMopackage.tag_name, pkg_traza.cnuNivelTrzDef);
        if NuActiPay = NuActiPC OR nuOrderCharge = NuActiPC then
          -- Orden de pago a la aseguradora en venta, se le paga el valor de la poliza que fue vendida
          if (rcMopackage.tag_name = 'P_TRAMITE_DE_VENTA_100236') or
             (rcMopackage.tag_name = 'P_TRAMITE_VENTA_SEGUROS_XML_100261') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              nuValuepol := ((rcPolicy.prem_policy) * rcPolicy.share_policy);
              --se debe poner parametro general para que valide si pone o no valor base total poliza
              nuPorcentaje := pkg_bcld_parameter.fnuobtienevalornumerico('PORC_BASE_VAL'); --edwardH
              nuValorBase  := Round(nuValuepol -
                                    (nuValuepol * (nuPorcentaje / 100)),
                                    0);
              -- Realizar el update a la poliza para agregar el Valor Base y el Porcentaje
              /* cambio 8540 obtiene valor base y linea para validar la estrategia*/
              OPEN cuGetBaseValue(onupoli);
              FETCH cuGetBaseValue
                INTO nuValorBase, nuLinea, nuValorPoliza;
              CLOSE cuGetBaseValue;
              OPEN cuValidaLinea(nuLinea);
              FETCH cuValidaLinea
                INTO nuporcentaje, nuValLinea;
              CLOSE cuValidaLinea;
              OPEN cuValidaRenov(onupoli);
              FETCH cuValidaRenov
                INTO nuCantidad;
              CLOSE cuValidaRenov;
              IF nuCantidad > 1 THEN
                UPDATE ld_policy
                   SET base_value = Round(nuValuepol), porc_base_val = 0
                 WHERE policy_id = onupoli;
              ELSE
                IF vaFlagEstr = 'S' THEN
                  IF nuValLinea = 0 THEN
                    UPDATE ld_policy
                       SET base_value    = Round(nuValuepol -
                                                 (nuValuepol *
                                                 (nuPorcentaje / 100)),
                                                 0),
                           porc_base_val = nuPorcentaje
                     WHERE policy_id = onupoli;
                  ELSE
                    UPDATE ld_policy
                       SET base_value    = Round(nuValuepol),
                           porc_base_val = 0
                     WHERE policy_id = onupoli;
                  END IF;
                ELSE
                  UPDATE ld_policy
                     SET base_value = Round(nuValuepol), porc_base_val = 0
                   WHERE policy_id = onupoli;
                END IF;
              END IF;
              onuValue := round(nuValuepol, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
            -- Orden de pago a la aseguradora en cancelacion, se le debe descontar las cuotas que no ha pagado el cliente
          elsif (rcMopackage.tag_name = 'P_TRAMITE_SALE_100231') or
                (rcMopackage.tag_name =
                'P_CANCELACION_DE_SEGUROS_XML_100266') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',2,3,4,',
                                                       onupoli);
            pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
              -- FSaldana por aqui entra para obtener el valor de la orden de cobro
              -- Valida si se ingeso valor de la nota
              if (inuValueNota = 0) then
                nuValuepol := ((rcPolicy.prem_policy) *
                              rcPolicy.fees_to_return);

                /*INICIO  Modificación para el caso 200-1121 valor de   */
                  /*caso 200-1121 */
                  OPEN cuvalopagpoli(rcPolicy.DEFERRED_POLICY_ID,
                                     rcPolicy.PRODUCT_ID);
                  FETCH cuvalopagpoli
                    INTO nuvalor;
                  CLOSE cuvalopagpoli;

                  if nuvalor > 0 then
                    nuValuepol := nuValuepol + nuvalor;
                  end if;

              else
                nuValuepol := inuValueNota;
              END if;
              onuValue := round(nuValuepol, 0) * (-1); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
              pkg_traza.Trace('Valor a cancelar ' || onuValue, pkg_traza.cnuNivelTrzDef);
            END if;
          else
            -- es renovacion
            -- Orden de pago a la aseguradora en renovacion, se le paga el valor de la poliza que fue renovada
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              nuValuepol := ((rcPolicy.prem_policy) * rcPolicy.share_policy);
              onuValue := round(nuValuepol, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
          end if;
        elsif NuActiCom = NuActiPC OR nuOrderPay = NuActiPC then
          -- Orden de cobro de comision a la aseguradora, por la venta
          if (rcMopackage.tag_name = 'P_TRAMITE_DE_VENTA_100236') or
             (rcMopackage.tag_name = 'P_TRAMITE_VENTA_SEGUROS_XML_100261') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              OPEN cuGetBaseValue(onupoli);
              FETCH cuGetBaseValue
                INTO nuValorBase, nuLinea, nuValorPoliza;
              CLOSE cuGetBaseValue;
              nuValuepol := nuValorBase;
              NuPoliType := rcPolicy.policy_type_id;
              dald_policy_type.getRecord(NuPoliType, rcPolityp);
              -- JCASTRO
              -- Con base al Numero de la Poliza (onuPoli) que se esta procesando se debe
              -- obtener el Id de la Vigencia asociada a dicha Poliza
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              dald_validity_policy_type.getRecord(rcPolicy.validity_policy_type_id,
                                                  rcValidityPolicyType);
              NucomiPay := (rcValidityPolicyType.COMMISSION_PERC_RENEW) / 100; -- JCASTRO
              onuValue := round((nuValuepol * (NucomiPay)), 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
            -- Orden de devolucion de comision a la aseguradora, por la cancelacion de seguro
          elsif (rcMopackage.tag_name = 'P_TRAMITE_SALE_100231') or
                (rcMopackage.tag_name =
                'P_CANCELACION_DE_SEGUROS_XML_100266') then
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',2,3,4,',
                                                       onupoli);
            pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
            if (dald_policy.fblExist(onupoli)) then
              pkg_traza.Trace('Poliza cancelada ' || onupoli, pkg_traza.cnuNivelTrzDef);
              dald_policy.getRecord(onupoli, rcPolicy);
              -- FSaldana Obtiene el valor de la orden de pago
              OPEN cuGetBaseValue(onupoli);
              FETCH cuGetBaseValue
                INTO nuValorBase, nuLinea, nuValorPoliza;
              CLOSE cuGetBaseValue;
              IF (inuValueNota = 0) THEN
                --no hay valor en nota
                nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                              rcPolicy.fees_to_return;
              ELSE
                --hay valor en nota
                IF ld_bosecuremanagement.fboAge THEN
                  --cancelacion por edad
                  OPEN cuValuesPolicyByAge;
                  FETCH cuValuesPolicyByAge
                    INTO nuValorAge;
                  CLOSE cuValuesPolicyByAge;
                  --obtiene el valor de todo
                ELSE
                  --cancelacion parcial
                  IF inuValueNota > nuValorPoliza THEN
                    --es mas de una poliza
                    --obtengo el codigo de la poliza anterior
                    OPEN cuPolizAnt(onupoli);
                    FETCH cuPolizAnt
                      INTO nuPolizAnt, nuValorCuotant, nuporcbaseAnt;
                    CLOSE cuPolizAnt;
                    IF nuporcbaseAnt = 0 THEN
                      nuValorDif := (inuValueNota - nuValorPoliza);
                      nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                                    rcPolicy.fees_to_return; --heiberb
                    ELSE
                      --obtengo la diferencia, valor a devolver de la poliza anterior, cuotas a devolver.
                      nuValorDif := ((inuValueNota - nuValorPoliza) /
                                    nuValorCuotant) *
                                    (nuValorCuotant -
                                    (nuValorCuotant *
                                    (nuporcbaseAnt / 100)));
                      nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                                    rcPolicy.fees_to_return;
                    END IF;
                  ELSE
                    --solo una poliza
                    nuValuepol := (nuValorBase / rcPolicy.share_policy) *
                                  rcPolicy.fees_to_return;
                  END IF;
                END IF;
              END if;


                /*caso 200-1121 */
                OPEN cuvalopagpoli(rcPolicy.PRODUCT_ID,
                                   rcPolicy.DEFERRED_POLICY_ID);
                FETCH cuvalopagpoli
                  INTO nuvalor;
                CLOSE cuvalopagpoli;

                if nuvalor > 0 then
                  nuValuepol := nuValuepol + nuvalor;
                end if;

              nuValuepol := nuValuepol + nuValorDif + nuValorAge;
              NuPoliType := rcPolicy.policy_type_id;
              dald_policy_type.getRecord(NuPoliType, rcPolityp);
              -- JCASTRO
              -- Con base al Numero de la Poliza (onuPoli) que se esta procesando se debe
              -- obtener el Id de la Vigencia asociada a dicha Poliza
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              dald_validity_policy_type.getRecord(rcPolicy.validity_policy_type_id,
                                                  rcValidityPolicyType);
              NucomiPay := (rcValidityPolicyType.COMMISSION_PERC_RENEW) / 100; -- JCASTRO
              onuValue := (nuValuepol * (NucomiPay)) * (-1);
              onuValue := round(onuValue, 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
            END if;
          else
            -- Orden de cobro de comision a la aseguradora, por la renovacion
            ld_bcsecuremanagement.GetServsPolicyByStat(nuProduct,
                                                       ',1,',
                                                       onupoli);
            if (dald_policy.fblExist(onupoli)) then
              dald_policy.getRecord(onupoli, rcPolicy);
              nuValuepol := ((rcPolicy.prem_policy) * rcPolicy.share_policy);
              nuValorBase := nuValuepol;
              --Hacer Update de valor Base y el porcentaje = 0
              UPDATE ld_policy
                 SET base_value = nuValorBase, porc_base_val = 0
               WHERE policy_id = onupoli;
              NuPoliType := rcPolicy.policy_type_id;
              dald_policy_type.getRecord(NuPoliType, rcPolityp);
              -- JCASTRO
              -- Con base al Numero de la Poliza (onuPoli) que se esta procesando se debe
              -- obtener el Ide la Vigencia asociada a dicha Poliza
              -- Se obtiene el record de la Vigencia por Tipo de Poliza   -- JCASTRO
              dald_validity_policy_type.getRecord(rcPolicy.validity_policy_type_id,
                                                  rcValidityPolicyType);
              -- NucomiPay := (rcPolityp.commission_porc) / 100; -- JCASTRO
              NucomiPay := (rcValidityPolicyType.COMMISSION_PERC_RENEW) / 100; -- JCASTRO
              onuValue := (nuValuepol * (NucomiPay));
              onuvalue := round(onuValue, 0);
            END if;
          end if;
        end if;
      end if;
    end if;
    onuValue := nvl(round(onuValue, 0), 0); --Spacheco nc4416 se modifica para redondear los valores de la ot y evitar decimales
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
  EXCEPTION
    when PKG_ERROR.CONTROLLED_ERROR then
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
      raise PKG_ERROR.CONTROLLED_ERROR;
    when others then
      pkg_error.SetError;
      pkg_error.getError(nuCodMenErro,sbMensaError);
      pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
      raise PKG_ERROR.CONTROLLED_ERROR;
  END GetLiquidationSecurevaluerenew;

	/**************************************************************
    Unidad      :  proRegistraNotaCredito
    Descripcion :  CASO 539: copia de proceso de GDC que se encarga de crear
				   la nota de credito
    Parametros  :  inuProducto   		-- Codigo del producto
                   inuContrato  		-- Codigo del contrato
				   inuCuencobr			-- Codigo de la cuenta de cobro
				   inuConcepto			-- codigo del concepto
				   inuCausa				-- causa del cargo
				   isbDescripcion		-- descripcion de la causa del cargo
				   inuValue				-- saldo pendiente de la deuda diferida
    Autor	       : Miguel Ballesteros
    Fecha	       : 20/01/2020
    Historia de Modificaciones
    Fecha        Autor                  Modificacion
    =========    =========              ====================
    ***************************************************************/
  PROCEDURE proRegistraNotaCredito(  inuProducto          IN servsusc.sesunuse%type,
                                     inuContrato          IN servsusc.sesususc%type,
                                     inuCuencobr          IN cuencobr.cucocodi%type,
                                     inuConcepto          IN concepto.conccodi%type,
                                     inuCausa             IN causcarg.cacacodi%TYPE,
                                     isbDescripcion       IN VARCHAR2,
                                     inuValue             IN diferido.difesape%type)
    IS
        csbMetodo    CONSTANT VARCHAR2(100) := csbNOMPKG||'proRegistraNotaCredito'; --Nombre del método en la traza
        nuNote       notas.notanume%type;
        rcNota       pkg_bcnotasrecord.tyrcNota;
        tbCargos     pkg_bcnotasrecord.tytbCargos;
    BEGIN
        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);
        --  Crea la nota credito
        rcNota.sbPrograma :='CUSTOMER';
        rcNota.nuProducto := inuProducto;
        rcNota.nuCuencobr := inuCuencobr;
        rcNota.nuNotacons := GE_BOConstants.fnuGetDocTypeCreNote;
        rcNota.dtNotafeco := sysdate;
        rcNota.sbNotaobse := isbDescripcion;
        rcNota.sbNotaToken:= pkBillConst.csbTOKEN_NOTA_CREDITO;
        tbCargos(1).nuProducto  := inuProducto;
        tbCargos(1).nuContrato  := inuContrato;
        tbCargos(1).nuCuencobr  := inuCuencobr;
        tbCargos(1).nuConcepto  := inuConcepto;
        tbCargos(1).NuCausaCargo:= inuCausa;
        tbCargos(1).nuValor := inuValue;
        tbCargos(1).nuValorBase := null;
   	    tbCargos(1).sbSigno := pkBillConst.CREDITO;
        tbCargos(1).sbAjustaCuenta := constants_per.CSBSI;
        tbCargos(1).sbCargdoso := pkBillConst.csbTOKEN_NOTA_CREDITO || nuNote;
       	tbCargos(1).sbBalancePostivo := constants_per.CSBNO;
      	tbCargos(1).boApruebaBal := FALSE;
        --Crea la nota con su detalle.
        api_registranotaydetalle(ircNota           => rcNota,
                                 itbCargos         => tbCargos,
                                 onuNote           => nuNote,
                                 onuCodigoError    => nuCodMenErro,
                                 osbMensajeError   => sbMensaError
                                );


        pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
    EXCEPTION
        WHEN PKG_ERROR.CONTROLLED_ERROR THEN
            pkg_error.getError(nuCodMenErro,sbMensaError);
            pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
            pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERC);
            RAISE PKG_ERROR.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            pkg_error.SetError;
            pkg_error.getError(nuCodMenErro,sbMensaError);
            pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
            pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
            RAISE PKG_ERROR.CONTROLLED_ERROR;
    END proRegistraNotaCredito;


    /**************************************************************
    Unidad      :  LDC_VALPRODMIGANULDIFE
    Descripcion :  CASO 539: Este proceso se encarga de realizar las configuraciones a la cuenta corriente
				   despues de haberse hecho la anulacion de diferido y de haberse consultado si la poliza a
				   cancelar esta en la tabla de migracion LDC_MIGRAPOLIZA, lo que hace es dejar el valor de
				   la deuda corriente con el valor anterior que tenia antes de la anulacion y lo mismo con el
				   saldo a favor, ademas que crea la nota de credito a la cuenta de cobro generada de la anulacion
				   del diferido.
    Parametros  :  inuProduct   		-- Codigo del producto
                   inuContrato  		-- Codigo del contrato
				   inuDeudaCorriente	-- valor de la deuda corriente
				   inuCodigoDiferido	-- codigo del diferido
				   inuSaldoFavor		-- saldo a favor del producto
    Autor	       : Miguel Ballesteros
    Fecha	       : 13/11/2020
    Historia de Modificaciones
    Fecha        Autor                  Modificacion
    =========    =========              ====================
  21-03-2024  pacosta             OSF-2380: Implementar Gestion de Archivos GDC - Parte 7
                                  Cambio DALD_PARAMETER.FNUGETNUMERIC_VALUE por PKG_BCLD_PARAMETER.FNUOBTIENEVALORNUMERICO
    ***************************************************************/
   PROCEDURE LDC_VALPRODMIGANULDIFE(inuProduct   			in servsusc.sesunuse%type,
									inuContrato  			in suscripc.susccodi%type,
									inuDeudaCorriente		in number,
									inuCodigoDiferido		in diferido.difecodi%type,
									inuDeudaDiferida		in diferido.difesape%type,
									inuSaldoFavor			in number,
									inuPackage				in mo_packages.package_id%type) IS
    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'LDC_VALPRODMIGANULDIFE'; --Nombre del método en la traza
    ------------------------------------------------------------------------
    --  Variables
    ------------------------------------------------------------------------
	  nuCuenCobProd		cuencobr.cucocodi%type;
	  nuValAlivCovid		number;
	  nuValCuentCorr		number;
	------------------------------------------------------------------------
    --  Cursores
    ------------------------------------------------------------------------
	-- se obtiene la cuenta de cobro apartir del codigo del diferido
	Cursor CuGetCuencobrDife is
		SELECT MAX(cucocodi)
              FROM cargos c, cuencobr cc, diferido d
             WHERE c.cargcuco = cc.cucocodi
               AND c.cargdoso = 'DF-' || d.difecodi
               AND d.difecodi = inuCodigoDiferido
               AND trunc(c.cargfecr) = trunc(sysdate);
	-- cursor que obtiene todas las cuentas de cobro asociada a ese producto
	Cursor CuGetAllCuencobrProd is
		SELECT cu.cucosacu, cu.cucocodi
		FROM cuencobr cu
		WHERE cu.cuconuse = inuProduct
		and   cu.cucosacu is not null
        order by cu.cucocodi;
	-- se obtienen los valores de la descripcion de la causa de cargo y el codigo del concepto de la cuenta de cobro
	Cursor cuGetConcepCargo(nuCucocodi		cuencobr.cucocodi%type)is
		SELECT	CARGCONC CONCEPTO,
				C.CARGCACA CAUSA_ID,
				(SELECT CACADESC FROM CAUSCARG WHERE CACACODI = C.CARGCACA) CAUSA_DESC
		FROM CARGOS C,
			 CUENCOBR CU
		WHERE C.CARGCUCO = CU.CUCOCODI
		AND   CU.CUCOCODI = nuCucocodi;
	-- se valida que el producto de Seguros estará incluido en diferidos generados por la Situación Alivios COVID
	Cursor CuGetProductAliCovid is
		SELECT /*+ index (diferido IX_DIFE_NUSE) */
		   nvl(max(difenucu - difecupa), 0)
			FROM diferido
		   WHERE difenuse = inuProduct
			 AND difenucu - difecupa < difenucu
			 AND difenucu - difecupa <> 0
			 And Difepldi In (Select PLFICOCO From LDC_CONFIG_CONTINGENC
							  Union
							  Select PLFICONT From LDC_CONFIG_CONTINGENC);
	-- se obtiene la cuenta corriente del producto
	Cursor CugetCuentCorr is
		SELECT sum(cb.cucosacu)
			FROM cuencobr cb
			WHERE cb.cuconuse = inuProduct
			AND cucosacu > 0;

    --ca 718 Entrega 1
    nuCause number:=0;
    sbDescripcionCausal causcarg.cacadesc%type;

    Cursor CuCausal(nuCausal in number) is
      select cacadesc
      from open.causcarg
      where cacacodi = nuCausal;
     --ca 718 Entrega 1

BEGIN
   pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

    --INICIO CASO 718 Entrega 1 Causal incorrecta se coloca la causal 1 que esta en el parametro
    nuCause := pkg_bcld_parameter.fnuobtienevalornumerico('COD_CAUSE_CARG');
    if(CuCausal%isopen)then
		close CuCausal;
	end if;

	open CuCausal(nuCause);
	fetch CuCausal into sbDescripcionCausal;
	close CuCausal;
    --FIN CASO 718 Entrega 1 Causal incorrecta se coloca la causal 1 que esta en el parametro


	-- se actualiza el saldo a favor para dejarlo como estaba antes
	--update servsusc set sesusafa = inuDeudaCorriente where sesunuse = inuProduct;
	update servsusc set sesusafa = inuSaldoFavor where sesunuse = inuProduct;
	-- commit;
	-- se obtiene la cuenta de cobro del producto
	if(CuGetCuencobrDife%isopen)then
		close CuGetCuencobrDife;
	end if;
	open CuGetCuencobrDife;
	fetch CuGetCuencobrDife into nuCuenCobProd;
	close CuGetCuencobrDife;
	if(cuGetConcepCargo%isopen)then
		close cuGetConcepCargo;
	end if;
	pkg_traza.Trace('Se inicia el proceso de creacion de NOTAS para la deuda diferida', pkg_traza.cnuNivelTrzDef);

	For i in cuGetConcepCargo(nuCuenCobProd)
	Loop

		-- se crea la nota de credito enviando el valor del diferido guardado
		ldc_boVentaConstructora.proRegistraNotaCredito(	 inuProduct,  				-- producto,
														 inuContrato,				-- contrato
														 nuCuenCobProd,				-- cuentacobro
														 i.Concepto,  	    		--concepto.conccodi%type,
														 nuCause,            	    --causcarg.cacacodi%TYPE,
														 sbDescripcionCausal,       --causcarg.cacadesc%type,
														 inuDeudaDiferida           -- inuValueDiferido

													);

	end loop;

	----------------------------------------------------------------------------------------------------------------
	-- segunda parte del desarrollo 539  se validara si el producto esta incluido en diferidos generados por la Situacion Alivios COVID --

    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);

  EXCEPTION
    when pkg_error.controlled_error then
		pkg_error.getError(nuCodMenErro,sbMensaError);
		pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
		pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
		RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
		pkg_error.SetError;
		pkg_error.getError(nuCodMenErro,sbMensaError);
		pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
		pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
		RAISE PKG_ERROR.CONTROLLED_ERROR;
  END LDC_VALPRODMIGANULDIFE;

  /**************************************************************
    Unidad      :  LDC_VALRETIROPRODUCTO
    Descripcion :  CASO 718: Este proceso se encarga de validar si el producto tiene deudas o alivios de covid
				   y asi no retirar el producto, de lo contrario se retira el producto



    Parametros  :  inuProduct   		-- Codigo del producto

    Autor	       : Olsoftware
    Fecha	       : 27/02/2021

    Historia de Modificaciones
    Fecha        Autor                  Modificacion
    =========    =========              ====================
    ***************************************************************/

   PROCEDURE LDC_VALRETIROPRODUCTO( inuProduct   		in servsusc.sesunuse%type,
									inuPackage			in mo_packages.package_id%type) IS

    csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'LDC_VALRETIROPRODUCTO'; --Nombre del método en la traza
    ------------------------------------------------------------------------
    --  Variables
    ------------------------------------------------------------------------
    nuVal				number:=0;
	nuCant				number;
	nuCuenCobProd		cuencobr.cucocodi%type;

	nuValAlivCovid		number := 0;
	nuValCuentCorr		number := 0;
	------------------------------------------------------------------------
    --  Cursores
    ------------------------------------------------------------------------
	-- se valida que el producto de Seguros estÿ¡ incluido en diferidos generados por la Situaciÿ³n Alivios COVID
	Cursor CuGetProductAliCovid is
		SELECT /*+ index (diferido IX_DIFE_NUSE) */
		   nvl(max(difenucu - difecupa), 0)
			FROM diferido
		   WHERE difenuse = inuProduct
			-- AND difenucu - difecupa < difenucu  CA 718 Se comenta por que si tiene cuotas pagas en 0 no ha pagado alguna
                                                   --el resultado de la resta siempre va ser igual a las cuotas
			 AND difenucu - difecupa <> 0
			 And Difepldi In (Select PLFICOCO From Open.LDC_CONFIG_CONTINGENC
							  Union
							  Select PLFICONT From Open.LDC_CONFIG_CONTINGENC);

	-- se obtiene la cuenta corriente del producto
	Cursor CugetCuentCorr is
		SELECT sum(cb.cucosacu)
			FROM open.cuencobr cb
			WHERE cb.cuconuse = inuProduct
			AND cucosacu > 0;

BEGIN
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

	if(CuGetProductAliCovid%isopen)then
		close CuGetProductAliCovid;
	end if;

	open CuGetProductAliCovid;
	fetch CuGetProductAliCovid into nuValAlivCovid;
	close CuGetProductAliCovid;

	if(CugetCuentCorr%isopen)then
		close CugetCuentCorr;
	end if;

	open CugetCuentCorr;
	fetch CugetCuentCorr into nuValCuentCorr;
	close CugetCuentCorr;


	-- si la variable nuValAlivCovid es menor o igual a cero quiere decir que el producto no tiene alivios de covid por lo que se procede a retirarlo
	-- ademas si la variable nuValCuentCorr es menor o igual a 0 quiere decir que no hay deuda corriente por lo que el producto se puede retirar
	if(nvl(nuValAlivCovid,0) <= 0 and nvl(nuValCuentCorr,0) <= 0)then
		/* Retirar el producto  */
		MO_BORetire.retireProdAttention(mo_bopackages.fnuGetInitialMotive(inupackage));
		pkg_traza.Trace('Se retira el producto', pkg_traza.cnuNivelTrzDef);
	end if;
    pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);

  EXCEPTION
    when pkg_error.controlled_error then
		pkg_error.getError(nuCodMenErro,sbMensaError);
		pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
		pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
		RAISE PKG_ERROR.CONTROLLED_ERROR;
    when others then
		pkg_error.SetError;
		pkg_error.getError(nuCodMenErro,sbMensaError);
		pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
		pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
		RAISE PKG_ERROR.CONTROLLED_ERROR;

END LDC_VALRETIROPRODUCTO;

  FUNCTION FNUGETSALPENPOL ( inuDiferido IN NUMBER,
							 inuproducto IN NUMBER) RETURN NUMBER IS
	/**************************************************************
    Unidad      :  FNUGETSALPENPOL
    Descripcion :  CASO 651: funcion que devuelve el valor acreditado de una poliza



    Parametros  :  inuDiferido   	    -- Codigo del diferido
                   inuproducto  		-- Codigo del producto


    Autor	       : Olsoftware
    Fecha	       : 19/02/2021

    Historia de Modificaciones
    Fecha        Autor                  Modificacion
    =========    =========              ====================
    ***************************************************************/
	  csbMetodo  CONSTANT VARCHAR2(100) := csbNOMPKG||'FNUGETSALPENPOL'; --Nombre del método en la traza
	  nuValorPend NUMBER;

	  nuSaldCorr NUMBER;
	  nuSaldDife NUMBER;

	  CURSOR cuGetSaldCorriete IS
	  Select nvl(SUM(decode(cargsign, 'DB', nvl(cargvalo, 0), -nvl(cargvalo, 0))),0)
	  from cargos, cuencobr
	  where cargnuse = inuproducto
	  and cargdoso = 'DF-'||inuDiferido
	  and cargcuco = cucocodi
	  and nvl(cucosacu,0) > 0;

	  CURSOR cuGetSaldDife IS
	  Select nvl(difesape,0)
	  from diferido
	  where difecodi = inuDiferido;


	BEGIN

	  pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbINICIO);

	  OPEN cuGetSaldCorriete;
	  FETCH cuGetSaldCorriete INTO nuSaldCorr;
	  CLOSE cuGetSaldCorriete;

	  OPEN cuGetSaldDife;
	  FETCH cuGetSaldDife INTO nuSaldDife;
	  CLOSE cuGetSaldDife;

	  nuValorPend := NVL(nuSaldCorr,0) + NVL(nuSaldDife,0);
      pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN);
	  RETURN nuValorPend;
	EXCEPTION
	  WHEN OTHERS THEN
		pkg_error.SetError;
		pkg_error.getError(nuCodMenErro,sbMensaError);
		pkg_traza.trace(csbPrefMerr||nuCodMenErro||'-'||sbMensaError,pkg_traza.cnuNivelTrzDef);
		pkg_traza.trace(csbMetodo,pkg_traza.cnuNivelTrzDef,pkg_traza.csbFIN_ERR);
		RETURN nuValorPend;
	END FNUGETSALPENPOL;
END Ld_BoSecureManagement;
/