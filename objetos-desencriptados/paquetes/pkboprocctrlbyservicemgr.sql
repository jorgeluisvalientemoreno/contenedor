PACKAGE BODY pkBOProcCtrlByServiceMgr AS



















































    
    
    

    
    CSBVERSION CONSTANT VARCHAR2(250) := 'SAO197796';

    
    
    

    
    SBERRMSG GE_ERROR_LOG.DESCRIPTION%TYPE;

    
    BLISLOADED BOOLEAN := FALSE ;

    
    GNUNUMEROHILOS NUMBER ;
    
    
    GBLISMULTIEMPR BOOLEAN;
    
    
    GNUEMPRESA EMPRPRSE.EMPSCODI%TYPE;

    
    
    
    
    
    

    PROCEDURE GETPARAMETERS ;
    
    
    PROCEDURE GETSERVTOLIQARR
        (
            INUCYCLE    IN  CICLO.CICLCODI%TYPE,
            OTBLIQSERV  OUT PKTBLSERVICIO.TYSERVCODI
        );






















PROCEDURE GETPARAMETERS IS

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetParameters');

    
    IF ( BLISLOADED ) THEN
    
        PKERRORS.POP;
        RETURN ;
    
    END IF ;

    
    PKGRLPARAMEXTENDEDMGR.SETCACHEON ;

    GNUNUMEROHILOS := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE
                                                ( 'NRO_PROCESOS_PARALELO' );

    
    

    
    

    
    BLISLOADED := TRUE ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        BLISLOADED := FALSE ;
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        BLISLOADED := FALSE ;
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        BLISLOADED := FALSE ;
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETPARAMETERS;























PROCEDURE BLOCKPROCESS ( ISBPROGRAMA VARCHAR2,
                         INUPERIODOF NUMBER
                       )
IS

BEGIN
    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.BlockProcess');

    
    PKBCPROCEJEC.BLOCKPROCESS(INUPERIODOF,ISBPROGRAMA);

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END BLOCKPROCESS;




































PROCEDURE CHECKPROCCSERVICES
    (
        INUCICLO IN CICLO.CICLCODI%TYPE,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ONUESTADO OUT NUMBER
    )
    IS

    NUIDX NUMBER ;

    
    RCESPRSEPE ESPRSEPE%ROWTYPE ;

    
    
    CNUCOMPLETO CONSTANT NUMBER := 0 ;
    CNUINCOMPLETO CONSTANT NUMBER := 1 ;

    
    CSBPROGRAMA CONSTANT VARCHAR2(4) := 'FGCA' ;

    
    TBSERV PKTBLSERVICIO.TYSERVCODI ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.CheckProccServices');

    
    PKBCSERVTOLIQUIDATE.GETSERVTOLIQARR
        (
            INUCICLO,
            TBSERV
        ) ;

    PKBCESPRSEPE.CLEARCACHE ;

    
    ONUESTADO := CNUCOMPLETO ;

    NUIDX := TBSERV.FIRST ;

    
    LOOP
    

        
        EXIT WHEN NUIDX IS NULL ;

        
        IF (PKBCESPRSEPE.FBLEXIST (TBSERV (NUIDX), INUPERIODO, CSBPROGRAMA))
        THEN
        

            
            PKBCESPRSEPE.GETRECORD
                (
                    TBSERV (NUIDX),
                    INUPERIODO,
                    CSBPROGRAMA,
                    RCESPRSEPE
                );

            
            IF (RCESPRSEPE.EPSPESTA NOT IN (CSBST_TERMINADO, CSBST_AUTORIZADO))
            THEN
                
                ONUESTADO := CNUINCOMPLETO ;

                EXIT;
            END IF;

        
        ELSE
        

            
            ONUESTADO := CNUINCOMPLETO ;
            EXIT;

        
        END IF;

        
        NUIDX := TBSERV.NEXT (NUIDX) ;

    
    END LOOP ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END CHECKPROCCSERVICES;
































PROCEDURE FILLFORMSERVPENDLIQ
(
    INUCICLO IN CICLO.CICLCODI%TYPE,
    INUPERIODO IN PERIFACT.PEFACODI%TYPE,
    IOTBSERVPENDLIQ IN OUT TYTBSERVPENDLIQU
)
IS
    
    TBSERVPENDLIQU PKTBLSERVICIO.TYSERVCODI;
    
    TBESTADO PKTBLESPRSEPE.TYEPSPESTA;
    
    SBPROGRAM VARCHAR2(4) := 'FGCA';

    NUINDEX NUMBER;

BEGIN

    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.FillFormServPendLiq');

    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVPENDLIQ
    (
        INUCICLO,
        INUPERIODO,
        SBPROGRAM,
        TBSERVPENDLIQU,
        TBESTADO
    );

    
    NUINDEX := TBSERVPENDLIQU.FIRST;

    LOOP

        EXIT WHEN NUINDEX IS NULL;

        IOTBSERVPENDLIQ(NUINDEX).SERVCODI := TBSERVPENDLIQU(NUINDEX);
        IOTBSERVPENDLIQ(NUINDEX).SERVESTA := TBESTADO(NUINDEX);

        NUINDEX := TBSERVPENDLIQU.NEXT(NUINDEX);

    END LOOP;


    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FILLFORMSERVPENDLIQ;

































PROCEDURE FILLSERVPENDLIQSERVTYPE
(
    INUCICLO IN CICLO.CICLCODI%TYPE,
    INUPERIODO IN PERIFACT.PEFACODI%TYPE,
    ISBTIPOSERV IN SERVICIO.SERVTISE%TYPE,
    IOTBSERVPENDLIQ IN OUT TYTBSERVPENDLIQU
)
IS
    
    TBSERVPENDLIQU PKTBLSERVICIO.TYSERVCODI;
    
    TBESTADO PKTBLESPRSEPE.TYEPSPESTA;
    
    SBPROGRAM VARCHAR2(4) := 'FGCA';

    NUINDEX NUMBER;
    NUINDEXTMP NUMBER;
    SBTIPO SERVICIO.SERVTISE%TYPE;

BEGIN

    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.FillServPendLiqServType');
    
    
    PKBCESPRSEPE.CLEARCACHE ;

    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVSETTOLIQ
    (
        INUCICLO,
        INUPERIODO,
        SBPROGRAM,
        TBSERVPENDLIQU,
        TBESTADO
    );

    
    
    IF ISBTIPOSERV = '-' THEN

        NUINDEX := TBSERVPENDLIQU.FIRST;

        LOOP

            EXIT WHEN NUINDEX IS NULL;

            IOTBSERVPENDLIQ(NUINDEX).SERVCODI := TBSERVPENDLIQU(NUINDEX);
            IOTBSERVPENDLIQ(NUINDEX).SERVESTA := TBESTADO(NUINDEX);

            NUINDEX := TBSERVPENDLIQU.NEXT(NUINDEX);

        END LOOP;
    ELSE

        NUINDEX := TBSERVPENDLIQU.FIRST;
        NUINDEXTMP := 1;

        LOOP

            EXIT WHEN NUINDEX IS NULL;

            SBTIPO := PKTBLSERVICIO.FSBGETSERVICETYPE ( TBSERVPENDLIQU(NUINDEX) );

            IF ( SBTIPO = ISBTIPOSERV ) THEN
                IOTBSERVPENDLIQ(NUINDEXTMP).SERVCODI := TBSERVPENDLIQU(NUINDEX);
                IOTBSERVPENDLIQ(NUINDEXTMP).SERVESTA := TBESTADO(NUINDEX);
                NUINDEXTMP := NUINDEXTMP + 1;
            END IF;

            NUINDEX := TBSERVPENDLIQU.NEXT(NUINDEX);

        END LOOP;

    END IF;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FILLSERVPENDLIQSERVTYPE;







































PROCEDURE GETEXECMODEBYSERV
    (
        INUSERVICIO IN SERVICIO.SERVCODI%TYPE,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OSBMODO OUT VARCHAR2,
        OSBTABLA OUT VARCHAR2,
        OSBFLAGINCO OUT VARCHAR2,
        OSBIDLASTEXEC OUT ESTAPROG.ESPRPROG%TYPE
    )
    IS

    NUIDX NUMBER ;

    
    SBMODO VARCHAR2(1) ;

    
    SBTABLA VARCHAR2(20) ;

    
    SBFLAGINCO VARCHAR2(1) ;

    
    SBIDLASTEXEC ESTAPROG.ESPRPROG%TYPE ;

    
    RCESPRSEPE ESPRSEPE%ROWTYPE ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetExecModeByServ');

    
    GETPARAMETERS ;

    
    SBMODO := PKBOPROCCTRLBYSERVICEMGR.CSBNORMAL ;
    SBTABLA := PKBOPROCCTRLBYSERVICEMGR.CSBSRC_NORMAL ;
    SBFLAGINCO := PKCONSTANTE.NO ;
    SBIDLASTEXEC := NULL ;

    
    
    IF (PKBCESPRSEPE.FBLEXIST (INUSERVICIO, INUPERIODO, ISBPROGRAMA)) THEN
    

        
        PKBCESPRSEPE.GETRECORD
            (
                INUSERVICIO,
                INUPERIODO,
                ISBPROGRAMA,
                RCESPRSEPE
            ) ;

        IF (RCESPRSEPE.EPSPESTA = PKBOPROCCTRLBYSERVICEMGR.CSBST_INCONSISTENTE)
        THEN
        
            
            
            SBMODO := PKBOPROCCTRLBYSERVICEMGR.CSBINCONSISTENTE ;

            
            SBTABLA := PKBOPROCCTRLBYSERVICEMGR.CSBSRC_INCO ;

        
        ELSIF (RCESPRSEPE.EPSPESTA = PKBOPROCCTRLBYSERVICEMGR.CSBST_AUTORIZADO)
        THEN
        

            
            
            SBMODO := PKBOPROCCTRLBYSERVICEMGR.CSBAUTORIZADO ;

        
        ELSIF (RCESPRSEPE.EPSPESTA = PKBOPROCCTRLBYSERVICEMGR.CSBST_BLOQUEADO
            OR RCESPRSEPE.EPSPESTA = PKBOPROCCTRLBYSERVICEMGR.CSBST_EJECUCION)
        THEN

            
            SBMODO := PKBOPROCCTRLBYSERVICEMGR.CSBCAIDO ;

            
            SBTABLA := RCESPRSEPE.EPSPTABL ;

            
            SBFLAGINCO := RCESPRSEPE.EPSPINPR ;

            
            SBIDLASTEXEC := RCESPRSEPE.EPSPIDPR ;

        END IF;

    
    END IF;

    
    OSBMODO := SBMODO ;
    OSBTABLA := SBTABLA ;
    OSBFLAGINCO := SBFLAGINCO ;
    OSBIDLASTEXEC := SBIDLASTEXEC ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETEXECMODEBYSERV;








































PROCEDURE GETEXECMODEBYSERVARR
    (
        ITBSERVICIOS IN PKTBLSERVICIO.TYSERVCODI,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OTBMODOEJEC OUT PKBOPROCCTRLBYSERVICEMGR.TYTBMODOEJECUCION
    )
    IS

    NUIDX NUMBER ;

    
    SBMODO VARCHAR2(1) ;

    
    SBTABLA ESPRSEPE.EPSPTABL%TYPE;

    
    SBFLAGINCO VARCHAR2(1) ;

    
    SBIDLASTEXEC ESTAPROG.ESPRPROG%TYPE ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetExecModeByServArr');

    
    GETPARAMETERS ;

    
    OTBMODOEJEC.DELETE ;

    NUIDX := ITBSERVICIOS.FIRST ;

    
    LOOP

        
        EXIT WHEN NUIDX IS NULL ;

        
        PKBOPROCCTRLBYSERVICEMGR.GETEXECMODEBYSERV
            (
                ITBSERVICIOS (NUIDX),
                INUPERIODO,
                ISBPROGRAMA,
                SBMODO,
                SBTABLA,
                SBFLAGINCO,
                SBIDLASTEXEC
            ) ;

        
        OTBMODOEJEC (NUIDX).NUSERVICIO := ITBSERVICIOS (NUIDX) ;
        OTBMODOEJEC (NUIDX).SBMODO := SBMODO ;
        OTBMODOEJEC (NUIDX).SBTABLA := SBTABLA ;
        OTBMODOEJEC (NUIDX).SBINCO := SBFLAGINCO ;
        OTBMODOEJEC (NUIDX).SBIDULTIMA := SBIDLASTEXEC ;

        
        NUIDX := ITBSERVICIOS.NEXT (NUIDX) ;

    END LOOP ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETEXECMODEBYSERVARR;

























PROCEDURE GETLASTSUBSSERVPROC ( INUSERVICIO ESTAPRHI.ESPHSERV%TYPE,
                                 ISBULTIDSEGUIM ESPRSEPE.EPSPIDPR%TYPE,
                                 INUHILO NUMBER,
                                 ISBMODOEJEC ESPRSEPE.EPSPESTA%TYPE,
                                 ONUULTIDSERVPROC OUT ESTAPRHI.ESPHTRAC%TYPE
                              )
IS
    
    FUNCTION FNUGETLASTSUBSSERVPROC
    RETURN NUMBER IS
        RCESTAPRHI ESTAPRHI%ROWTYPE;
    BEGIN
    
        PKERRORS.PUSH('pkBOProCtrlBySerMgr.GetLastSuSeProc.fnuGetLastSuSerProc');

        
        IF ( ISBMODOEJEC = PKBOPROCCTRLBYSERVICEMGR.CSBNORMAL ) THEN
        
            PKERRORS.POP;
            RETURN 0;
        
        END IF;

        
        IF ( ISBMODOEJEC = PKBOPROCCTRLBYSERVICEMGR.CSBCAIDO ) THEN
        
            PKBCESTAPRHI.GETRECORD(INUSERVICIO,ISBULTIDSEGUIM,INUHILO,RCESTAPRHI);

            PKERRORS.POP;
            RETURN RCESTAPRHI.ESPHTRAC;
        
        END IF;

        PKERRORS.POP;
        RETURN 0;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END FNUGETLASTSUBSSERVPROC;
    
BEGIN

        PKERRORS.PUSH('pkBOProcCtrlByServMgr.GetLastSubsServProc');

    
    IF ( PKBCESTAPRHI.FBLEXIST(INUSERVICIO,ISBULTIDSEGUIM,INUHILO)) THEN
    
        ONUULTIDSERVPROC := FNUGETLASTSUBSSERVPROC;
    ELSE
        ONUULTIDSERVPROC := 0;
    
    END IF;

EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
                PKERRORS.POP;
                RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END GETLASTSUBSSERVPROC;

    




























PROCEDURE VALPRODTYPELIMIT
    (
        INUREPONUME	IN	REPORTES.REPONUME%TYPE,
        INULIMITE	IN	NUMBER,
        ONURESULTADO	OUT	NUMBER
    )
    IS

    
    NUNUMRECS	NUMBER ;

    
    CNUERROR	CONSTANT NUMBER := 1;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.ValProdTypeLimit');

    
    ONURESULTADO := 0;

    
    PKBCREPOINCO.GETNUMOFRECS
	( 
	    INUREPONUME,
	    NUNUMRECS
	);

    IF (NUNUMRECS > INULIMITE) THEN
	ONURESULTADO := CNUERROR ;
    END IF;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END VALPRODTYPELIMIT;

    































PROCEDURE GETSERVFROMREPOINCO
    (
        INUREPONUME IN REPORTES.REPONUME%TYPE,
        ONUNUMREGIS OUT NUMBER,
        OTBSERVICIOS OUT PKTBLSERVICIO.TYSERVCODI,
        OTBMODOEJEC OUT PKTBLESPRSEPE.TYEPSPESTA,
        OTBTABLAFUENTE OUT PKTBLESPRSEPE.TYEPSPTABL,
        OTBINCO OUT PKTBLESPRSEPE.TYEPSPINPR,
        OTBIDULTIMA OUT PKTBLESPRSEPE.TYEPSPIDPR
    )IS

    RCTBREPOINCO PKTBLREPOINCO.TYTBREPOINCO;
    
BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServFromRepoinco');

    ONUNUMREGIS := 0;

    
    PKBCREPOINCO.GETREPORTRECORDS(  INUREPONUME,
                                    RCTBREPOINCO
                                 );
    IF ( RCTBREPOINCO.REINREPO.FIRST IS NULL ) THEN
    
        PKERRORS.POP;
        RETURN;
    
    END IF;

    FOR NUIDX IN RCTBREPOINCO.REINREPO.FIRST .. RCTBREPOINCO.REINREPO.LAST LOOP
    
        ONUNUMREGIS := ONUNUMREGIS + 1;
        OTBSERVICIOS(NUIDX) := NVL(RCTBREPOINCO.REINLON1(NUIDX),PKCONSTANTE.NULLNUM);
        OTBMODOEJEC(NUIDX) := NVL(RCTBREPOINCO.REINCHR1(NUIDX),PKCONSTANTE.NULLSB);
        OTBTABLAFUENTE(NUIDX) := NVL(RCTBREPOINCO.REINDES1(NUIDX),PKCONSTANTE.NULLSB);
        OTBINCO(NUIDX) := NVL(RCTBREPOINCO.REINCHR2(NUIDX),PKCONSTANTE.NULLSB);
        OTBIDULTIMA(NUIDX) := NVL(RCTBREPOINCO.REINDES2(NUIDX),PKCONSTANTE.NULLSB);
    
    END LOOP;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END GETSERVFROMREPOINCO;









































PROCEDURE GETSERVPENDLIQ
    (
        INUCICLO IN CICLO.CICLCODI%TYPE,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVPEND OUT PKTBLSERVICIO.TYSERVCODI,
        OTBESTADO OUT PKTBLESPRSEPE.TYEPSPESTA
    )
    IS

    
    TBSERVLIQ PKTBLSERVICIO.TYSERVCODI ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServPendLiq');

    
    GETPARAMETERS ;

    
    OTBSERVPEND.DELETE ;

    
    PKBCSERVTOLIQUIDATE.GETSERVTOLIQARR
        (
            INUCICLO,
            TBSERVLIQ
        );

    
    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVSETPENDLIQ
        (
            TBSERVLIQ,
            INUPERIODO,
            ISBPROGRAMA,
            OTBSERVPEND,
            OTBESTADO
        ) ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVPENDLIQ;













































PROCEDURE GETSERVSETPENDLIQ
    (
        ITBSERVLIQ IN PKTBLSERVICIO.TYSERVCODI,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVPEND OUT PKTBLSERVICIO.TYSERVCODI,
        OTBESTADO OUT PKTBLESPRSEPE.TYEPSPESTA
    )
    IS

    NUIDX NUMBER ;

    
    NUSERV SERVICIO.SERVCODI%TYPE ;

    
    SBSTAT ESPRSEPE.EPSPESTA%TYPE ;

    
    RCESPRSEPE ESPRSEPE%ROWTYPE ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServSetPendLiq');

    
    GETPARAMETERS ;

    
    OTBSERVPEND.DELETE ;

    NUIDX := ITBSERVLIQ.FIRST ;

    
    LOOP

        
        EXIT WHEN NUIDX IS NULL ;

        
        NUSERV := ITBSERVLIQ (NUIDX) ;

        
        
        IF (PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGRAMA))
        THEN
        

            
            PKBCESPRSEPE.GETRECORD
                (
                    NUSERV,
                    INUPERIODO,
                    ISBPROGRAMA,
                    RCESPRSEPE
                ) ;

            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_TERMINADO OR
                RCESPRSEPE.EPSPESTA = CSBST_AUTORIZADO) THEN
                GOTO PROXIMO ;
            END IF;

            
            
            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_BLOQUEADO OR
                RCESPRSEPE.EPSPESTA = CSBST_EJECUCION)
            THEN

                
                IF (PKSESSIONMGR.FBLEXISTSESSION (RCESPRSEPE.EPSPPRID)) THEN
                    SBSTAT := RCESPRSEPE.EPSPESTA ;
                ELSE
                    SBSTAT := CSBST_CAIDO ;
                END IF;

            ELSE

                
                SBSTAT := RCESPRSEPE.EPSPESTA ;
            END IF;

        
        ELSE
        

            
            SBSTAT := CSBST_PENDIENTE ;
        
        END IF ;

        
        OTBSERVPEND (NVL(OTBSERVPEND.LAST,0) + 1) := NUSERV ;
        OTBESTADO (NVL(OTBESTADO.LAST,0) + 1) := SBSTAT ;


        << PROXIMO >>

        
        NUIDX := ITBSERVLIQ.NEXT (NUIDX) ;

    END LOOP ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVSETPENDLIQ;


































PROCEDURE GETSERVSETTOAUTHORIZE
    (
        ITBSERVLIQ IN PKTBLSERVICIO.TYSERVCODI,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVTOAUTH IN OUT TYTBSERVTOAUTH
    )
    IS

    NUIDX NUMBER ; 
    NUSERV SERVICIO.SERVCODI%TYPE ; 

    
    RCESPRSEPE ESPRSEPE%ROWTYPE ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServSetToAuthorize');

    
    GETPARAMETERS ;

    
    OTBSERVTOAUTH.DELETE ;

    NUIDX := ITBSERVLIQ.FIRST ;

    
    LOOP

        
        EXIT WHEN NUIDX IS NULL ;

        
        NUSERV := ITBSERVLIQ (NUIDX) ;

        
        
        IF (PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGRAMA))
        THEN
        
            
            PKBCESPRSEPE.GETRECORD
                (
                    NUSERV,
                    INUPERIODO,
                    ISBPROGRAMA,
                    RCESPRSEPE
                ) ;

            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_INCONSISTENTE) THEN

                OTBSERVTOAUTH (NVL(OTBSERVTOAUTH.LAST,0) + 1).SERVCODI := NUSERV ;

            END IF;

            
            
            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_BLOQUEADO OR
                RCESPRSEPE.EPSPESTA = CSBST_EJECUCION) THEN

                
                IF (NOT PKSESSIONMGR.FBLEXISTSESSION (RCESPRSEPE.EPSPPRID)) THEN

                    
                    OTBSERVTOAUTH (NVL(OTBSERVTOAUTH.LAST,0) + 1).SERVCODI := NUSERV ;

                END IF;

            END IF;

        
        END IF ;

        
        NUIDX := ITBSERVLIQ.NEXT (NUIDX) ;

    END LOOP ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVSETTOAUTHORIZE;










































PROCEDURE GETSERVSETTODELLIQ
    (
        ITBSERVLIQ IN PKTBLSERVICIO.TYSERVCODI,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGLIQ IN VARCHAR2,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVDISP OUT TYTBSERVTOAUTH
    )
    IS

    NUIDX NUMBER ;

    
    NUSERV SERVICIO.SERVCODI%TYPE ;

    
    RCESPRSEPE ESPRSEPE%ROWTYPE ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServSetToDelLiq');

    
    GETPARAMETERS ;

    
    OTBSERVDISP.DELETE ;

    NUIDX := ITBSERVLIQ.FIRST ;

    
    LOOP
    

        
        EXIT WHEN NUIDX IS NULL ;

        
        NUSERV := ITBSERVLIQ (NUIDX) ;

        
        
        
        
        IF ( (NOT PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGLIQ))
           AND (NOT PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGRAMA)))
        THEN
            GOTO PROXIMO ;
        END IF;
        
        
        IF (PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGLIQ))
        THEN

            
            PKBCESPRSEPE.GETRECORD
                (
                    NUSERV,
                    INUPERIODO,
                    ISBPROGLIQ,
                    RCESPRSEPE
                ) ;

            
            
            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_BLOQUEADO OR
                RCESPRSEPE.EPSPESTA = CSBST_EJECUCION)
            THEN

                
                IF (PKSESSIONMGR.FBLEXISTSESSION (RCESPRSEPE.EPSPPRID)) THEN
                    GOTO PROXIMO ;
                END IF;

            END IF;
        END IF;

        
        

        IF (PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGRAMA))
        THEN

            
            PKBCESPRSEPE.GETRECORD
                (
                    NUSERV,
                    INUPERIODO,
                    ISBPROGRAMA,
                    RCESPRSEPE
                ) ;
                
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_TERMINADO AND
                NOT PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGLIQ))
            THEN
                GOTO PROXIMO;
            END IF;

            
            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_BLOQUEADO OR
                RCESPRSEPE.EPSPESTA = CSBST_EJECUCION)
            THEN

                
                IF (PKSESSIONMGR.FBLEXISTSESSION (RCESPRSEPE.EPSPPRID)) THEN
                    GOTO PROXIMO ;
                END IF;

            END IF;
        END IF;

        
        OTBSERVDISP(NVL(OTBSERVDISP.LAST,0) + 1).SERVCODI := NUSERV ;

        << PROXIMO >>

        
        NUIDX := ITBSERVLIQ.NEXT (NUIDX) ;

    
    END LOOP ;

    

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVSETTODELLIQ;









































PROCEDURE GETSERVSETTOLIQ
    (
        INUCICLO IN CICLO.CICLCODI%TYPE,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVPEND OUT PKTBLSERVICIO.TYSERVCODI,
        OTBESTADO OUT PKTBLESPRSEPE.TYEPSPESTA
    )
    IS

    
    TBSERVLIQ PKTBLSERVICIO.TYSERVCODI ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServSetToLiq');

    
    GETPARAMETERS ;

    
    OTBSERVPEND.DELETE ;

    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVTOLIQUIDATE
        (
            INUCICLO,
            INUPERIODO,
            ISBPROGRAMA,
            TBSERVLIQ
        );

    
    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVSETPENDLIQ
        (
            TBSERVLIQ,
            INUPERIODO,
            ISBPROGRAMA,
            OTBSERVPEND,
            OTBESTADO
        ) ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVSETTOLIQ;



































PROCEDURE GETSERVSETTOLIQUIDATE
    (
        ITBSERVLIQ IN PKTBLSERVICIO.TYSERVCODI,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVPEND OUT PKTBLSERVICIO.TYSERVCODI
    )
    IS

    NUIDX NUMBER ;

    
    NUSERV SERVICIO.SERVCODI%TYPE ;

    
    RCESPRSEPE ESPRSEPE%ROWTYPE ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServSetToLiquidate');

    
    GETPARAMETERS ;

    
    OTBSERVPEND.DELETE ;

    NUIDX := ITBSERVLIQ.FIRST ;

    
    LOOP

        
        EXIT WHEN NUIDX IS NULL ;

        
        NUSERV := ITBSERVLIQ (NUIDX) ;

        
        
        IF (PKBCESPRSEPE.FBLEXIST (NUSERV, INUPERIODO, ISBPROGRAMA))
        THEN
        

            
            PKBCESPRSEPE.GETRECORD
                (
                    NUSERV,
                    INUPERIODO,
                    ISBPROGRAMA,
                    RCESPRSEPE
                ) ;

            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_TERMINADO) THEN
                GOTO PROXIMO ;
            END IF;

            
            
            
            
            IF (RCESPRSEPE.EPSPESTA = CSBST_BLOQUEADO OR
                RCESPRSEPE.EPSPESTA = CSBST_EJECUCION)
            THEN

                
                IF (PKSESSIONMGR.FBLEXISTSESSION (RCESPRSEPE.EPSPPRID)) THEN
                    GOTO PROXIMO ;
                END IF;

            END IF;

        
        END IF ;

        
        OTBSERVPEND (NVL(OTBSERVPEND.LAST,0) + 1) := NUSERV ;

        << PROXIMO >>

        
        NUIDX := ITBSERVLIQ.NEXT (NUIDX) ;

    END LOOP ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVSETTOLIQUIDATE;





































PROCEDURE GETSERVTOAUTHORIZE
(
    INUCICLO IN CICLO.CICLCODI%TYPE,
    INUPERIODO IN PERIFACT.PEFACODI%TYPE,
    OTBSERVTOAUTH IN OUT TYTBSERVTOAUTH
)
IS
    
    TBSERVLIQ PKTBLSERVICIO.TYSERVCODI ;

    
    SBPROGRAMA VARCHAR2(10):='FGCA';

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServToAuthorize');

    
    GETPARAMETERS ;

    
    OTBSERVTOAUTH.DELETE ;

    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVTOLIQARR
        (
            INUCICLO,
            TBSERVLIQ
        );

    
    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVSETTOAUTHORIZE
        (
            TBSERVLIQ,
            INUPERIODO,
            SBPROGRAMA,
            OTBSERVTOAUTH
        ) ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVTOAUTHORIZE;









































PROCEDURE GETSERVTODELLIQ
    (
        INUCICLO IN CICLO.CICLCODI%TYPE,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGLIQ IN VARCHAR2,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVPEND OUT TYTBSERVTOAUTH
    )
    IS

    
    TBSERVLIQ PKTBLSERVICIO.TYSERVCODI ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServToDelLiq');

    
    GETPARAMETERS ;

    
    OTBSERVPEND.DELETE ;
    
    IF (GBLISMULTIEMPR) THEN
        PKBCSERVTOLIQUIDATE.GETCOMPANYSERVTOLIQ
        (
            GNUEMPRESA,
            TBSERVLIQ
        );
    ELSE
        
        PKBCSERVTOLIQUIDATE.GETSERVTOLIQARR
            (
                INUCICLO,
                TBSERVLIQ
            );
    END IF;

    
    
    

    PKBOPROCCTRLBYSERVICEMGR.GETSERVSETTODELLIQ
        (
            TBSERVLIQ,
            INUPERIODO,
            ISBPROGLIQ,
            ISBPROGRAMA,
            OTBSERVPEND
        ) ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVTODELLIQ;












































PROCEDURE GETSERVTOLIQUIDATE
    (
        INUCICLO IN CICLO.CICLCODI%TYPE,
        INUPERIODO IN PERIFACT.PEFACODI%TYPE,
        ISBPROGRAMA IN VARCHAR2,
        OTBSERVPEND OUT PKTBLSERVICIO.TYSERVCODI
    )
    IS

    
    TBSERVLIQ PKTBLSERVICIO.TYSERVCODI ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServToLiquidate');

    
    GETPARAMETERS ;

    
    OTBSERVPEND.DELETE ;
    
    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVTOLIQARR
        (
            INUCICLO,
            TBSERVLIQ
        );

    
    
    PKBOPROCCTRLBYSERVICEMGR.GETSERVSETTOLIQUIDATE
        (
            TBSERVLIQ,
            INUPERIODO,
            ISBPROGRAMA,
            OTBSERVPEND
        ) ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END GETSERVTOLIQUIDATE;


































PROCEDURE INSSERVTOPROCINREPOINCO
    (
        INUSERVICIO IN REPOINCO.REINLON1%TYPE,
        ISBMODO IN REPOINCO.REINCHR1%TYPE,
        ISBTABLA IN REPOINCO.REINDES1%TYPE,
        ISBINCO IN REPOINCO.REINCHR2%TYPE,
        ISBIDULTIMA IN REPOINCO.REINDES2%TYPE,
        ISBTITULOREPO IN VARCHAR2,
        IONUREPONUME IN OUT REPORTES.REPONUME%TYPE
    )IS

    RCREPOINCO REPOINCO%ROWTYPE;
    
    PROCEDURE FILLREPOINCOREC
    IS
    BEGIN
        PKERRORS.PUSH('pkBOProCtrlBySerMgr.InsServToProcInRepoinco.Fill');

        RCREPOINCO.REINREPO := IONUREPONUME;
        RCREPOINCO.REINLON1 := INUSERVICIO;
        RCREPOINCO.REINCHR1 := ISBMODO;
        RCREPOINCO.REINDES1 := ISBTABLA;
        RCREPOINCO.REINCHR2 := ISBINCO;
        RCREPOINCO.REINDES2 := ISBIDULTIMA;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END FILLREPOINCOREC;
    
BEGIN

    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.InsServToProcInRepoinco');

    
    IF ( NOT PKTBLREPORTES.FBLEXIST(
                                        IONUREPONUME
                                    )) THEN
    
        
        PKREPORTSMGR.CREATEREPORT ( ISBTITULOREPO,
                                    IONUREPONUME
                                  );
    
    END IF;
    
    FILLREPOINCOREC;

    
    PKBCREPOINCO.INSRECORD(RCREPOINCO);

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END INSSERVTOPROCINREPOINCO;






























PROCEDURE INSTABSERVTOPROCINREPO
(
        ITBRCMODOEJEC IN TYTBMODOEJECUCION,
        ISBTITULOREPO IN VARCHAR2,
        IONUREPONUME IN OUT REPORTES.REPONUME%TYPE
)IS
    
BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.InsTabServToProcInRepo');

    IF ( ITBRCMODOEJEC.FIRST IS NULL ) THEN
    
        PKERRORS.POP;
        IONUREPONUME := 0;
        RETURN;
    
    END IF;

    
    FOR NUIDX IN ITBRCMODOEJEC.FIRST .. ITBRCMODOEJEC.LAST LOOP
    
        PKBOPROCCTRLBYSERVICEMGR.INSSERVTOPROCINREPOINCO(
                                     ITBRCMODOEJEC(NUIDX).NUSERVICIO,
                                     ITBRCMODOEJEC(NUIDX).SBMODO,
                                     ITBRCMODOEJEC(NUIDX).SBTABLA,
                                     ITBRCMODOEJEC(NUIDX).SBINCO,
                                     ITBRCMODOEJEC(NUIDX).SBIDULTIMA,
                                     ISBTITULOREPO,
                                     IONUREPONUME
                                    );
    
    END LOOP;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END INSTABSERVTOPROCINREPO;






































































PROCEDURE REGNUMOFSUBSERVBYSERV
    (
        INUCICLO IN CICLO.CICLCODI%TYPE,
        INUPERIODOF IN PERIFACT.PEFACODI%TYPE,
        ITBSERVICIOS IN PKTBLSERVICIO.TYSERVCODI,
        ITBMODOEJEC IN PKTBLESPRSEPE.TYEPSPESTA,
        ITBTABLAFUENTE IN PKTBLESPRSEPE.TYEPSPTABL,
        ISBPROGRAMA IN VARCHAR2,
        OSBIDSEGUIMNUEVO OUT ESTAPROG.ESPRPROG%TYPE
    )
    IS

    PRAGMA AUTONOMOUS_TRANSACTION;

    
    NUNUMSUBSERVICES NUMBER := 0;

    
    SBMENSAJE ESTAPROG.ESPRMESG%TYPE;

    
    
    CURSOR  CU_GETPROBYSERV(SERV_ NUMBER, CICL NUMBER) IS
      SELECT /*+ index(servsusc,ix_servsusc08) */
       COUNT(1)
       FROM   SERVSUSC
       WHERE  SESUCICL = CICL
       AND    SESUSERV = SERV_;
    

    PROCEDURE GETDATA IS

    BEGIN
    

        PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetData');

        OSBIDSEGUIMNUEVO := PKSTATUSEXEPROGRAMMGR.FSBGETPROGRAMID
                                (
                                    ISBPROGRAMA
                                );

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    
    END GETDATA;

    

    PROCEDURE REGSTATUSPROCESS IS
    BEGIN
    

        PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.RegStatusProcess');

        SBMENSAJE := PKTBLMENSAJE.FSBGETDESCRIPTION
                            ( PKCONSTANTE.CSBDIVISION,
                              PKCONSTANTE.CSBMOD_BIL,
                              12067 );

        
        PKSTATUSEXEPROGRAMMGR.ADDRECORD ( OSBIDSEGUIMNUEVO,
                                          SBMENSAJE,
                                          0,
                                          0,
                                          INUPERIODOF);

        COMMIT;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    
    END REGSTATUSPROCESS;

    

    PROCEDURE UPSTATUSEXEPROG
        (
            INUNUMSUSBSERVICES IN ESTAPROG.ESPRTAPR%TYPE
        )
        IS

    BEGIN
    

        PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.UpStatusExeProg');

        IF (INUNUMSUSBSERVICES = 0) THEN
        
            SBMENSAJE := PKTBLMENSAJE.FSBGETDESCRIPTION
                                    ( PKCONSTANTE.CSBDIVISION,
                                      PKCONSTANTE.CSBMOD_GRL,
                                      10032 );
        
        END IF;

        
        PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROG
                (
                    OSBIDSEGUIMNUEVO,
                    SBMENSAJE,
                    0,
                    NULL,
                    INUNUMSUSBSERVICES
                );

        COMMIT;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    
    END UPSTATUSEXEPROG;

    

    FUNCTION FNUGETNUMSUBSERVNORMAL
        (
            INUSERVICIO ESPRSEPE.EPSPSERV%TYPE
        )
        RETURN NUMBER
        IS

        NUREGPORSERV NUMBER := 0;
        RCESPRSEPE ESPRSEPE%ROWTYPE;

    BEGIN
    

        PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.fnuGetNumSubServNormal');

        IF (CU_GETPROBYSERV%ISOPEN) THEN
           CLOSE CU_GETPROBYSERV;
        END IF ;

        OPEN CU_GETPROBYSERV(INUSERVICIO, INUCICLO);
        FETCH CU_GETPROBYSERV INTO NUREGPORSERV;
        CLOSE CU_GETPROBYSERV;

        
        PKBCESPRSEPE.UPDREGTOPROCESS
            (
                INUSERVICIO,
                INUPERIODOF,
                ISBPROGRAMA,
                NUREGPORSERV,
                NULL, 
                0, 
                0, 
                OSBIDSEGUIMNUEVO,
    		    CSBSRC_NORMAL
            );
            

        PKERRORS.POP;
        RETURN (NUREGPORSERV);

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    
    END FNUGETNUMSUBSERVNORMAL;

    

    FUNCTION FNUGETNUMSUBSERVINCO
        (
            INUSERVICIO ESPRSEPE.EPSPSERV%TYPE
        )
        RETURN NUMBER
        IS

        NUREGPORSERV NUMBER := 0;

    BEGIN
    

        PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.fnuGetNumSubServInco');

        
        NUREGPORSERV := PKBCREGIINCO.FNUGETNUMSUBSERBYTHREAD
                        (
                            INUPERIODOF,
                            INUSERVICIO,
                            100, 
                            1, 
                            1 
                        );

        
        PKBCESPRSEPE.UPDREGTOPROCESS
            (
                INUSERVICIO,
                INUPERIODOF,
                ISBPROGRAMA,
                NULL, 
                NUREGPORSERV, 
                NULL, 
                0, 
                OSBIDSEGUIMNUEVO,
		CSBSRC_INCO
            );

        
        PKERRORS.POP;
        RETURN (NUREGPORSERV);

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    
    END FNUGETNUMSUBSERVINCO;

    

    FUNCTION FNUGETNUMSUBSERVFAIL
        (
            INUSERVICIO ESPRSEPE.EPSPSERV%TYPE,
            ISBTABLAFUENTE VARCHAR2
        )
        RETURN NUMBER
        IS

        NUREGFALTANTES NUMBER := 0;
        RCESPRSEPE ESPRSEPE%ROWTYPE;

    BEGIN
    

        PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.fnuGetNumSubServFail');

        PKBCESPRSEPE.GETRECORD( INUSERVICIO,
                                INUPERIODOF,
                                ISBPROGRAMA,
                                RCESPRSEPE );

        
        IF (ISBTABLAFUENTE = CSBSRC_NORMAL) THEN
        

            
            NUREGFALTANTES := NVL(RCESPRSEPE.EPSPNUTO,0) -
                              NVL(RCESPRSEPE.EPSPNUPR,0);

        ELSIF (ISBTABLAFUENTE = CSBSRC_INCO) THEN
            
            
            NUREGFALTANTES := NVL(RCESPRSEPE.EPSPNTIN,0) -
                              NVL(RCESPRSEPE.EPSPNPIN,0);

        
        END IF;

        
        PKBCESPRSEPE.UPDREGTOPROCESS
            (
                INUSERVICIO,
                INUPERIODOF,
                ISBPROGRAMA,
                NULL, 
                NULL, 
                NULL, 
                NULL, 
                OSBIDSEGUIMNUEVO,
		ISBTABLAFUENTE
            );

        
        PKERRORS.POP;
        RETURN (NUREGFALTANTES);

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    
    END FNUGETNUMSUBSERVFAIL;

    

    PROCEDURE PROCESSSERVICES IS
    BEGIN
    

        PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.ProcessServices');

        IF (ITBSERVICIOS.FIRST IS NULL) THEN
            PKERRORS.POP;
            RETURN ;
        END IF;

        FOR NUIDX IN ITBSERVICIOS.FIRST..ITBSERVICIOS.LAST LOOP
        

            PKGENERALSERVICES.TRACEDATA ('Servicio : '||ITBSERVICIOS(NUIDX));
            PKGENERALSERVICES.TRACEDATA ('Modo ejec: '||ITBMODOEJEC(NUIDX));

            
            IF (ITBMODOEJEC(NUIDX) = CSBNORMAL) THEN
            

                NUNUMSUBSERVICES := NUNUMSUBSERVICES +
                                FNUGETNUMSUBSERVNORMAL(ITBSERVICIOS(NUIDX));

            ELSIF (ITBMODOEJEC(NUIDX) = CSBINCONSISTENTE) THEN

                NUNUMSUBSERVICES := NUNUMSUBSERVICES +
                                FNUGETNUMSUBSERVINCO(ITBSERVICIOS(NUIDX));

            ELSIF (ITBMODOEJEC(NUIDX) = CSBCAIDO) THEN

                NUNUMSUBSERVICES := NUNUMSUBSERVICES +
                    FNUGETNUMSUBSERVFAIL(ITBSERVICIOS(NUIDX),
                                         ITBTABLAFUENTE(NUIDX));
            
            END IF;

        
        END LOOP;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    
    END PROCESSSERVICES;

    

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.RegNumOfSubServByServ');

    
    GETDATA;

    
    REGSTATUSPROCESS;

    
    PROCESSSERVICES;

    PKGENERALSERVICES.TRACEDATA ('Numero total productos: '||NUNUMSUBSERVICES);

    
    UPSTATUSEXEPROG (NUNUMSUBSERVICES);

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END REGNUMOFSUBSERVBYSERV;
























PROCEDURE REGPROCSTATUSBYTHREAD ( INUSERVICIO ESTAPRHI.ESPHSERV%TYPE,
                                  INUPERIODO ESTAPRHI.ESPHPEFA%TYPE,
                                  INUHILO NUMBER,
                                  ISBNUEVOIDSEGUIM ESPRSEPE.EPSPIDPR%TYPE,
                                  INUTRACK ESTAPRHI.ESPHTRAC%TYPE
                                )
IS
    RCESTAPRHI ESTAPRHI%ROWTYPE;
    
BEGIN

        PKERRORS.PUSH('pkBOProcCtrlByServMgr.RegProcStatuSByThread');

    RCESTAPRHI.ESPHCOPR := PKGENERALSERVICES.FNUGETNEXTSEQUENCEVAL('SQ_ESTAPRHI_ESPHCOPR');
    RCESTAPRHI.ESPHSERV := INUSERVICIO;
    RCESTAPRHI.ESPHPEFA := INUPERIODO;
    RCESTAPRHI.ESPHPROC := INUHILO;
    RCESTAPRHI.ESPHIDPR := ISBNUEVOIDSEGUIM;
    RCESTAPRHI.ESPHTRAC := NVL(INUTRACK,0);

    PKTBLESTAPRHI.INSRECORD(RCESTAPRHI);

EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
                PKERRORS.POP;
                RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END REGPROCSTATUSBYTHREAD;





















PROCEDURE REGSERVICEPROCESSSTAT
(
    INUPERIODOF ESPRSEPE.EPSPPEFA%TYPE,
    INUSERVICIO ESPRSEPE.EPSPSERV%TYPE,
    ISBPROGRAMA ESPRSEPE.EPSPPROG%TYPE,
    INUNUMSERVSUSC ESPRSEPE.EPSPNUTO%TYPE
)
IS
    CNUINICIOPROCESO CONSTANT NUMBER := 2;
    SBMENSAJE ESPRSEPE.EPSPMENS%TYPE;
    RCESPRSEPE ESPRSEPE%ROWTYPE;

BEGIN

    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.RegServiceProcessStat');

    GETPARAMETERS;

    SBMENSAJE := PKTBLMENSAJE.FSBGETDESCRIPTION(
                                                PKCONSTANTE.CSBDIVISION,
                                                PKCONSTANTE.CSBMOD_GRL,
                                                CNUINICIOPROCESO );

    RCESPRSEPE.EPSPCOEP := PKGENERALSERVICES.FNUGETNEXTSEQUENCEVAL
                                                    ('SQ_ESPRSEPE_EPSPCOEP');
    RCESPRSEPE.EPSPPEFA := INUPERIODOF;
    RCESPRSEPE.EPSPSERV := INUSERVICIO;
    RCESPRSEPE.EPSPPROG := ISBPROGRAMA;
    RCESPRSEPE.EPSPNUHI := GNUNUMEROHILOS;
    RCESPRSEPE.EPSPNUTO := INUNUMSERVSUSC;
    RCESPRSEPE.EPSPNUPR := 0;
    RCESPRSEPE.EPSPMENS := SBMENSAJE;
    RCESPRSEPE.EPSPPRID := PKSESSIONMGR.FSBGETPROCSESSION;
    RCESPRSEPE.EPSPINPR := PKCONSTANTE.NO;
    RCESPRSEPE.EPSPESTA := CSBST_BLOQUEADO;
    RCESPRSEPE.EPSPTABL := CSBSRC_NORMAL;

    PKTBLESPRSEPE.INSRECORD(RCESPRSEPE);

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END REGSERVICEPROCESSSTAT;























PROCEDURE UNBLOCKPROCESS( ISBPROGRAMA VARCHAR2,
                            INUPERIODOF NUMBER,
                            ISBACCION VARCHAR2)
IS
BEGIN
    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.UnBlockProcess');

    PKBCPROCEJEC.UNBLOCKPROCESS(INUPERIODOF,ISBPROGRAMA,ISBACCION);

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END UNBLOCKPROCESS;




























PROCEDURE UPSERVPROCESSSTATE
    (
        INUSERVICIO ESPRSEPE.EPSPSERV%TYPE,
        INUPERIODO ESPRSEPE.EPSPPEFA%TYPE,
        ISBPROGRAMA ESPRSEPE.EPSPPROG%TYPE,
        ISBESTADO ESPRSEPE.EPSPESTA%TYPE
    )
    IS

    
    CSBTERMINO CONSTANT NUMBER := 4271;
    CSBTERMINOERROR CONSTANT NUMBER := 1543;
    CSBINCONS CONSTANT NUMBER := 1298;

    RCESPRSEPE ESPRSEPE%ROWTYPE;
    SBESTADO ESPRSEPE.EPSPESTA%TYPE;
    SBMENSAJE ESTAPROG.ESPRMESG%TYPE;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServMgr.UpServProcessState');

    
    SBESTADO := ISBESTADO ;

    IF (SBESTADO != CSBST_AUTORIZADO) THEN
    

        
        PKBCESPRSEPE.GETRECORD (INUSERVICIO,INUPERIODO,ISBPROGRAMA,RCESPRSEPE);

        
        IF (RCESPRSEPE.EPSPINPR = PKCONSTANTE.SI) THEN
        
            
            SBMENSAJE := PKTBLMENSAJE.FSBGETDESCRIPTION
                                (
                                  PKCONSTANTE.CSBDIVISION,
                                  PKCONSTANTE.CSBMOD_SAT,
                                  CSBINCONS
                                );

            
            SBESTADO := CSBST_INCONSISTENTE ;

        ELSE

            
            SBMENSAJE := PKTBLMENSAJE.FSBGETDESCRIPTION
                                (
                                  PKCONSTANTE.CSBDIVISION,
                                  PKCONSTANTE.CSBMOD_SAT,
                                  CSBTERMINO
                                );

        
        END IF;

        IF (ISBESTADO IS NULL) THEN

            SBESTADO := ISBESTADO ;

            
            SBMENSAJE := PKTBLMENSAJE.FSBGETDESCRIPTION
                                (
                                  PKCONSTANTE.CSBDIVISION,
                                  PKCONSTANTE.CSBMOD_GRL,
                                  CSBTERMINOERROR
                                );
        END IF;

    
    END IF;

    
    PKBCESPRSEPE.UPSTATEDATA
        (
            INUSERVICIO,
            INUPERIODO,
            ISBPROGRAMA,
            SBESTADO,
            NULL, 
            SBMENSAJE
        );

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );


END UPSERVPROCESSSTATE;
























FUNCTION FSBGETBLOCKSTATE RETURN VARCHAR2 IS

BEGIN
    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.fsbGetBlockState');
    
    RETURN (CSBST_BLOQUEADO);
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END FSBGETBLOCKSTATE;
























FUNCTION FSBGETEXECSTATE RETURN VARCHAR2 IS

BEGIN
    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.fsbGetExecState');
    
    RETURN (CSBST_EJECUCION);
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END FSBGETEXECSTATE;
























FUNCTION FSBGETFINISHSTATE RETURN VARCHAR2 IS

BEGIN
    PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.fsbGetFinishState');
    
    RETURN (CSBST_TERMINADO);
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END FSBGETFINISHSTATE;

    






































PROCEDURE ALLSRVPROCESSFINISHED
    (
        INUCICLO	IN	CICLO.CICLCODI%TYPE,
        INUPERIODO	IN	PERIFACT.PEFACODI%TYPE,
        OBLTERMINADO	OUT	BOOLEAN
    )
    IS

    NUIDX NUMBER ;

    
    RCESPRSEPE ESPRSEPE%ROWTYPE ;

    
    CSBPROGRAMA CONSTANT VARCHAR2(4) := 'FGCA' ;

    
    TBSERV PKTBLSERVICIO.TYSERVCODI ;

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.AllSrvProcessFinished');

    
    PKBCSERVTOLIQUIDATE.GETSERVTOLIQARR
        (
            INUCICLO,
            TBSERV
        ) ;

    PKBCESPRSEPE.CLEARCACHE ;

    
    OBLTERMINADO := TRUE ;

    NUIDX := TBSERV.FIRST ;

    
    LOOP
    

        
        EXIT WHEN NUIDX IS NULL ;

        
        IF (PKBCESPRSEPE.FBLEXIST (TBSERV (NUIDX), INUPERIODO, CSBPROGRAMA))
        THEN
        

            
            PKBCESPRSEPE.GETRECORD
                (
                    TBSERV (NUIDX),
                    INUPERIODO,
                    CSBPROGRAMA,
                    RCESPRSEPE
                );

            
            IF (RCESPRSEPE.EPSPESTA NOT IN (CSBST_TERMINADO,CSBST_AUTORIZADO)) THEN
                
                OBLTERMINADO := FALSE ;
                EXIT;
            END IF;

        
        ELSE
            
	    OBLTERMINADO := FALSE ;
	    EXIT;
        END IF;

        
        NUIDX := TBSERV.NEXT (NUIDX) ;

    
    END LOOP ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);


END ALLSRVPROCESSFINISHED;




























PROCEDURE SETCOMPANYID
(
    INUEMPRESA IN EMPRPRSE.EMPSCODI%TYPE
) IS

BEGIN

    GNUEMPRESA := INUEMPRESA ;

END SETCOMPANYID ;


























PROCEDURE SETCOMPANYCONTROL
(
    IBLMULTEMPR IN BOOLEAN
) IS

BEGIN

    GBLISMULTIEMPR := IBLMULTEMPR ;

END SETCOMPANYCONTROL ;

























FUNCTION FBLCOMPANYCONTROL RETURN BOOLEAN IS

BEGIN

    RETURN(GBLISMULTIEMPR);

END FBLCOMPANYCONTROL ;




    

























FUNCTION FSBVERSION RETURN VARCHAR2 IS

BEGIN
    
    RETURN (CSBVERSION);
END FSBVERSION;


    

























    PROCEDURE CONSESTAPROCPORCICL (
        ISBLLAVECONS    IN  VARCHAR2,
        OCUESPRSEPE     OUT PKCONSTANTE.TYREFCURSOR
    )
    IS
        
        SBEPSPCOEP      VARCHAR2( 15 );
        SBCICLCODI      VARCHAR2( 4 );
        SBPEFACODI      VARCHAR2( 6 );
        
        NUEPSPCOEP      ESPRSEPE.EPSPCOEP%TYPE;
        NUCICLCODI      CICLO.CICLCODI%TYPE;
        NUPEFACODI      PERIFACT.PEFACODI%TYPE;
    BEGIN
        PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.ConsEstaProcPorCicl');
        UT_TRACE.TRACE('Inicio [pkBOProcCtrlByServiceMgr.ConsEstaProcPorCicl]');

        IF ( ISBLLAVECONS IS NOT NULL ) THEN
            
            SBEPSPCOEP := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 1 );
            SBCICLCODI := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 2 );
            SBPEFACODI := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 3 );
            
            NUEPSPCOEP := TO_NUMBER( SBEPSPCOEP );
            NUCICLCODI := TO_NUMBER( SBCICLCODI );
            NUPEFACODI := TO_NUMBER( SBPEFACODI );
        END IF;

        
        PKBCESPRSEPE.CONSESTAPROCPORCICL(
            SBCICLCODI,
            SBPEFACODI,
            SBEPSPCOEP,
            OCUESPRSEPE
        );
        
        UT_TRACE.TRACE('Fin [pkBOProcCtrlByServiceMgr.ConsEstaProcPorCicl]');
        PKERRORS.POP;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END CONSESTAPROCPORCICL;
    
    
    


























    PROCEDURE OBTESTAPROCPORCICLO (
        INUCICLCODI     IN  CICLO.CICLCODI%TYPE,
        OCUESPRSEPE     OUT PKCONSTANTE.TYREFCURSOR
    )
    IS
        NUPEFACODI      PERIFACT.PEFACODI%TYPE;
    BEGIN
        PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.ObtEstaProcPorCiclo');
        UT_TRACE.TRACE('Inicio [pkBOProcCtrlByServiceMgr.ObtEstaProcPorCiclo]');

        IF ( INUCICLCODI IS NOT NULL ) THEN
            NUPEFACODI := PKBCPERIFACT.FRCGETCURRBILPERBYCYC( INUCICLCODI ).PEFACODI;
        END IF;

        PKBCESPRSEPE.OBTESTAPROCPORPEFACICL(
            INUCICLCODI,
            NUPEFACODI,
            OCUESPRSEPE
        );

        UT_TRACE.TRACE('Fin [pkBOProcCtrlByServiceMgr.ObtEstaProcPorCiclo]');
        PKERRORS.POP;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END OBTESTAPROCPORCICLO;


    
























    PROCEDURE OBTCICLOPORESTAPROC (
        ISBLLAVECONS    IN  VARCHAR2,
        ONUCICLCODI     OUT CICLO.CICLCODI%TYPE
    )
    IS
        
        SBCICLCODI      VARCHAR2( 4 );
    BEGIN
        PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.ObtCicloPorEstaProc');
        UT_TRACE.TRACE('Inicio [pkBOProcCtrlByServiceMgr.ObtCicloPorEstaProc]');

        IF ( ISBLLAVECONS IS NOT NULL ) THEN
            
            SBCICLCODI := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 2 );
            
            ONUCICLCODI := TO_NUMBER( SBCICLCODI );
        END IF;

        UT_TRACE.TRACE('Fin [pkBOProcCtrlByServiceMgr.ObtCicloPorEstaProc]');
        PKERRORS.POP;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END OBTCICLOPORESTAPROC;
    
    
    
























    PROCEDURE CONSSERVPENDLIQPORCICLO (
        ISBLLAVECONS    IN  VARCHAR2,
        OCUSERVPENDLIQ  OUT PKCONSTANTE.TYREFCURSOR
    )
    IS
        
        TBSERVPENDLIQU      TYTBSERVPENDLIQU;
        
        TBOBJSERVPENDLIQU   FA_TYTBSERVPENDLIQU := FA_TYTBSERVPENDLIQU();
        
        NUCONTADOR          NUMBER;

        
        SBCICLCODI      VARCHAR2( 4 );
        SBPEFACODI      VARCHAR2( 6 );
        SBSERVCODI      VARCHAR2( 4 );
        
        NUCICLCODI      CICLO.CICLCODI%TYPE;
        NUPEFACODI      PERIFACT.PEFACODI%TYPE;
        NUSERVCODI      SERVICIO.SERVCODI%TYPE;
    BEGIN
        PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.ConsServPendLiqPorCiclo');
        UT_TRACE.TRACE('Inicio [pkBOProcCtrlByServiceMgr.ConsServPendLiqPorCiclo]');
        
        IF ( ISBLLAVECONS IS NOT NULL ) THEN
            
            SBCICLCODI := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 1 );
            SBPEFACODI := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 2 );
            SBSERVCODI := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 3 );
            
            NUCICLCODI := TO_NUMBER( SBCICLCODI );
            NUPEFACODI := TO_NUMBER( SBPEFACODI );
            NUSERVCODI := TO_NUMBER( SBSERVCODI );
        END IF;
        
        
        PKBOPROCCTRLBYSERVICEMGR.FILLFORMSERVPENDLIQ (
            NUCICLCODI,
            NUPEFACODI,
            TBSERVPENDLIQU
        );

        
        
        TBOBJSERVPENDLIQU := FA_TYTBSERVPENDLIQU ( FA_TYOBSERVPENDLIQU ( NULL, NULL, NULL ) );

        
        NUCONTADOR := TBSERVPENDLIQU.FIRST;

        
        WHILE ( NUCONTADOR IS NOT NULL ) LOOP

            IF ( NUCONTADOR <> 1 ) THEN
                TBOBJSERVPENDLIQU.EXTEND;
            END IF;

            TBOBJSERVPENDLIQU( NUCONTADOR ) := FA_TYOBSERVPENDLIQU ( NULL, NULL, NULL );

            TBOBJSERVPENDLIQU( NUCONTADOR ).SERVCODI := TBSERVPENDLIQU( NUCONTADOR ).SERVCODI;
            TBOBJSERVPENDLIQU( NUCONTADOR ).SERVDESC := PKTBLSERVICIO.FSBGETDESCRIPTION( TBSERVPENDLIQU( NUCONTADOR ).SERVCODI );

            CASE UPPER( TBSERVPENDLIQU( NUCONTADOR ).SERVESTA )
               WHEN 'B' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'BLOQUEADO';
               WHEN 'E' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'EJECUCIN';
               WHEN 'I' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'INCONSISTENTE';
               WHEN 'C' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'CADO';
               WHEN 'P' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'PENDIENTE';
               WHEN 'A' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'AUTORIZADO';
            END CASE;

            NUCONTADOR := TBSERVPENDLIQU.NEXT( NUCONTADOR );

        END LOOP;

        
        IF ( OCUSERVPENDLIQ%ISOPEN ) THEN
            CLOSE OCUSERVPENDLIQ;
        END IF;

        OPEN OCUSERVPENDLIQ FOR
            SELECT  TO_CHAR( NUCICLCODI ) || '|' || TO_CHAR( NUPEFACODI ) || '|' || TO_CHAR( SERVICIOS.SERVCODI ) PK,
                    SERVICIOS.*,
                    TO_CHAR ( NUCICLCODI ) PARENT_ID
            FROM    TABLE( CAST( TBOBJSERVPENDLIQU AS FA_TYTBSERVPENDLIQU ) ) SERVICIOS
            WHERE   SERVICIOS.SERVCODI = NUSERVCODI;
            
        UT_TRACE.TRACE('Fin [pkBOProcCtrlByServiceMgr.ConsServPendLiqPorCiclo]');
        PKERRORS.POP;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END CONSSERVPENDLIQPORCICLO;


    


























    PROCEDURE OBTSERVPENDLIQPORCICLO (
        INUCICLCODI     IN  CICLO.CICLCODI%TYPE,
        OCUSERVPENDLIQ  OUT PKCONSTANTE.TYREFCURSOR
    )
    IS
        
        TBSERVPENDLIQU      TYTBSERVPENDLIQU;
        
        TBOBJSERVPENDLIQU   FA_TYTBSERVPENDLIQU := FA_TYTBSERVPENDLIQU();
        
        NUCONTADOR          NUMBER;
        
        NUPEFACODI          PERIFACT.PEFACODI%TYPE;
    BEGIN
        PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.ObtServPendLiqPorCiclo');
        UT_TRACE.TRACE('Inicio [pkBOProcCtrlByServiceMgr.ObtServPendLiqPorCiclo]');
        
        
        IF ( INUCICLCODI IS NOT NULL ) THEN
            NUPEFACODI := PKBCPERIFACT.FRCGETCURRBILPERBYCYC( INUCICLCODI ).PEFACODI;
        END IF;
        
        PKBOPROCCTRLBYSERVICEMGR.FILLFORMSERVPENDLIQ (
            INUCICLCODI,
            NUPEFACODI,
            TBSERVPENDLIQU
        );

        
        
        TBOBJSERVPENDLIQU := FA_TYTBSERVPENDLIQU ( FA_TYOBSERVPENDLIQU ( NULL, NULL, NULL ) );
        
        
        NUCONTADOR := TBSERVPENDLIQU.FIRST;

        
        WHILE ( NUCONTADOR IS NOT NULL ) LOOP
        
            IF ( NUCONTADOR <> 1 ) THEN
                TBOBJSERVPENDLIQU.EXTEND;
            END IF;

            TBOBJSERVPENDLIQU( NUCONTADOR ) := FA_TYOBSERVPENDLIQU ( NULL, NULL, NULL );
        
            TBOBJSERVPENDLIQU( NUCONTADOR ).SERVCODI := TBSERVPENDLIQU( NUCONTADOR ).SERVCODI;
            TBOBJSERVPENDLIQU( NUCONTADOR ).SERVDESC := PKTBLSERVICIO.FSBGETDESCRIPTION( TBSERVPENDLIQU( NUCONTADOR ).SERVCODI );
            
            CASE UPPER( TBSERVPENDLIQU( NUCONTADOR ).SERVESTA )
               WHEN 'B' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'BLOQUEADO';
               WHEN 'E' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'EJECUCIN';
               WHEN 'I' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'INCONSISTENTE';
               WHEN 'C' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'CADO';
               WHEN 'P' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'PENDIENTE';
               WHEN 'A' THEN TBOBJSERVPENDLIQU( NUCONTADOR ).SERVESTA := 'AUTORIZADO';
            END CASE;

            NUCONTADOR := TBSERVPENDLIQU.NEXT( NUCONTADOR );
            
        END LOOP;
        
        
        IF ( OCUSERVPENDLIQ%ISOPEN ) THEN
            CLOSE OCUSERVPENDLIQ;
        END IF;

        IF ( INUCICLCODI IS NOT NULL ) THEN
            OPEN OCUSERVPENDLIQ FOR
                SELECT  TO_CHAR( INUCICLCODI ) || '|' || TO_CHAR( NUPEFACODI ) || '|' || TO_CHAR( SERVICIOS.SERVCODI ) PK,
                        SERVICIOS.*,
                        TO_CHAR ( INUCICLCODI ) PARENT_ID
                FROM    TABLE( CAST( TBOBJSERVPENDLIQU AS FA_TYTBSERVPENDLIQU ) ) SERVICIOS;
        ELSE
                OPEN OCUSERVPENDLIQ FOR
                SELECT  TO_CHAR( INUCICLCODI ) || '|' || TO_CHAR( NUPEFACODI ) || '|' || TO_CHAR( SERVICIOS.SERVCODI ) PK,
                        SERVICIOS.*,
                        TO_CHAR ( INUCICLCODI ) PARENT_ID
                FROM    TABLE( CAST( TBOBJSERVPENDLIQU AS FA_TYTBSERVPENDLIQU ) ) SERVICIOS
                WHERE   1 <> 1;
        END IF;

        UT_TRACE.TRACE('Fin [pkBOProcCtrlByServiceMgr.ObtServPendLiqPorCiclo]');
        PKERRORS.POP;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END OBTSERVPENDLIQPORCICLO;
    

    























    PROCEDURE OBTCICLOPORSERVPENDLIQ (
        ISBLLAVECONS    IN  VARCHAR2,
        ONUCICLCODI     OUT CICLO.CICLCODI%TYPE
    )
    IS
        
        SBCICLCODI      VARCHAR2( 4 );
    BEGIN
        PKERRORS.PUSH('pkBOProcCtrlByServiceMgr.ObtCicloPorServPendLiq');
        UT_TRACE.TRACE('Inicio [pkBOProcCtrlByServiceMgr.ObtCicloPorServPendLiq]');
        
        IF ( ISBLLAVECONS IS NOT NULL ) THEN
            
            SBCICLCODI := UT_STRING.EXTSTRFIELD( ISBLLAVECONS, '|', 1 );
            
            ONUCICLCODI := TO_NUMBER( SBCICLCODI );
        END IF;
        
        UT_TRACE.TRACE('Fin [pkBOProcCtrlByServiceMgr.ObtCicloPorServPendLiq]');
        PKERRORS.POP;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END OBTCICLOPORSERVPENDLIQ;
    
    
























PROCEDURE GETSERVTOLIQARR
    (
        INUCYCLE    IN  CICLO.CICLCODI%TYPE,
        OTBLIQSERV  OUT PKTBLSERVICIO.TYSERVCODI
    )
    IS

BEGIN


    PKERRORS.PUSH ('pkBOProcCtrlByServiceMgr.GetServToLiqArr');

    IF (GBLISMULTIEMPR) THEN
        PKBCSERVTOLIQUIDATE.GETCOMPANYSERVTOLIQ
            (
                GNUEMPRESA,
                OTBLIQSERV
            );
    ELSE
        
        PKBCSERVTOLIQUIDATE.GETSERVTOLIQARR
            (
                INUCYCLE,
                OTBLIQSERV
            );
    END IF;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END GETSERVTOLIQARR;

END PKBOPROCCTRLBYSERVICEMGR;