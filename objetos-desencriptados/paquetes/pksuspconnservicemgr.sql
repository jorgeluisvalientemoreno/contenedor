PACKAGE BODY pkSuspConnServiceMgr AS



























































































































































































































































































































































































































































































    
    
    
    SBERRMSG            VARCHAR2(2000);		        
    NUCAUSASINACT	    CAUSCODE.CACDCODI%TYPE ;    
    NUESTCORTESINDX     CONFESCO.COECCODI%TYPE ;    
    RCSERVSUSC          SERVSUSC%ROWTYPE;           
    NULINEA		        NUMBER := 0;
    BLACTPROCCONN       BOOLEAN := TRUE;            
    GRCTBSTATESTOEXEC   PKSUSPCONNSERVICEMGR.TYTBSTATES; 
    GNUAPPLYEVENT        ESTACORT.ESCOCODI%TYPE;    
                                                    
    GNUIDSUSPCONE       SUSPCONE.SUCOIDSC%TYPE ;    
    GNUORDERTYPE        NUMBER ;                    
    GRCTBRULEINMEM      TYTBRULES;                  
    GRCTBRECINMEM       PKTBLCONFESCO.TYTBCONFESCO; 
    GRCTBRECCONFINMEM   PKTBLCONFCOSE.TYTBCONFCOSE; 
    NUORDEN	            SUSPCONE.SUCONUOR%TYPE ;	
    GRCTRGSERVSUSC      SERVSUSC%ROWTYPE;  
                                                    
                                                    
    
    GNUACTIVITY             NUMBER;                 
    GBLEXEACTIVITYRULE      BOOLEAN ;               
    GNUORDERID              NUMBER;                 
    GNUORDERACTIVITYID      NUMBER;                 
    GSBORDERPROCESS         VARCHAR2(1);            
    
    
    GNUPAIDCOUPON           SUSPCONE.SUCOCUPO%TYPE; 

    TYPE TYTBPARAMJOBS IS TABLE OF VARCHAR2(100)
    INDEX BY BINARY_INTEGER; 
                             
                             
    
    TYPE TYTBACCOUNT   IS TABLE OF CUENCOBR%ROWTYPE
                       INDEX BY BINARY_INTEGER;

    NUORDESCONEXIONTOTAL     ESTACORT.ESCOCODI%TYPE;     
    NUORDESCONEXIONPARCIAL   ESTACORT.ESCOCODI%TYPE;     
    NUORCONEXION             ESTACORT.ESCOCODI%TYPE;     
    NUORRETIRO               ESTACORT.ESCOCODI%TYPE;     
    NUESCO_ORDEN_REVISION    ESTACORT.ESCOCODI%TYPE;     
    NUESCO_SUSP_TOTAL        ESTACORT.ESCOCODI%TYPE;     
    
    
    GNUESTCORTEINACTIVO         ESTACORT.ESCOCODI%TYPE;
    
    GNUDIAS_ADICION_FECHA_SUSP  NUMBER;
    
    GNULIMITE_DE_USO            NUMBER;

    
    
    
    
    CSBVERSION   CONSTANT VARCHAR2(250) := 'SAO336567';
    
    CNUORDEN_NO_EXISTE	CONSTANT NUMBER:= 4231;    
    CNUTIP_CLI_NO_VALID CONSTANT NUMBER:= 10024;    
    CNUCAU_NO_PERMITIDA CONSTANT NUMBER:= 10028;    
    CNUNO_ENCO_CUENTAS  CONSTANT NUMBER:= 9306;    
    CNUNO_CUMP_DIAS     CONSTANT NUMBER:= 10059;    
    CNUMOT_NO_PERMITIDO CONSTANT NUMBER:= 9723;	    
    CNUORDEN_NO_CORRESP CONSTANT NUMBER:= 10158;    
    CNUERROR_HAS_ORDER  CONSTANT NUMBER:= 10463;      
    CNUPROD_RETIRE      CONSTANT NUMBER:= 18696;      

    
    CSBWORKTYPE         CONSTANT VARCHAR2(1) := 'T'; 
						    
    CSBDESCONEXION	CONSTANT VARCHAR2(1) := 'D' ; 
    CSBCONEXION		CONSTANT VARCHAR2(1) := 'C' ; 
    CSBRETIRO		CONSTANT VARCHAR2(1) := 'R';  
    CNUBULK         CONSTANT NUMBER:= 100;        
    CNURECORD_YA_EXISTE        CONSTANT NUMBER := 10551; 

    CSBDIVISION                CONSTANT VARCHAR2(20) := PKCONSTANTE.CSBDIVISION;
    CSBMODULE           	   CONSTANT VARCHAR2(20) := PKCONSTANTE.CSBMOD_BIL;
    SBEXISTSOSS                 PARAMETR.PAMECHAR%TYPE ; 

    CNUTIENE        CONSTANT NUMBER := 1 ;
    CNUNOTIENE      CONSTANT NUMBER := 0 ;

    
    
    
    CURSOR CURECAESCO (INUSERVCODI	IN	SERVICIO.SERVCODI%TYPE,
		       INUCOECCODI	IN	CONFESCO.COECCODI%TYPE)
    IS
        SELECT RCECFUFA
        FROM  RECAESCO
        WHERE RCECSERV = INUSERVCODI
        AND   RCECCOEC = INUCOECCODI
        AND   RCECFUFA IS NOT NULL
        GROUP BY RCECFUFA ;

    CURSOR CURECAESCOFUFA ( INUSERVCODI	IN	SERVICIO.SERVCODI%TYPE,
                            INUCOECCODI	IN	CONFESCO.COECCODI%TYPE)
    IS
        SELECT RCECFUFA
        FROM  RECAESCO
        WHERE RCECSERV = INUSERVCODI
        AND   RCECCOEC = INUCOECCODI
        AND   RCECFUFA IS NOT NULL
        GROUP BY RCECFUFA ;
    
    
    
    PROCEDURE EXERULECHARGECALCULATE
    (
        IRCCONFESCO    IN    CONFESCO%ROWTYPE,
        ONURATEVALUE   OUT   TA_VIGETACO.VITCVALO%TYPE
    );
    PROCEDURE GENERATECHARGE
    (
        IRCSERVSUSC    IN    SERVSUSC%ROWTYPE,
        IRCCONFESCO    IN    CONFESCO%ROWTYPE,
        INUCICLO       IN    SUSCRIPC.SUSCCICL%TYPE,
        INURATEVALUE   IN    TA_VIGETACO.VITCVALO%TYPE
    );
































PROCEDURE ATTENDCOLLECTACTIVITY
(
    INUORDERID      IN      SUSPCONE.SUCOIDSC%TYPE
)
IS

    
    RCSUSPCONE                  SUSPCONE%ROWTYPE;
    
    
    
    NUPENDINGORDERS             NUMBER;

BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.AttendCollectActivity]', 5 );
    
    
    RCSUSPCONE := PKTBLSUSPCONE.FRCGETRECORD( INUORDERID );

    
    
    IF ( RCSUSPCONE.SUCOACGC IS NOT NULL ) THEN
    
        
        
        NUPENDINGORDERS := PKBCSUSPCONE.FNUGETPENDORDERSBYCOLLECTACTIV( RCSUSPCONE.SUCOACGC );

        IF ( NUPENDINGORDERS = 0 ) THEN
        
            
            
            PKBCAVANPCSS.UPDACTSTATE( RCSUSPCONE.SUCOACGC, TRUE );
        
        END IF;
    
    END IF;

    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.AttendCollectActivity]', 5 );

EXCEPTION

    WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttendCollectActivity]', 5 );
        RAISE;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttendCollectActivity]', 5 );
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;




























PROCEDURE EXERULECHARGECALCULATE
(
    IRCCONFESCO    IN    CONFESCO%ROWTYPE,
    ONURATEVALUE   OUT   TA_VIGETACO.VITCVALO%TYPE
)
IS

BEGIN

    UT_TRACE.TRACE('INICIA  pkSuspConnServiceMgr.ExeRuleChargeCalculate', 5);
    
    
    PKGENERALSERVICES.EXECDYNAMICFUNCTION( IRCCONFESCO.COECFUFA, ONURATEVALUE );
		
    UT_TRACE.TRACE('FIN  pkSuspConnServiceMgr.ExeRuleChargeCalculate', 5);
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END EXERULECHARGECALCULATE;




















































PROCEDURE GENERATECHARGE
(
    IRCSERVSUSC    IN    SERVSUSC%ROWTYPE,
    IRCCONFESCO    IN    CONFESCO%ROWTYPE,
    INUCICLO       IN    SUSCRIPC.SUSCCICL%TYPE,
    INURATEVALUE   IN    TA_VIGETACO.VITCVALO%TYPE
)
IS

    
    SBSIGNCARG      CARGOS.CARGSIGN%TYPE;
    RCCARGOS        CARGOS%ROWTYPE;

    
    NUCHARGECAUSE   CAUSCARG.CACACODI%TYPE;

    
    NUPRODUCTTYPE   SERVICIO.SERVCODI%TYPE;
    
    
    NUCOLLECTIONCONCEPT CONCEPTO.CONCCODI%TYPE;
    
    
    NURATEVALUE    TA_VIGETACO.VITCVALO%TYPE;

BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.GenerateCharge');
    
    
    NURATEVALUE :=  INURATEVALUE;
    
    
    SBDOCUSOPO := PKCONSTANTE.NULLSB;
    
    
    NUPRODUCTTYPE := IRCSERVSUSC.SESUSERV;

    
    NUCHARGECAUSE := FA_BOCHARGECAUSES.FNURECONNECTIONCHCAUSE(NUPRODUCTTYPE);

    UT_TRACE.TRACE('Causa de cargo: '||NUCHARGECAUSE,5);

    
    IF ( NURATEVALUE = PKBILLCONST.CERO ) THEN
    
        PKERRORS.POP;
        RETURN ;
    
    END IF ;
    
    
    SBSIGNCARG := PKBILLCONST.DEBITO;
    
    IF ( NURATEVALUE < PKBILLCONST.CERO ) THEN
    
        
        SBSIGNCARG := PKBILLCONST.CREDITO;
        NURATEVALUE := ABS ( NURATEVALUE );
    
    END IF ;
    
    UT_TRACE.TRACE('Signo del Cargo: '||SBSIGNCARG,5);

    
    GC_BOSUSPREMRECONCHAR.GETCOLLECTIONCONCEPT(NUCOLLECTIONCONCEPT);

    
    PKCHARGEMGR.GENERATECHARGE
    (
        IRCSERVSUSC.SESUNUSE,
        PKCONSTANTE.NULLNUM,
        NUCOLLECTIONCONCEPT,
        NUCHARGECAUSE,
        NURATEVALUE,
        SBSIGNCARG,
        SBDOCUSOPO
    );
    
    UT_TRACE.TRACE('Cargo Generado.',5);
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END GENERATECHARGE;



























PROCEDURE ANNULORDERPENDING
(
	INUNUSE    IN    SERVSUSC.SESUNUSE%TYPE,
    INUTIPO    IN    SUSPCONE.SUCOTIPO%TYPE,
    INUOBSE    IN    SUSPCONE.SUCOOBSE%TYPE DEFAULT NULL
)
IS
    
    CSBANULADA    CONSTANT VARCHAR2(1) := 'A' ;
    
    CURSOR CUSUSPCONE IS
        SELECT /*+ index( suspcone IX_SUCO_NUSE )*/
               SUSPCONE.*
        FROM   SUSPCONE
        WHERE  SUCONUSE = INUNUSE
        AND    SUCOTIPO = INUTIPO
        AND    SUCOFEAT IS NULL;
        
    
    
    

    



    PROCEDURE UPRECORD
	(
	    IORCSUSPCONE    IN OUT    SUSPCONE%ROWTYPE
	)
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.AnnulOrderPending.UpRecord');
        
    	IORCSUSPCONE.SUCOFEAT := SYSDATE ;
    	IORCSUSPCONE.SUCOTIPO := CSBANULADA ;
    	IORCSUSPCONE.SUCOOBSE := NVL ( INUOBSE, IORCSUSPCONE.SUCOOBSE );
    	
    	PKERRORS.POP;
    EXCEPTION
    	WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
    	    PKERRORS.POP;
    	    RAISE;
    
    END UPRECORD;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.AnnulOrderPending');
    
    
    FOR RCSUSPCONE IN CUSUSPCONE LOOP
    
    	
    	
    	
    	
    	UPRECORD ( RCSUSPCONE );
    	
    	PKTBLSUSPCONE.UPRECORD ( RCSUSPCONE );
    
    END LOOP ;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END ANNULORDERPENDING;


































PROCEDURE APPLYCHARGE
(
    IRCSERVSUSC    IN    SERVSUSC%ROWTYPE,
    IRCCONFESCO    IN    CONFESCO%ROWTYPE,
    INUCICLO       IN    SUSCRIPC.SUSCCICL%TYPE DEFAULT NULL
)
IS
    NURATEVALUE     TA_VIGETACO.VITCVALO%TYPE;

BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ApplyCharge');
    
    
    IF ( IRCCONFESCO.COECGECA = PKCONSTANTE.SI
       AND IRCCONFESCO.COECFUFA IS NOT NULL)
    THEN
    
        
        GC_BOSUSPREMRECONCHAR.SETPRODUCTID(IRCSERVSUSC.SESUNUSE);
    
        
        PKSUSPCONNSERVICEMGR.EXERULECHARGECALCULATE ( IRCCONFESCO , NURATEVALUE);

        
        PKSUSPCONNSERVICEMGR.GENERATECHARGE ( IRCSERVSUSC, IRCCONFESCO, INUCICLO, NURATEVALUE );
    
    END IF ;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END APPLYCHARGE;





























PROCEDURE ATTWITHOUTACTORDERPENDING
(
	INUNUSE    	IN  SERVSUSC.SESUNUSE%TYPE,
    INUTIPO    	IN  SUSPCONE.SUCOTIPO%TYPE,
	INUFEAT		IN	SUSPCONE.SUCOFEAT%TYPE,
	INUCODI		IN	CAUSCODE.CACDCODI%TYPE
)
IS
    
    CURSOR CUSUSPCONE
    IS
        SELECT /*+ index( suspcone IX_SUCO_NUSE )*/ SUSPCONE.*
        FROM  SUSPCONE
        WHERE SUCONUSE = INUNUSE
        AND   SUCOTIPO = INUTIPO
        AND   SUCOFEAT IS NULL;
        
    
    
    

    



    PROCEDURE UPRECORD
	(
	    IORCSUSPCONE    IN OUT    SUSPCONE%ROWTYPE
	)
    IS
    BEGIN
    
    	PKERRORS.PUSH('pkSuspConnServiceMgr.AttWithOutActOrderPending.UpRecord');
    	
    	IORCSUSPCONE.SUCOFEAT := INUFEAT ;
    	IORCSUSPCONE.SUCOCACD := INUCODI ;
    	
    	PKERRORS.POP;
    EXCEPTION
    	WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
    	    PKERRORS.POP;
    	    RAISE;
    
    END UPRECORD;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.AttWithOutActOrderPending');
    
    PKGENERALSERVICES.TRACEDATA('Tipo '||INUTIPO);
    PKGENERALSERVICES.TRACEDATA('Numero servicio '||INUNUSE);
    
    
    FOR RCSUSPCONE IN CUSUSPCONE LOOP
    
    	
    	
    	
    	UPRECORD ( RCSUSPCONE );
    	
    	PKTBLSUSPCONE.UPRECORD ( RCSUSPCONE );
    
    END LOOP ;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END ATTWITHOUTACTORDERPENDING;








































































PROCEDURE ATTENINDIVSUSPECONNE
(
	INUSESUNUSE    IN      SERVSUSC.SESUNUSE%TYPE,
	ISBROWIDSUS    IN      ROWID,
	IDTFECHATEN    IN      SERVSUSC.SESUFECO%TYPE,
	IDTSESUFECO    IN      SERVSUSC.SESUFECO%TYPE,
	ISBSUCOTIPO    IN      SUSPCONE.SUCOTIPO%TYPE,
	ISBFLAGCUMP    IN      SUSPCONE.SUCOTIPO%TYPE,
	IRCCONFESCO    IN OUT  CONFESCO%ROWTYPE,
	INUCICLO       IN      SUSCRIPC.SUSCCICL%TYPE DEFAULT NULL
)
IS

    
    RCSUSPCONE      SUSPCONE%ROWTYPE;

    
    DTSESUFECO    	SERVSUSC.SESUFECO%TYPE;
    
    
    DTATCOFEAT	 	SUSPCONE.SUCOFEAT%TYPE;
    
    
    SBATCOTIPO		SUSPCONE.SUCOTIPO%TYPE;
    
    
    NUPERIFACT		PERIFACT.PEFACODI%TYPE;
    
    
    NUCOECCODI		CONFESCO.COECCODI%TYPE;
   
    
    
    

    PROCEDURE GETPARAMETERS
    IS
    BEGIN
    
        UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.AttenIndivSuspeConne.Getparameters]', 6 );
        
    	
    	NUCAUSASINACT := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE( 'CAUS_ATEN_SIN_ACT_CAMPO');
    	
    	
    	NUESTCORTESINDX := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE( 'EST_SERVICIO_SIN_CORTE' );
    	
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.AttenIndivSuspeConne.Getparameters]', 6 );

    EXCEPTION

        WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttenIndivSuspeConne.Getparameters]', 6 );
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttenIndivSuspeConne.Getparameters]', 6 );
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END;
    
    
    

BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.AttenIndivSuspeConne]', 5 );
    
    GETPARAMETERS;

	UT_TRACE.TRACE( 'Sesunuse    -> ' || INUSESUNUSE, 6 );
	UT_TRACE.TRACE( 'IDSusp      -> ' || ISBROWIDSUS, 6 );
	UT_TRACE.TRACE( 'idtfechaten -> ' || IDTFECHATEN, 6 );
	UT_TRACE.TRACE( 'idtsesufeco -> ' || IDTSESUFECO, 6 );
	UT_TRACE.TRACE( 'isbSucotipo -> ' || ISBSUCOTIPO, 6 );
	UT_TRACE.TRACE( 'ircConfesco.coeccodi -> ' || IRCCONFESCO.COECCODI, 6 );
	UT_TRACE.TRACE( 'inuCiclo    ->' || INUCICLO, 6 );

    PKSUSPCONNSERVICEMGR.VALIDSUSPENSIONDAYS
    (
    	INUSESUNUSE,
    	IRCCONFESCO.COECDICO,
    	IDTSESUFECO
    );
    
    
    NUCOECCODI := IRCCONFESCO.COECCODI;
    
    IF ( GRCTRGSERVSUSC.SESUNUSE IS NULL ) THEN
        
        RCSERVSUSC := PKTBLSERVSUSC.FRCGETRECORD( INUSESUNUSE, PKCONSTANTE.CACHE );
    ELSE
        RCSERVSUSC := GRCTRGSERVSUSC;    	                              				
	END IF;
	
	
	RCSUSPCONE := PKBCSUSPCONE.FRCGETRECORDBYROWID( ISBROWIDSUS );
	
    
    PKBCSUSPCONE.UPATTENTIONDATE
    (
        RCSUSPCONE.SUCOIDSC,
		NVL( IDTFECHATEN, SYSDATE ),
        NULL
    );
				     
    
    ATTENDCOLLECTACTIVITY( RCSUSPCONE.SUCOIDSC );

    
    UT_TRACE.TRACE( 'Estado de corte -> ' || IRCCONFESCO.COECCODI, 6 );
    
    DTSESUFECO := NVL( IDTFECHATEN, SYSDATE );

    
    IF ( ISBSUCOTIPO = CSBCONEXION ) THEN
    
        SBATCOTIPO := CSBDESCONEXION;
        
	    IF ( FBLHASORDER( INUSESUNUSE, SBATCOTIPO ) ) THEN
	    
	        
            PKERRORS.SETERRORCODE
            (
                PKCONSTANTE.CSBDIVISION,
                PKCONSTANTE.CSBMOD_BIL,
		  		CNUERROR_HAS_ORDER
            );
            
	        RAISE LOGIN_DENIED;
        
	    END IF;
	    
    	
	    PKSUSPCONNSERVICEMGR.APPLYCHARGE( RCSERVSUSC, IRCCONFESCO, INUCICLO );
    
    
    ELSE
    
        SBATCOTIPO := CSBCONEXION;

        
        IF ( ISBFLAGCUMP = PKCONSTANTE.NO ) THEN
        
            PKSUSPCONNSERVICEMGR.ATTWITHOUTACTORDERPENDING
            (
                INUSESUNUSE,
                SBATCOTIPO,
                SYSDATE,
                NUCAUSASINACT
            );

            NUCOECCODI := NUESTCORTESINDX;

            
            PKTBLSUSPCONE.UPORDERCAUSE( ISBROWIDSUS, NUCAUSASINACT );
        
        ELSE
        
            
            PKSUSPCONNSERVICEMGR.APPLYCHARGE( RCSERVSUSC, IRCCONFESCO, INUCICLO );
        
        END IF;
    
    END IF;
    
    
    IF ( PR_BOSUSPCORTERECONEXION.FBOESESTADOCORTEACTIVO( NUCOECCODI ) ) THEN
        DTSESUFECO := NULL;
    END IF;
    
    
    UT_TRACE.TRACE( 'Estado de corte a aplicar -> ' || NUCOECCODI, 6 );
    IF ( GRCTRGSERVSUSC.SESUNUSE IS NULL ) THEN
    
        
        
        
        IF ( ( NUCOECCODI = NUESCO_ORDEN_REVISION AND RCSERVSUSC.SESUESCO = NUESCO_SUSP_TOTAL )
           OR ( NUCOECCODI = NUESCO_SUSP_TOTAL AND RCSERVSUSC.SESUESCO = NUESCO_ORDEN_REVISION ) )
        THEN
            PKTBLSERVSUSC.UPSUSPENSIONSTATUS( INUSESUNUSE, NUCOECCODI );
        ELSE
            PKTBLSERVSUSC.UPSUSPENSIONSTATUS( INUSESUNUSE, NUCOECCODI, DTSESUFECO );
        END IF;
    
    ELSE
    
        GRCTRGSERVSUSC.SESUFECO := DTSESUFECO;
        GRCTRGSERVSUSC.SESUESCO := NUCOECCODI;
    
    END IF;
    
    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.AttenIndivSuspeConne]', 5 );

EXCEPTION

    WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttenIndivSuspeConne]', 5 );
        RAISE;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttenIndivSuspeConne]', 5 );
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;
















































PROCEDURE ATTENINDIVWITHDRAW
(
	INUSESUNUSE	   IN	SERVSUSC.SESUNUSE%TYPE,
	INUORDERID     IN   SUSPCONE.SUCOIDSC%TYPE,
	IDTFECHATEN    IN   SERVSUSC.SESUFECO%TYPE,
	IDTSESUFECO	   IN	SERVSUSC.SESUFECO%TYPE,
	INUMOTIVO	   IN	NUMBER,
    IRCCONFESCO    IN   CONFESCO%ROWTYPE,
    INUCICLO       IN   SUSCRIPC.SUSCCICL%TYPE DEFAULT NULL
)
IS
BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.AttenIndivWithDraw]', 5 );

    
    PKSUSPCONNSERVICEMGR.VALIDSUSPENSIONDAYS
    (
        INUSESUNUSE,
    	IRCCONFESCO.COECDICO,
    	IDTSESUFECO
    );
    
    RCSERVSUSC := PKTBLSERVSUSC.FRCGETRECORD( INUSESUNUSE, PKCONSTANTE.NOCACHE );
    
    
    PKSUSPCONNSERVICEMGR.APPLYCHARGE ( RCSERVSUSC ,IRCCONFESCO, INUCICLO );

    
    PKBCSUSPCONE.UPATTENTIONDATE
    (
        INUORDERID,
        NVL( IDTFECHATEN, SYSDATE ),
        NULL
    );
                                     
    
    ATTENDCOLLECTACTIVITY( INUORDERID );

    
    
    PKWITHDRAWSERVNUMBER.EXECUTEWITHDRAW
    (
        INUSESUNUSE,
        INUMOTIVO,
        PKCONSTANTE.NULLSB,
		IDTFECHATEN,
        FALSE,
        IRCCONFESCO.COECCODI
    );
    
    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.AttenIndivWithDraw]', 5 );

EXCEPTION

    WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttenIndivWithDraw]', 5 );
        RAISE;

    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AttenIndivWithDraw]', 5 );
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;























































PROCEDURE CREATESUSPCONNE
(
	INUSUSPIDSC    IN    SUSPCONE.SUCOIDSC%TYPE,
	INUDEPAORDE    IN    SUSPCONE.SUCODEPA%TYPE,
	INULOCAORDE    IN    SUSPCONE.SUCOLOCA%TYPE,
	INUNUMEORDE    IN    SUSPCONE.SUCONUOR%TYPE,
	INUEVENAPLI    IN    CONFESCO.COECCODI%TYPE,
	INUCAUSDESC    IN    SUSPCONE.SUCOCACD%TYPE,
	ISBSUCOTIPO    IN    SUSPCONE.SUCOTIPO%TYPE,
	ISBOBSERVAC    IN    SUSPCONE.SUCOOBSE%TYPE,
	IRCSERVSUSC    IN    SERVSUSC%ROWTYPE,
	INUCICLO       IN    SUSCRIPC.SUSCCICL%TYPE
)
IS
    
    RCSUSPCONE      SUSPCONE%ROWTYPE;

BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.CreateSuspConne]', 5 );
    
    
    RCSUSPCONE.SUCOIDSC := INUSUSPIDSC;
    RCSUSPCONE.SUCODEPA := INUDEPAORDE;
    RCSUSPCONE.SUCOLOCA := INULOCAORDE;
    RCSUSPCONE.SUCONUOR := INUNUMEORDE;
    RCSUSPCONE.SUCOSUSC := IRCSERVSUSC.SESUSUSC;
    RCSUSPCONE.SUCOSERV := IRCSERVSUSC.SESUSERV;
    RCSUSPCONE.SUCONUSE := IRCSERVSUSC.SESUNUSE;
    RCSUSPCONE.SUCOTIPO := ISBSUCOTIPO;
    RCSUSPCONE.SUCOFEOR := SYSDATE;
    RCSUSPCONE.SUCOCACD := INUCAUSDESC;
    RCSUSPCONE.SUCOOBSE := ISBOBSERVAC;
    RCSUSPCONE.SUCOCOEC := INUEVENAPLI;
    RCSUSPCONE.SUCOCICL := INUCICLO;
    RCSUSPCONE.SUCOORIM := PKCONSTANTE.NO;
    RCSUSPCONE.SUCOPROG := PKERRORS.FSBGETAPPLICATION;
    RCSUSPCONE.SUCOTERM := PKGENERALSERVICES.FSBGETTERMINAL;
    RCSUSPCONE.SUCOUSUA := PKGENERALSERVICES.FSBGETUSERNAME;
    
    RCSUSPCONE.SUCOCUPO := GNUPAIDCOUPON;

    
    IF ( GBLEXEACTIVITYRULE ) THEN
    
        RCSUSPCONE.PROCESS_STATUS := 'A';
    
    END IF;
    
    
    
    IF ( PKACCREIVADVANCEMGR.GNUACTIVITYCONS IS NOT NULL ) THEN
    
        
        RCSUSPCONE.SUCOACGC := PKACCREIVADVANCEMGR.GNUACTIVITYCONS;
    
    END IF;

    
	PKTBLSUSPCONE.INSRECORD( RCSUSPCONE );
    
    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.CreateSuspConne]', 5 );
    
EXCEPTION

    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.CreateSuspConne]', 5 );
    	RAISE;

    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.CreateSuspConne]', 5 );
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;




































































PROCEDURE EXECUTEFUNCTIONAPPLY
(
    INUPRODUCT  IN  SERVSUSC.SESUNUSE%TYPE,
    INUSERVCODI	IN  SERVSUSC.SESUSERV%TYPE,
	INUCOECCODI	IN	CONFESCO.COECCODI%TYPE,
	INURCECCOER IN  RECAESCO.RCECCOER%TYPE
)
IS
    BOISBUNDLED     BOOLEAN;
    RCRECAESCO      RECAESCO%ROWTYPE ;
    NURULEID        GE_ACT_PRODTYPE_STAT.RULE_ID%TYPE;
    NUORDERPROCESS  VARCHAR2(1);
    ONUERRCODE      NUMBER;
    OSBERRMSG       VARCHAR2(2000);
    
BEGIN

    UT_TRACE.TRACE( 'pkSuspConnServiceMgr.ExecuteFunctionApply', 15 );
    
    
    GC_BOSUSPREMRECONORD.SETPRODUCTID(INUPRODUCT);

    
    BOISBUNDLED := CC_BOBUNDLINGPROCESS.FBLISBUNDLEDPRODUCT( INUPRODUCT,
                                                             SYSDATE,       
                                                             SYSDATE );     

    
    RCRECAESCO := PKTBLRECAESCO.FRCGETRECORD ( 	INUSERVCODI, 
						INUCOECCODI, 
						INURCECCOER );

    GBLEXEACTIVITYRULE  := FALSE;
    GSBORDERPROCESS     := ''; 

    
    PKSUSPCONNSERVICEMGR.GETACTIVITYEXECDATA(INUSERVCODI,
					  INUCOECCODI,
					  NURULEID,
					  NUORDERPROCESS
                      );

    
    PKSUSPCONNSERVICEMGR.SETORDERPROCESS(NUORDERPROCESS);

    
    IF ( RCRECAESCO.RCECFUFA IS NOT NULL ) THEN
    
        
        PKGENERALSERVICES.EXECUTEDYNAMICPLSQL( RCRECAESCO.RCECFUFA || ';' );
    
    END IF ;
    
    
    
    
    IF ( BOISBUNDLED AND ( INUCOECCODI IN ( NUORDESCONEXIONTOTAL, NUORRETIRO ) ) )
    THEN
        RETURN;
    END IF;

    
    
    
    IF ( NURULEID IS NOT NULL
        AND PKSUSPCONNSERVICEMGR.FNUGETIDSUSPCONE > 0 )
    THEN
        GBLEXEACTIVITYRULE := TRUE;
        
        GR_BOCONFIG_EXPRESSION.EXECUTE(NURULEID, ONUERRCODE, OSBERRMSG);

        IF( ONUERRCODE <> PKCONSTANTE.EXITO )THEN
            ERRORS.SETERROR (ONUERRCODE);
            ERRORS.SETMESSAGE(OSBERRMSG);
            RAISE EX.CONTROLLED_ERROR;
        END IF;
    END IF ;

    UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.ExecuteFunctionApply', 15 );

EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
        UT_TRACE.TRACE( 'Error pkSuspConnServiceMgr.ExecuteFunctionApply', 15 );
        RAISE;
    WHEN OTHERS THEN
        ERRORS.SETERROR;
        UT_TRACE.TRACE( 'Error no controlado pkSuspConnServiceMgr.ExecuteFunctionApply', 15 );
        RAISE EX.CONTROLLED_ERROR;
END EXECUTEFUNCTIONAPPLY;






















PROCEDURE GENERATEORDERFILE
(
    INUSUCODEPA	IN      SUSPCONE.SUCODEPA%TYPE,
    INUSUCOLOCA	IN      SUSPCONE.SUCOLOCA%TYPE,
    INUSUCONUOR	IN      SUSPCONE.SUCONUOR%TYPE,
    INUSUCONUSE	IN      SUSPCONE.SUCONUSE%TYPE,
    INUCOECCODI	IN      CONFESCO.COECCODI%TYPE,
    ISBCOECREGE	IN      CONFESCO.COECREGE%TYPE,
    ISBCOECTECS	IN      CONFESCO.COECTECS%TYPE
)
IS
    SBNOMBREPO    	VARCHAR2(2000) ;
    SBNOMBARCH    	VARCHAR2(2000) ;
    SBCOMANDO     	VARCHAR2(2000) ;
    SBRUTASQL		VARCHAR2(2000) ;
    SBRUTAREPO		VARCHAR2(2000) ;
    SBSTRGCONN		VARCHAR2(2000) ;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.GenerateOrderFile');
    
    
    SBSTRGCONN := PKGENERALSERVICES.FSBGETCOMPLETECONNSTR ;
    
    SBRUTASQL  := PKGENERALSERVICES.FSBGETPATHSQLREPORTS ;
    
    SBRUTAREPO  := PKGENERALSERVICES.FSBGETPATHUSERREPORTS ;
    
    SBNOMBREPO := TRIM ( SBRUTASQL ) || ISBCOECREGE ;
    
    SBNOMBARCH :=   ISBCOECTECS                 || '_' ||
		    TO_CHAR ( INUSUCONUSE )     || '_' ||
		    TO_CHAR ( SYSDATE, 'YYYY' ) ||
		    TO_CHAR ( SYSDATE, 'MON' )  ||
		    TO_CHAR ( SYSDATE, 'DD' )   ||
		    TO_CHAR ( SYSDATE, 'HH24' ) ||
		    TO_CHAR ( SYSDATE, 'MI' )   ||
		    TO_CHAR ( SYSDATE, 'SS' )   || '.OPF';
		    
    SBNOMBARCH :=   SBRUTAREPO || SBNOMBARCH ;
    
    SBCOMANDO := 'sqlplus '  || ' ' ||
		 SBSTRGCONN || ' ' ||
		 '@' || SBNOMBREPO || ' ' ||
		 SBNOMBARCH || ' ' ||
		 TO_CHAR ( SA_BOSYSTEM.FNUGETUSERCOMPANYID ) || ' ' ||
		 TO_CHAR ( INUSUCONUOR ) || ' ' ||
		 TO_CHAR ( INUSUCONUSE ) ;
		 
    
    LLAMASIST ( SBCOMANDO );
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END GENERATEORDERFILE;



















































































PROCEDURE ORDERINDIVSUSPECONNE
(
    
    
	INUNUMEORDE    IN    SUSPCONE.SUCONUOR%TYPE,
	INUREPONUME    IN    REPORTES.REPONUME%TYPE,
	INUCAUSDESC    IN    SUSPCONE.SUCOCACD%TYPE,
	ISBSUCOTIPO    IN    SUSPCONE.SUCOTIPO%TYPE,
	ISBOBSERVAC    IN    SUSPCONE.SUCOOBSE%TYPE,
	INULINEA       IN    NUMBER,
	IRCSERVSUSC    IN    SERVSUSC%ROWTYPE,
	IRCCONFESCO    IN    CONFESCO%ROWTYPE,
	INUCICLO       IN    SUSCRIPC.SUSCCICL%TYPE DEFAULT NULL,
    IBLUPSERVSUSC  IN    BOOLEAN DEFAULT TRUE
)
IS

	NUCICLO        SUSCRIPC.SUSCCODI%TYPE;
	NUNUMEORDE     NUMBER;
	
BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.OrderIndivSuspeConne]', 5 );

    GNUIDSUSPCONE := PKBCSUSPCONE.FNUGETNEXTSEQUENCE;

    NUNUMEORDE := INUNUMEORDE;
    
    
    IF ( NOT DAOR_ORDER.FBLEXIST( NUNUMEORDE ) ) THEN
        NUNUMEORDE := -1;
    END IF;
    
    IF ( NUNUMEORDE = -1 ) THEN
        NUNUMEORDE := -1 * GNUIDSUSPCONE;  
    END IF;

    
    GNUORDERID := NUNUMEORDE;
    
    UT_TRACE.TRACE( 'gnuIdsuspcone -> ' || TO_CHAR( GNUIDSUSPCONE ), 6 );
    UT_TRACE.TRACE( 'gnuOrderId    -> ' || TO_CHAR( GNUORDERID ), 6 );

    NUCICLO := INUCICLO;

    
    IF ( INUCICLO IS NULL ) THEN
    
        
    	NUCICLO := PKTBLSUSCRIPC.FNUGETBILLINGCYCLE( IRCSERVSUSC.SESUSUSC );
    
    END IF;

    
    CREATESUSPCONNE
    (
        GNUIDSUSPCONE,
        -1, 
        -1, 
        NUNUMEORDE,
        IRCCONFESCO.COECCODI,
        INUCAUSDESC,
        ISBSUCOTIPO,
        ISBOBSERVAC,
        IRCSERVSUSC,
        NUCICLO
    );
                        				  
    
    APPLYCHARGE( IRCSERVSUSC, IRCCONFESCO, INUCICLO );

    
    
    IF ( IBLUPSERVSUSC ) THEN
    
        
        
        
        IF ( ( IRCCONFESCO.COECCODI = NUESCO_ORDEN_REVISION AND IRCSERVSUSC.SESUESCO = NUESCO_SUSP_TOTAL ) OR
             ( IRCCONFESCO.COECCODI = NUESCO_SUSP_TOTAL AND IRCSERVSUSC.SESUESCO = NUESCO_ORDEN_REVISION )
        ) THEN
            PKTBLSERVSUSC.UPSUSPENSIONSTATUS( IRCSERVSUSC.SESUNUSE, IRCCONFESCO.COECCODI );
        ELSE
            PKTBLSERVSUSC.UPSUSPENSIONSTATUS( IRCSERVSUSC.SESUNUSE, IRCCONFESCO.COECCODI, SYSDATE );
        END IF;
        
        
        IF ( INUREPONUME IS NOT NULL ) THEN
        
            
            PKREPORTSINCMGR.INSERTREPORTLINE
            (
                INUREPONUME,
                INULINEA,
                INUNUMEORDE,
                IRCSERVSUSC.SESUSUSC,
                IRCSERVSUSC.SESUNUSE,
                NULL,
                NULL,
                NULL,
                ISBOBSERVAC
            );
        END IF;
    
    ELSE
    
        
        GRCTRGSERVSUSC.SESUESCO := IRCCONFESCO.COECCODI;
        GRCTRGSERVSUSC.SESUFECO := SYSDATE;
    
    END IF;
    
    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.OrderIndivSuspeConne]', 5 );

EXCEPTION

    WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.OrderIndivSuspeConne]', 5 );
    	RAISE;

    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.OrderIndivSuspeConne]', 5 );
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;































PROCEDURE TRANSFERSUSPCONNEC
(
	INUSESUACTUAL   IN      SERVSUSC.SESUNUSE%TYPE,
	INUSESUNUEVO    IN     	SERVSUSC.SESUNUSE%TYPE
)
IS
    
    
    
    
    
    CNURECORDS_READ    CONSTANT NUMBER := 100;
    
    
    
    
    
    TNUSUCODEPA	PKSUSPCONNSERVICEMGR.TYSUCODEPA;
    TNUSUCOLOCA	PKSUSPCONNSERVICEMGR.TYSUCOLOCA;
    TNUSUCONUOR	PKSUSPCONNSERVICEMGR.TYSUCONUOR;
    TNUSUCONUSE	PKSUSPCONNSERVICEMGR.TYSUCONUSE;
    
    
    
    
    
    CURSOR CUSUSPCONNEC
    (
	INUSESUACT          IN      SERVSUSC.SESUNUSE%TYPE
    )
    IS
        SELECT SUCODEPA, SUCOLOCA, SUCONUOR, SUCONUSE
          FROM SUSPCONE
         WHERE SUCONUSE = INUSESUACT
           AND SUCOFEAT IS NULL;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.TransferSuspConnec');
    
    
    OPEN CUSUSPCONNEC( INUSESUACTUAL );
    LOOP
    
    	
    	FETCH CUSUSPCONNEC BULK COLLECT INTO TNUSUCODEPA,
    					     TNUSUCOLOCA,
    					     TNUSUCONUOR,
    					     TNUSUCONUSE
       	LIMIT CNURECORDS_READ;
       	
    	
    	
    	
    	
    	IF ( TNUSUCONUOR.FIRST IS NULL ) THEN
    	    EXIT ;
    	END IF ;
    	
    	
    	UPSUBSCRIBEDSERVICE
    	(
    		TNUSUCODEPA,
    		TNUSUCOLOCA,
    		TNUSUCONUOR,
    		TNUSUCONUSE,
    		INUSESUNUEVO
    	);
    	
    	
    	TNUSUCODEPA.DELETE;
    	TNUSUCOLOCA.DELETE;
    	TNUSUCONUOR.DELETE;
    	TNUSUCONUSE.DELETE;
    	
    	
    	
    	
    	EXIT WHEN CUSUSPCONNEC%NOTFOUND ;
    
    END LOOP;
    
    CLOSE CUSUSPCONNEC;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	IF ( CUSUSPCONNEC%ISOPEN ) THEN
    	    CLOSE CUSUSPCONNEC;
    	END IF;
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	IF ( CUSUSPCONNEC%ISOPEN ) THEN
    	    CLOSE CUSUSPCONNEC;
    	END IF;
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	IF ( CUSUSPCONNEC%ISOPEN ) THEN
    	    CLOSE CUSUSPCONNEC;
    	END IF;
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END TRANSFERSUSPCONNEC;



























PROCEDURE UPSUBSCRIBEDSERVICE
(
	ITNUSUCODEPA	IN OUT NOCOPY 	TYSUCODEPA,
	ITNUSUCOLOCA	IN OUT NOCOPY 	TYSUCOLOCA,
	ITNUSUCONUOR	IN OUT NOCOPY 	TYSUCONUOR,
	ITNUSUCONUSE	IN OUT NOCOPY 	TYSUCONUSE,
	INUSESUNUEVO    IN     		SERVSUSC.SESUNUSE%TYPE
)
IS
    
    
    
    CNURECORD_NO_EXISTE CONSTANT NUMBER := 4165; 
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.UpSubscribedService');
    
    FORALL INDX IN ITNUSUCONUSE.FIRST .. ITNUSUCONUSE.LAST
	UPDATE SUSPCONE
           SET SUCONUSE = INUSESUNUEVO
	 WHERE SUCODEPA = ITNUSUCODEPA( INDX )
	   AND SUCOLOCA = ITNUSUCOLOCA( INDX )
	   AND SUCONUOR = ITNUSUCONUOR( INDX )
	   AND SUCONUSE = ITNUSUCONUSE( INDX );
	   
    IF ( SQL%NOTFOUND ) THEN
    
        PKERRORS.SETERRORCODE ( PKCONSTANTE.CSBDIVISION,
                                PKCONSTANTE.CSBMOD_SAT,
                                CNURECORD_NO_EXISTE );
        RAISE LOGIN_DENIED ;
    
    END IF;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	    RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END UPSUBSCRIBEDSERVICE;

























PROCEDURE UPDATEPACKAGE
(
    INUORDERNUMBER  IN  SUSPCONE.SUCONUOR%TYPE
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.UpdatePackage');

    IF ( PKBCSUSPCONE.FBLEXISTORDER(INUORDERNUMBER) ) THEN
    
        PKGENERALSERVICES.TRACEDATA('Se actualizar� estado Paquete :'||INUORDERNUMBER);
        
        PKBOSC_CALLSERVICESOSS.UPDSTAPACKSENDING ( INUORDERNUMBER );
    
    ELSE
    
        PKGENERALSERVICES.TRACEDATA('Se eliminar� Paquete :'||INUORDERNUMBER);
        
        PKBOSC_CALLSERVICESOSS.DELETEPACKAGE ( INUORDERNUMBER );
    
    END IF ;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	   PKERRORS.POP;
	   RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	   PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	   RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END UPDATEPACKAGE;






















PROCEDURE VALAUTOMATICCAUSE
(
    INUSUCOCACD	IN      SUSPCONE.SUCOCACD%TYPE
)
IS
    NUCAUSDESC          SUSPCONE.SUCOCACD%TYPE ;    
    NUCAUSCONE          SUSPCONE.SUCOCACD%TYPE ;    
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValAutomaticCause');
    
    
    NUCAUSDESC := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE('CAUS_DESC');
    
    NUCAUSCONE := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE('CAUS_CONE');
    
    
    IF ( INUSUCOCACD = NUCAUSCONE OR INUSUCOCACD = NUCAUSDESC ) THEN
    
    	
    	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
    				PKCONSTANTE.CSBMOD_BIL,
    				CNUCAU_NO_PERMITIDA );
    	RAISE LOGIN_DENIED;
    
    END IF ;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALAUTOMATICCAUSE;

























PROCEDURE VALCLIENTTYPE
(
    INUSESUSUSC	IN      SERVSUSC.SESUSUSC%TYPE
)
IS
    
    RCSUSCRIPC    SUSCRIPC%ROWTYPE ;
    RCCLIENTE     DAGE_SUBSCRIBER.STYGE_SUBSCRIBER ;
    RCTIPOCLIE    DAGE_SUBSCRIBER_TYPE.STYGE_SUBSCRIBER_TYPE ;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValClientType');
    
    
    RCSUSCRIPC := PKTBLSUSCRIPC.FRCGETRECORD ( INUSESUSUSC );
    
    RCCLIENTE  := DAGE_SUBSCRIBER.FRCGETRECORD ( RCSUSCRIPC.SUSCCLIE );
    
    RCTIPOCLIE := DAGE_SUBSCRIBER_TYPE.FRCGETRECORD ( RCCLIENTE.SUBSCRIBER_TYPE_ID );
    
    IF ( RCTIPOCLIE.VALID_FOR_DISCONNECT != PKCONSTANTE.SI ) THEN
    
    	
    	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
    				PKCONSTANTE.CSBMOD_SAT,
    				CNUTIP_CLI_NO_VALID );
    	RAISE LOGIN_DENIED;
    
    END IF ;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALCLIENTTYPE;





























FUNCTION FBLEXISTORDER
(
    INUDEPACODI	IN      SUSPCONE.SUCODEPA%TYPE,
    INULOCACODI	IN      SUSPCONE.SUCOLOCA%TYPE,
    INUSESUNUSE IN 	    SUSPCONE.SUCONUSE%TYPE,
    ISBSUCOTIPO IN      SUSPCONE.SUCOTIPO%TYPE
)
RETURN BOOLEAN
IS
    
    NUORDEN	SUSPCONE.SUCONUOR%TYPE ;	
    
    
    CURSOR CUSUSPCONE IS
        SELECT SUCONUOR
        FROM  SUSPCONE
        WHERE SUCONUSE = INUSESUNUSE
        AND   SUCOTIPO = ISBSUCOTIPO
        AND   SUCOFEAT IS NULL
        AND   ROWNUM = 1;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fblExistOrder');
    
    
    OPEN CUSUSPCONE ;
    FETCH CUSUSPCONE INTO NUORDEN ;
    
    IF ( CUSUSPCONE%FOUND ) THEN
    
	    CLOSE CUSUSPCONE ;
        RETURN TRUE;
    
    END IF;
    
    CLOSE CUSUSPCONE;
    PKERRORS.POP;
    RETURN FALSE;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FBLEXISTORDER;























PROCEDURE VALEXISTORDER
(
    INUDEPACODI	IN      SUSPCONE.SUCODEPA%TYPE,
	INULOCACODI	IN      SUSPCONE.SUCOLOCA%TYPE,
	INUNUMEORDE	IN	    SUSPCONE.SUCONUOR%TYPE
)
IS
    
    NUORDEN	SUSPCONE.SUCONUOR%TYPE ;	
    
    
    CURSOR CUSUSPCONE IS
        SELECT SUCONUOR
        FROM  SUSPCONE
        WHERE SUCODEPA = INUDEPACODI
        AND   SUCOLOCA = INULOCACODI
        AND   SUCONUOR = INUNUMEORDE
        AND   SUCOFEAT IS NULL
        AND   ROWNUM = 1;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValExistOrder');
    
    
    OPEN CUSUSPCONE ;
    FETCH CUSUSPCONE INTO NUORDEN ;
    
    IF ( CUSUSPCONE%NOTFOUND ) THEN
    
    	
    	CLOSE CUSUSPCONE ;
    	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
    				PKCONSTANTE.CSBMOD_SAT,
    				CNUORDEN_NO_EXISTE );
    	RAISE LOGIN_DENIED;
    
    END IF;
    
    CLOSE CUSUSPCONE;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALEXISTORDER;





















PROCEDURE VALEXISTORDER
(
	INUNUMEORDE	IN	SUSPCONE.SUCONUOR%TYPE
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValExistOrder');

    IF ( NOT PKSUSPCONNSERVICEMGR.FBLEXISTORDER(INUNUMEORDE)) THEN
    
    	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
    				PKCONSTANTE.CSBMOD_SAT,
    				CNUORDEN_NO_EXISTE );
    	RAISE LOGIN_DENIED;
    
    END IF;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALEXISTORDER;























PROCEDURE VALMOTIVESUSPNONPAY
(
	INUMOTIRETI     IN   NUMBER
)
IS
    NUMOTIRETI          NUMBER ;    
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValMotiveSuspNonPay');
    
    
    NUMOTIRETI := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE
					('MOTIVO_RETIRO_POR_NO_PAGO' );
					
    IF ( INUMOTIRETI != NUMOTIRETI ) THEN
    
    	
    	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
    				PKCONSTANTE.CSBMOD_SAT,
    				CNUMOT_NO_PERMITIDO );
    	RAISE LOGIN_DENIED;
    
    END IF ;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALMOTIVESUSPNONPAY;























PROCEDURE VALNUMBERORDERSERVICE
(
    INUNUMEORDE  IN   SUSPCONE.SUCONUOR%TYPE,
    INUNUNSERVI  IN   SUSPCONE.SUCOSERV%TYPE
)
IS
    
    CURSOR CUVALIDORD IS
    	SELECT  SUCOSERV
    	FROM    SUSPCONE
    	WHERE   SUCONUOR = INUNUMEORDE
    	AND     ROWNUM = 1;
    	
    NUNUNSERVI  SUSPCONE.SUCOSERV%TYPE; 
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValNumberOrderService');
    
    
    OPEN CUVALIDORD;
    
    FETCH CUVALIDORD INTO NUNUNSERVI;
    
    CLOSE CUVALIDORD;
    
    
    IF (INUNUNSERVI <> NUNUNSERVI) THEN
    
    	
    	PKERRORS.SETERRORCODE
    	                     (
    			         PKCONSTANTE.CSBDIVISION,
    				 PKCONSTANTE.CSBMOD_BIL,
    				 CNUORDEN_NO_CORRESP
    			     );
    	RAISE LOGIN_DENIED;
    
    END IF;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALNUMBERORDERSERVICE;






































PROCEDURE VALIDSUSPENSIONDAYS
(
    INUNUMESERV    IN    SERVSUSC.SESUNUSE%TYPE,
	INUDIASCORT    IN    CONFESCO.COECDICO%TYPE,
	IDTFECHCORT    IN    SERVSUSC.SESUFECO%TYPE,
    INUCUENSALD    IN    CONFCOSE.COCSNCDX%TYPE DEFAULT NULL
)
IS
    BLVALID BOOLEAN;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValidSuspensionDays');
    
    
    BLVALID := FBLVALSUSPENSIONDAYS(INUNUMESERV,INUDIASCORT,IDTFECHCORT,INUCUENSALD);
    
    IF (NOT(BLVALID)) THEN
    
	    
	    PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				    PKCONSTANTE.CSBMOD_BIL,
				    CNUNO_CUMP_DIAS );
	    RAISE LOGIN_DENIED;
    
    END IF ;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALIDSUSPENSIONDAYS;
























FUNCTION FBLHASORDER
(
	INUNUSE    	IN    	SERVSUSC.SESUNUSE%TYPE,
    INUTIPO    	IN    	SUSPCONE.SUCOTIPO%TYPE
)
RETURN BOOLEAN
IS
    
    CURSOR CUSUSPCONE IS
        SELECT /*+ index( suspcone IX_SUCO_NUSE )*/ SUSPCONE.*
        FROM  SUSPCONE
        WHERE SUCONUSE = INUNUSE
        AND   SUCOTIPO = INUTIPO
        AND   SUCOFEAT IS NULL;
        
    BLRESULTADO	BOOLEAN := FALSE;
    RCSUSPCONE	SUSPCONE%ROWTYPE;
BEGIN

    PKERRORS.PUSH ('pkSuspConnServiceMgr.fblHasOrder');
    
    PKGENERALSERVICES.TRACEDATA('Numero Servicio '||INUNUSE);
    PKGENERALSERVICES.TRACEDATA('Tipo '||INUTIPO);

    OPEN CUSUSPCONE;
    FETCH CUSUSPCONE INTO RCSUSPCONE;
    
    IF ( CUSUSPCONE%FOUND ) THEN
	   BLRESULTADO := TRUE;
    END IF;
    
    CLOSE CUSUSPCONE;
    PKERRORS.POP;
    RETURN( BLRESULTADO );
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FBLHASORDER;



















































FUNCTION FBLVALSUSPENSIONDAYS
(
    INUNUMESERV    IN       SERVSUSC.SESUNUSE%TYPE,
    INUDIASCORT    IN       CONFESCO.COECDICO%TYPE,
    IDTFECHCORT    IN       SERVSUSC.SESUFECO%TYPE,
    INUCUENSALD    IN       CONFCOSE.COCSNCDX%TYPE DEFAULT NULL
)
RETURN BOOLEAN
IS
    DTULTFECHVENC           PERIFACT.PEFAFEPA%TYPE ;
    NUCUCOCODI	            CUENCOBR.CUCOCODI%TYPE ;
    NUSERVICE               SERVSUSC.SESUSERV%TYPE;
    RCCONFCOSE              CONFCOSE%ROWTYPE;

    CUACCOUNTS              PKCONSTANTE.TYREFCURSOR;
    TBDUEBALANCEACC         TYTBACCOUNT;
    RCPRODUCTO              SERVSUSC%ROWTYPE;
    SBCUENCUENTASRECLAMOS   GE_EQUIVALENC_VALUES.TARGET_VALUE%TYPE;
    
    NUCUENTASALDO           NUMBER;

BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.fblValSuspensionDays');

    
    IF ( IDTFECHCORT IS NOT NULL ) THEN

	    
	    
	    IF ( ( TRUNC ( SYSDATE ) - INUDIASCORT ) < TRUNC ( IDTFECHCORT ) ) THEN
	    
	    
	       PKERRORS.POP;
	       RETURN FALSE;
	    END IF;

        PKERRORS.POP;
	    RETURN TRUE;
    END IF ;

    
    NUSERVICE := PKTBLSERVSUSC.FNUGETSERVICE( INUNUMESERV );

    
    RCCONFCOSE := PKTBLCONFCOSE.FRCGETRECORD( NUSERVICE );

    
    RCPRODUCTO := PKTBLSERVSUSC.FRCGETRECORD( INUNUMESERV );

    
    
    IF NOT GE_BOEQUIVALENCVALUES.FBLEXISTEQUIVTARGET(
        PKBOCLAIMCONSTANTS.FNUCONJEQUIPROTTIPOPROD, RCPRODUCTO.SESUSERV ) THEN

        
        SBCUENCUENTASRECLAMOS := PKCONSTANTE.SI;

    ELSE
        
        
        SBCUENCUENTASRECLAMOS := GE_BOEQUIVALENCVALUES.FSBGETTARGETVALUE(
            PKBOCLAIMCONSTANTS.FNUCONJEQUIPROTTIPOPROD, RCPRODUCTO.SESUSERV );

    END IF;

    
    IF SBCUENCUENTASRECLAMOS = PKCONSTANTE.SI THEN

        
        PKACCOUNTMGR.GETPRODUCTDUEBALANCE( INUNUMESERV, CUACCOUNTS );

    ELSE

        
        PKACCOUNTMGR.OBTSALDOPENDPRODUCTO( INUNUMESERV, CUACCOUNTS );

    END IF;

    FETCH CUACCOUNTS BULK COLLECT INTO TBDUEBALANCEACC;
    CLOSE CUACCOUNTS;

    NUCUENTASALDO := NVL( INUCUENSALD, RCCONFCOSE.COCSNCDX );

    
    
    
    IF ( TBDUEBALANCEACC.COUNT = 0 ) OR ( TBDUEBALANCEACC.COUNT < NUCUENTASALDO ) THEN
    
        PKERRORS.POP;
        RETURN FALSE;
    
    END IF;

    
    
    NUCUCOCODI := NULL;
    IF ( TBDUEBALANCEACC.EXISTS( NUCUENTASALDO ) ) THEN
    
        NUCUCOCODI := TBDUEBALANCEACC( NUCUENTASALDO ).CUCOCODI;
    
    END IF;

    IF ( NUCUCOCODI IS NULL ) THEN
        PKERRORS.POP;
        RETURN FALSE;
    END IF;

    
    DTULTFECHVENC :=  PKTBLCUENCOBR.FDTGETEXPIRATIONDATE ( NUCUCOCODI );

    IF ( ( SYSDATE - INUDIASCORT ) < DTULTFECHVENC ) THEN
	   
	   
	   PKERRORS.POP;
	   RETURN FALSE;
    END IF;
    
    PKERRORS.POP;
    RETURN TRUE;

EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FBLVALSUSPENSIONDAYS;
























FUNCTION FNUGETNEXTLINENUMBER RETURN NUMBER
IS
BEGIN

    PKERRORS.PUSH ('pkSuspConnServiceMgr.fnuGetNextLineNumber');
    
    NULINEA:= NVL(NULINEA,0)+1;

    PKERRORS.POP;
    RETURN NULINEA;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FNUGETNEXTLINENUMBER;


























FUNCTION FNUGETNEXTORDERNUMBER RETURN VARCHAR2
IS
    
    CURSOR CU_NEXTORDERNUMBER
    IS
    	SELECT SQSUSPCONE.NEXTVAL FROM DUAL;
        NUORDERNUMBER NUMBER;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetNextOrderNumber');
    
    PKERRORS.POP;
    RETURN PKGENERALSERVICES.FNUGETNEXTSEQUENCEVAL('seq_or_order');
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	    RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FNUGETNEXTORDERNUMBER;























FUNCTION FSBGETORDERTYPE ( INUSUCONUOR	SUSPCONE.SUCONUOR%TYPE )
RETURN SUSPCONE.SUCOTIPO%TYPE
IS
    
    CURSOR CUORDERTYPE
    IS
    	SELECT SUCOTIPO
    	FROM SUSPCONE
    	WHERE SUCONUOR = INUSUCONUOR
    	AND SUCOTIPO IN ('D','C','R')
    	AND ROWNUM = 1;
    	
    NUORDERTYPE  SUSPCONE.SUCOTIPO%TYPE;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fsbGetOrderType');
    
    
    IF (CUORDERTYPE%ISOPEN) THEN
	    CLOSE CUORDERTYPE;
    END IF;
    
    OPEN CUORDERTYPE;
    FETCH CUORDERTYPE INTO NUORDERTYPE;
    CLOSE CUORDERTYPE;
    
    PKERRORS.POP;
    RETURN NUORDERTYPE;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	    RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FSBGETORDERTYPE;

























PROCEDURE VALDATELESSCURRENT
(
    IDTSUCOFEAT	IN      SUSPCONE.SUCOFEAT%TYPE
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValDateLessCurrent');

    
    IF ( IDTSUCOFEAT > SYSDATE ) THEN
    
        PKERRORS.SETERRORCODE ( PKCONSTANTE.CSBDIVISION,
    				PKCONSTANTE.CSBMOD_BIL,
    				10459 );
        RAISE LOGIN_DENIED ;
    
    END IF ;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALDATELESSCURRENT;


























PROCEDURE VALDATELESSORDERDATE
(
    IDTSUCOFEOR	IN      SUSPCONE.SUCOFEOR%TYPE,
	IDTSUCOFEAT	IN      SUSPCONE.SUCOFEAT%TYPE
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValDateLessOrderDate');

    
    IF ( IDTSUCOFEOR > IDTSUCOFEAT ) THEN
    
        PKERRORS.SETERRORCODE ( PKCONSTANTE.CSBDIVISION,
    				PKCONSTANTE.CSBMOD_BIL,
    				10462 );
        RAISE LOGIN_DENIED ;
    
    END IF ;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END VALDATELESSORDERDATE;




















PROCEDURE SETPROCESSCONNECTIONON
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetProcessConnectionOn');

    BLACTPROCCONN := TRUE;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	   PKERRORS.POP;
	   RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	   PKERRORS.POP;
	   RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	   PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	   PKERRORS.POP;
	   RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END SETPROCESSCONNECTIONON;




















PROCEDURE SETPROCESSCONNECTIONOFF
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetProcessConnectionOff');

    BLACTPROCCONN := FALSE;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	   PKERRORS.POP;
	   RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	   PKERRORS.POP;
	   RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	   PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	   PKERRORS.POP;
	   RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END SETPROCESSCONNECTIONOFF;




















FUNCTION FBLISACTIVEPROCESSCONNECTION
RETURN BOOLEAN
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fblIsActiveProcessConnection');

    PKERRORS.POP;
    RETURN ( BLACTPROCCONN );
EXCEPTION
    WHEN LOGIN_DENIED THEN
	   PKERRORS.POP;
	   RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	   PKERRORS.POP;
	   RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	   PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	   PKERRORS.POP;
	   RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FBLISACTIVEPROCESSCONNECTION;























PROCEDURE INSERTREPORT
(
	ISBTITUREPO	IN	VARCHAR2,
	INUNUMEORDE	IN	SUSPCONE.SUCONUOR%TYPE,
	ONUREPONUME	OUT	REPORTES.REPONUME%TYPE,
	ONUINCONUME	OUT	REPORTES.REPONUME%TYPE
)
IS
	SBREPOTITU	VARCHAR2(200);
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.InsertReport');

    SBREPOTITU := ISBTITUREPO||'('||TO_CHAR(INUNUMEORDE)||')';
    
    PKREPORTSMGR.CREATEREPORT (
				'Informe ' ||ISBTITUREPO ,
				ONUREPONUME );
    
    PKREPORTSMGR.CREATEREPORT (
				'Inconsistencias ' || SBREPOTITU,
				ONUINCONUME
			      );

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END INSERTREPORT;






















FUNCTION FNUGETINCOORDENUMBER ( INUSUCONUOR	SUSPCONE.SUCONUOR%TYPE )
RETURN REPOINCO.REINREPO%TYPE
IS
    NUINCONUMBER	REPOINCO.REINREPO%TYPE;
    
    
    CURSOR CUINCONUMBER
    IS
    	SELECT REPONUME
    	FROM REPORTES
    	WHERE REPODESC LIKE '%'||TO_CHAR(INUSUCONUOR)||'%'
    	AND ROWNUM = 1;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetIncoOrdeNumber');
    
    
    IF (CUINCONUMBER%ISOPEN) THEN
	    CLOSE CUINCONUMBER;
    END IF;
    
    OPEN CUINCONUMBER;
    FETCH CUINCONUMBER INTO NUINCONUMBER;
    CLOSE CUINCONUMBER;
    
    PKERRORS.POP;
    RETURN NUINCONUMBER;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	    RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FNUGETINCOORDENUMBER;































PROCEDURE GENERATEORDERFILE
(
    ISBSTRCONN	    IN	VARCHAR2,
	ISBTITULO	    IN	VARCHAR2,
	ISBRUTAREPORT	IN	VARCHAR2,
	ISBRUTAARCH	    IN	VARCHAR2,
	INUSUCONUOR	    IN  SUSPCONE.SUCONUOR%TYPE,
	INUNUREPO	    IN	REPORTES.REPONUME%TYPE DEFAULT NULL,
	IBLCONCORDER    IN  BOOLEAN DEFAULT TRUE
)
IS

    
    PRAGMA AUTONOMOUS_TRANSACTION;

    SBNOMBARCH      VARCHAR2(2000);
    SBRUTAARCH	    VARCHAR2(2000);
    SBCOMANDO     	VARCHAR2(2000);
    SBSTRGCONN		VARCHAR2(2000);
    SBNULO		    PARAMETR.PAMECHAR%TYPE;
    SBCONSPARA		VARCHAR2(500);

    PROCEDURE GETPARAMETERS
    IS
    BEGIN
    
        UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.GenerateOrderFile.GetParameters]', 6 );
        
        
    	SBNULO := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE( 'NULLSTR' );
    	
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.GenerateOrderFile.GetParameters]', 6 );
        
    EXCEPTION
    
        WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenerateOrderFile.GetParameters]', 6 );
            RAISE;
            
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenerateOrderFile.GetParameters]', 6 );
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END GETPARAMETERS;
    
BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.GenerateOrderFile]', 5 );

    GETPARAMETERS;

    SBRUTAARCH := ISBRUTAARCH;
    
    IF ( IBLCONCORDER ) THEN
        SBNOMBARCH :=   ISBTITULO || '_' || TO_CHAR( INUSUCONUOR ) || '.lst';
    ELSE
        SBNOMBARCH := ISBTITULO || '.lst';
    END IF;

    SBCONSPARA := SA_BOSYSTEM.FNUGETUSERCOMPANYID || ' ' ||
        PKCONSTANTE.NULLNUM || ' ' || PKCONSTANTE.NULLNUM;

    SBRUTAARCH := SBRUTAARCH || SBNOMBARCH ||' '||SBCONSPARA;

    IF ( INSTR(ISBTITULO,'INCO') > 0 ) THEN
    	SBRUTAARCH := SBRUTAARCH || ' ' || INUNUREPO || ' ' || SBNULO;
    	SBCONSPARA := SBCONSPARA || ' ' || INUNUREPO || ' ' || '''' || SBNULO || '''';
    ELSE
    	SBRUTAARCH := SBRUTAARCH || ' ' || INUSUCONUOR;
    	SBCONSPARA := SBCONSPARA || ' ' || INUSUCONUOR;
    END IF;

    SBCOMANDO := 'sqlplus ' || ' ' || ISBSTRCONN|| ' ' ||
        '@' || ISBRUTAREPORT || ' ' || SBRUTAARCH;

    IF ( INUNUREPO IS NOT NULL ) THEN
    
    	
    	PKTBLREPORTES.UPEXESTRING
        (
            INUNUREPO,
            ISBRUTAREPORT,
            SBCONSPARA
        );
    
    END IF;

    
    PKGENERALSERVICES.COMMITTRANSACTION;

    
    LLAMASIST( SBCOMANDO );
    
    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.GenerateOrderFile]', 5 );
    
EXCEPTION

    WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKGENERALSERVICES.ROLLBACKTRANSACTION;
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenerateOrderFile]', 5 );
    	RAISE;

    WHEN OTHERS THEN
        
        PKGENERALSERVICES.ROLLBACKTRANSACTION;
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenerateOrderFile]', 5 );
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;



































PROCEDURE ADDSTATUSREG
(
    ISBIDTRACKING       IN	ESTAPROG.ESPRPROG%TYPE,
    INUNUMORDEN	        IN	SUSPCONE.SUCONUOR%TYPE,
    INUTOTALTHREADS     IN  NUMBER,
    INUNUMETHREAD       IN  NUMBER,
    INUEVENAPLI         IN  CONFESCO.COECCODI%TYPE,
    INUCICLCODI         IN  CICLO.CICLCODI%TYPE,
    INUNUMESERV         IN  SERVSUSC.SESUNUSE%TYPE
)
IS

    
    PRAGMA AUTONOMOUS_TRANSACTION;

    SBMESSAGE           ESTAPROG.ESPRMESG%TYPE;
    NUNUMSUBSSERVICES   NUMBER;
    
BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.AddStatusReg]', 5 );

    SBMESSAGE := PKTBLMENSAJE.FSBGETDESCRIPTION
    (
        PKCONSTANTE.CSBDIVISION,
        PKCONSTANTE.CSBMOD_BIL,
        CNUMESSAGE
    );

    
    PKSTATUSEXEPROGRAMMGR.ADDRECORD
    (
        ISBIDTRACKING,
        SBMESSAGE,
        0,
		INUNUMORDEN
    );

    
    NUNUMSUBSSERVICES := PKSUSPCONNSERVICEMGR.FNUGETNUMOFSUBSSERV
    (
        INUEVENAPLI,
        INUCICLCODI,
        INUNUMESERV,
        INUTOTALTHREADS,
        INUNUMETHREAD
    );

    IF ( NUNUMSUBSSERVICES = 0 ) THEN
    
        SBMESSAGE := PKTBLMENSAJE.FSBGETDESCRIPTION
        (
            PKCONSTANTE.CSBDIVISION,
    		PKCONSTANTE.CSBMOD_GRL,
    		10032
        );
    
    END IF;

    
    PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROG
    (
		ISBIDTRACKING,
		SBMESSAGE,
		0,
		NULL,
		NUNUMSUBSSERVICES,
		INUNUMORDEN
    );

    
    PKGENERALSERVICES.COMMITTRANSACTION;

    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.AddStatusReg]', 5 );
    
EXCEPTION

    WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKGENERALSERVICES.ROLLBACKTRANSACTION;
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AddStatusReg]', 5 );
        RAISE;

    WHEN OTHERS THEN
        
        PKGENERALSERVICES.ROLLBACKTRANSACTION;
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.AddStatusReg]', 5 );
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;



























FUNCTION FBLEXISTORDER
(
	INUNUMEORDEN	IN	SUSPCONE.SUCONUOR%TYPE
)
RETURN BOOLEAN
IS
    

    
    CURSOR CUSUSPCONE IS
        SELECT SUCONUOR
        FROM  SUSPCONE
        WHERE SUCONUOR = INUNUMEORDEN
        AND   SUCOFEAT IS NULL
        AND   ROWNUM = 1;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fblExistOrder');

    IF ( NUORDEN = INUNUMEORDEN ) THEN
    
        PKERRORS.POP;
        RETURN TRUE;
    
    END IF;

    IF (CUSUSPCONE%ISOPEN) THEN
        CLOSE CUSUSPCONE;
    END IF;
    
    
    OPEN CUSUSPCONE ;

    FETCH CUSUSPCONE INTO NUORDEN ;

    IF ( CUSUSPCONE%FOUND ) THEN
    
        CLOSE CUSUSPCONE ;
        RETURN TRUE;
    
    END IF;

    CLOSE CUSUSPCONE;
    
    PKERRORS.POP;
    RETURN FALSE;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FBLEXISTORDER;































PROCEDURE INACTIVEBILLING
(
	IRCSERVSUSC    IN    SERVSUSC%ROWTYPE,
	IRCCONFESCO    IN    CONFESCO%ROWTYPE,
	INUCICLO       IN    SUSCRIPC.SUSCCICL%TYPE    DEFAULT NULL
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.InactiveBilling');

    
    PKSUSPCONNSERVICEMGR.APPLYCHARGE ( IRCSERVSUSC, IRCCONFESCO, INUCICLO );

    
    
    
    IF ( ( IRCCONFESCO.COECCODI = NUESCO_ORDEN_REVISION AND IRCSERVSUSC.SESUESCO = NUESCO_SUSP_TOTAL )
       OR ( IRCCONFESCO.COECCODI = NUESCO_SUSP_TOTAL AND IRCSERVSUSC.SESUESCO = NUESCO_ORDEN_REVISION ) )
    THEN
        PKTBLSERVSUSC.UPSUSPENSIONSTATUS( IRCSERVSUSC.SESUNUSE, IRCCONFESCO.COECCODI);
    ELSE
        PKTBLSERVSUSC.UPSUSPENSIONSTATUS( IRCSERVSUSC.SESUNUSE, IRCCONFESCO.COECCODI, SYSDATE );
    END IF;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END INACTIVEBILLING;


























PROCEDURE ISJOBEXITS
(
	ISBWHAT   IN DBA_JOBS.WHAT%TYPE
)
IS
    TBFORMCOECCODI      PKTBLCONFESCO.TYCOECCODI;
    TBFORMCYCLES        PKTBLCICLO.TYCICLCODI;
    TBFORMCAUSES        TYCACDCODI;
    TBFORMSERVNUMBER    TYSESUNUSE;
    NUFORMNUMPROCESS    NUMBER;

    TBJOBCOECCODI       PKTBLCONFESCO.TYCOECCODI;
    TBJOBCYCLES         PKTBLCICLO.TYCICLCODI;
    TBJOBCAUSES         TYCACDCODI;
    TBJOBSERVNUMBER      TYSESUNUSE;
    NUJOBNUMPROCESS     NUMBER;

    THEREAREJOBS        BOOLEAN;   
    THEREAREJOBS1       BOOLEAN;
    SBPARAMJOBS         DBA_JOBS.WHAT%TYPE;

    TBJOBSWHAT          PKBIUT_JOBMGR.TYTBJOBSWHAT; 
                                       
    TBJOBSJOB           PKBIUT_JOBMGR.TYTBJOBSJOB; 
    NUCODEJOB           DBA_JOBS.JOB%TYPE;

    SBWHATJOBLIKE       DBA_JOBS.WHAT%TYPE;

    SBWHAT              DBA_JOBS.WHAT%TYPE;
    SBWHATJOB           DBA_JOBS.WHAT%TYPE;
    BMORERECORD         BOOLEAN;

    PROCEDURE INITIALIZE
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.IsJobExits.Initialize');

        TBFORMCOECCODI.DELETE;
        TBFORMCYCLES.DELETE;
        TBFORMCAUSES.DELETE;
        TBFORMSERVNUMBER.DELETE;

        BMORERECORD := FALSE;
        SBWHATJOBLIKE := '%DECLARE%nuErrorCode%number;%sbErrorMessage%mensaje.mensdesc%type;%BEGIN%pkSuspConnService.ExeSuspeConneEvent%';

        NUCODEJOB := 0;
        SBWHAT := ISBWHAT;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END INITIALIZE;

    PROCEDURE INITIALIZE_JOBS
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.IsJobExits.Initialize_Jobs');

        TBJOBCOECCODI.DELETE;
        TBJOBCYCLES.DELETE;
        TBJOBCAUSES.DELETE;
        TBJOBSERVNUMBER.DELETE;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END INITIALIZE_JOBS;

    PROCEDURE GETPARAMJOBOFWHAT
    (
        ISBWHAT IN DBA_JOBS.WHAT%TYPE,
        OSBPARAMJOBS OUT DBA_JOBS.WHAT%TYPE
    )
    IS
        SBCRITERIO DBA_JOBS.WHAT%TYPE;
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.IsJobExits.GetParamJobOfWhat');

        
        
        SBCRITERIO := SUBSTR(ISBWHAT,INSTR(ISBWHAT,'(')+2);
        SBCRITERIO := SUBSTR(SBCRITERIO,0,INSTR(SBCRITERIO,'''')-1);
        OSBPARAMJOBS := SBCRITERIO;
        
        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END GETPARAMJOBOFWHAT;

    FUNCTION FBCOMPARAJOBS
    (
        ITBFORMCOECCODI     IN  PKTBLCONFESCO.TYCOECCODI,
        ITBFORMCYCLES       IN  PKTBLCICLO.TYCICLCODI,
        ITBFORMSERVNUMBER   IN  TYSESUNUSE,
        ITBJOBCOECCODI      IN  PKTBLCONFESCO.TYCOECCODI,
        ITBJOBCYCLES        IN  PKTBLCICLO.TYCICLCODI,
        ITBJOBERVNUMBER     IN  TYSESUNUSE
    )
    RETURN BOOLEAN
    IS
        THEREAREJOBS BOOLEAN := FALSE;
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.IsJobExits.fbComparaJobs');
       
        
        FOR NUIDXFORM IN ITBFORMCOECCODI.FIRST .. ITBFORMCOECCODI.LAST LOOP
            FOR NUIDXJOB IN ITBJOBCOECCODI.FIRST .. ITBJOBCOECCODI.LAST LOOP
                IF ( ITBFORMCOECCODI(NUIDXFORM) = ITBJOBCOECCODI(NUIDXJOB)
                    AND ITBFORMCYCLES(NUIDXFORM) = ITBJOBCYCLES(NUIDXJOB)
                    AND ITBFORMSERVNUMBER(NUIDXFORM) = ITBJOBERVNUMBER(NUIDXJOB)
                  )
                THEN
                
                    THEREAREJOBS := TRUE;
                    RETURN THEREAREJOBS;
                
                END IF;
            END LOOP;
        END LOOP;

        RETURN (THEREAREJOBS);

        PKERRORS.POP;

    EXCEPTION
            WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
                PKERRORS.POP;
                RAISE;
            WHEN OTHERS THEN
                PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
                PKERRORS.POP;
                RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END FBCOMPARAJOBS;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.IsJobExits');

    
    INITIALIZE ;
    
    
    GETPARAMJOBOFWHAT( ISBWHAT,
                       SBPARAMJOBS
                     );
    
    GETPARAMSJOBS
    (
        SBPARAMJOBS,
        NUFORMNUMPROCESS,
        TBFORMCOECCODI,
        TBFORMCYCLES,
        TBFORMCAUSES,
        TBFORMSERVNUMBER
    );

    
    
    LOOP
    
        
        INITIALIZE_JOBS;
        
        BMORERECORD := PKBIUT_JOBMGR.FBQUERYJOBWHAT( TBJOBSWHAT,
                                                     TBJOBSJOB,
                                                     NUCODEJOB,
                                                     SBWHATJOBLIKE,
                                                     CNUBULK
                                                   );

        IF ( TBJOBSJOB.FIRST IS NULL ) THEN
            EXIT;
        END IF;
        
        
        FOR NUIDX IN TBJOBSJOB.FIRST .. TBJOBSJOB.LAST LOOP
        
            
            GETPARAMSJOBS( TBJOBSWHAT(NUIDX),
                           NUJOBNUMPROCESS,
                           TBJOBCOECCODI,
                           TBJOBCYCLES,
                           TBJOBCAUSES,
                           TBJOBSERVNUMBER
                          );

             
             
             THEREAREJOBS := FBCOMPARAJOBS( TBFORMCOECCODI,
                                            TBFORMCYCLES,
                                            TBFORMSERVNUMBER,
                                            TBJOBCOECCODI,
                                            TBJOBCYCLES,
                                            TBJOBSERVNUMBER
                                          );
            IF (THEREAREJOBS) THEN
                THEREAREJOBS1 := TRUE;
            END IF;
        
        END LOOP;

        IF ( NOT BMORERECORD ) THEN
            EXIT;
        END IF;

        
        NUCODEJOB := TBJOBSJOB.LAST;
    
    END LOOP;

    
    IF ( THEREAREJOBS1 ) THEN
    
        PKERRORS.SETERRORCODE( CSBDIVISION, CSBMODULE, CNURECORD_YA_EXISTE );
        RAISE LOGIN_DENIED ;
    
    END IF;
    
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END ISJOBEXITS;




































PROCEDURE GETPARAMSJOBS
(
    ISBPARAMETRS   IN    VARCHAR2,
    ONUNUMPROCESS  OUT   NUMBER,
    OTBCOECCODI    OUT   PKTBLCONFESCO.TYCOECCODI,
    OTBCYCLES      OUT   PKTBLCICLO.TYCICLCODI,
    OTBCAUSES      OUT   TYCACDCODI,
    OBTSERVNUMBER  OUT   TYSESUNUSE
)
IS
    SBPARAMETRS         VARCHAR2(2000);
    NUIDX               NUMBER := 0;
    SBESCO              VARCHAR2(3);
    SBCICL              VARCHAR2(4);
    SBCAUSE             VARCHAR2(4);
    SBSERVNUMBER        VARCHAR2(10);
    RCTBREQSTATES       PKSUSPCONNSERVICEMGR.TYTBSTATES;

    PROCEDURE INITIALIZE
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.GetParamsJobs.Initialize');

        ONUNUMPROCESS := PKCONSTANTE.NULLNUM;
        SBPARAMETRS := ISBPARAMETRS;
        OBTSERVNUMBER.DELETE;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END INITIALIZE;

    FUNCTION FSBGETCRITERIA(IOSBPARAMETERS IN OUT VARCHAR2)
    RETURN VARCHAR2
    IS
        SBCRITERIA  VARCHAR2(100);
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.GetParamsJobs.fsbGetCriteria');

        
        SBCRITERIA := SUBSTR(IOSBPARAMETERS,1,INSTR(IOSBPARAMETERS,'|')-1);

        
        IOSBPARAMETERS := SUBSTR (IOSBPARAMETERS,INSTR(IOSBPARAMETERS,'|')+1);

        PKERRORS.POP;
        RETURN SBCRITERIA;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END FSBGETCRITERIA;

    PROCEDURE GETPROCESSDATA
    (
        IOSBPARAMETRS   IN  OUT VARCHAR2,
        OSBESCO            OUT VARCHAR2,
        OSBCICL            OUT VARCHAR2,
        OSBCAUSE           OUT VARCHAR2,
        OSBSERVNUMBER      OUT VARCHAR2
    )
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.GetParamsJobs.GetProcessData');

        
        OSBESCO := FSBGETCRITERIA(IOSBPARAMETRS);

        
        OSBCICL := FSBGETCRITERIA(IOSBPARAMETRS);

        
        OSBCAUSE := FSBGETCRITERIA(IOSBPARAMETRS);

        
        OSBSERVNUMBER := FSBGETCRITERIA(IOSBPARAMETRS);

        
        IOSBPARAMETRS := SUBSTR (IOSBPARAMETRS,INSTR(IOSBPARAMETRS,',')+1);

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END GETPROCESSDATA;

    PROCEDURE FILLDATATABLES
    (
        ISBESCO             VARCHAR2,
        ISBCICL             VARCHAR2,
        ISBCAUSE            VARCHAR2,
        ISBSERVNUMBER       VARCHAR2
    )
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.GetParamsJobs.FillDataTables');

        
        NUIDX := NUIDX + 1;

    	OTBCOECCODI(NUIDX)   :=   ISBESCO;
    	OTBCYCLES(NUIDX)     :=   ISBCICL;
    	OTBCAUSES(NUIDX)     :=   ISBCAUSE;
    	OBTSERVNUMBER(NUIDX) :=   ISBSERVNUMBER;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END FILLDATATABLES;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.GetParamsJobs');

    INITIALIZE;

    LOOP
    
        EXIT WHEN SBPARAMETRS IS NULL;

        
        GETPROCESSDATA(SBPARAMETRS,SBESCO,SBCICL,SBCAUSE,SBSERVNUMBER);

        
        FILLDATATABLES(SBESCO,SBCICL,SBCAUSE,SBSERVNUMBER);
    
    END LOOP;

    
    ONUNUMPROCESS := OTBCOECCODI.COUNT;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END GETPARAMSJOBS;





























PROCEDURE GETPROCESTOEXECUTE
(
	ISBPARAMETRS   IN    VARCHAR2,
	ONUNUMPROCESS  OUT   NUMBER,
	OTBCOECCODI    OUT   PKTBLCONFESCO.TYCOECCODI,
	OTBCYCLES      OUT   PKTBLCICLO.TYCICLCODI,
	OTBCAUSES      OUT   TYCACDCODI,
	OBTSERVNUMBER  OUT   TYSESUNUSE
)
IS
    SBPARAMETRS         VARCHAR2(2000);
    NUIDX               NUMBER := 0;
    SBESCO              VARCHAR2(3);
    SBCICL              VARCHAR2(4);
    SBCAUSE             VARCHAR2(4);
    SBSERVNUMBER        VARCHAR2(10);
    RCTBREQSTATES       PKSUSPCONNSERVICEMGR.TYTBSTATES;

    TBCOECCODI          PKTBLCONFESCO.TYCOECCODI;
	TBCYCLES            PKTBLCICLO.TYCICLCODI;
	TBCAUSES            TYCACDCODI;
	TBSERVNUMBER        TYSESUNUSE;


    PROCEDURE INITIALIZE
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.GetProcesToExecute.Initialize');

        ONUNUMPROCESS := PKCONSTANTE.NULLNUM;
        SBPARAMETRS := ISBPARAMETRS;
        OBTSERVNUMBER.DELETE;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END INITIALIZE;

    PROCEDURE FILLDATATABLES
    (
        ISBESCO        IN   CONFESCO.COECCODI%TYPE,
        ISBCICL        IN   CICLO.CICLCODI%TYPE,
        ISBCAUSE       IN   CAUSCODE.CACDCODI%TYPE,
        ISBSERVNUMBER  IN   SERVSUSC.SESUNUSE%TYPE
    )
    IS
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.GetProcesToExecute.FillDataTables');

        
        NUIDX := NUIDX + 1;

        OTBCOECCODI(NUIDX)   :=   ISBESCO;
    	OTBCYCLES(NUIDX)     :=   ISBCICL;
    	OTBCAUSES(NUIDX)     :=   ISBCAUSE;
    	OBTSERVNUMBER(NUIDX) :=   ISBSERVNUMBER;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END FILLDATATABLES;

    PROCEDURE GETALLSTATES
    (
        ISBESCO         IN  CONFESCO.COECCODI%TYPE,
        ISBCICL         IN  CICLO.CICLCODI%TYPE,
        ISBCAUSE        IN  CAUSCODE.CACDCODI%TYPE,
        ISBSERVNUMBER   IN  SERVSUSC.SESUNUSE%TYPE
    )
    IS
        NUBEFORESTATE   NUMBER :=0;
    BEGIN
    
        PKERRORS.PUSH('pkSuspConnServiceMgr.GetProcesToExecute.GetAllStates');

        
        RCTBREQSTATES := PKSUSPCONNSERVICEMGR.FTBGETSTATESTOPROCESS(  ISBESCO );

        IF ( RCTBREQSTATES.TBRCECCOEC.FIRST IS NULL ) THEN
            PKERRORS.POP;
            RETURN;
        END IF;

        FOR NUIDX IN RCTBREQSTATES.TBRCECCOEC.FIRST .. RCTBREQSTATES.TBRCECCOEC.LAST LOOP
        
            IF ( RCTBREQSTATES.TBRCECCOEC(NUIDX) != NUBEFORESTATE ) THEN
                
                FILLDATATABLES( RCTBREQSTATES.TBRCECCOEC(NUIDX),
                                ISBCICL,
                                ISBCAUSE,
                                ISBSERVNUMBER );
            END IF;

            
            NUBEFORESTATE := RCTBREQSTATES.TBRCECCOEC(NUIDX);
        
        END LOOP;

        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END GETALLSTATES;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.GetProcesToExecute');

    INITIALIZE;

    GETPARAMSJOBS( SBPARAMETRS,
	               ONUNUMPROCESS,
                   TBCOECCODI,
                   TBCYCLES,
                   TBCAUSES,
                   TBSERVNUMBER
                 );


    FOR NUINDEX IN TBCOECCODI.FIRST .. TBCOECCODI.LAST LOOP
    
        IF ( TBCOECCODI(NUINDEX) = PKCONSTANTE.NULLNUM ) THEN
            
            GETALLSTATES( TBCOECCODI(NUINDEX),
                          TBCYCLES(NUINDEX),
                          TBCAUSES(NUINDEX),
                          TBSERVNUMBER(NUINDEX)
                        );
        ELSE
            
            FILLDATATABLES(TBCOECCODI(NUINDEX),
                           TBCYCLES(NUINDEX),
                           TBCAUSES(NUINDEX),
                           TBSERVNUMBER(NUINDEX)
                          );
        END IF;
    
    END LOOP;

    
    ONUNUMPROCESS := OTBCOECCODI.COUNT;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
    	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END GETPROCESTOEXECUTE;









































FUNCTION FNUGETNUMOFSUBSSERV
(
    INUCOECCODI         SERVSUSC.SESUESCO%TYPE,
    INUCYCLE            CICLO.CICLCODI%TYPE,
    INUSUBSSERVICE      SERVSUSC.SESUNUSE%TYPE,
    INUTOTALTHEADS      NUMBER,
    INUNUMETHREAD       NUMBER
)
RETURN NUMBER
IS
    
    
    
    BLREGTOPROCESS      BOOLEAN;
    RCTBREQSTATES       PKSUSPCONNSERVICEMGR.TYTBSTATES;
    RCTBSUBSSERVICES    PKSUSPCONNSERVICEMGR.TYTBSUBSSERVICES;
    NUREGAPROCESAR	    NUMBER := 0;		
    
    
    

    PROCEDURE GETDATA
    IS
        RCPRODUCT   SERVSUSC%ROWTYPE;
    BEGIN
    
        UT_TRACE.TRACE( 'pkSuspConnServiceMgr.fnugetNumofSubsServ.GetData', 16 );

        

        IF ( PKACCREIVADVANCEMGR.GNUACTIVITYCONS IS NOT NULL ) THEN

            
            RCPRODUCT := PKTBLSERVSUSC.FRCGETRECORD( INUSUBSSERVICE,
                                                     PKCONSTANTE.NOCACHE );

            

            RCTBREQSTATES.TBRCECCOEC( 1 ) := INUCOECCODI;
            RCTBREQSTATES.TBRCECCOER( 1 ) := RCPRODUCT.SESUESCO;

        ELSE

            
        RCTBREQSTATES := PKSUSPCONNSERVICEMGR.FTBGETSTATESTOPROCESS(  INUCOECCODI );

        END IF;


        UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.fnugetNumofSubsServ.GetData', 16 );

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END GETDATA;

    PROCEDURE COUNTSUBSSERVICES
    (
        INUEVENTAPPLY  RECAESCO.RCECCOEC%TYPE,
        INUREQSTATE    RECAESCO.RCECCOER%TYPE
    )
    IS
        NUMINSUBSSERV   NUMBER := 0;
    BEGIN
    
        UT_TRACE.TRACE( 'pkSuspConnServiceMgr.fnugetNumofSubsServ.CountSubsServices', 16 );

        LOOP
        
    	    
            RCTBSUBSSERVICES := NULL;
            
            BLREGTOPROCESS := PKSUSPCONNSERVICEMGR.FBLGETSUBSSERVICES
                                                            (  INUREQSTATE,
                                                               INUCYCLE,
                                                               INUSUBSSERVICE,
                                                               NUMINSUBSSERV,
                                                               INUEVENTAPPLY,
                                                               INUTOTALTHEADS,
                                                               INUNUMETHREAD,
                                                               CNUBULK,
                                                               RCTBSUBSSERVICES
                                                             );

            
            NUREGAPROCESAR := NUREGAPROCESAR + RCTBSUBSSERVICES.TBSERVROWID.COUNT;

            EXIT WHEN ( RCTBSUBSSERVICES.TBSUBSSERVICES.COUNT < CNUBULK );

            
            NUMINSUBSSERV := RCTBSUBSSERVICES.TBSUBSSERVICES(RCTBSUBSSERVICES.TBSUBSSERVICES.LAST);
        
        END LOOP;
        
        UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.fnugetNumofSubsServ.CountSubsServices', 16 );
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END COUNTSUBSSERVICES ;
    
    PROCEDURE COUNTCONTRACTS
    (
        INUEVENTAPPLY   IN  RECAESCO.RCECCOEC%TYPE,
        INUREQSTATE     IN  RECAESCO.RCECCOER%TYPE
    )
    IS
        TBCONTRACTS     PKSUSPCONNSERVICEMGR.TYTBSUBSSERVICES;
        NUMINCONTRACT   NUMBER := 0;
    BEGIN

        UT_TRACE.TRACE( 'pkSuspConnServiceMgr.fnugetNumofSubsServ.CountContracts', 16 );

        LOOP

    	    
    	    TBCONTRACTS := NULL;

            
            PKSUSPCONNSERVICEMGR.GETCONTRACTS( INUREQSTATE,
                                               INUCYCLE,
                                               INUSUBSSERVICE,
                                               NUMINCONTRACT,
                                               INUEVENTAPPLY,
                                               INUTOTALTHEADS,
                                               INUNUMETHREAD,
                                               CNUBULK,
                                               TBCONTRACTS );

            
            NUREGAPROCESAR := NUREGAPROCESAR + TBCONTRACTS.TBSUSCCODI.COUNT;

            EXIT WHEN TBCONTRACTS.TBSUSCCODI.COUNT < CNUBULK;

            
            NUMINCONTRACT := TBCONTRACTS.TBSUSCCODI(TBCONTRACTS.TBSUSCCODI.LAST);

        END LOOP;

        UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.fnugetNumofSubsServ.CountContracts', 16 );

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END COUNTCONTRACTS;
    
    PROCEDURE COUNTPROCESS
    IS
        SBSUSPRETIRECOCONT  PARAMETR.PAMECHAR%TYPE;
    BEGIN
    
        UT_TRACE.TRACE( 'pkSuspConnServiceMgr.fnugetNumofSubsServ.CountProcess', 16 );

        
        SBSUSPRETIRECOCONT :=
            PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE('FA_SUSP_RETI_RECO_CONT');
            
        IF ( RCTBREQSTATES.TBRCECCOEC.FIRST IS NULL ) THEN
        
            PKERRORS.POP;
            RETURN;
        
        END IF;

        FOR NUIDX IN RCTBREQSTATES.TBRCECCOEC.FIRST .. RCTBREQSTATES.TBRCECCOEC.LAST LOOP
        
            
            IF SBSUSPRETIRECOCONT = PKCONSTANTE.SI THEN
                
                COUNTCONTRACTS( RCTBREQSTATES.TBRCECCOEC(NUIDX),
                                RCTBREQSTATES.TBRCECCOER(NUIDX) );
            ELSE
                
                COUNTSUBSSERVICES(RCTBREQSTATES.TBRCECCOEC(NUIDX),
                                  RCTBREQSTATES.TBRCECCOER(NUIDX));
            END IF;
        
        END LOOP;
        
        UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.fnugetNumofSubsServ.CountProcess', 16 );
        
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END COUNTPROCESS ;
    
BEGIN

    UT_TRACE.TRACE( 'pkSuspConnServiceMgr.fnugetNumofSubsServ', 15 );

	
	GETDATA;

    
	COUNTPROCESS;

    UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.fnugetNumofSubsServ', 15 );
    RETURN (NVL(NUREGAPROCESAR,0));
    
EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
        RAISE;
    WHEN OTHERS THEN
        ERRORS.SETERROR;
        RAISE EX.CONTROLLED_ERROR;

END FNUGETNUMOFSUBSSERV;









































































FUNCTION FBLGETSUBSSERVICES
(
    INUREQESTATE        IN  ESTACORT.ESCOCODI%TYPE,
    INUCYCLE            IN  CICLO.CICLCODI%TYPE,
    INUSUBSSERVICE      IN  SERVSUSC.SESUNUSE%TYPE,
    INUSUBSSERVMIN      IN  SERVSUSC.SESUNUSE%TYPE,
    INUAPPLYEVENT       IN  ESTACORT.ESCOCODI%TYPE,
	INUTOTALTHREADS     IN  NUMBER,
	INUTHREAD           IN  NUMBER,
	INUBULKNUM          IN  NUMBER,
	ORCTBSUBSSERVICES   OUT NOCOPY PKSUSPCONNSERVICEMGR.TYTBSUBSSERVICES
)
RETURN BOOLEAN
IS
    
    
    
    BLMORERECORDS   BOOLEAN := TRUE;

    
    
    

    

    CURSOR CUSUBSSERVICES IS
        SELECT /*+ NO_EXPAND
                   INDEX(SERVSUSC IX_SERVSUSC02)
                   USE_NL(SUSCRIPC) */
               SERVSUSC.ROWID, SESUNUSE, SESUESCO, SESUSERV,
               SUSCCICL, SUSCCLIE, SUSCCODI
        FROM   SERVSUSC, SUSCRIPC /*+ pkSuspConnServiceMgr.fblGetsubsServices */
        WHERE  SESUESCO = INUREQESTATE
        AND    SESUNUSE > INUSUBSSERVMIN
        AND    MOD( SESUNUSE, INUTOTALTHREADS ) + 1 = INUTHREAD
        AND    EXISTS
               (
                   SELECT  /*+ USE_NL(RECAESCO) */
                           'x'
                   FROM    RECAESCO
                   WHERE   SESUSERV = RCECSERV
                   AND     SESUESCO = RCECCOER
                   AND     RCECCOEC = INUAPPLYEVENT
               )
        AND    SESUSUSC = SUSCCODI
        ORDER BY SESUNUSE;

    CURSOR CUPRODSBYCYCLE IS
        SELECT /*+ NO_EXPAND
                   INDEX(SERVSUSC IX_SERVSUSC02)
                   USE_NL(SUSCRIPC) */
               SERVSUSC.ROWID, SESUNUSE, SESUESCO, SESUSERV,
               SUSCCICL, SUSCCLIE, SUSCCODI
        FROM   SERVSUSC, SUSCRIPC /*+ pkSuspConnServiceMgr.fblGetsubsServices */
        WHERE  SESUESCO = INUREQESTATE
        AND    SESUNUSE > INUSUBSSERVMIN
        AND    MOD( SESUNUSE, INUTOTALTHREADS ) + 1 = INUTHREAD
        AND    EXISTS
               (
                   SELECT  /*+ USE_NL(RECAESCO) */
                           'x'
                   FROM    RECAESCO
                   WHERE   SESUSERV = RCECSERV
                   AND     SESUESCO = RCECCOER
                   AND     RCECCOEC = INUAPPLYEVENT
               )
        AND    SESUSUSC = SUSCCODI
        AND    SUSCCICL = INUCYCLE
        ORDER BY SESUNUSE;


        
    

    CURSOR CUSERVSUSC
    (
        INUREQESTATE        IN      ESTACORT.ESCOCODI%TYPE,
        INUCYCLE            IN      CICLO.CICLCODI%TYPE,
        INUSUBSSERVICE      IN      SERVSUSC.SESUNUSE%TYPE,
        INUAPPLYEVENT       IN      ESTACORT.ESCOCODI%TYPE,
        INUTOTALTHREADS     IN      NUMBER,
        INUTHREAD           IN      NUMBER
    )
    IS

        SELECT  /*+ INDEX(SERVSUSC PK_SERVSUSC)
                    USE_NL(SUSCRIPC) */
                    SERVSUSC.ROWID, SESUNUSE, SESUESCO, SESUSERV,
                    SUSCCICL, SUSCCLIE, SUSCCODI
        FROM         /*+ pkSuspConnServiceMgr.fblGetsubsServices */
                    SERVSUSC,
                    SUSCRIPC
        WHERE       SESUESCO = INUREQESTATE
        AND         SESUNUSE = INUSUBSSERVICE
        AND         MOD( SESUNUSE, INUTOTALTHREADS ) + 1 = INUTHREAD
        AND         EXISTS
                    (
                        SELECT  /*+ USE_NL(RECAESCO) */
                                'x'
                        FROM    RECAESCO
                        WHERE   SESUSERV = RCECSERV
                        AND     SESUESCO = RCECCOER
                        AND     RCECCOEC = INUAPPLYEVENT )
        AND         SESUSUSC = SUSCCODI
        AND         SUSCCICL + 0 = DECODE( INUCYCLE, PKCONSTANTE.NULLNUM, SUSCCICL, INUCYCLE );

    CURSOR CUPRODINFO
    IS  SELECT /*+ index (servsusc, pk_servsusc)
                   USE_NL(SUSCRIPC)*/
    		   SERVSUSC.ROWID, SESUNUSE, SESUESCO, SESUSERV,
               SUSCCICL, SUSCCLIE, SUSCCODI
        FROM  SERVSUSC, SUSCRIPC /*+ pkSuspConnServiceMgr.fblGetsubsServices */
        WHERE SESUSUSC = SUSCCODI
        AND   SESUNUSE = INUSUBSSERVICE
        AND   SESUESCO = INUREQESTATE
        AND   MOD( SESUNUSE, INUTOTALTHREADS ) + 1 = INUTHREAD
        AND   EXISTS (  SELECT /*+ USE_NL(RECAESCO) */
                               'x'
                        FROM RECAESCO
                        WHERE SESUSERV = RCECSERV
                        AND   SESUESCO = RCECCOER
                        AND   RCECCOEC = INUAPPLYEVENT )
        AND   SUSCCICL + 0 = DECODE( INUCYCLE, PKCONSTANTE.NULLNUM, SUSCCICL, INUCYCLE );
        
BEGIN

    UT_TRACE.TRACE( 'INICIO: pkSuspConnServiceMgr.fblGetsubsServices', 15 );

    
    IF ( INUSUBSSERVICE = PKCONSTANTE.NULLNUM ) THEN
    
        IF ( INUCYCLE = PKCONSTANTE.NULLNUM ) THEN

            OPEN CUSUBSSERVICES;
            FETCH CUSUBSSERVICES BULK COLLECT INTO ORCTBSUBSSERVICES.TBSERVROWID,
                                                   ORCTBSUBSSERVICES.TBSUBSSERVICES,
                                                   ORCTBSUBSSERVICES.TBESCOSTATES,
                                                   ORCTBSUBSSERVICES.TBSERVICES,
                                                   ORCTBSUBSSERVICES.TBCYCLES,
                                                   ORCTBSUBSSERVICES.TBSUSCCLIE,
                                                   ORCTBSUBSSERVICES.TBSUSCCODI
            LIMIT INUBULKNUM;

            IF ( CUSUBSSERVICES%NOTFOUND OR ORCTBSUBSSERVICES.TBSERVROWID.COUNT < INUBULKNUM ) THEN
                BLMORERECORDS := FALSE;
            END IF;

            CLOSE CUSUBSSERVICES;
            
        ELSE
        
            OPEN CUPRODSBYCYCLE;
            FETCH CUPRODSBYCYCLE BULK COLLECT INTO ORCTBSUBSSERVICES.TBSERVROWID,
                                                   ORCTBSUBSSERVICES.TBSUBSSERVICES,
                                                   ORCTBSUBSSERVICES.TBESCOSTATES,
                                                   ORCTBSUBSSERVICES.TBSERVICES,
                                                   ORCTBSUBSSERVICES.TBCYCLES,
                                                   ORCTBSUBSSERVICES.TBSUSCCLIE,
                                                   ORCTBSUBSSERVICES.TBSUSCCODI
            LIMIT INUBULKNUM;

            IF ( CUPRODSBYCYCLE%NOTFOUND OR ORCTBSUBSSERVICES.TBSERVROWID.COUNT < INUBULKNUM ) THEN
                BLMORERECORDS := FALSE;
            END IF;

            CLOSE CUPRODSBYCYCLE;
        
        END IF;

    ELSE
        
        OPEN CUPRODINFO;
        FETCH CUPRODINFO BULK COLLECT INTO ORCTBSUBSSERVICES;
        CLOSE CUPRODINFO;
        BLMORERECORDS := FALSE;

    END IF;

    UT_TRACE.TRACE( 'FIN: pkSuspConnServiceMgr.fblGetsubsServices', 15 );
    RETURN ( BLMORERECORDS );
    
EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
    	RAISE;
    WHEN OTHERS THEN
        ERRORS.SETERROR;
        RAISE EX.CONTROLLED_ERROR;
END FBLGETSUBSSERVICES;

































FUNCTION FTBGETSTATESTOPROCESS ( INUAPPLYEVENT  ESTACORT.ESCOCODI%TYPE)
RETURN PKSUSPCONNSERVICEMGR.TYTBSTATES IS


    
    
    
    
    CURSOR CUALLEVENTTOEXEC (
                          SBOXTYPE  VARCHAR2,
                          SBOCTYPE  VARCHAR2,
                          SBOITYPE  VARCHAR2,
                          SBRTTYPE  VARCHAR2 )
    IS
        SELECT  /*+ ORDERED use_nl ( es, confesco ) */
                DISTINCT RCECCOEC,RCECCOER
        FROM  ( SELECT /*+ index_ffs ( recaesco, pk_recaesco ) */
                RCECCOER, RCECSERV,RCECCOEC
                FROM   RECAESCO
               ) ES, CONFESCO
        WHERE  COECSERV = ES.RCECSERV
        AND    COECCODI = ES.RCECCOEC
        AND    COECTECS IN ( SBOXTYPE,SBOCTYPE,SBOITYPE,SBRTTYPE );

    


    CURSOR CUEVENTTOEXEC (INUEVENT  RECAESCO.RCECCOEC%TYPE,
                          SBOXTYPE  VARCHAR2,
                          SBOCTYPE  VARCHAR2,
                          SBOITYPE  VARCHAR2,
                          SBRTTYPE  VARCHAR2 )
    IS
        SELECT  /*+ ORDERED use_nl ( es, confesco ) */
                DISTINCT RCECCOEC,RCECCOER
        FROM  ( SELECT /*+ index_ffs ( recaesco, pk_recaesco ) */
                        RCECCOER, RCECSERV,RCECCOEC
                FROM   RECAESCO
                WHERE  RCECCOEC = INUEVENT
               ) ES, CONFESCO
        WHERE  COECSERV = ES.RCECSERV
        AND    COECCODI = ES.RCECCOEC
        AND    COECTECS IN ( SBOXTYPE,SBOCTYPE,SBOITYPE,SBRTTYPE );

    
    
    
    NUTIEV_OX		TIEVCOSE.TECSCODI%TYPE ;
    NUTIEV_OC		TIEVCOSE.TECSCODI%TYPE ;
    NUTIEV_OI		TIEVCOSE.TECSCODI%TYPE ;
    NUTIEV_RT		TIEVCOSE.TECSCODI%TYPE ;
    
    
    
    
    PROCEDURE GETPARAMETERS
    IS
    BEGIN
    	PKERRORS.PUSH('pkSuspConnServiceMgr.ftbGetStatesToProcess.Getparameters');

        
        NUTIEV_OX := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE('TIPO_EVENTO_OX');

        
        NUTIEV_OC := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE('TIPO_EVENTO_OC');

        
        NUTIEV_OI := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE('TIPO_EVENTO_OI');

        
        NUTIEV_RT := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE('TIPO_EVENTO_RT');

    	PKERRORS.POP;
    EXCEPTION
	WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
	    PKERRORS.POP;
	    RAISE;
	WHEN OTHERS THEN
	    PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	    PKERRORS.POP;
	    RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETPARAMETERS;
    
BEGIN


    PKERRORS.PUSH ('pkSuspConnServiceMgr.ftbGetStatesToProcess');

    
    IF ( GNUAPPLYEVENT = INUAPPLYEVENT AND GRCTBSTATESTOEXEC.TBRCECCOEC.COUNT > 0 ) THEN
    
        PKERRORS.POP;

        RETURN GRCTBSTATESTOEXEC;
    
    END IF;

    
    GETPARAMETERS;

    GNUAPPLYEVENT := INUAPPLYEVENT;

    
    IF(INUAPPLYEVENT = PKCONSTANTE.NULLNUM) THEN

        IF ( CUALLEVENTTOEXEC%ISOPEN ) THEN
            CLOSE CUALLEVENTTOEXEC;
        END IF;

        OPEN CUALLEVENTTOEXEC(NUTIEV_OX,NUTIEV_OC,NUTIEV_OI,NUTIEV_RT);

        FETCH CUALLEVENTTOEXEC BULK COLLECT INTO GRCTBSTATESTOEXEC.TBRCECCOEC,
                                              GRCTBSTATESTOEXEC.TBRCECCOER;

        CLOSE CUALLEVENTTOEXEC;
    ELSE
        
        
        IF ( CUEVENTTOEXEC%ISOPEN ) THEN
            CLOSE CUEVENTTOEXEC;
        END IF;

        OPEN CUEVENTTOEXEC(INUAPPLYEVENT,NUTIEV_OX,NUTIEV_OC,NUTIEV_OI,NUTIEV_RT);

        FETCH CUEVENTTOEXEC BULK COLLECT INTO GRCTBSTATESTOEXEC.TBRCECCOEC,
                                              GRCTBSTATESTOEXEC.TBRCECCOER;

        CLOSE CUEVENTTOEXEC;

    END IF;

    PKERRORS.POP;

    RETURN GRCTBSTATESTOEXEC;

EXCEPTION
    WHEN LOGIN_DENIED THEN
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
	   RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FTBGETSTATESTOPROCESS;

























FUNCTION FNUGETORDERNUMBER (    INUSUBSSERVICE      SERVSUSC.SESUNUSE%TYPE,
                                IDTATTDATE          DATE )
RETURN NUMBER IS
    
    
    
    CURSOR CUORDERNUMBER ( INUSUBSSERVICE      SERVSUSC.SESUNUSE%TYPE,
                           IDTATTDATE          DATE )IS
    SELECT SUCONUOR
    FROM  SUSPCONE
    WHERE SUCONUSE = INUSUBSSERVICE
    AND   SUCOFEAT = IDTATTDATE;

    NUORDERNUMBER	NUMBER;			

    
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetOrderNumber');

    
    NUORDERNUMBER := 0;

    IF (CUORDERNUMBER%ISOPEN) THEN
        CLOSE CUORDERNUMBER;
    END IF;

    OPEN CUORDERNUMBER(INUSUBSSERVICE,IDTATTDATE);

    
    FETCH CUORDERNUMBER INTO NUORDERNUMBER;

    CLOSE CUORDERNUMBER;

    PKERRORS.POP;
    RETURN (NVL(NUORDERNUMBER,0));

EXCEPTION
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FNUGETORDERNUMBER;






















FUNCTION FNUGETIDSUSPCONE
RETURN NUMBER IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetIdSuspcone');

    PKERRORS.POP;
    RETURN (NVL(GNUIDSUSPCONE,0));

EXCEPTION
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END FNUGETIDSUSPCONE;
































PROCEDURE SETORDERTYPE
    (
        INUORDERTYPE    IN  NUMBER
    )
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetOrderType');

    
    GNUORDERTYPE := INUORDERTYPE ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END SETORDERTYPE;






















PROCEDURE SETRECORDTRIGGER
    (
        RCSERVSUSC    IN  SERVSUSC%ROWTYPE
    )
IS
    RCSERVSUSCNULL SERVSUSC%ROWTYPE;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetRecordTrigger');
    
    GRCTRGSERVSUSC     := RCSERVSUSCNULL;
    
    GRCTRGSERVSUSC := RCSERVSUSC ;

    PKERRORS.POP;


END SETRECORDTRIGGER;























FUNCTION FRCGETRECORDPROCESSED
RETURN SERVSUSC%ROWTYPE
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.frcGetRecordProcessed');
    
    RETURN (GRCTRGSERVSUSC);

    PKERRORS.POP;


END FRCGETRECORDPROCESSED;






























FUNCTION FNUGETORDERTYPE
RETURN NUMBER
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetOrderType');

    PKERRORS.POP;
    
    RETURN GNUORDERTYPE;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FNUGETORDERTYPE;






















FUNCTION FSBGETWORKTYPE
RETURN VARCHAR2
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fsbGetWorkType');

    PKERRORS.POP;
    
    RETURN CSBWORKTYPE;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FSBGETWORKTYPE;





















FUNCTION FRCGETCONFESCO
(
    INUSERVCODI	IN      SERVSUSC.SESUSERV%TYPE,
	INUCOECCODI	IN	CONFESCO.COECCODI%TYPE
) RETURN CONFESCO%ROWTYPE
IS
    RCTBRECTORETURN    CONFESCO%ROWTYPE;
    
    
    
    
    PROCEDURE GETRECTOAPLYINMEM(  INUSERVCODI	IN  SERVSUSC.SESUSERV%TYPE,
                            	  INUCOECCODI	IN	CONFESCO.COECCODI%TYPE )

    IS
    BEGIN
        PKERRORS.PUSH('pkSuspConnServiceMgr.frcGetConfesco.GetRecToAplyInmem');

        
        RCTBRECTORETURN := NULL;

        IF ( GRCTBRECINMEM.COECSERV.FIRST IS NULL ) THEN
        
            PKERRORS.POP;
            RETURN;
        
        END IF;

        FOR NUINDXINMEM IN GRCTBRECINMEM.COECSERV.FIRST..GRCTBRECINMEM.COECSERV.LAST LOOP
        
            
            IF (GRCTBRECINMEM.COECSERV(NUINDXINMEM) = INUSERVCODI AND
                            GRCTBRECINMEM.COECCODI(NUINDXINMEM) = INUCOECCODI) THEN
            
                RCTBRECTORETURN.COECSERV := GRCTBRECINMEM.COECSERV(NUINDXINMEM);
                RCTBRECTORETURN.COECCODI := GRCTBRECINMEM.COECCODI(NUINDXINMEM);
                RCTBRECTORETURN.COECFUFA := GRCTBRECINMEM.COECFUFA(NUINDXINMEM);
                RCTBRECTORETURN.COECFACT := GRCTBRECINMEM.COECFACT(NUINDXINMEM);
                RCTBRECTORETURN.COECDICO := GRCTBRECINMEM.COECDICO(NUINDXINMEM);
                RCTBRECTORETURN.COECGECA := GRCTBRECINMEM.COECGECA(NUINDXINMEM);
                RCTBRECTORETURN.COECREDA := GRCTBRECINMEM.COECREDA(NUINDXINMEM);
                RCTBRECTORETURN.COECTECS := GRCTBRECINMEM.COECTECS(NUINDXINMEM);
                RCTBRECTORETURN.COECREGE := GRCTBRECINMEM.COECREGE(NUINDXINMEM);
                RCTBRECTORETURN.COECREGL := GRCTBRECINMEM.COECREGL(NUINDXINMEM);
                RETURN;
            
            END IF;
        
        END LOOP;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETRECTOAPLYINMEM ;
    
    PROCEDURE GETRECTOAPLYINBD(  INUSERVCODI	IN  SERVSUSC.SESUSERV%TYPE,
                              	 INUCOECCODI	IN	CONFESCO.COECCODI%TYPE)


    IS
        NUINDXINMEM NUMBER;
    BEGIN
        PKERRORS.PUSH('pkSuspConnServicemgr.frcGetConfesco.GetRecToAplyInBD');

        RCTBRECTORETURN := PKTBLCONFESCO.FRCGETRECORD (  INUSERVCODI,
                            						     INUCOECCODI );

        NUINDXINMEM := NVL(GRCTBRECINMEM.COECSERV.LAST + 1,0);

        
        GRCTBRECINMEM.COECSERV(NUINDXINMEM) := RCTBRECTORETURN.COECSERV;
        GRCTBRECINMEM.COECCODI(NUINDXINMEM) := RCTBRECTORETURN.COECCODI;
        GRCTBRECINMEM.COECFUFA(NUINDXINMEM) := RCTBRECTORETURN.COECFUFA;
        GRCTBRECINMEM.COECFACT(NUINDXINMEM) := RCTBRECTORETURN.COECFACT;
        GRCTBRECINMEM.COECDICO(NUINDXINMEM) := RCTBRECTORETURN.COECDICO;
        GRCTBRECINMEM.COECGECA(NUINDXINMEM) := RCTBRECTORETURN.COECGECA;
        GRCTBRECINMEM.COECREDA(NUINDXINMEM) := RCTBRECTORETURN.COECREDA;
        GRCTBRECINMEM.COECTECS(NUINDXINMEM) := RCTBRECTORETURN.COECTECS;
        GRCTBRECINMEM.COECREGE(NUINDXINMEM) := RCTBRECTORETURN.COECREGE;
        GRCTBRECINMEM.COECREGL(NUINDXINMEM) := RCTBRECTORETURN.COECREGL;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETRECTOAPLYINBD ;
    
BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.frcGetConfesco');

    
    GETRECTOAPLYINMEM(INUSERVCODI,INUCOECCODI);

    
    IF (RCTBRECTORETURN.COECCODI IS NULL) THEN
    
        
        GETRECTOAPLYINBD(INUSERVCODI,INUCOECCODI);
    
    END IF;

    PKERRORS.POP;
    RETURN RCTBRECTORETURN;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END FRCGETCONFESCO;



















FUNCTION FRCGETCONFCOSE
(
    INUSERVCODI	IN      SERVSUSC.SESUSERV%TYPE
) RETURN CONFCOSE%ROWTYPE
IS
    RCTBRECTORETURN    CONFCOSE%ROWTYPE;
    
    
    
    
    PROCEDURE GETRECTOAPLYINMEM(  INUSERVCODI	IN  SERVSUSC.SESUSERV%TYPE )

    IS
    BEGIN
        PKERRORS.PUSH('pkSuspConnServiceMgr.frcGetConfcose.G>etRecToAplyInmem');

        
        RCTBRECTORETURN := NULL;

        IF ( GRCTBRECCONFINMEM.COCSSERV.EXISTS(INUSERVCODI)) THEN
        
            RCTBRECTORETURN.COCSSERV := GRCTBRECCONFINMEM.COCSSERV(INUSERVCODI);
            RCTBRECTORETURN.COCSNCDX := GRCTBRECCONFINMEM.COCSNCDX(INUSERVCODI);
            RCTBRECTORETURN.COCSNCCX := GRCTBRECCONFINMEM.COCSNCCX(INUSERVCODI);
            RCTBRECTORETURN.COCSMNCR := GRCTBRECCONFINMEM.COCSMNCR(INUSERVCODI);
            RCTBRECTORETURN.COCSPDCX := GRCTBRECCONFINMEM.COCSPDCX(INUSERVCODI);
            RCTBRECTORETURN.COCSNDRL := GRCTBRECCONFINMEM.COCSNDRL(INUSERVCODI);
            RCTBRECTORETURN.COCSPDCR := GRCTBRECCONFINMEM.COCSPDCR(INUSERVCODI);
            RCTBRECTORETURN.COCSNCRI := GRCTBRECCONFINMEM.COCSNCRI(INUSERVCODI);
        
        END IF;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETRECTOAPLYINMEM ;
    
    PROCEDURE GETRECTOAPLYINBD(  INUSERVCODI	IN  SERVSUSC.SESUSERV%TYPE)

    IS
    BEGIN
        PKERRORS.PUSH('pkSuspConnServicemgr.frcGetConfcose.GetRecToAplyInBD');

        RCTBRECTORETURN := PKTBLCONFCOSE.FRCGETRECORD (  INUSERVCODI );

        
        GRCTBRECCONFINMEM.COCSSERV(INUSERVCODI):= RCTBRECTORETURN.COCSSERV;
        GRCTBRECCONFINMEM.COCSNCDX(INUSERVCODI):= RCTBRECTORETURN.COCSNCDX;
        GRCTBRECCONFINMEM.COCSNCCX(INUSERVCODI):= RCTBRECTORETURN.COCSNCCX;
        GRCTBRECCONFINMEM.COCSMNCR(INUSERVCODI):= RCTBRECTORETURN.COCSMNCR;
        GRCTBRECCONFINMEM.COCSPDCX(INUSERVCODI):= RCTBRECTORETURN.COCSPDCX;
        GRCTBRECCONFINMEM.COCSNDRL(INUSERVCODI):= RCTBRECTORETURN.COCSNDRL;
        GRCTBRECCONFINMEM.COCSPDCR(INUSERVCODI):= RCTBRECTORETURN.COCSPDCR;
        GRCTBRECCONFINMEM.COCSNCRI(INUSERVCODI):= RCTBRECTORETURN.COCSNCRI;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETRECTOAPLYINBD ;
    
BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.frcGetConfcose');

    
    GETRECTOAPLYINMEM(INUSERVCODI);

    
    IF (RCTBRECTORETURN.COCSSERV IS NULL) THEN
    
        
        GETRECTOAPLYINBD(INUSERVCODI);
    
    END IF;

    PKERRORS.POP;
    RETURN RCTBRECTORETURN;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END FRCGETCONFCOSE;



















FUNCTION FSBVERSION  RETURN VARCHAR2 IS
BEGIN

    RETURN CSBVERSION;

END;




















PROCEDURE EXECUTEFUNCTIONAPPLY
    (
        INUSERVCODI	IN      SERVSUSC.SESUSERV%TYPE,
        INUCOECCODI	IN	CONFESCO.COECCODI%TYPE
    )
IS

BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.ExecuteFunctionApply');

    
    FOR RCRECAESCO IN CURECAESCOFUFA(INUSERVCODI,INUCOECCODI) LOOP
	   
	   PKGENERALSERVICES.EXECUTEDYNAMICPLSQL( RCRECAESCO.RCECFUFA || ';' );
    END LOOP ;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	   PKERRORS.POP;
	   RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	
	   PKERRORS.POP;
	   RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
       PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
	   PKERRORS.POP;
	   RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END EXECUTEFUNCTIONAPPLY;






















PROCEDURE INIIDSUSPCONE
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.IniIdSuspcone');

    GNUIDSUSPCONE := NULL ;

    PKERRORS.POP;

EXCEPTION
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END INIIDSUSPCONE;






























PROCEDURE GENORDERSUSPINDIVIDUAL( INUSERVNUMBER IN  SERVSUSC.SESUNUSE%TYPE,
                                  INUEVENTAPLI  IN  ESTACORT.ESCOCODI%TYPE,
                                  INUCAUSDESC   IN  SUSPCONE.SUCOCACD%TYPE,
                                  INUTYPEORDER  IN  NUMBER,
                                  ONUNUMORDER   OUT NOCOPY SUSPCONE.SUCONUOR%TYPE,
                                  INSBTIPOORD   IN VARCHAR2,
                                  ISBOBSERV       IN  SUSPCONE.SUCOOBSE%TYPE
                                )
IS
BEGIN
    
    GENORDERINDIVIDUAL
        (
        INUSERVNUMBER,
        INUEVENTAPLI,
        INUCAUSDESC,
        INUTYPEORDER,
        ONUNUMORDER,
        INSBTIPOORD,
        ISBOBSERV
        );
    EXCEPTION
        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END GENORDERSUSPINDIVIDUAL;





































PROCEDURE CREATEORDERSUSPCONE( INUNUMESERV    IN  SERVSUSC.SESUNUSE%TYPE,
                               INUEVENTOAPLI  IN  ESTACORT.ESCOCODI%TYPE,
                               INUCAUSADESC   IN  SUSPCONE.SUCOCACD%TYPE,
                               ONUNUMEORDER   OUT NOCOPY SUSPCONE.SUCONUOR%TYPE,
                               ISBTYPEORDEN   IN VARCHAR2,
                               ISBOBSERVACION IN  SUSPCONE.SUCOOBSE%TYPE
                             )
IS
    NUORDEN       NUMBER;    
    RCSERVSUSC    SERVSUSC%ROWTYPE;
    RCCONFESCO    CONFESCO%ROWTYPE;
    NUCYCLE       SUSCRIPC.SUSCCICL%TYPE; 

    PROCEDURE GETDATA
    IS
    BEGIN

        PKERRORS.PUSH('pkSuspConnServiceMgr.CreateOrderSuspcone.GetData');

        
        RCSERVSUSC := PKTBLSERVSUSC.FRCGETSERVICENUMBER( INUNUMESERV );

        
        RCCONFESCO := PKTBLCONFESCO.FRCGETRECORD( RCSERVSUSC.SESUSERV,
                                                  INUEVENTOAPLI
                                                );
        
        NUCYCLE := PKTBLSUSCRIPC.FNUGETBILLINGCYCLE( RCSERVSUSC.SESUSUSC );

    EXCEPTION
        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETDATA;

BEGIN

    GETDATA;

    
    NUORDEN     := -1; 

    
    PKSUSPCONNSERVICEMGR.ORDERINDIVSUSPECONNE
                                     (
                                        
                                        
                                        NUORDEN,
                                        NULL, 
                                        INUCAUSADESC,
                                        ISBTYPEORDEN,
                                        ISBOBSERVACION,
                                        NULL, 
                                        RCSERVSUSC,
                                        RCCONFESCO,
                                        NUCYCLE,
                                        FALSE );

    
    
    
    IF ( ( INUEVENTOAPLI = NUESCO_ORDEN_REVISION AND RCSERVSUSC.SESUESCO = NUESCO_SUSP_TOTAL )
       OR ( INUEVENTOAPLI = NUESCO_SUSP_TOTAL AND RCSERVSUSC.SESUESCO = NUESCO_ORDEN_REVISION ) )
    THEN
        PKTBLSERVSUSC.UPSUSPENSIONSTATUS( RCSERVSUSC.SESUNUSE, INUEVENTOAPLI);
    ELSE
        PKTBLSERVSUSC.UPSUSPENSIONSTATUS( RCSERVSUSC.SESUNUSE, INUEVENTOAPLI, SYSDATE );
    END IF;

    
    ONUNUMEORDER := NUORDEN;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
	        RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	        
	        PKERRORS.POP;
	        RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
	        PKERRORS.POP;
	        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END CREATEORDERSUSPCONE;













































PROCEDURE EXECUTEORDERWORKFUNCTION( INUORDEN     IN  SUSPCONE.SUCONUOR%TYPE,
                                    INUCOECCODI  IN  CONFESCO.COECCODI%TYPE,
                                    IRCSERVSUSC  IN  SERVSUSC%ROWTYPE,
                                    INUTIPOORDEN IN  NUMBER
                                  )
IS
    RCRECAESCONULL      RECAESCO%ROWTYPE ;
    RCRECAESCO          RECAESCO%ROWTYPE :=RCRECAESCONULL;
    RCMEMORYDATANULL    PKSUSPCONNSERVICE.TYMEMORYVAR;
    RCMEMORYDATA        PKSUSPCONNSERVICE.TYMEMORYVAR := RCMEMORYDATANULL;
    BLEXEWORKRULE       BOOLEAN;
    NURULEID            GE_ACT_PRODTYPE_STAT.RULE_ID%TYPE;
    NUORDERPROCESS      VARCHAR2(1);
    ONUERRCODE          NUMBER;
    OSBERRMSG           VARCHAR2(2000);

    PROCEDURE GETPARAMETERS
    IS
    BEGIN
        PKERRORS.PUSH ('pkSuspConnServiceMgr.ExecuteOrderWorkFunction.GetParameters');

        
        SBEXISTSOSS := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE('EXIST_OSS');

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
    	    PKERRORS.POP;
    	    RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	    
    	    PKERRORS.POP;
    	    RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
    	    PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
    	    PKERRORS.POP;
    	    RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
            
    END GETPARAMETERS;

BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ExecuteOrderWorkFunction');
    GETPARAMETERS;

    
    IF(	SBEXISTSOSS <> PKCONSTANTE.SI ) THEN
        PKERRORS.POP;
        RETURN;
    END IF;

    GSBORDERPROCESS :=  ''; 

    

    
    PKSUSPCONNSERVICEMGR.GETACTIVITYEXECDATA(
                        IRCSERVSUSC.SESUSERV,
                        INUCOECCODI,
                        NURULEID,
                        NUORDERPROCESS
                        );

    
    PKSUSPCONNSERVICEMGR.SETORDERPROCESS(NUORDERPROCESS);

    
    GC_BOSUSPREMRECONORD.SETPRODUCTID(IRCSERVSUSC.SESUNUSE);

    
    GBLEXEACTIVITYRULE := FALSE;
    PKGENERALSERVICES.TRACEDATA('Id de Suspcone :'||PKSUSPCONNSERVICEMGR.FNUGETIDSUSPCONE);
    PKGENERALSERVICES.TRACEDATA('Regla de Orden :'||NURULEID);

    IF ( NURULEID IS NOT NULL
         AND PKSUSPCONNSERVICEMGR.FNUGETIDSUSPCONE > 0 )
    THEN
        
        
        PKSUSPCONNSERVICEMGR.SETORDERTYPE(INUTIPOORDEN);
        RCMEMORYDATA.NUEVENAPLI   := INUCOECCODI;
        RCMEMORYDATA.NUSERVICE    := IRCSERVSUSC.SESUSERV;
        RCMEMORYDATA.NUNUMESERV   := IRCSERVSUSC.SESUNUSE;
        RCMEMORYDATA.NUORDENUME   := INUORDEN;

        PKSUSPCONNSERVICE.SETINSTANCEDATA(RCMEMORYDATA);
        

        
        GR_BOCONFIG_EXPRESSION.EXECUTE(NURULEID, ONUERRCODE, OSBERRMSG);
        
        IF( ONUERRCODE <> PKCONSTANTE.EXITO )THEN
            ERRORS.SETERROR (ONUERRCODE);
            ERRORS.SETMESSAGE(OSBERRMSG);
            RAISE EX.CONTROLLED_ERROR;
        END IF;
        
        
        RCMEMORYDATA.NUORDENUME   := PKSUSPCONNSERVICEMGR.FNUGETORDERID;
        PKSUSPCONNSERVICE.SETINSTANCEDATA(RCMEMORYDATA);

        GBLEXEACTIVITYRULE := TRUE;

        
    END IF ;

    PKERRORS.POP;

    EXCEPTION

        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END EXECUTEORDERWORKFUNCTION;




















PROCEDURE VALIDATESTATEWITHDRAW
    (
        INUNUMESERV	 IN	 NUMBER, 
        INUESTACORT  IN  NUMBER  
    )
    IS
    RCSERVSUSC  SERVSUSC%ROWTYPE;
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ValidateStateWithDraw');
    
    RCSERVSUSC := PKTBLSERVSUSC.FRCGETSERVICENUMBER( INUNUMESERV );

    UT_TRACE.TRACE('pkSuspConnServiceMgr.ValidateStateWithDraw ['||RCSERVSUSC.SESUSERV||'] ['||INUESTACORT||']['||RCSERVSUSC.SESUESCO||']',12);
    
    PKTBLRECAESCO.ACCKEY( RCSERVSUSC.SESUSERV, INUESTACORT, RCSERVSUSC.SESUESCO );

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALIDATESTATEWITHDRAW;




















PROCEDURE ANULORDSUSPAYMENT
    (
        INUNUMESERV	 IN	 SERVSUSC.SESUNUSE%TYPE  
    )
    IS

    RCSERVNUMBER     SERVSUSC%ROWTYPE;

    NUORDENDESCTOT  ESTACORT.ESCOCODI%TYPE; 
                                           

    NUORDENDESCPARC ESTACORT.ESCOCODI%TYPE; 
                                            

    NUSERVCONECT    ESTACORT.ESCOCODI%TYPE;  
    NUDEPSERVNUMBER   SERVSUSC.SESUDEPA%TYPE; 
    NULOCSERVNUMBER   SERVSUSC.SESULOCA%TYPE; 
    NUESTCORTSERVNUM  SERVSUSC.SESUESCO%TYPE;


    CSBDESCONEXION	CONSTANT VARCHAR2(1) := 'D' ; 
    CNUER_NOT_ORDER_SUP CONSTANT NUMBER := 16014; 
                                              
                                              


    PROCEDURE GETPARAMETERS
    IS
    BEGIN
        PKERRORS.PUSH('pkSuspConnServiceMgr.AnulOrdSuspayment.GetParameters');

        
        NUORDENDESCTOT  := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE(
                                                     'CON_ORDEN_DESCONEXION_TOTAL'
                                                                  );

        
        NUORDENDESCPARC := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE(
                                                     'CON_ORDEN_DESCONEXION'
                                                                  );

        
        NUSERVCONECT := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE(
                                                     'EST_SERVICIO_SIN_CORTE'
                                                                );

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETPARAMETERS;

    PROCEDURE GETDATA
    IS
    BEGIN
        PKERRORS.PUSH('pkSuspConnServiceMgr.AnulOrdSuspayment.GetData');

        
        RCSERVNUMBER := PKTBLSERVSUSC.FRCGETRECORD( INUNUMESERV );

        
        NUDEPSERVNUMBER  := RCSERVNUMBER.SESUDEPA;

        
        NULOCSERVNUMBER  := RCSERVNUMBER.SESULOCA;

        
        NUESTCORTSERVNUM := RCSERVNUMBER.SESUESCO;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END GETDATA;

    
    FUNCTION FBLVALESTCORTORDSUSP
    RETURN BOOLEAN
    IS
        BLESTORDSUSPEN BOOLEAN := TRUE;
    BEGIN
        PKERRORS.PUSH('pkSuspConnServiceMgr.AnulOrdSuspayment.ValEstCortOrdSusp');

        IF ( ( NUESTCORTSERVNUM <> NUORDENDESCTOT )
              AND
             ( NUESTCORTSERVNUM <> NUORDENDESCPARC )
           )
        THEN
            BLESTORDSUSPEN := FALSE;

        END IF;

        RETURN BLESTORDSUSPEN;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END FBLVALESTCORTORDSUSP;


BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.AnulOrdSuspayment');

    GETPARAMETERS;
    GETDATA;
    
    
    IF ( NOT FBLVALESTCORTORDSUSP ) THEN

        PKERRORS.SETERRORCODE ( PKCONSTANTE.CSBDIVISION,
                                PKCONSTANTE.CSBMOD_BIL,
		    		            CNUER_NOT_ORDER_SUP );
	    RAISE LOGIN_DENIED;

    END IF;

    
    IF ( PKSUSPCONNSERVICEMGR.FBLEXISTORDER( NUDEPSERVNUMBER,
                                             NULOCSERVNUMBER,
                                             INUNUMESERV,
                                             CSBDESCONEXION )
       )
    THEN
        
        UPATTENDORDERSUSP( INUNUMESERV,
                           CSBDESCONEXION,
                           'A'
                          );
    END IF;
    
    PKTBLSERVSUSC.UPSUSPENSIONSTATUS( INUNUMESERV, NUSERVCONECT, NULL );

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END ANULORDSUSPAYMENT;




















PROCEDURE UPATTENDORDERSUSP
    (
        INUNUSE     	IN    	SERVSUSC.SESUNUSE%TYPE,
        INUTIPOOLD    	IN    	SUSPCONE.SUCOTIPO%TYPE,
        INUTIPONEW    	IN    	SUSPCONE.SUCOTIPO%TYPE
    )
    IS
       RWORDERSUSP  ROWID; 
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.upAttendOrderSusp');
    
    RWORDERSUSP := PKBCSUSPCONE.FNUROWIDORDER( INUNUSE, INUTIPOOLD );

    
    PKTBLSUSPCONE.UPATTENDANCEDATE( RWORDERSUSP, SYSDATE,'', INUTIPONEW );

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END UPATTENDORDERSUSP;


























PROCEDURE GETACTIVITYEXECDATA ( INUSERVICE      IN    SERVSUSC.SESUSERV%TYPE,
                              INUCOECCODI       IN    SERVSUSC.SESUESCO%TYPE,
                              ONURULEID         OUT   GE_ACT_PRODTYPE_STAT.RULE_ID%TYPE,
                              ONUORDERPROCESS   OUT   VARCHAR2
                               )
IS
    RCACTIPRDTYPESTATUS     GE_BCACT_PRODTYPE_STAT.TYRCACT_PRODTYPE_STAT;
    NUERRORCODE             GE_ERROR_LOG.ERROR_LOG_ID%TYPE;
    SBERRORMSG              GE_ERROR_LOG.DESCRIPTION%TYPE;


    PROCEDURE GETPARAMETERS
    IS
    BEGIN
        PKERRORS.PUSH ('pkSuspConnServiceMgr.ExecuteOrderWorkFunction.GetParameters');

        
        SBEXISTSOSS := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE('EXIST_OSS');

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
    	    PKERRORS.POP;
    	    RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	    
    	    PKERRORS.POP;
    	    RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
    	    PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
    	    PKERRORS.POP;
    	    RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
            
    END GETPARAMETERS;

BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.GetActivityExecData');
    GETPARAMETERS;

    
    IF(	SBEXISTSOSS <> PKCONSTANTE.SI ) THEN
        PKERRORS.POP;
        RETURN;
    END IF;

    

    GE_BOACT_PRODTYPE_STAT.GETACTIV_PRODTYPE_STA_CONF(  INUCOECCODI,
                                                        INUSERVICE,
                                                        RCACTIPRDTYPESTATUS,
                                                        NUERRORCODE,
                                                        SBERRORMSG);

    ONURULEID       := RCACTIPRDTYPESTATUS.RULE_ID;
    ONUORDERPROCESS := RCACTIPRDTYPESTATUS.ORDER_PROCESS;  

    
    IF ( NUERRORCODE <> 0 ) THEN
    
        
        UT_TRACE.TRACE('GetActivityExecData Error:'||SBERRORMSG);

        PKERRORS.SETERRORMESSAGE ( TO_CHAR ( NUERRORCODE ) || ' - ' || SBERRORMSG );
        PKERRORS.SETOBJECTNAME ( 'ge_boactiv_prodtype_status.GetACTIV_PRODTYPE_STA_CONF' ) ;

        RAISE LOGIN_DENIED;
    
    END IF ;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END GETACTIVITYEXECDATA;




















PROCEDURE SETACTIVITY
    (
        INUACTIVITY    IN  NUMBER
    )
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetActivity');

    GNUACTIVITY := INUACTIVITY ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END SETACTIVITY;




















FUNCTION FNUGETACTIVITY
RETURN NUMBER
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetActivity');

    PKERRORS.POP;
    
    RETURN GNUACTIVITY;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FNUGETACTIVITY;





















FUNCTION FNUGETORDERID
RETURN NUMBER
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetOrderId');

    PKERRORS.POP;
    
    RETURN GNUORDERID;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FNUGETORDERID;



















PROCEDURE SETORDERID
(
    INUORDERID    IN  NUMBER
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetOrderId');

    GNUORDERID := INUORDERID ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END SETORDERID;


















PROCEDURE SETORDERACTIVITY
(
    INUORDERACTIVITY    IN NUMBER
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetOrderActivity');

    GNUORDERACTIVITYID := INUORDERACTIVITY ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END SETORDERACTIVITY;


















FUNCTION FNUGETORDERACTIVITYID
RETURN NUMBER
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fnuGetOrderActivityId');

    PKERRORS.POP;
    
    RETURN GNUORDERACTIVITYID;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FNUGETORDERACTIVITYID;






















FUNCTION FBLGETEXEACTIVITYRULE
RETURN BOOLEAN
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fblGetExeActivityRule');
    PKERRORS.POP;
    
    RETURN GBLEXEACTIVITYRULE;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FBLGETEXEACTIVITYRULE;

















PROCEDURE SETORDERPROCESS
(
    ISBORDERPROCESS IN  VARCHAR2
)
IS
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.SetOrderProcess');

    GSBORDERPROCESS := ISBORDERPROCESS;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END SETORDERPROCESS;





















FUNCTION FSBGETORDERPROCESS
RETURN VARCHAR2
IS

BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.fsbGetOrderProcess');
    PKERRORS.POP;
    
    RETURN GSBORDERPROCESS;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END FSBGETORDERPROCESS;

















PROCEDURE EXECUTEADDVALRULE
    (
        INUSERVCODI	IN  SERVSUSC.SESUSERV%TYPE,
    	INUCOECCODI	IN	CONFESCO.COECCODI%TYPE
    )
IS
    RCCONFESCO          CONFESCO%ROWTYPE ;
BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.ExecuteAddValRule');

    
    RCCONFESCO := PKTBLCONFESCO.FRCGETRECORD ( INUSERVCODI, INUCOECCODI );

    
    IF ( RCCONFESCO.COECRVAD IS NOT NULL ) THEN
    
        
        PKGENERALSERVICES.EXECUTEDYNAMICPLSQL( RCCONFESCO.COECRVAD || ';' );
    
    END IF ;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED ;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END EXECUTEADDVALRULE;































PROCEDURE UPANULLORDER
    (
        INUNUSE     	IN    	SERVSUSC.SESUNUSE%TYPE,
        ISBTIPO         IN      SUSPCONE.SUCOTIPO%TYPE,
        ISBOBSERVAC     IN      VARCHAR2,
        OBLACTUALIZO    OUT     BOOLEAN
    )
    IS
       RWORDERSUSP  ROWID; 
BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.UpAnullOrder');
    
    UPDATE SUSPCONE
    SET    SUCOTIPO = 'A',
           SUCOFEAT = SYSDATE,
           SUCOOBSE = SUBSTR(SUCOOBSE||'|'||ISBOBSERVAC, 0,120)
    WHERE  SUCONUSE = INUNUSE
    AND    SUCOTIPO = ISBTIPO
    AND    SUCOORIM = PKCONSTANTE.NO
    AND    SUCOFEAT IS NULL;
    
    IF ( SQL%FOUND ) THEN
        OBLACTUALIZO := TRUE;
    ELSE
        OBLACTUALIZO := FALSE;
    END IF;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END UPANULLORDER;









































    PROCEDURE GENORDERINDIVIDUAL
    (
        INUSERVNUMBER   IN          SERVSUSC.SESUNUSE%TYPE,
        INUEVENTAPLI    IN          ESTACORT.ESCOCODI%TYPE,
        INUCAUSDESC     IN          SUSPCONE.SUCOCACD%TYPE,
        INUTYPEORDER    IN          NUMBER,
        ONUNUMORDER     OUT NOCOPY  SUSPCONE.SUCONUOR%TYPE,
        INSBTIPOORD     IN          VARCHAR2,
        ISBOBSERV       IN          SUSPCONE.SUCOOBSE%TYPE
    )
    IS

        
        RCSERVSUSC              SERVSUSC%ROWTYPE;

        
        NUNUMORDER              NUMBER;

        
        BOPROCESS               BOOLEAN := TRUE;

        
        
        BOISSPONSORPROD         BOOLEAN := FALSE;

        
        
        BOISCOVEREDPROD         BOOLEAN := FALSE;

        
        
        TBCOMMRELDETAILS        DACC_DETAIL_COM_RELA.TYTBCC_DETAIL_COM_RELA;

        
        
        RCCOMMRELDETAIL         DACC_DETAIL_COM_RELA.STYCC_DETAIL_COM_RELA;

        
        
        RCCOMMRELATIONTYPE      DACC_RELATION_TYPE.STYCC_RELATION_TYPE;

        
        
        

        PROCEDURE GETDATA
        IS
        BEGIN
        
            UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.GenOrderIndividual.GetData]', 6 );

            
            RCSERVSUSC := PKTBLSERVSUSC.FRCGETSERVICENUMBER( INUSERVNUMBER );

            
            
            RCCOMMRELDETAIL := CC_BCRELACIONCOMERCIAL.FRCOBTDETPRODAMPARADO
            (
                RCSERVSUSC.SESUNUSE,
                UT_DATE.FDTSYSDATE
            );

            IF ( RCCOMMRELDETAIL.DETAIL_COM_RELA_ID IS NOT NULL ) THEN
            
                
                
                BOISCOVEREDPROD := TRUE;
                BOISSPONSORPROD := FALSE;
            
            
            
            ELSE
            
                TBCOMMRELDETAILS := CC_BCRELACIONCOMERCIAL.FTBOBTDETPRODAMPARADOR
                (
                    RCSERVSUSC.SESUNUSE,
                    UT_DATE.FDTSYSDATE
                );

                IF ( TBCOMMRELDETAILS.COUNT > 0 ) THEN
                
                    
                    
                    BOISCOVEREDPROD := FALSE;
                    BOISSPONSORPROD := TRUE;
                
                ELSE
                
                    
                    
                    BOISCOVEREDPROD := FALSE;
                    BOISSPONSORPROD := FALSE;
                
                END IF;
            
            END IF;

            UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.GenOrderIndividual.GetData]', 6 );

        EXCEPTION

            WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
                UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenOrderIndividual.GetData]', 6 );
                RAISE;

            WHEN OTHERS THEN
                PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
                UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenOrderIndividual.GetData]', 6 );
                RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
        
        END GETDATA;

        

        PROCEDURE PROCESSCOVEREDPRODS
        IS

            
            RCCOVEREDPROD       SERVSUSC%ROWTYPE;

            
            NUCOVPRODSIDX       BINARY_INTEGER;

            
            BOPROCESSCOVERED    BOOLEAN := TRUE;

        BEGIN
        
            UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.GenOrderIndividual.ProcessCoveredProds]', 6 );

            
            IF ( BOISSPONSORPROD ) THEN
            
                UT_TRACE.TRACE( 'El producto es amparador en una relaci�n comercial, se genera orden para productos amparados', 7 );

                
                NUCOVPRODSIDX := TBCOMMRELDETAILS.FIRST;

                LOOP
                
                    
                    EXIT WHEN NUCOVPRODSIDX IS NULL;

                    
                    
                    RCCOMMRELATIONTYPE := CC_BORELACIONCOMERCIAL.FRCOBTTIPORELCOMERCIAL( TBCOMMRELDETAILS( NUCOVPRODSIDX ).COMM_RELATION_ID );

                    UT_TRACE.TRACE( 'Producto amparado [' || TO_CHAR( TBCOMMRELDETAILS( NUCOVPRODSIDX ).CV_PRODUCT_ID ) || ']', 8 );

                    
                    
                    
                    CASE INSBTIPOORD
                    
                        WHEN PKSUSPCONNSERVICE.CSBDESCONEXION THEN
                            
                            
                            
                            UT_TRACE.TRACE( 'Flag de suspensi�n de producto amparado al suspender producto amparador [' || RCCOMMRELATIONTYPE.SPONSOR_SUSP_COVERED || ']', 8 );
                            BOPROCESSCOVERED := ( RCCOMMRELATIONTYPE.SPONSOR_SUSP_COVERED = CC_BOCONSTANTS.CSBSI );

                        WHEN PKSUSPCONNSERVICE.CSBRETIRO THEN
                            
                            
                            
                            UT_TRACE.TRACE( 'Flag de retiro de producto amparado al retirar producto amparador [' || RCCOMMRELATIONTYPE.SPONSOR_RETI_COVERED || ']', 8 );
                            BOPROCESSCOVERED := ( RCCOMMRELATIONTYPE.SPONSOR_RETI_COVERED = CC_BOCONSTANTS.CSBSI );

                        WHEN PKSUSPCONNSERVICE.CSBCONEXION THEN
                            
                            
                            
                            UT_TRACE.TRACE( 'Flag de reconexi�n de producto amparado al reconectar producto amparador [' || RCCOMMRELATIONTYPE.SPONSOR_CONN_COVERED || ']', 8 );
                            BOPROCESSCOVERED := ( RCCOMMRELATIONTYPE.SPONSOR_CONN_COVERED = CC_BOCONSTANTS.CSBSI );

                        ELSE
                            BOPROCESSCOVERED := TRUE;
                    
                    END CASE;

                    
                    IF ( BOPROCESSCOVERED ) THEN
                    
                        
                        RCCOVEREDPROD := PKTBLSERVSUSC.FRCGETRECORD
                        (
                            TBCOMMRELDETAILS( NUCOVPRODSIDX ).CV_PRODUCT_ID
                        );

                        
                        IF ( ( RCCOVEREDPROD.SESUESCO <> GNUESTCORTEINACTIVO AND INSBTIPOORD <> CSBCONEXION ) AND
                             NVL( RCCOVEREDPROD.SESUROGA, PKCONSTANTE.NULLSB ) <> PKWARRANTYMGR.CSBPROPIETARIO AND
                             NOT PKSUSPCONNSERVICE.FBOHASPENDVOLWITHDRAW( RCCOVEREDPROD.SESUNUSE ) AND
                             NOT PKSUSPCONNSERVICEMGR.FBLEXISTORDER( RCCOVEREDPROD.SESUDEPA,
                                                                     RCCOVEREDPROD.SESULOCA,
                                                                     RCCOVEREDPROD.SESUNUSE,
                                                                     INSBTIPOORD )
                        ) THEN
                        
                            
                            CREATEORDERSUSPCONE
                            (
                                RCCOVEREDPROD.SESUNUSE,
                                INUEVENTAPLI,
                                INUCAUSDESC,
                                NUNUMORDER,
                                INSBTIPOORD,
                                ISBOBSERV
                            );

                            
                            EXECUTEORDERWORKFUNCTION
                            (
                                NUNUMORDER,
                                INUEVENTAPLI,
                                RCCOVEREDPROD,
                                INUTYPEORDER
                            );
                        
                        END IF;
                    
                    END IF;

                    
                    NUCOVPRODSIDX := TBCOMMRELDETAILS.NEXT( NUCOVPRODSIDX );
                
                END LOOP;
            
            END IF;

            UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.GenOrderIndividual.ProcessCoveredProds]', 6 );

        EXCEPTION

            WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
                UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenOrderIndividual.ProcessCoveredProds]', 6 );
                RAISE;

            WHEN OTHERS THEN
                PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
                UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenOrderIndividual.GenOrderForCoveredProds]', 6 );
                RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
        
        END;

    BEGIN
    
        UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.GenOrderIndividual]', 5 );

        
        GETDATA;

        
        IF ( BOISCOVEREDPROD ) THEN
        
            UT_TRACE.TRACE( 'El producto se encuentra amparado en una relaci�n comercial', 6 );
            
            
            RCCOMMRELATIONTYPE := CC_BORELACIONCOMERCIAL.FRCOBTTIPORELCOMERCIAL( RCCOMMRELDETAIL.COMM_RELATION_ID );

            
            
            CASE INSBTIPOORD
            
                WHEN PKSUSPCONNSERVICE.CSBDESCONEXION THEN
                    
                    
                    BOPROCESS := ( RCCOMMRELATIONTYPE.INDIV_COVERED_SUSP = CC_BOCONSTANTS.CSBSI );

                WHEN PKSUSPCONNSERVICE.CSBRETIRO THEN
                    
                    
                    BOPROCESS := ( RCCOMMRELATIONTYPE.INDIV_COVERED_RETIRE = CC_BOCONSTANTS.CSBSI );

                WHEN PKSUSPCONNSERVICE.CSBCONEXION THEN
                    
                    
                    
                    BOPROCESS := ( RCCOMMRELATIONTYPE.INDIV_COVERED_CONN = CC_BOCONSTANTS.CSBSI ) AND
                                 PR_BOSUSPCORTERECONEXION.FBOESVALIDOPARACONEXION( RCSERVSUSC.SESUNUSE );

                ELSE
                    BOPROCESS := TRUE;
            
            END CASE;
        
        END IF;

        
        IF ( BOPROCESS ) THEN
        
            
            CREATEORDERSUSPCONE
            (
                INUSERVNUMBER,
                INUEVENTAPLI,
                INUCAUSDESC,
                NUNUMORDER,
                INSBTIPOORD,
                ISBOBSERV
            );

            
            EXECUTEORDERWORKFUNCTION
            (
                NUNUMORDER,
                INUEVENTAPLI,
                RCSERVSUSC,
                INUTYPEORDER
            );

            
            IF ( PKSUSPCONNSERVICEMGR.FBLGETEXEACTIVITYRULE ) THEN
            
                
                NUNUMORDER := PKSUSPCONNSERVICEMGR.FNUGETORDERID;
            
            END IF;

            ONUNUMORDER := NUNUMORDER;

            
            PROCESSCOVEREDPRODS;
        
        END IF;

        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.GenOrderIndividual]', 5 );

    EXCEPTION

        WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenOrderIndividual]', 5 );
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.GenOrderIndividual]', 5 );
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END;
























PROCEDURE GETGENERALPARAMETR
IS

BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.GetGeneralParametr');
    
    NUORDESCONEXIONTOTAL  := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE(
                                                 'CON_ORDEN_DESCONEXION_TOTAL');

    
    NUORDESCONEXIONPARCIAL := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE(
                                                 'CON_ORDEN_DESCONEXION');
    
    NUORCONEXION := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE(
                                                 'CON_ORDEN_DE_CONEXION');

    
    NUORRETIRO := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE('TELEF_RETIRO');
    
    
    NUESCO_ORDEN_REVISION := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE('ESCO_ORDEN_REVISION');

    
    NUESCO_SUSP_TOTAL := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE('ESCO_SUSP_TOTAL');
    
    
    GNUESTCORTEINACTIVO := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE
	                                   					('ESTACORT_INACTIVE');

    
    GNUDIAS_ADICION_FECHA_SUSP := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE
                                                ( 'DIAS_ADICION_FECHA_SUSP' ) ;


    
    PKGENERALSERVICES.VALVALUEEQUALGREATERZERO( GNUDIAS_ADICION_FECHA_SUSP ) ;

    
    GNULIMITE_DE_USO := PKGENERALPARAMETERSMGR.FNUGETNUMBERVALUE(
                            'LIMITE_DE_USO'
                            ) ;
    
    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED ;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END GETGENERALPARAMETR;


















FUNCTION FSBGETTYPEBYSTATUS (INUESTACORT IN ESTACORT.ESCOCODI%TYPE)
RETURN VARCHAR2
IS
  SBTIPO VARCHAR2(1) := NULL;
BEGIN
    PKERRORS.PUSH('pkSuspConnServiceMgr.fsbGetTypeByStatus');

    IF (INUESTACORT IN (NUORDESCONEXIONTOTAL,NUORDESCONEXIONPARCIAL)) THEN
       SBTIPO := CSBDESCONEXION;
    ELSIF (INUESTACORT = NUORCONEXION) THEN
        SBTIPO := CSBCONEXION;
    ELSIF (INUESTACORT = NUORRETIRO) THEN
        SBTIPO := CSBRETIRO;
    END IF;
    
    PKERRORS.POP;
    RETURN SBTIPO;
    
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED ;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END FSBGETTYPEBYSTATUS;

    





















    PROCEDURE UPDISCHARGEDFLAG
    (
        INUPRODUCT     IN SERVSUSC.SESUNUSE%TYPE
    ) IS
        
        NUINDEX              NUMBER := NULL;

        
        RCDEPENDINGPRODUCTS PKBCDEPENDINGPRODUCT.TYRCDEPENDINGPRODUCTS := NULL;

        
        DTSYSDATE            DATE   := NULL;

    BEGIN

        PKERRORS.PUSH ('pkSuspConnServiceMgr.UpDischargedflag');

        
        PKTBLSERVSUSC.UPDISCHARGEDFLAG ( INUPRODUCT, PKCONSTANTE.NO );

        
        
        PKBCDEPENDINGPRODUCT.GETDEPENDINGPRODUCTS ( INUPRODUCT,
                                                    NULL,
                                                    RCDEPENDINGPRODUCTS );

        
        DTSYSDATE := PKGENERALSERVICES.FDTGETSYSTEMDATE();

        
        NUINDEX := RCDEPENDINGPRODUCTS.TBSESUNUSE.FIRST;

        LOOP

            
            EXIT WHEN NUINDEX IS NULL;

            
            IF ( NVL ( RCDEPENDINGPRODUCTS.TBSESUFERE (NUINDEX), DTSYSDATE ) >=
                 DTSYSDATE ) THEN

                
                PKTBLSERVSUSC.UPDISCHARGEDFLAG
                (
                    RCDEPENDINGPRODUCTS.TBSESUNUSE(NUINDEX),
                    PKCONSTANTE.NO
                );

            END IF;

            
            NUINDEX := RCDEPENDINGPRODUCTS.TBSESUNUSE.NEXT ( NUINDEX );

        END LOOP;

        PKERRORS.POP;

    EXCEPTION

        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;

        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    END UPDISCHARGEDFLAG;
    
    



































    PROCEDURE ATTENINDIVREINSTALL
    (
        INUSESUNUSE     IN      SERVSUSC.SESUNUSE%TYPE,
        ISBROWIDSUS     IN      ROWID,
        IDTFECHATEN     IN      SERVSUSC.SESUFECO%TYPE,
        IDTSESUFECO     IN      SERVSUSC.SESUFECO%TYPE,
        IRCCONFESCO     IN      CONFESCO%ROWTYPE,
        INUCICLO        IN      SUSCRIPC.SUSCCICL%TYPE DEFAULT NULL
    )
    IS
        DTPROCESSDATE   DATE;
    BEGIN
        PKERRORS.PUSH('pkSuspConnServiceMgr.AttenIndivReinstall');

    	PKGENERALSERVICES.TRACEDATA('Sesunuse :'||INUSESUNUSE);
    	PKGENERALSERVICES.TRACEDATA('IDSusp   :'||ISBROWIDSUS);
    	PKGENERALSERVICES.TRACEDATA('idtfechaten :'||IDTFECHATEN);
    	PKGENERALSERVICES.TRACEDATA('idtsesufeco	:'||IDTSESUFECO);
    	PKGENERALSERVICES.TRACEDATA('ircConfesco.coeccodi :'||IRCCONFESCO.COECCODI);
    	PKGENERALSERVICES.TRACEDATA('inuCiclo   :'||INUCICLO);

        
        DTPROCESSDATE := NVL(IDTFECHATEN,SYSDATE);

        
        PKSUSPCONNSERVICEMGR.VALIDSUSPENSIONDAYS
        (
           INUSESUNUSE,
    	   IRCCONFESCO.COECDICO,
           IDTSESUFECO
        );

        
        RCSERVSUSC := PKTBLSERVSUSC.FRCGETRECORD (  INUSESUNUSE,
                                                    PKCONSTANTE.NOCACHE );


        
        PKTBLSUSPCONE.UPATTENDANCEDATE ( ISBROWIDSUS, DTPROCESSDATE,  NULL );

        
        IF (PKSUSPCONNSERVICEMGR.FBLHASORDER ( INUSESUNUSE, CSBDESCONEXION)) THEN

	        
	       PKERRORS.SETERRORCODE ( PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_BIL,
		  				            CNUERROR_HAS_ORDER );
	                               RAISE LOGIN_DENIED ;
	    END IF;

        
        PKSUSPCONNSERVICEMGR.APPLYCHARGE ( RCSERVSUSC, IRCCONFESCO, INUCICLO );


        
        RCSERVSUSC.SESUFECO := NULL;
        RCSERVSUSC.SESUESCO := IRCCONFESCO.COECCODI;
        
        RCSERVSUSC.SESUFEIN := DTPROCESSDATE;
        RCSERVSUSC.SESUFERE := PKGENERALSERVICES.FDTGETMAXDATE;
        PKTBLSERVSUSC.UPRECORD(RCSERVSUSC);


        PKERRORS.POP;
    EXCEPTION
        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END ATTENINDIVREINSTALL;
    






























PROCEDURE CONEXDESCONEX_LC
(
    INUPRODUCTO     IN  SERVSUSC.SESUNUSE%TYPE,
	INUTIPOORDEN    IN  GE_SUSPENSION_TYPE.SUSPENSION_TYPE_ID%TYPE,
	INUTIPOORDENBSS IN  SUSPCONE.SUCOORDTYPE%TYPE,
	INUACTIVIDAD    IN  GE_ITEMS.ITEMS_ID%TYPE,
    INUORDEN        IN  SUSPCONE.SUCOIDSC%TYPE,
    ISBPROCESO      IN  SUSPCONE.SUCOTIPO%TYPE
)
IS
    RCSERVSUSC      SERVSUSC%ROWTYPE;
    RCDATOSMEMORIA  PKSUSPCONNSERVICE.TYMEMORYVAR;

BEGIN

    PKERRORS.PUSH('pkSuspConnServiceMgr.ConexDesconex_LC');

    GNUIDSUSPCONE := INUORDEN;
    PKSUSPCONNSERVICEMGR.SETACTIVITY(INUACTIVIDAD);
    RCDATOSMEMORIA.NUNUMESERV := INUPRODUCTO;
    GNUORDERTYPE := INUTIPOORDENBSS;

    PKSUSPCONNSERVICE.SETINSTANCEDATA(RCDATOSMEMORIA);

    
    IF ISBPROCESO = CSBDESCONEXION THEN

        SM_BOSERVICEMEDIATION.REGISTERPRODUCTSUSPCONN(FALSE,INUTIPOORDEN);

    ELSE

        SM_BOSERVICEMEDIATION.REGISTERPRODUCTSUSPCONN(TRUE,INUTIPOORDEN);

    END IF;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END CONEXDESCONEX_LC;





































FUNCTION FBLPRODAPLICAPARACORTE
(
    INUSERVSUSC     IN      SERVSUSC.SESUNUSE%TYPE,
    INUEVENAPLI     IN      ESTACORT.ESCOCODI%TYPE
) RETURN BOOLEAN
IS

    DTDIASADIC      DATE;                       
    NUDIASADIC      NUMBER;                     

    NUVALORRECLAMO  PKBCSERVSUSC.STYSESUVARE;   
    NURECLPAGNOABO	PKBCSERVSUSC.STYSESUVRAP;   
    NUDIASCORT      CONFESCO.COECDICO%TYPE;     
    NUCUENSALD		CONFCOSE.COCSNCDX%TYPE;     
    NUCUENSALDSERV  PKBCSERVSUSC.STYSESUCUSA;   

    RCSERVSUSC      SERVSUSC%ROWTYPE;           
    RCCONFESCO      CONFESCO%ROWTYPE;           
    RCCONFCOSE      CONFCOSE%ROWTYPE;           
    RCTIPOCLIE      DAGE_SUBSCRIBER_TYPE.STYGE_SUBSCRIBER_TYPE; 
    
    
    
    BOISSPONSORPROD             BOOLEAN := FALSE;

    
    
    BOISCOVEREDPROD             BOOLEAN := FALSE;

    
    
    TBCOMMRELDETAILS            DACC_DETAIL_COM_RELA.TYTBCC_DETAIL_COM_RELA;

    
    
    RCCOMMRELDETAIL             DACC_DETAIL_COM_RELA.STYCC_DETAIL_COM_RELA;

    
    
    RCCOMMRELATIONTYPE          DACC_RELATION_TYPE.STYCC_RELATION_TYPE;

    
    
    

    

























    PROCEDURE GETDATA
    IS
    
        NUCUSTTYPE      GE_SUBSCRIBER.SUBSCRIBER_TYPE_ID%TYPE;
        RCSUSCRIPC      SUSCRIPC%ROWTYPE;
        
    BEGIN
    
        UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.fblProdAplicaParaCorte.GetData]', 6 );

        
        RCSERVSUSC := PKTBLSERVSUSC.FRCGETRECORD( INUSERVSUSC );
        
        
        
        RCCOMMRELDETAIL := CC_BCRELACIONCOMERCIAL.FRCOBTDETPRODAMPARADO
        (
            RCSERVSUSC.SESUNUSE,
            UT_DATE.FDTSYSDATE
        );

        IF ( RCCOMMRELDETAIL.DETAIL_COM_RELA_ID IS NOT NULL ) THEN
        
            
            
            BOISCOVEREDPROD := TRUE;
            BOISSPONSORPROD := FALSE;
        
        
        
        ELSE
        
            TBCOMMRELDETAILS := CC_BCRELACIONCOMERCIAL.FTBOBTDETPRODAMPARADOR
            (
                RCSERVSUSC.SESUNUSE,
                UT_DATE.FDTSYSDATE
            );

            IF ( TBCOMMRELDETAILS.COUNT > 0 ) THEN
            
                
                
                BOISCOVEREDPROD := FALSE;
                BOISSPONSORPROD := TRUE;
            
            ELSE
            
                
                
                BOISCOVEREDPROD := FALSE;
                BOISSPONSORPROD := FALSE;
            
            END IF;
        
        END IF;
        
        
        RCSUSCRIPC := PKTBLSUSCRIPC.FRCGETRECORD( RCSERVSUSC.SESUSUSC );

        
        RCCONFESCO := PKSUSPCONNSERVICEMGR.FRCGETCONFESCO
        (
            RCSERVSUSC.SESUSERV,
            INUEVENAPLI
        );

        
        NUDIASCORT := RCCONFESCO.COECDICO;

        
        NUCUSTTYPE := DAGE_SUBSCRIBER.FNUGETSUBSCRIBER_TYPE_ID( RCSUSCRIPC.SUSCCLIE );

        
        RCTIPOCLIE := DAGE_SUBSCRIBER_TYPE.FRCGETRECORD( NUCUSTTYPE );

        
        PKSUSPCONNSERVICE.GETSTATUSCONFDATA
        (
            NUCUSTTYPE,
            RCSERVSUSC.SESUPLFA,
            RCSERVSUSC.SESUSERV,
            RCSERVSUSC.SESUNUSE,
            RCCONFCOSE,
            TRUE
        );

        NUCUENSALD := RCCONFCOSE.COCSNCDX;

    	
    	DTDIASADIC := PKHOLIDAYMGR.FDTGETDATENONHOLIDAY( SYSDATE, GNUDIAS_ADICION_FECHA_SUSP );

        NUDIASADIC := TO_NUMBER( TRUNC( DTDIASADIC ) - TRUNC( SYSDATE ) );

        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte.GetData]', 6 );

    EXCEPTION

        WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.fblProdAplicaParaCorte.GetData]', 6 );
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.fblProdAplicaParaCorte.GetData]', 6 );
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END;

BEGIN

    UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );

    
    GETDATA;

    
    IF ( BOISCOVEREDPROD ) THEN
    
        UT_TRACE.TRACE( 'El producto se encuentra amparado en una relaci�n comercial', 6 );
        
        
        RCCOMMRELATIONTYPE := CC_BORELACIONCOMERCIAL.FRCOBTTIPORELCOMERCIAL( RCCOMMRELDETAIL.COMM_RELATION_ID );

        
        
        IF ( RCCOMMRELATIONTYPE.INDIV_COVERED_SUSP = CC_BOCONSTANTS.CSBNO ) THEN
        
            UT_TRACE.TRACE( 'Relaci�n comercial no permite suspensi�n individual de productos amparados, no genera orden', 6 );
            UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
            RETURN FALSE;
        
        END IF;
    
    END IF;

    
    IF ( RCSERVSUSC.SESUESCO = GNUESTCORTEINACTIVO ) THEN
    
        UT_TRACE.TRACE( 'Producto tiene estado de corte inactivo, no genera orden [' || GNUESTCORTEINACTIVO || ']', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
    END IF;

    
    IF ( PKSUSPCONNSERVICEMGR.FBLEXISTORDER( RCSERVSUSC.SESUDEPA,
                                             RCSERVSUSC.SESULOCA,
                                             RCSERVSUSC.SESUNUSE,
                                             PKSUSPCONNSERVICE.CSBDESCONEXION )
    ) THEN
    
        UT_TRACE.TRACE( 'El producto tiene una orden de desconexi�n pendiente de atender, no genera orden', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
    END IF;

    
    IF ( PKSUSPCONNSERVICE.FBOHASPENDVOLWITHDRAW( RCSERVSUSC.SESUNUSE ) ) THEN
    
        UT_TRACE.TRACE( 'Producto tiene solicitud de retiro voluntario pendiente, no genera orden', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
    END IF;

	
    IF ( NVL( INSTR( RCSERVSUSC.SESUINCL, '|' || INUEVENAPLI || '|' ), 0 ) > 0 ) THEN
	
	    UT_TRACE.TRACE( 'Producto tiene inclusion, genera orden [' || RCSERVSUSC.SESUINCL || ']', 6 );
	    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
	    RETURN TRUE;
	
	END IF;


    
	IF  ( NVL( PKBCCUENCOBR.FNUGETOUTSTANDBAL( RCSERVSUSC.SESUNUSE ), 0 ) -
          ( NVL( PKBCCUENCOBR.FNUGETCLAIMVALUE( RCSERVSUSC.SESUNUSE ), 0 )  +
            NVL( PKBCCUENCOBR.FNUGETNONAPPLIEDPAY( RCSERVSUSC.SESUNUSE ), 0 )
          ) <= 0
    ) THEN
	
        UT_TRACE.TRACE( 'Producto tiene valor en reclamo mayor o igual al saldo saldo pendiente, no genera orden', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
	
	END IF;

    
    PKBCDEPENDINGPRODUCT.GETDEPENDINGPRODUCTSCLAIMVALUE
    (
        RCSERVSUSC.SESUNUSE,
        NUVALORRECLAMO,
        NURECLPAGNOABO
    );

    
	IF ( NVL( PKBCCUENCOBR.FNUGETOUTSTANDBAL( RCSERVSUSC.SESUNUSE ), 0 ) -
         ( NUVALORRECLAMO + NURECLPAGNOABO ) <= 0
       )
    THEN
	
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
	
	END IF;


    
    IF ( NVL( INSTR( RCSERVSUSC.SESUEXCL, '|' || INUEVENAPLI || '|' ), 0 ) > 0 ) THEN
	
        UT_TRACE.TRACE( 'Producto tiene exclusi�n, no genera orden [' || RCSERVSUSC.SESUEXCL || ']', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
	
	END IF;

	
    IF ( RCSERVSUSC.SESUROGA = PKWARRANTYMGR.CSBPROPIETARIO ) THEN
    
        UT_TRACE.TRACE( 'Producto es propietario, no genera orden ', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
	END IF;
	
	
    NUCUENSALDSERV := PKBOEXPIREDACCOUNTS.FNUPERIODSWITHEXPACCOUNTS( RCSERVSUSC.SESUNUSE );

    UT_TRACE.TRACE( 'Valida el n�mero de per�odos vencidos del producto, Per�odos vencidos producto ['
                   || NUCUENSALDSERV || '] -> Per�odos vencidos para suspensi�n [' || NUCUENSALD || ']', 6 );

    
    IF ( NUCUENSALDSERV < NUCUENSALD ) THEN
    
        UT_TRACE.TRACE( 'N�mero de per�odos vencidos del producto es menor al n�mero de per�odos para suspensi�n, no genera orden', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
    END IF;

    
    IF ( RCTIPOCLIE.VALID_FOR_DISCONNECT NOT IN ( PKCONSTANTE.SI, PKSUSPCONNSERVICE.CSBDESCONEXION ) ) THEN
    
        UT_TRACE.TRACE( 'Tipo de cliente no es v�lido para suspensi�n, no genera orden', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
    END IF;

    
    IF ( PKSUSPENTERMSFORBILLMGR.FNUHASTERMFORSUSP( RCSERVSUSC.SESUSUSC,
                                                    RCSERVSUSC.SESUNUSE ) = CNUTIENE
    ) THEN
    
        UT_TRACE.TRACE( 'Producto tiene plazo vigente para suspensi�n, no genera orden', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
    END IF;

    
    IF ( GNULIMITE_DE_USO >= PKBCCUENCOBR.FNUGETOUTSTANDBAL( RCSERVSUSC.SESUNUSE ) ) THEN
    
        UT_TRACE.TRACE( 'Saldo pendiente del producto es menor o igual al l�mite de uso para suspensi�n, no genera orden', 6 );
        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
        RETURN FALSE;
    
    END IF;

    
    IF ( NVL( INSTR( RCSERVSUSC.SESUINCL, '|' || INUEVENAPLI || '|' ), 0 ) = CNUNOTIENE ) THEN
    
        
        
        IF ( NOT PKSUSPCONNSERVICEMGR.FBLVALSUSPENSIONDAYS( RCSERVSUSC.SESUNUSE,
                                                            NUDIASCORT,
                                                            RCSERVSUSC.SESUFECO,
                                                            NUCUENSALD )
        ) THEN
        
            UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
            RETURN FALSE;
        
        END IF;
    
    END IF;

    UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
    RETURN TRUE;
    
EXCEPTION

    WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
    	RAISE;

    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.fblProdAplicaParaCorte]', 5 );
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END;

























    PROCEDURE CHANGETOPREVSUSPSTATUS
    (
        INUPRODUCT      IN      SERVSUSC.SESUNUSE%TYPE,
        INUACTIVITY     IN      OR_ORDER_ACTIVITY.ORDER_ACTIVITY_ID%TYPE,
        ISBCOMMENT      IN      SUSPCONE.SUCOOBSE%TYPE DEFAULT NULL
    )
    IS

        
        RCPRODUCT       SERVSUSC%ROWTYPE;

        
        RCHICAESCO      HICAESCO%ROWTYPE;

        
        NUORDERID       SUSPCONE.SUCOIDSC%TYPE;

        
        SBORDERTYPE     SUSPCONE.SUCOTIPO%TYPE;

        
        RCSUSPCONE      SUSPCONE%ROWTYPE;

    BEGIN

        PKERRORS.PUSH( 'pkSuspConnServiceMgr.ChangeToPrevSuspStatus' );
        UT_TRACE.TRACE( 'INICIO - pkSuspConnServiceMgr.ChangeToPrevSuspStatus',25);

        PKGENERALSERVICES.TRACEDATA( 'Producto  [' || INUPRODUCT || ']' );
        UT_TRACE.TRACE( 'Producto  [' || INUPRODUCT || ']',25);
        PKGENERALSERVICES.TRACEDATA( 'Actividad [' || INUACTIVITY || ']' );
        UT_TRACE.TRACE( 'Actividad [' || INUACTIVITY || ']',25);

        
        RCPRODUCT := PKTBLSERVSUSC.FRCGETRECORD( INUPRODUCT );

        
        
        RCHICAESCO := PKBCHICAESCO.FRCGETLASTCHANGEOFSTATUSLOG( RCPRODUCT );
        
        IF ( RCHICAESCO.HCECECAN IS NULL ) THEN
            
            PKERRORS.SETERRORCODE
            (
                PKCONSTANTE.CSBDIVISION,
                PKCONSTANTE.CSBMOD_BIL,
                10987
            );
            RAISE LOGIN_DENIED;
        END IF;

        PKGENERALSERVICES.TRACEDATA( 'Estado de corte actual   [' || RCHICAESCO.HCECECAC || ']' );
        UT_TRACE.TRACE( 'Estado de corte actual   [' || RCHICAESCO.HCECECAC || ']',25);
        PKGENERALSERVICES.TRACEDATA( 'Estado de corte anterior [' || RCHICAESCO.HCECECAN || ']' );
        UT_TRACE.TRACE( 'Estado de corte actual   [' || RCHICAESCO.HCECECAN || ']',25);

        
        
        PKBCSUSPCONE.GETFIELDSUSPCNEBYACTIV
        (
            INUACTIVITY,
            NUORDERID,
            SBORDERTYPE
        );

        PKGENERALSERVICES.TRACEDATA( 'Orden en SUSPCONE [' || NUORDERID || '] Tipo [' || SBORDERTYPE || ']' );

        
        IF ( NUORDERID IS NOT NULL ) THEN
        
            
            
            RCSUSPCONE := PKTBLSUSPCONE.FRCGETRECORD( NUORDERID );

            
            RCSUSPCONE.SUCOTIPO := 'A';
            RCSUSPCONE.SUCOFEAT := SYSDATE;
            RCSUSPCONE.SUCOOBSE := NVL( ISBCOMMENT, RCSUSPCONE.SUCOOBSE );

            PKTBLSUSPCONE.UPRECORD( RCSUSPCONE );
        
        END IF;

        
        PKTBLSERVSUSC.UPSUSPENSIONSTATUS
        (
            INUPRODUCT,
            RCHICAESCO.HCECECAN,
            RCHICAESCO.HCECFECH
        );
        
        UT_TRACE.TRACE( 'FIN - pkSuspConnServiceMgr.ChangeToPrevSuspStatus',25);

    EXCEPTION

        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

    END CHANGETOPREVSUSPSTATUS;

    
    

























    PROCEDURE GETCONTRACTS
    (
        INUREQSTATE     IN  ESTACORT.ESCOCODI%TYPE,
        INUCYCLE        IN  CICLO.CICLCODI%TYPE,
        INUPRODUCT      IN  SERVSUSC.SESUNUSE%TYPE,
        INUMINCONTRACT  IN  SUSCRIPC.SUSCCODI%TYPE,
        INUAPPLYEVENT   IN  ESTACORT.ESCOCODI%TYPE,
    	INUTOTALTHREADS IN  NUMBER,
    	INUTHREAD       IN  NUMBER,
    	INUBULKNUM      IN  NUMBER,
        OTBCONTRACTS    OUT NOCOPY TYTBSUBSSERVICES
    )
    IS
        
        
        
        CUSUBSCRIP  CONSTANTS.TYREFCURSOR;
    BEGIN

        UT_TRACE.TRACE( 'pkSuspConnServiceMgr.GetContracts', 15 );

        
        IF ( INUPRODUCT = PKCONSTANTE.NULLNUM AND INUCYCLE = PKCONSTANTE.NULLNUM )
        THEN

            OPEN CUSUBSCRIP FOR
            SELECT  SUSCCODI, SUSCCLIE, SUSCCICL
            FROM    SUSCRIPC    --+ pkSuspConnServiceMgr.GetContracts (1)
            WHERE   SUSCCODI > INUMINCONTRACT
            AND     SUSCCODI IN
            (   SELECT  /*+ index(servsusc IX_SERVSUSC02) index(recaesco pk_recaesco)*/
                        SESUSUSC
                FROM    SERVSUSC, RECAESCO
                WHERE   SESUSERV = RCECSERV
                AND     SESUESCO = RCECCOER
                AND     SESUESCO = INUREQSTATE
                AND     RCECCOEC = INUAPPLYEVENT
                AND     RCECCOER = INUREQSTATE
            )
            AND     MOD( SUSCCODI, INUTOTALTHREADS ) + 1 = INUTHREAD
            ORDER BY SUSCCODI;

        
        ELSIF ( INUCYCLE = PKCONSTANTE.NULLNUM ) THEN

            OPEN CUSUBSCRIP FOR
            SELECT  SUSCCODI, SUSCCLIE, SUSCCICL
            FROM    SUSCRIPC    --+ pkSuspConnServiceMgr.GetContracts (2)
            WHERE   SUSCCODI > INUMINCONTRACT
            AND     SUSCCODI IN
            (   SELECT  /*+ index(servsusc pk_servsusc) index(recaesco pk_recaesco)*/
                        SESUSUSC
                FROM    SERVSUSC, RECAESCO
                WHERE   SESUSERV = RCECSERV
                AND     SESUESCO = RCECCOER
                AND     SESUNUSE = INUPRODUCT
                AND     SESUESCO = INUREQSTATE
                AND     RCECCOEC = INUAPPLYEVENT
                AND     RCECCOER = INUREQSTATE
            )
            AND     MOD( SUSCCODI, INUTOTALTHREADS ) + 1 = INUTHREAD
            ORDER BY SUSCCODI;

        
        ELSIF ( INUPRODUCT = PKCONSTANTE.NULLNUM ) THEN

            OPEN CUSUBSCRIP FOR
            SELECT  /*+ ordered use_nl(suscripc servsusc) index(suscripc IX_SUSCRIPC02)*/
                    DISTINCT SUSCCODI, SUSCCLIE, SUSCCICL
            FROM    SUSCRIPC, SERVSUSC, RECAESCO   --+ pkSuspConnServiceMgr.GetContracts (3)
            WHERE   SUSCCODI = SESUSUSC
            AND     SESUSERV = RCECSERV
            AND     SESUESCO = RCECCOER
            AND     SUSCCICL = INUCYCLE
            AND     SUSCCODI > INUMINCONTRACT
            AND     SESUESCO = INUREQSTATE
            AND     RCECCOEC = INUAPPLYEVENT
            AND     RCECCOER = INUREQSTATE
            AND     MOD( SUSCCODI, INUTOTALTHREADS ) + 1 = INUTHREAD
            ORDER BY SUSCCODI;

        
        ELSE

            OPEN CUSUBSCRIP FOR
            SELECT  SUSCCODI, SUSCCLIE, SUSCCICL
            FROM    SUSCRIPC    --+ pkSuspConnServiceMgr.GetContracts (4)
            WHERE   SUSCCODI > INUMINCONTRACT
            AND     SUSCCODI IN
            (   SELECT  SESUSUSC
                FROM    SERVSUSC, RECAESCO
                WHERE   SESUSERV = RCECSERV
                AND     SESUESCO = RCECCOER
                AND     SESUESCO = INUREQSTATE
                AND     SESUNUSE = INUPRODUCT
                AND     RCECCOEC = INUAPPLYEVENT
                AND     RCECCOER = INUREQSTATE
            )
            AND     SUSCCICL + 0 = INUCYCLE
            AND     MOD( SUSCCODI, INUTOTALTHREADS ) + 1 = INUTHREAD
            ORDER BY SUSCCODI;

        END IF;

        FETCH CUSUBSCRIP BULK COLLECT INTO OTBCONTRACTS.TBSUSCCODI,
                                           OTBCONTRACTS.TBSUSCCLIE,
                                           OTBCONTRACTS.TBCYCLES

        LIMIT INUBULKNUM;
        CLOSE CUSUBSCRIP;

        UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.GetContracts', 15 );

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END GETCONTRACTS;
    

    






















    
    PROCEDURE EXECFUNCBYCONTRACT
    (
        INUCONTRACT     IN  SERVSUSC.SESUSERV%TYPE,
        INUSTATETOAPPLY IN  CONFESCO.COECCODI%TYPE,
        INUREQSTATE     IN  RECAESCO.RCECCOER%TYPE
    )
    IS
        
        
        
        RCRECAESCO          RECAESCO%ROWTYPE;
        
        
        
        CURSOR CUPRODTYPE IS
            SELECT  DISTINCT SESUSERV
            FROM    SERVSUSC
            WHERE   SESUESCO = INUREQSTATE
            AND     SESUSUSC = INUCONTRACT
            AND     EXISTS
            (   SELECT  'x'
                FROM    RECAESCO
                WHERE   SESUSERV = RCECSERV
                AND     SESUESCO = RCECCOER
                AND     RCECCOEC = INUSTATETOAPPLY
            );

    BEGIN
    
        PKERRORS.PUSH( 'pkSuspConnServiceMgr.ExecFuncByContract' );

        FOR RCPRODTYPE IN CUPRODTYPE LOOP
        
            
            RCRECAESCO := PKTBLRECAESCO.FRCGETRECORD
            (
                RCPRODTYPE.SESUSERV,
                INUSTATETOAPPLY,
                INUREQSTATE
            );

            
            IF ( RCRECAESCO.RCECFUFA IS NOT NULL ) THEN
            
                
                PKGENERALSERVICES.EXECUTEDYNAMICPLSQL( RCRECAESCO.RCECFUFA || ';' );
            
            END IF;
        
        END LOOP;

        PKERRORS.POP;

    EXCEPTION

        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
        	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG );
    
    END EXECFUNCBYCONTRACT;


    






















    PROCEDURE ENABLEEXEACTIVITYRULE
    (
        IBOFLAG     IN      BOOLEAN
    )
    IS
    BEGIN
    
        PKERRORS.PUSH( 'pkSuspConnServiceMgr.EnableExeActivityRule' );

        
        
        GBLEXEACTIVITYRULE := IBOFLAG;

        PKERRORS.POP;

    EXCEPTION

        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END;
    
    
    




















    PROCEDURE SETIDSUSPCONE
    (
        INUIDSUSPCONE       IN      SUSPCONE.SUCOIDSC%TYPE
    )
    IS
    BEGIN
    
        UT_TRACE.TRACE( 'Inicio: [pkSuspConnServiceMgr.SetIdSuspcone]', 5 );

        
        GNUIDSUSPCONE := INUIDSUSPCONE;

        UT_TRACE.TRACE( 'Fin: [pkSuspConnServiceMgr.SetIdSuspcone]', 5 );

    EXCEPTION

        WHEN LOGIN_DENIED OR EX.CONTROLLED_ERROR OR PKCONSTANTE.EXERROR_LEVEL2 THEN
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.SetIdSuspcone]', 5 );
            RAISE;

        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            UT_TRACE.TRACE( 'Error: [pkSuspConnServiceMgr.SetIdSuspcone]', 5 );
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END;

    






















    PROCEDURE GETPRODINFO
    (
        INUPRODUCT      IN  SERVSUSC.SESUNUSE%TYPE,
        INUREQSTATUS    IN  ESTACORT.ESCOCODI%TYPE,
        INUAPPLYSTATUS  IN  ESTACORT.ESCOCODI%TYPE,
        ORCPRODUCT      OUT PKSUSPCONNSERVICEMGR.TYTBSUBSSERVICES
    )
    IS
        
        
        
        CURSOR CUPRODUCT
        IS  SELECT /*+ index (servsusc, pk_servsusc)*/
                   SERVSUSC.ROWID, SESUNUSE, SESUESCO, SESUSERV,
                   SUSCCICL, SUSCCLIE, SUSCCODI
            FROM  SERVSUSC,
                  SUSCRIPC,
                  RECAESCO 
            WHERE SESUSUSC = SUSCCODI
            AND   SESUSERV = RCECSERV
            AND   SESUESCO = RCECCOER
            AND   SESUESCO = INUREQSTATUS
            AND   SESUNUSE = INUPRODUCT
            AND   RCECCOEC = INUAPPLYSTATUS;
    BEGIN

        UT_TRACE.TRACE( 'pkSuspConnServiceMgr.GetProdInfo', 15 );

        
        OPEN CUPRODUCT;
        FETCH CUPRODUCT BULK COLLECT INTO ORCPRODUCT;
        CLOSE CUPRODUCT;

        UT_TRACE.TRACE( 'Fin pkSuspConnServiceMgr.GetProdInfo', 15 );

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
        	ERRORS.SETERROR;
        	RAISE EX.CONTROLLED_ERROR;
    END GETPRODINFO;
    
    














    PROCEDURE SETPAIDCOUPON
    (
        INUPAIDCOUPON    IN    SUSPCONE.SUCOCUPO%TYPE
    )
    IS
    BEGIN
        UT_TRACE.TRACE('pkSuspConnServiceMgr.SetPaidCoupon Cup�n de Pago['||INUPAIDCOUPON||']',10);
        GNUPAIDCOUPON := INUPAIDCOUPON;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END SETPAIDCOUPON;

    














    FUNCTION FNUGETPAIDCOUPON
    RETURN SUSPCONE.SUCOCUPO%TYPE
    IS
    BEGIN
        UT_TRACE.TRACE('pkSuspConnServiceMgr.fnuPaidCoupon Cup�n de Pago['||GNUPAIDCOUPON||']',10);
        
        RETURN GNUPAIDCOUPON;
    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END FNUGETPAIDCOUPON;
    
    














    PROCEDURE UPDRECONACTIVANDORDER
    IS
        
        RCBSSORDER           SUSPCONE%ROWTYPE;
        
        NUPRODUCTID          PR_PRODUCT.PRODUCT_ID%TYPE;
        
        NUORDERACTIVITYID    OR_ORDER_ACTIVITY.ORDER_ACTIVITY_ID%TYPE;
        
        NUORDERID            OR_ORDER_ACTIVITY.ORDER_ID%TYPE;
    
    BEGIN
        UT_TRACE.TRACE('Inicio: pkSuspConnServiceMgr.UpdReconActivAndOrder',10);
        
        
        NUPRODUCTID := OR_BOLEGALIZEACTIVITIES.FNUGETCURRPRODUCT;
        UT_TRACE.TRACE('Producto['||NUPRODUCTID||']',12);
        
        
        RCBSSORDER  := PKBCSUSPCONE.FRCGETRECORDBYTYPE(NUPRODUCTID, PKSUSPCONNSERVICE.CSBCONEXION);
        
        IF (RCBSSORDER.SUCOIDSC IS NOT NULL) THEN
        
            
            NUORDERACTIVITYID := OR_BOLEGALIZEACTIVITIES.FNUGETCURRACTIVITY;
            UT_TRACE.TRACE('Actividad['||NUORDERACTIVITYID||']',12);

            
            NUORDERID := DAOR_ORDER_ACTIVITY.FNUGETORDER_ID(NUORDERACTIVITYID);
            UT_TRACE.TRACE('Orden['||NUORDERID||']',12);
            
            
            PKBCSUSPCONE.UPORDERNUMBER
            (
                RCBSSORDER.SUCOIDSC,
                NUORDERID,
                NUORDERACTIVITYID,
                RCBSSORDER.SUCOORDTYPE,
                RCBSSORDER.SUCOORIM
            );
            
        END IF;
        
        UT_TRACE.TRACE('Fin: pkSuspConnServiceMgr.UpdReconActivAndOrder',10);

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            RAISE;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END UPDRECONACTIVANDORDER;
    
    



















    PROCEDURE UPDRECONECTORDER
    (
        INUPACKAGESID   IN  MO_PACKAGES.PACKAGE_ID%TYPE
    )
    IS
        
        CURFMOTIVES         CONSTANTS.TYREFCURSOR;
        
        RCMOTIVE            DAMO_MOTIVE.STYMO_MOTIVE;
        
        RCBSSORDER           SUSPCONE%ROWTYPE;
        
        NUPRODUCTID          PR_PRODUCT.PRODUCT_ID%TYPE;
        
        TBOR_ORDER_ACTIVITY  DAOR_ORDER_ACTIVITY.TYTBOR_ORDER_ACTIVITY;
        
        NUACTIVITYIDX        BINARY_INTEGER;
        
        
        NUORDERACTIVITYID    OR_ORDER_ACTIVITY.ORDER_ACTIVITY_ID%TYPE;
        
        NUORDERID            OR_ORDER_ACTIVITY.ORDER_ID%TYPE;

    BEGIN
        UT_TRACE.TRACE('Inicio: pkSuspConnServiceMgr.UpdReconectOrder',10);
        UT_TRACE.TRACE('Solicitud['|| INUPACKAGESID|| ']', 2);

        
        CURFMOTIVES :=  MO_BCMOTIVE.FRFMOTIVESBYPACKAGEID(INUPACKAGESID);

        
        FETCH CURFMOTIVES INTO RCMOTIVE;
        CLOSE CURFMOTIVES;

        
        NUPRODUCTID := RCMOTIVE.PRODUCT_ID;
        UT_TRACE.TRACE('Motivo['||RCMOTIVE.MOTIVE_ID || ']', 2);
        UT_TRACE.TRACE('Producto['||NUPRODUCTID||']',2);

        
        RCBSSORDER  := PKBCSUSPCONE.FRCGETRECORDBYTYPE(NUPRODUCTID, PKSUSPCONNSERVICE.CSBCONEXION);
        UT_TRACE.TRACE('suspcone: ' || RCBSSORDER.SUCOIDSC, 2);

        IF (RCBSSORDER.SUCOIDSC IS NOT NULL) THEN

            
            OR_BCORDERACTIVITIES.GETPENDACTIVBYPACK(INUPACKAGESID, TBOR_ORDER_ACTIVITY);
            
            
            NUACTIVITYIDX   :=  TBOR_ORDER_ACTIVITY.FIRST;
            UT_TRACE.TRACE('Cantidad actividades: ' || TBOR_ORDER_ACTIVITY.COUNT , 2);

            IF( NUACTIVITYIDX IS NOT NULL )THEN

                
                NUORDERACTIVITYID := TBOR_ORDER_ACTIVITY(NUACTIVITYIDX).ORDER_ACTIVITY_ID;
                UT_TRACE.TRACE('Actividad['||NUORDERACTIVITYID||']',12);

                
                NUORDERID := DAOR_ORDER_ACTIVITY.FNUGETORDER_ID(NUORDERACTIVITYID);
                UT_TRACE.TRACE('Orden['||NUORDERID||']',12);

                
                PKBCSUSPCONE.UPORDERNUMBER
                (
                    RCBSSORDER.SUCOIDSC,
                    NUORDERID,
                    NUORDERACTIVITYID,
                    RCBSSORDER.SUCOORDTYPE,
                    RCBSSORDER.SUCOORIM
                );
            
            END IF;

        END IF;

        UT_TRACE.TRACE('Fin: pkSuspConnServiceMgr.UpdReconectOrder',10);

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            IF (CURFMOTIVES%ISOPEN) THEN
                CLOSE CURFMOTIVES;
            END IF;
            RAISE;
        WHEN OTHERS THEN
            IF (CURFMOTIVES%ISOPEN) THEN
                CLOSE CURFMOTIVES;
            END IF;
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END UPDRECONECTORDER;
    
BEGIN

     GETGENERALPARAMETR;
     
END PKSUSPCONNSERVICEMGR;