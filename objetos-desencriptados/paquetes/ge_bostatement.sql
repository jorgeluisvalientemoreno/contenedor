PACKAGE BODY GE_BOStatement AS







































































    
    
    
    
    CSBVERSION  CONSTANT VARCHAR2(250)  := 'SAO201755';

    
    CNUERRINVALIDCURSOR CONSTANT NUMBER(6) := 901873;

    CSBCOLON        CONSTANT VARCHAR2(1) := ':';
    CSBDOT          CONSTANT VARCHAR2(1) := '.';
    
    CNUMESS_NO_EXIST_ATTRI_STATE CONSTANT NUMBER(4) := 3114;


    







    CSBFINALCHAR    CONSTANT VARCHAR2(10):= ' '||CHR(10)||'),'||CHR(8)||'|'||CHR(13);
    CSBLETRA_A      CONSTANT VARCHAR2(1) := 'A';   
    
    CNUTIPODATO     CONSTANT NUMBER := 1015;

    
    
    

    RCCURRSTATEMENT DAGE_STATEMENT.STYGE_STATEMENT;
    TBSTATEMENT     DAGE_STATEMENT.TYTBGE_STATEMENT;

    
    
    
    FUNCTION FSBVERSION  RETURN VARCHAR2 IS
    BEGIN
        RETURN CSBVERSION;
    END;

    



    
   PROCEDURE REPLACE_PARAMETER
   (
      ISBINITIALSCHAR IN     VARCHAR2,
      ISBSEPARATORS   IN     VARCHAR2,
      IOSBSTATEMENT   IN OUT NOCOPY VARCHAR2
   )
   IS
      NUPOS    PLS_INTEGER := 1;
      NUINDICE PLS_INTEGER := 0;
      SBCHAR   VARCHAR2(1);
      BOFIND   BOOLEAN := FALSE;
      SBTOKEN  GE_STATEMENT.STATEMENT%TYPE := NULL;
   BEGIN
      IF (LENGTH(IOSBSTATEMENT)) = 0 THEN
         RETURN;
      END IF;

      WHILE (NUPOS <= LENGTH(IOSBSTATEMENT)) LOOP
         SBCHAR := SUBSTR(IOSBSTATEMENT, NUPOS, 1);
         IF (INSTR (ISBINITIALSCHAR, SBCHAR) > 0) THEN 
            WHILE (INSTR(ISBSEPARATORS, SBCHAR) = 0) LOOP
               IF NOT BOFIND THEN
                  NUINDICE := NUINDICE + 1;
                  BOFIND := TRUE;
                  SBTOKEN := SBTOKEN||SBCHAR||CSBLETRA_A||TO_CHAR(NUINDICE);
               END IF;

               NUPOS   := NUPOS + 1;
               SBCHAR := SUBSTR(IOSBSTATEMENT, NUPOS, 1);
             END LOOP;

             BOFIND := FALSE;
         END IF;

         SBTOKEN := SBTOKEN||SBCHAR;

         NUPOS := NUPOS + 1;
      END LOOP;

      IOSBSTATEMENT := SBTOKEN;
      EXCEPTION
        WHEN  EX.CONTROLLED_ERROR THEN
            RAISE;

        WHEN OTHERS THEN
           ERRORS.SETERROR;
           RAISE EX.CONTROLLED_ERROR;

   END ;

    




















   PROCEDURE DEFINECOLUMN
   (
      IRCRECORDS  IN DESCSELECT,
      IONUCURSOR  IN OUT NOCOPY NUMBER
   )
   IS
      NUNUMBER NUMBER := NULL;
      SBVARCHAR2 VARCHAR2(2000);
      DTDATE   DATE;
   BEGIN
      IF IONUCURSOR IS NOT NULL AND DBMS_SQL.IS_OPEN( IONUCURSOR ) THEN
        FOR NUBIND IN 1..IRCRECORDS.COUNT LOOP
            NUNUMBER := 0.0; SBVARCHAR2 := NULL; DTDATE   := NULL;
            
            IF ( IRCRECORDS(NUBIND).COL_TYPE = CNUNUMBER) THEN     
                DBMS_SQL.DEFINE_COLUMN(IONUCURSOR, NUBIND , NUNUMBER);

            ELSIF
                ( IRCRECORDS(NUBIND).COL_TYPE = CNUVARCHAR2) OR
                ( IRCRECORDS(NUBIND).COL_TYPE = CNUCHAR) THEN 
                DBMS_SQL.DEFINE_COLUMN(IONUCURSOR, NUBIND , SBVARCHAR2,
                                       IRCRECORDS(NUBIND).COL_MAX_LEN);

            ELSIF ( IRCRECORDS(NUBIND).COL_TYPE = CNUDATE) THEN 
                DBMS_SQL.DEFINE_COLUMN(IONUCURSOR, NUBIND , DTDATE);

            ELSE
               ERRORS.SETERROR(CNUTIPODATO, IRCRECORDS(NUBIND).COL_NAME||'|'||RCCURRSTATEMENT.STATEMENT_ID);
               RAISE EX.CONTROLLED_ERROR;
            END IF;

        END LOOP;
       ELSE
            ERRORS.SETERROR( CNUERRINVALIDCURSOR,IONUCURSOR );
            RAISE EX.CONTROLLED_ERROR;
       END IF;
   EXCEPTION
        WHEN  EX.CONTROLLED_ERROR THEN
            RAISE;

        WHEN OTHERS THEN
           ERRORS.SETERROR;
           RAISE EX.CONTROLLED_ERROR;
   END DEFINECOLUMN;

    























    PROCEDURE DEFINEBINDVARIABLES
    (
       ITYTBINSTANCE IN OUT NOCOPY GE_BOINSTANCE.TYTBINSTANCE,
       INUCURSOR    IN NUMBER
    )
    IS
       DTDATE      DATE;
       NUINDICE    PLS_INTEGER;
       NUNUMBER    NUMBER;  
       TBWHERE     UT_STRING.TYTB_STRING;
       TBBIND      UT_STRING.TYTB_STRING;
       SBVARCHAR2  VARCHAR2(500);
       SBINSTANCE  VARCHAR2(100);
       SBATTRIBUTE VARCHAR2(100);
    BEGIN
        UT_TRACE.TRACE('GE_BOSTATEMENT.DefineBindVariables 1:',5);
        
        IF NOT (UT_STRING.FBOTABLESTRTOKEN(RCCURRSTATEMENT.STATEMENT, CSBCOLON,
                                           CSBFINALCHAR, TBWHERE)) THEN
            RETURN; 
        END IF;

        
        NUNUMBER := TBWHERE.FIRST;
        LOOP
            




            TBWHERE(NUNUMBER) := UT_STRING.FSBCUTNEXTWORD(TBWHERE(NUNUMBER),':');
            NUNUMBER := TBWHERE.NEXT(NUNUMBER);
            EXIT WHEN (NUNUMBER IS NULL);
        END LOOP;

        FOR NUBIND IN 1..TBWHERE.COUNT LOOP
            NUNUMBER   := 0.0;
            SBVARCHAR2 := NULL;
            DTDATE     := NULL;

            
            UT_STRING.EXTSTRING(TBWHERE(NUBIND),CSBDOT,TBBIND);

            

            IF TBBIND.COUNT = 1 THEN
                SBATTRIBUTE := TBBIND(1);
            ELSIF TBBIND.COUNT > 1 THEN
                SBINSTANCE := TBBIND(1);   
                SBATTRIBUTE := TBBIND(2);  
            ELSE
                
                ERRORS.SETERROR(GE_BOMESSAGE_CONSTANTS.CNUERR_STATEMENT_979,
                                RCCURRSTATEMENT.STATEMENT_ID);
                                
                RAISE EX.CONTROLLED_ERROR;
            END IF;

            IF NOT (GE_BOINSTANCE.FBLEXISTS(ITYTBINSTANCE,
                                            SBINSTANCE,
                                            SBATTRIBUTE,
                                            NUINDICE))
            THEN
                    ERRORS.SETERROR(CNUMESS_NO_EXIST_ATTRI_STATE, SBATTRIBUTE||'|'||RCCURRSTATEMENT.STATEMENT_ID);
                    RAISE EX.CONTROLLED_ERROR;
            END IF;

            IF INUCURSOR IS NOT NULL AND DBMS_SQL.IS_OPEN( INUCURSOR ) THEN
                
                
                IF ( ITYTBINSTANCE(NUINDICE).ATTRIBUTE_TYPE = CSBNUMBER) THEN
                   NUNUMBER := ITYTBINSTANCE(NUINDICE).VALUE_;
                   DBMS_SQL.BIND_VARIABLE(INUCURSOR, CSBLETRA_A||NUBIND,
                                         NUNUMBER);
                
                ELSIF ( ITYTBINSTANCE(NUINDICE).ATTRIBUTE_TYPE = CSBVARCHAR2) THEN
                   SBVARCHAR2 := ITYTBINSTANCE(NUINDICE).VALUE_;
                   DBMS_SQL.BIND_VARIABLE(INUCURSOR, CSBLETRA_A||NUBIND,
                                         SBVARCHAR2);
                
                ELSIF ( ITYTBINSTANCE(NUINDICE).ATTRIBUTE_TYPE = CSBDATE) THEN
                   DTDATE := TO_DATE(ITYTBINSTANCE(NUINDICE).VALUE_, UT_DATE.FSBDATE_FORMAT);
                   DBMS_SQL.BIND_VARIABLE(INUCURSOR, CSBLETRA_A||NUBIND, DTDATE);
                ELSE
                   ERRORS.SETERROR(CNUTIPODATO, SBATTRIBUTE||'|'||RCCURRSTATEMENT.STATEMENT_ID);
                   RAISE EX.CONTROLLED_ERROR;
                END IF;
            ELSE
                ERRORS.SETERROR( CNUERRINVALIDCURSOR, INUCURSOR );
                RAISE EX.CONTROLLED_ERROR;
            END IF;

        END LOOP;

    EXCEPTION
        WHEN  EX.CONTROLLED_ERROR THEN
            RAISE;

        WHEN OTHERS THEN
           ERRORS.SETERROR;
           RAISE EX.CONTROLLED_ERROR;

    END DEFINEBINDVARIABLES;
    
    





















    PROCEDURE COLUMNVALUE
    (
       INUCURSOR     IN  NUMBER,
       IRCRECORDS    IN  DESCSELECT,
       IOTYSELECT    IN OUT NOCOPY GE_BOINSTANCE.TYTBINSTANCE
    )
    IS
       RCDESCRIBE  DBMS_SQL.DESC_REC;
       RCSELECT    GE_BOINSTANCE.TYRCINSTANCE;
       SBVARCHAR2  VARCHAR2(4000); 
       DTDATE      DATE;
       NUNUMBER    NUMBER;
       NUINDICEREC PLS_INTEGER;
       NUINDICE    PLS_INTEGER;
    BEGIN
        NUINDICEREC := IRCRECORDS.FIRST;

        IF INUCURSOR IS NULL OR NOT DBMS_SQL.IS_OPEN( INUCURSOR ) THEN
            ERRORS.SETERROR( CNUERRINVALIDCURSOR, INUCURSOR );
            RAISE EX.CONTROLLED_ERROR;
        END IF;

        FOR NUBIND IN 1..IRCRECORDS.COUNT LOOP

             RCDESCRIBE := IRCRECORDS(NUINDICEREC);
            
            IF ( RCDESCRIBE.COL_TYPE = CNUNUMBER) THEN     
                DBMS_SQL.COLUMN_VALUE(INUCURSOR,NUBIND,NUNUMBER);
                RCSELECT.NAME_ATTRIBUTE := RCDESCRIBE.COL_NAME;
                RCSELECT.ATTRIBUTE_TYPE := CSBNUMBER;
                RCSELECT.VALUE_         := NUNUMBER;

            ELSIF ( RCDESCRIBE.COL_TYPE = CNUVARCHAR2) OR  
                  ( RCDESCRIBE.COL_TYPE = CNUCHAR) THEN 
                DBMS_SQL.COLUMN_VALUE(INUCURSOR, NUBIND , SBVARCHAR2);
                RCSELECT.NAME_ATTRIBUTE := RCDESCRIBE.COL_NAME;
                RCSELECT.ATTRIBUTE_TYPE := CSBVARCHAR2;
                RCSELECT.VALUE_         := SBVARCHAR2;

            ELSIF ( RCDESCRIBE.COL_TYPE = CNUDATE) THEN 
                DBMS_SQL.COLUMN_VALUE(INUCURSOR, NUBIND , DTDATE);
                RCSELECT.NAME_ATTRIBUTE := RCDESCRIBE.COL_NAME;
                RCSELECT.ATTRIBUTE_TYPE := CSBDATE;
                RCSELECT.VALUE_         := TO_CHAR(DTDATE,UT_DATE.FSBDATE_FORMAT);
            ELSE
               ERRORS.SETERROR(CNUTIPODATO, IRCRECORDS(NUBIND).COL_NAME||'|'||RCCURRSTATEMENT.STATEMENT_ID);
               RAISE EX.CONTROLLED_ERROR;
            END IF;

            RCSELECT.INSTANCE_      := NULL;
            RCSELECT.ATTRIBUTE_ID   := NULL;

            NUINDICEREC := IRCRECORDS.NEXT(NUINDICEREC);

            IOTYSELECT(NUBIND) := RCSELECT;
        END LOOP;

    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
             RAISE;

        WHEN OTHERS THEN
           ERRORS.SETERROR;
           RAISE EX.CONTROLLED_ERROR;

     END COLUMNVALUE;

    






















    FUNCTION FETCHSTATEMENT
    (
       IONUCURSOR    IN OUT NOCOPY NUMBER,
       IORCRECORDS   IN OUT NOCOPY DESCSELECT,
       IOTYTBSELECT  IN OUT NOCOPY GE_BOINSTANCE.TYTBINSTANCE
    ) RETURN BOOLEAN
    IS
       NUFETCH PLS_INTEGER;
    BEGIN
       IF IONUCURSOR IS NOT NULL AND DBMS_SQL.IS_OPEN( IONUCURSOR ) THEN
          NUFETCH := DBMS_SQL.FETCH_ROWS(IONUCURSOR);
       ELSE
            ERRORS.SETERROR( CNUERRINVALIDCURSOR, IONUCURSOR );
            RAISE EX.CONTROLLED_ERROR;
       END IF;

       IF NUFETCH <> 1 THEN
          RETURN FALSE;
       END IF;

       COLUMNVALUE(IONUCURSOR,IORCRECORDS, IOTYTBSELECT);

       RETURN TRUE;
    EXCEPTION
        WHEN  EX.CONTROLLED_ERROR THEN
            RAISE;

        WHEN OTHERS THEN
           ERRORS.SETERROR;
           RAISE EX.CONTROLLED_ERROR;
    END FETCHSTATEMENT;

    























    FUNCTION EXECSTATEMENT
    (
       ITYTBINSTANCE   IN OUT NOCOPY GE_BOINSTANCE.TYTBINSTANCE,
       ORCRECORDS      OUT NOCOPY  DESCSELECT
    ) RETURN NUMBER
    IS
       NUNUMBERFETCH PLS_INTEGER;
       NUCOL_CNT     PLS_INTEGER;
       IONUCURSOR    PLS_INTEGER;
       SBSTATEMENT   GE_STATEMENT.STATEMENT%TYPE := RCCURRSTATEMENT.STATEMENT;
    BEGIN
        
        REPLACE_PARAMETER(CSBCOLON, CSBFINALCHAR, SBSTATEMENT);
        
        UT_TRACE.TRACE(SUBSTR(SBSTATEMENT,2900, LENGTH(SBSTATEMENT)));

        
        IONUCURSOR := DBMS_SQL.OPEN_CURSOR;

        
        DBMS_SQL.PARSE(IONUCURSOR, SBSTATEMENT, DBMS_SQL.NATIVE);

        
        UT_TRACE.TRACE('Entra DefineBind');
        
        DEFINEBINDVARIABLES(ITYTBINSTANCE, IONUCURSOR);
        
        UT_TRACE.TRACE('Sale DefineBind');
        
        
        NUNUMBERFETCH := DBMS_SQL.EXECUTE(IONUCURSOR);

        
        DBMS_SQL.DESCRIBE_COLUMNS(IONUCURSOR, NUCOL_CNT, ORCRECORDS);

        
        DEFINECOLUMN(ORCRECORDS, IONUCURSOR);

        
        NUNUMBERFETCH := DBMS_SQL.EXECUTE(IONUCURSOR);

        RETURN IONUCURSOR;

        EXCEPTION
        WHEN  EX.CONTROLLED_ERROR THEN
            IF IONUCURSOR IS NOT NULL AND DBMS_SQL.IS_OPEN( IONUCURSOR ) THEN
                DBMS_SQL.CLOSE_CURSOR( IONUCURSOR );
            END IF;
            RAISE;

        WHEN OTHERS THEN
            IF IONUCURSOR IS NOT NULL AND DBMS_SQL.IS_OPEN( IONUCURSOR ) THEN
                DBMS_SQL.CLOSE_CURSOR( IONUCURSOR );
            END IF;
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END EXECSTATEMENT;

    





















    PROCEDURE CLOSESTATEMENT (IONUCURSOR IN OUT NOCOPY NUMBER) IS
    BEGIN
        IF IONUCURSOR IS NOT NULL AND DBMS_SQL.IS_OPEN( IONUCURSOR ) THEN
            DBMS_SQL.CLOSE_CURSOR(IONUCURSOR);
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EX.CONTROLLED_ERROR;
    END;


    PROCEDURE VALSTATEMENT (INUSTATEMENT_ID GE_STATEMENT.STATEMENT_ID%TYPE) IS
    BEGIN
       IF NOT TBSTATEMENT.EXISTS(INUSTATEMENT_ID) THEN
          RCCURRSTATEMENT := DAGE_STATEMENT.FRCGETRECORD(INUSTATEMENT_ID);
          TBSTATEMENT(INUSTATEMENT_ID):= RCCURRSTATEMENT;
          RETURN;
       END IF;

       RCCURRSTATEMENT := TBSTATEMENT(INUSTATEMENT_ID);
    END;

    
    

    PROCEDURE OPENSTATEMENT
    (
       ITYTBINSTANCE   IN OUT NOCOPY GE_BOINSTANCE.TYTBINSTANCE,
       INUSTATEMENT_ID IN GE_STATEMENT.STATEMENT_ID%TYPE,
       ORCRECORDS      OUT NOCOPY DESCSELECT,
       ONUCURSOR       OUT NOCOPY NUMBER
    )
    IS
       RCSTATEMENT DAGE_STATEMENT.STYGE_STATEMENT;
    BEGIN

       VALSTATEMENT (INUSTATEMENT_ID);

        ONUCURSOR := GE_BOCONSTANTS.NOK;

        ONUCURSOR := EXECSTATEMENT(ITYTBINSTANCE, ORCRECORDS);

     EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
             RAISE;

        WHEN OTHERS THEN
             ERRORS.SETERROR;
             RAISE EX.CONTROLLED_ERROR;
    END;

    FUNCTION GETALLSTATEMENT (INUMODULE IN GE_STATEMENT.MODULE_ID%TYPE)
         RETURN DAGE_STATEMENT.TYREFCURSOR
    IS
    BEGIN

        RETURN  DAGE_STATEMENT.FRFGETRECORDS('MODULE_ID = '||INUMODULE);

       EXCEPTION
        WHEN  EX.CONTROLLED_ERROR THEN
           RAISE;

        WHEN OTHERS THEN
           ERRORS.SETERROR;
           RAISE EX.CONTROLLED_ERROR;
    END;
    
    FUNCTION GETSTATEMENTINFO
    (
        INUSTATEMENTID IN GE_STATEMENT.STATEMENT_ID%TYPE
    )
    RETURN CONSTANTS.TYREFCURSOR
    IS
        SBCRITERIA VARCHAR2(1024) := '';
        REFCURSOR  CONSTANTS.TYREFCURSOR;
    BEGIN

        SBCRITERIA := 'SELECT * FROM GE_STATEMENT WHERE STATEMENT_ID = :ID';
        OPEN REFCURSOR FOR SBCRITERIA USING INUSTATEMENTID;
        RETURN REFCURSOR;

       EXCEPTION
        WHEN  EX.CONTROLLED_ERROR THEN
            IF(REFCURSOR%ISOPEN)THEN
               CLOSE REFCURSOR;
            END IF;
           RAISE;
        WHEN OTHERS THEN
            IF(REFCURSOR%ISOPEN)THEN
               CLOSE REFCURSOR;
            END IF;
           ERRORS.SETERROR;
           RAISE EX.CONTROLLED_ERROR;
    END GETSTATEMENTINFO;




























PROCEDURE INSERTSTATEMENT
(
    INUSTATEMENTID  IN GE_STATEMENT.STATEMENT_ID%TYPE,
    INUMODULE       IN GE_STATEMENT.MODULE_ID%TYPE,
    ISBNAME         IN GE_STATEMENT.NAME%TYPE,
    ISBDESCRIPTION  IN GE_STATEMENT.DESCRIPTION%TYPE,
    ISBSTATEMENT    IN GE_STATEMENT.STATEMENT%TYPE,
    ONUSTATEMENTID  OUT GE_STATEMENT.STATEMENT_ID%TYPE
)
IS

RCSTATEMENT DAGE_STATEMENT.STYGE_STATEMENT;

BEGIN
    IF INUSTATEMENTID IS NOT NULL THEN
        ONUSTATEMENTID := INUSTATEMENTID;
    ELSE
        ONUSTATEMENTID := GE_BOSEQUENCE.NEXTGE_STATEMENT;
    END IF;
    
    RCSTATEMENT.STATEMENT_ID := ONUSTATEMENTID;
    RCSTATEMENT.MODULE_ID    := INUMODULE;
    RCSTATEMENT.NAME         := ISBNAME;
    RCSTATEMENT.DESCRIPTION  := ISBDESCRIPTION;
    RCSTATEMENT.STATEMENT    := ISBSTATEMENT;

    DAGE_STATEMENT.INSRECORD (RCSTATEMENT);

EXCEPTION
    WHEN EX.CONTROLLED_ERROR THEN
        RAISE;

    WHEN OTHERS THEN
        ERRORS.SETERROR;
        RAISE EX.CONTROLLED_ERROR;
END;





















PROCEDURE UPDATESTATEMENT
(
    INUSTATEMENTID IN GE_STATEMENT.STATEMENT_ID%TYPE,
    INUMODULE      IN GE_STATEMENT.MODULE_ID%TYPE,
    ISBNAME        IN GE_STATEMENT.NAME%TYPE,
    ISBDESCRIPTION IN GE_STATEMENT.DESCRIPTION%TYPE,
    ISBSTATEMENT   IN GE_STATEMENT.STATEMENT%TYPE
)
IS

RCSTATEMENT DAGE_STATEMENT.STYGE_STATEMENT;

BEGIN
    RCSTATEMENT := DAGE_STATEMENT.FRCGETRECORD (INUSTATEMENTID);

    RCSTATEMENT.MODULE_ID    := INUMODULE;
    RCSTATEMENT.NAME         := ISBNAME;
    RCSTATEMENT.DESCRIPTION  := ISBDESCRIPTION;
    RCSTATEMENT.STATEMENT    := ISBSTATEMENT;

    DAGE_STATEMENT.UPDRECORD (RCSTATEMENT);

EXCEPTION
    WHEN EX.CONTROLLED_ERROR THEN
        RAISE;

    WHEN OTHERS THEN
        ERRORS.SETERROR;
        RAISE EX.CONTROLLED_ERROR;
END;





























PROCEDURE SAVESTATEMENT
(
    INUSTATEMENTID  IN GE_STATEMENT.STATEMENT_ID%TYPE,
    INUMODULE       IN GE_STATEMENT.MODULE_ID%TYPE,
    ISBNAME         IN GE_STATEMENT.NAME%TYPE,
    ISBDESCRIPTION  IN GE_STATEMENT.DESCRIPTION%TYPE,
    ISBSTATEMENT    IN GE_STATEMENT.STATEMENT%TYPE,
    ONUSTATEMENTID  OUT GE_STATEMENT.STATEMENT_ID%TYPE
)
IS
BEGIN
    IF INUSTATEMENTID IS NOT NULL AND DAGE_STATEMENT.FBLEXIST (INUSTATEMENTID) THEN
        ONUSTATEMENTID := INUSTATEMENTID;

        UPDATESTATEMENT (INUSTATEMENTID, INUMODULE, ISBNAME, ISBDESCRIPTION, ISBSTATEMENT);
    ELSE
        INSERTSTATEMENT (INUSTATEMENTID, INUMODULE, ISBNAME, ISBDESCRIPTION, ISBSTATEMENT, ONUSTATEMENTID);
    END IF;
    
EXCEPTION
    WHEN EX.CONTROLLED_ERROR THEN
        RAISE;

    WHEN OTHERS THEN
        ERRORS.SETERROR;
        RAISE EX.CONTROLLED_ERROR;
END;

    

















    FUNCTION FBOVALIDATESTATEMENT
    (
        IORFSTATEMENT   IN OUT  CONSTANTS.TYREFCURSOR,
        ISBVALUE        IN      VARCHAR2
    )

    RETURN BOOLEAN IS

        NUCURSOR        NUMBER;                 
        SBRESULT        VARCHAR2(2000);         
        NUCOLUMN        NUMBER(1)   := 1;       
        BOFINDED        BOOLEAN     := FALSE;

    BEGIN
    UT_TRACE.TRACE('INICIO GE_BOStatement.fboValidateStatement',26);
    
    NUCURSOR := DBMS_SQL.TO_CURSOR_NUMBER(IORFSTATEMENT);

    
    DBMS_SQL.DEFINE_COLUMN(NUCURSOR,NUCOLUMN,SBRESULT,2000);
    WHILE (DBMS_SQL.FETCH_ROWS(NUCURSOR) > 0) LOOP
        DBMS_SQL.COLUMN_VALUE(NUCURSOR, NUCOLUMN, SBRESULT);
        BOFINDED := SBRESULT = ISBVALUE;
        EXIT WHEN BOFINDED;
    END LOOP;
    DBMS_SQL.CLOSE_CURSOR(NUCURSOR);
    
    UT_TRACE.TRACE('FIN GE_BOStatement.fboValidateStatement',26);
    RETURN NVL((BOFINDED),FALSE);

    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            DBMS_SQL.CLOSE_CURSOR(NUCURSOR);
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            DBMS_SQL.CLOSE_CURSOR(NUCURSOR);
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END FBOVALIDATESTATEMENT;
    
    

























    FUNCTION FBOVALUEISVALIDINSTATEMENQUERY
    (
        ISBSTATEMENT    IN GE_STATEMENT.STATEMENT%TYPE,
        ISBVALUE        IN VARCHAR2
    )
    RETURN BOOLEAN IS
        SBSTRING            VARCHAR2(2000) := NULL;
        SBNEWSTRING         VARCHAR2(2000) := NULL;
        NUFIRSTCHARACTER    NUMBER := 0;
        NUSECONDCHARACTER   NUMBER := 0;
        SBSTATEMENT         VARCHAR2(2000) := NULL;
        SBID                VARCHAR2(2000) := NULL;
        SBDESCRIPTION       VARCHAR2(2000) := NULL;
        RFSTATEMENT         CONSTANTS.TYREFCURSOR;
        BOHASBINDVARIABLE   BOOLEAN := FALSE;
        BORESPONSE          BOOLEAN := FALSE;
    BEGIN
        UT_TRACE.TRACE('Inicio GE_BOStatement.fboValueIsValidInStatemenQuery',25);
        SBSTATEMENT := ISBSTATEMENT;

        
        SBSTATEMENT:= TRIM(SBSTATEMENT);
        
        SBSTATEMENT := REPLACE(SBSTATEMENT,'F[');
        
        SBSTATEMENT := REPLACE(SBSTATEMENT,']');

        
        LOOP
            NUFIRSTCHARACTER := 0;
            NUSECONDCHARACTER := 0;
            SBSTRING := NULL;

            
            NUFIRSTCHARACTER := INSTR(SBSTATEMENT,'@',1);

            
            EXIT WHEN NUFIRSTCHARACTER = 0;

            
            NUSECONDCHARACTER := INSTR(SBSTATEMENT,'@',1,2);
            UT_TRACE.TRACE('Primer Caracter @:['||NUFIRSTCHARACTER||']Segundo Caracter @:['||NUSECONDCHARACTER||']',25);

            
            SBSTRING := SUBSTR(SBSTATEMENT, NUFIRSTCHARACTER, NUSECONDCHARACTER - NUFIRSTCHARACTER + 1);
            UT_TRACE.TRACE('Cadena a Parsear:['||SBSTRING||']',25);

            

            IF (INSTR(SBSTRING,':') > 0) THEN

                
                IF NOT BOHASBINDVARIABLE THEN
                    BOHASBINDVARIABLE := TRUE;
                    UT_TRACE.TRACE('Encontr? Variable Bind',25);
                ELSE
                    
                    SBSTATEMENT:= REPLACE(SBSTATEMENT, SBSTRING, '');
                END IF;
            END IF;

            

            IF (INSTR(UPPER(SBSTRING), 'WHERE') > 0) THEN
                SBNEWSTRING := TRIM(REPLACE(SBSTRING,'@'));

                
                IF (LENGTH(SBNEWSTRING) = 5) THEN

                    SBNEWSTRING := SBNEWSTRING || ' 1 = 1 ';
                ELSE
                    
                    IF (UPPER(SUBSTR(SBNEWSTRING,1,5)) <> 'WHERE') THEN

                        SBNEWSTRING := ' AND ' || TRIM(REPLACE(SBSTRING,'@'));
                    END IF;
                END IF;
            ELSE
                SBNEWSTRING := ' AND ' || TRIM(REPLACE(SBSTRING,'@'));
            END IF;
            UT_TRACE.TRACE('Cadena Parseada:['||SBNEWSTRING||']',25);

            
            SBSTATEMENT:= REPLACE(SBSTATEMENT, SBSTRING, SBNEWSTRING);
        END LOOP;

        
        IF BOHASBINDVARIABLE THEN
            
            OPEN RFSTATEMENT FOR SBSTATEMENT USING ISBVALUE;
        ELSE
            
            OPEN RFSTATEMENT FOR SBSTATEMENT;
        END IF;
        
        
        BORESPONSE := FBOVALIDATESTATEMENT(RFSTATEMENT,ISBVALUE);
        
        UT_TRACE.TRACE('FIN GE_BOStatement.fboValueIsValidInStatemenQuery',25);
        RETURN BORESPONSE;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END FBOVALUEISVALIDINSTATEMENQUERY;
    
    


























    FUNCTION FBOVALUEISVALIDINSTATEMENPROC
    (
        ISBSTATEMENT    IN GE_STATEMENT.STATEMENT%TYPE,
        ISBVALUE        IN VARCHAR2
    )
    RETURN BOOLEAN IS
        SBSCRIPT            VARCHAR2(2000)  := NULL;
        SBPROCEDURENAME     VARCHAR2(2000)  := NULL;
        BORESPONSE          BOOLEAN         := FALSE;
        TBDESCRIBE          GE_TYTB_DESCRIBE;
        RFSTATEMENT         CONSTANTS.TYREFCURSOR;
    BEGIN
        UT_TRACE.TRACE('Inicio GE_BOStatement.fboValueIsValidInStatemenProc',25);
        
        SBPROCEDURENAME := SUBSTR(ISBSTATEMENT,1,INSTR(ISBSTATEMENT,'(',1) - 1);
        UT_TRACE.TRACE('Procedimiento:['||SBPROCEDURENAME||']',25);

        
        TBDESCRIBE := UT_DESCRIBE.FTBOBJECTDESCRIBE(SBPROCEDURENAME);

        
        IF (TBDESCRIBE.COUNT = 2) THEN
            SBPROCEDURENAME := SBPROCEDURENAME || '(:isbValue, :orfStatement)';
        ELSE
            SBPROCEDURENAME := SBPROCEDURENAME || '(:isbValue, Null, :orfStatement)';
        END IF;

        
        SBSCRIPT :=
            'BEGIN '                                                    ||CHR(10)||
            SBPROCEDURENAME|| '; '                                      ||CHR(10)||
            'EXCEPTION '                                                ||CHR(10)||
            '   when ex.CONTROLLED_ERROR then '                         ||CHR(10)||
            '       raise ex.CONTROLLED_ERROR; '                        ||CHR(10)||
            '   when others then '                                      ||CHR(10)||
            '       Errors.setError; '                                  ||CHR(10)||
            '       raise ex.CONTROLLED_ERROR;'                         ||CHR(10)||
            'END;';

        EXECUTE IMMEDIATE SBSCRIPT USING ISBVALUE, OUT RFSTATEMENT;

        BORESPONSE := FBOVALIDATESTATEMENT(RFSTATEMENT,ISBVALUE);
            
        UT_TRACE.TRACE('FIN GE_BOStatement.fboValueIsValidInStatemenProc',25);
        RETURN BORESPONSE;
    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END FBOVALUEISVALIDINSTATEMENPROC;


    FUNCTION FBOVALUEISVALIDINSTATEMENT
    (
        INUSTATEMENTID  IN GE_STATEMENT.STATEMENT_ID%TYPE,
        ISBVALUE        IN VARCHAR2
    )
    RETURN BOOLEAN IS
        RCSTATEMENT DAGE_STATEMENT.STYGE_STATEMENT;
        BORESPONSE  BOOLEAN := FALSE;
    BEGIN
        UT_TRACE.TRACE('Inicia GE_BOStatement.fboValueIsValidInStatement Statement_id:['||INUSTATEMENTID||']Valor:['||ISBVALUE||']',24);

        RCSTATEMENT := DAGE_STATEMENT.FRCGETRECORD(INUSTATEMENTID);
        UT_TRACE.TRACE('Statement:['||RCSTATEMENT.STATEMENT||']',25);
        
        IF(ISBVALUE IS NOT NULL) THEN
            
            IF  ((INSTR(UPPER(RCSTATEMENT.STATEMENT),'SELECT',1) > 0))
                AND
                ((INSTR(UPPER(RCSTATEMENT.STATEMENT),'FROM',1) > 0))
            THEN
                BORESPONSE  := FBOVALUEISVALIDINSTATEMENQUERY (RCSTATEMENT.STATEMENT, ISBVALUE);
            ELSE
                BORESPONSE  := FBOVALUEISVALIDINSTATEMENPROC (RCSTATEMENT.STATEMENT, ISBVALUE);
            END IF;
        END IF;
        UT_TRACE.TRACE('Fin GE_BOStatement.fboValueIsValidInStatement',24);
        RETURN BORESPONSE;

    EXCEPTION
        WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
        WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
    END FBOVALUEISVALIDINSTATEMENT;


BEGIN
    
    CSBNUMBER	 := DAGE_ATTRIBUTES_TYPE.FSBGETDESCRIPTION(1);
    CNUNUMBER	 := DAGE_ATTRIBUTES_TYPE.FNUGETINTERNAL_TYPE(1);
    
    CSBVARCHAR2  := DAGE_ATTRIBUTES_TYPE.FSBGETDESCRIPTION(2);
    CNUVARCHAR2  := DAGE_ATTRIBUTES_TYPE.FNUGETINTERNAL_TYPE(2);
    
    CSBDATE      := DAGE_ATTRIBUTES_TYPE.FSBGETDESCRIPTION(3);
    CNUDATE      := DAGE_ATTRIBUTES_TYPE.FNUGETINTERNAL_TYPE(3);
    
    CSBCHAR      := DAGE_ATTRIBUTES_TYPE.FSBGETDESCRIPTION(11);
    CNUCHAR      := DAGE_ATTRIBUTES_TYPE.FNUGETINTERNAL_TYPE(11);

    TBSTATEMENT.DELETE;
END GE_BOSTATEMENT;