PACKAGE pkGeneralServices AS























































































































































































































    
    
    

	
	GCNUNIVELRASTREODEF    CONSTANT NUMBER      := 10;
	
	GCSBCARACTERRASTREO    CONSTANT VARCHAR2(1) := CHR( 9 );
	
	GCNUTIPORASTREOSTDOUT  CONSTANT NUMBER      := 1;
	
	GCNUTIPORASTREOTABLA   CONSTANT NUMBER      := 2;

    
    
    
    SBERRMSG	VARCHAR2(2000);		
    
    
    
    FUNCTION FSBGETUSERNAME RETURN VARCHAR2 ;
    FUNCTION FSBGETTERMINAL RETURN VARCHAR2 ;
    FUNCTION FSBGETDATEFORMAT RETURN VARCHAR2 ;
    PROCEDURE VALDATEY2K
    (
	DTFECHA	IN	DATE
    ) ;
    FUNCTION EXECUTEPIPE (ISBCOMANDO 	IN 	VARCHAR2,
			  ISBCANAL	        IN	VARCHAR2)
    RETURN NUMBER; 
    PROCEDURE COMMITTRANSACTION ;
    PROCEDURE ROLLBACKTRANSACTION ;
    PROCEDURE TABLETRUNCATE (SBTABLTRUNC IN VARCHAR2) ;
    
    FUNCTION FSBGETSTRINGNULL
    (
	ISBTABLE	IN	VARCHAR2,
	ISBCOLUMN	IN	VARCHAR2
    )
    RETURN VARCHAR2 ;
    PROCEDURE ROLLBACKTRANSACTIONTOX ;
    PROCEDURE EXECUTEDYNAMICSQL
    (
        ISBSENTENCE             IN      VARCHAR2
    );
    PROCEDURE EXECUTEDYNAMICPLSQL
    (
	SBDYNAMICPROC		IN 	VARCHAR2
    ) ;
    PROCEDURE VALDATEGREATER
    (
	IDTFECHAINICIAL	IN	DATE,
	IDTFECHAFINAL	IN	DATE
    ) ;
    PROCEDURE VALDATERANGE
    (
	IDTFECHAINI	IN	DATE,
	IDTFECHAFIN	IN	DATE
    ) ;
    PROCEDURE VALVALUERANGE
    (
	INUVALORINI	IN	NUMBER,
	INUVALORFIN	IN	NUMBER
    ) ;
    PROCEDURE VALPERCENTAGE
    (
	INUPORCENTAJE	IN	NUMBER
    ) ;
    PROCEDURE VALCURRENTDATE
    (
	IDTFECHA	IN	DATE
    ) ;
    PROCEDURE VALVALUEISPOSITIVE
    (
        INUVALUE        IN      NUMBER,
	INUCACHE        IN      NUMBER DEFAULT NULL
    ) ;
    PROCEDURE VALVALUEEQUALGREATERZERO
    (
        INUVALUE        IN      NUMBER
    ) ;
    PROCEDURE VALDATELESSCURRENT
    (
        IDTFECHA        IN      DATE
    ) ;
    PROCEDURE VALIDATEYESORNOT
    (
        INUCAMPO    IN VARCHAR2,
        ICNUCACHE   IN NUMBER DEFAULT 0
    ) ;
    PROCEDURE EXECDYNAMICFUNCTION
    (
	ISBPROCDYANM	IN	VARCHAR2,
	ONUVALORFUNC	OUT	NUMBER
    ) ;
    PROCEDURE EXECDYNAMICFUNCTION
    (
        ISBPROCDYANM    IN      VARCHAR2,
        OSBVALORFUNC    OUT     VARCHAR2
    ) ;
    FUNCTION FSBGETPIPENAME
    (
	ISBPIPENAME	IN	VARCHAR2,
	ISBUSERDEFAULT	IN	VARCHAR2 DEFAULT 'S'
    )
    RETURN VARCHAR2 ;
   FUNCTION FNUCOUNTNUMOFRECS
   (
      ISBWHERE    IN   VARCHAR2
   )
   RETURN NUMBER;
   FUNCTION FSBCOUNTSENTENCE
   (
     ISBWHERE    IN   VARCHAR2
   )
   RETURN VARCHAR2;
   FUNCTION FSBGETNUMBERTOHEX(INUNUMBER IN NUMBER)
   RETURN VARCHAR2;
   FUNCTION FNUGETHEXTONUMBER(ISBHEXT IN VARCHAR2)
   RETURN NUMBER ;
   
   
   PROCEDURE CALCULATEDATEDIFFERENCE
   (
        IDTFECHINIC  IN    DATE,
	IDTFECHFINA  IN    DATE,
	ONUDIFEDIAS  OUT   NUMBER,
	ONUDIFEHORA  OUT   NUMBER,
	ONUDIFEMINU  OUT   NUMBER,
	ONUDIFESEGU  OUT   NUMBER
    );
    
    
    FUNCTION FNUGETNUMBEROFRECS
    (
	ISBQUERY	IN	VARCHAR2
    )
    RETURN NUMBER ;
    FUNCTION FBOHASRECORDS
    (
	ISBQUERY	IN	VARCHAR2
    )
    RETURN BOOLEAN ;
    PROCEDURE VALIDOBJECT
    (
	ISBOBJECTNAME	IN	VARCHAR2
    ) ;
    PROCEDURE VALDATEGREATERCURRENT
    (
	IDTFECHA	IN	DATE
    ) ;
    PROCEDURE SETSERVICEREP
    (
	ISBFUNCIONA	IN	FUNCIONA.FUNCCODI%TYPE
    );
    FUNCTION FSBGETSERVICEREP
    RETURN FUNCIONA.FUNCCODI%TYPE ;
    
    
    PROCEDURE VALIDENTIFIERISVALID
    (
        ISBCADENA       IN      VARCHAR2
    );
    PROCEDURE VALDATERANGEANDSYSDATE
	(
	    IDTFECHAINI	IN	DATE,
	    IDTFECHAFIN	IN	DATE
	) ;
    FUNCTION FSBGETSYSTEMDATE RETURN VARCHAR2
    ;
    FUNCTION FDTGETSYSTEMDATE RETURN DATE
    ;
    FUNCTION FDTGETMAXDATE RETURN DATE
    ;
    FUNCTION FNUGETMONTHSBETWEEN (
    IDTFECHAINI         IN      DATE,
    IDTFECHAFIN         IN      DATE,
    ICHTRUNCROUND       IN      CHAR DEFAULT 'T'
    )
    RETURN NUMBER;
    FUNCTION FNUGETNEXTSEQUENCEVAL
    (
	SBSEQUENCENAME		IN	VARCHAR2
    )
    RETURN NUMBER ;
    PROCEDURE VALDATETIMERANGE
    (
        IDTFECHAINI     IN      DATE,
        IDTFECHAFIN     IN      DATE
    );
    PROCEDURE VALCURRENTDATETIME
    (
        IDTFECHA        IN      DATE
    );
    PROCEDURE SETPASSWORD
    (
	ISBPASSWORD	IN	VARCHAR2
    );
    PROCEDURE SETCONNECT_STRING
    (
	ISBCONNECT_STRING	IN	VARCHAR2
    );
    FUNCTION FSBGETCOMPLETECONNSTR
    RETURN VARCHAR2 ;
    PROCEDURE SETPATHSQLREPORTS
    (
	ISBPATHSQLREPORTS	IN	VARCHAR2
    ) ;
    PROCEDURE SETPATHUSERREPORTS
    (
	ISBPATHUSERREPORTS	IN	VARCHAR2
    ) ;
    FUNCTION FSBGETPATHSQLREPORTS
    RETURN VARCHAR2 ;
    FUNCTION FSBGETPATHUSERREPORTS
    RETURN VARCHAR2 ;
    PROCEDURE TRACEDATA
    (
	SBSTRING    IN    VARCHAR2
    ) ;
    PROCEDURE SETTRACEDATAON ;
    PROCEDURE SETTRACEDATAON
    (
	ISBTRACEOUTPUT IN VARCHAR2,
	ISBOBJECT      IN VARCHAR2
    );
    PROCEDURE SETTRACEDATAOFF ;
    PROCEDURE VALIDEXECINDIVIDUALFORM
    (
	ISBFORMA	IN SA_EXECUTABLE.NAME%TYPE
    ) ;
    PROCEDURE SETSQLTRACEOFF ;
    PROCEDURE SETSQLTRACEON ;
    FUNCTION FNUGETCOLUMNSIZE
    (
	ISBTABLENAME	IN	USER_TAB_COLUMNS.TABLE_NAME%TYPE,
	ISBCOLUMNNAME	IN	USER_TAB_COLUMNS.COLUMN_NAME%TYPE
    )
    RETURN NUMBER ;
    FUNCTION FNUGETMINVALUE
    (
	ISBTABLA	IN	VARCHAR2,
	ISBEXPRESION	IN	VARCHAR2,
	ISBWHERE	IN	VARCHAR2 DEFAULT NULL
    )
    RETURN NUMBER ;
    PROCEDURE RESETSEQUENCE
    (ISBSEQUENCENAME IN VARCHAR2,
     INUSTARTWITH    IN NUMBER DEFAULT 1);
    FUNCTION FDTGREATHERDATE( IDTDATE1 IN DATE,
                          IDTDATE2 IN DATE )
    RETURN DATE;
    FUNCTION FSBVERSION  RETURN VARCHAR2;
   	PROCEDURE VALYEARWITHCURRENT (INUYEAR 	IN 	NUMBER);
    FUNCTION FNUGETNUMBERYEAR (IDTDATE 	IN DATE) RETURN NUMBER;
   	PROCEDURE VALMONTH (INUMONTH 	IN 	NUMBER);

    FUNCTION FNUGETNUMBERORHASHOFSTRING
    (
        ISBSTRING	IN	VARCHAR2,
        INUBASE     IN  NUMBER,
        INUSIZE     IN  NUMBER
    ) RETURN NUMBER;
    
    PROCEDURE EXTPARAMFORSTRING
    (
      ISBSTRING         IN VARCHAR2,
      ISBDELSTRING      IN VARCHAR2,
      ISBDELPARAM       IN VARCHAR2,
      ISBDELVALUE       IN VARCHAR2,
      IOTBPARAMETERS    IN OUT NOCOPY UT_STRING.TYTB_STRPARAMETERS,
      ISBINITSTRING     IN VARCHAR2 DEFAULT NULL
   );
   
    
    PROCEDURE VALIDATEDATENULLITY
    (
        IDTDATE IN  DATE
    );

   FUNCTION FNUIDPROCESO RETURN NUMBER;
   
    
    PROCEDURE VALFORMATOFECHA
    (
        ISBFECHA    IN  VARCHAR2,
        ISBFORMATO  IN  VARCHAR2
    );
    
    
    PROCEDURE VALFECHAMENORACTUAL
    (
        IDTFECHA    IN  DATE
    );

    PROCEDURE VALRANGOHORAS
    (
        INUHORAINI	IN	NUMBER,
        INUHORAFIN	IN	NUMBER
    );
    
    PROCEDURE CREARSAVEPOINTX;
    
    PROCEDURE CREARSAVEPOINT(ISBSAVEPOINT IN VARCHAR2);
    
    PROCEDURE ROLLBACKTRANSACTIONTO(ISBSAVEPOINT IN VARCHAR2);
    
    
    PROCEDURE ACTIVARRASTREO
    (
        INUNIVELRASTREO IN  NUMBER DEFAULT GCNUNIVELRASTREODEF  ,
        INUTIPORASTREO  IN  NUMBER DEFAULT GCNUTIPORASTREOSTDOUT
    );
    
    
    PROCEDURE DESACTIVARRASTREO;
    
    
    PROCEDURE DESPLEGARRASTREO
    (
        ISBDATOS        IN  VARCHAR2                          ,
        INUNIVELRASTREO IN  NUMBER DEFAULT GCNUNIVELRASTREODEF
    );
    
    
    PROCEDURE VALRUTAARCHIVO
    (
        ISBRUTA IN  VARCHAR2
    );
    
    
    PROCEDURE VALARCHIVO
    (
        ISBRUTA     IN  VARCHAR2,
        ISBNOMBRE   IN  VARCHAR2
    );
    
    
    PROCEDURE SETTERMINAL
    (
        ISBTERMINAL IN VARCHAR2
    );
    
    
    PROCEDURE OPENREFCURSORWITHDYNAMICSQL
    (
        ISBSENTENCE IN  VARCHAR2,
        OCUCURSOR   OUT PKCONSTANTE.TYREFCURSOR
    );
    
    FUNCTION FBOEXEDYNBOLFUNCTION
    (
        ISBPARTIALSENTENCE      IN      VARCHAR2
    )
    RETURN BOOLEAN;
   
END PKGENERALSERVICES;

PACKAGE BODY pkGeneralServices AS










































































































	CSBVERSION CONSTANT VARCHAR2(250) := 'SAO295862' ;

    
    
    
    SBFUNCIONARIO		FUNCIONA.FUNCCODI%TYPE; 
    SBUSUARIO			VARCHAR2(100);			
    SBPASSWORD			VARCHAR2(100);			
    SBCONNECT_STRING    VARCHAR2(50);			
    SBPATHUSERREPORTS   VARCHAR2(256);			
    SBPATHSQLREPORTS    VARCHAR2(256);			
    SBTRACEOUTPUT		VARCHAR2(20);			
    SBOBJECT			OPENFLTR.OPFTOBJE%TYPE; 
    SBTERM				OPENFLTR.OPFTTERM%TYPE; 
    SBUSER				OPENFLTR.OPFTUSER%TYPE; 
    GBLTRACEDATA		BOOLEAN := FALSE;		
    GSBTERMINAL			VARCHAR2(64);	
    GNUSESSIONID		NUMBER ;				
    GSBUSER             VARCHAR2(50);           

    
    GBLRASTREOACTIVO    BOOLEAN := FALSE;
    
    GNUNIVELRASTREO     NUMBER;
    
    GNUTIPORASTREO      NUMBER;
    
    
    
    
    CNULINESIZE   	CONSTANT NUMBER(2)     := 80; 

	CNUYEARBAD	    CONSTANT NUMBER		  := 11410;
	CNUMONTHBAD		CONSTANT NUMBER		  := 10058;
	
	CNUNULLDATE    CONSTANT MENSAJE.MENSCODI%TYPE := 18501;

    
    
    
    
    FUNCTION FNUGETNEXTSEQUENCEVAL_TROFF
    (
        SBSEQUENCENAME IN VARCHAR2
    ) RETURN NUMBER;
    
    PROCEDURE TRACEINSERTION
    (
	ISBSTRING VARCHAR2
    );
    PROCEDURE TRACEDISPLAY
    (
	ISBSTRING VARCHAR2
    );














PROCEDURE TRACEDISPLAY
(
    ISBSTRING VARCHAR2
)
IS
    NUPOSINI NUMBER DEFAULT 1;  
BEGIN
    WHILE (TRUE) LOOP
        
        
        IF LENGTH(SUBSTR(ISBSTRING,NUPOSINI,LENGTH(ISBSTRING)))>CNULINESIZE THEN
            
            DBMS_OUTPUT.PUT_LINE(SUBSTR(ISBSTRING,NUPOSINI,CNULINESIZE));
            
            
            NUPOSINI:=NUPOSINI+CNULINESIZE;
        ELSE
            
            
            DBMS_OUTPUT.PUT_LINE(SUBSTR(ISBSTRING,NUPOSINI,LENGTH(ISBSTRING)));
            RETURN;
        END IF;
    END LOOP;
END TRACEDISPLAY;






























PROCEDURE TRACEINSERTION
(
    ISBSTRING VARCHAR2
)
IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    NUCONSECU NUMBER;
    CNUSEQUENCE CONSTANT VARCHAR2(50) := 'SQ_OPENFLTR_OPFTCONS';

    CNUMAX    CONSTANT NUMBER := 2000;
    NUPOSINI  NUMBER ;

    PROCEDURE INSTRAZA (ISBPEDAZO VARCHAR2) IS
    BEGIN
        
        NUCONSECU := FNUGETNEXTSEQUENCEVAL_TROFF(CNUSEQUENCE);
        INSERT INTO OPENFLTR (OPFTCONS,OPFTOBJE,OPFTTERM,OPFTUSER,OPFTFECH,OPFTDESC)
        VALUES (NUCONSECU, SBOBJECT, SBTERM, SBUSER, SYSDATE, ISBPEDAZO);
        COMMIT;
    END;

BEGIN

    NUPOSINI := 1;

    WHILE (TRUE) LOOP
        
        
        IF LENGTH(SUBSTR(ISBSTRING,NUPOSINI,LENGTH(ISBSTRING)))>CNUMAX THEN
            
            INSTRAZA (SUBSTR(ISBSTRING,NUPOSINI,CNUMAX));
            
            
            NUPOSINI:=NUPOSINI+CNUMAX;
        ELSE
            
            
            INSTRAZA (SUBSTR(ISBSTRING,NUPOSINI,LENGTH(ISBSTRING)));
            RETURN;
        END IF;
    END LOOP;

END TRACEINSERTION;




















PROCEDURE CALCULATEDATEDIFFERENCE
    (
	IDTFECHINIC  IN    DATE,
	IDTFECHFINA  IN    DATE,
	ONUDIFEDIAS  OUT   NUMBER,
	ONUDIFEHORA  OUT   NUMBER,
	ONUDIFEMINU  OUT   NUMBER,
	ONUDIFESEGU  OUT   NUMBER
    )
IS
    
    NUPORCDIA    NUMBER ;	    
    NURESIDUO	 NUMBER ;	    
    SBERRMSG	 VARCHAR2(2000);    
    
    CNUTOT_SEG_DIA    CONSTANT NUMBER := 86400 ;    
    CNUTOT_SEG_HORA   CONSTANT NUMBER := 3600 ;	    
    CNUTOT_SEG_MINU   CONSTANT NUMBER := 60 ;	    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.CalculateDateDifference');
    
    ONUDIFEDIAS := TRUNC ( IDTFECHFINA - IDTFECHINIC ) ;
    
    NUPORCDIA   := ( IDTFECHFINA - IDTFECHINIC ) - ONUDIFEDIAS ;
    
    ONUDIFESEGU := ROUND ( ( CNUTOT_SEG_DIA * NUPORCDIA ), 0 ) ;
    
    ONUDIFEHORA := TRUNC ( ONUDIFESEGU / CNUTOT_SEG_HORA ) ;
    
    NURESIDUO   := MOD ( ONUDIFESEGU , CNUTOT_SEG_HORA ) ;
    
    ONUDIFEMINU := TRUNC ( NURESIDUO / CNUTOT_SEG_MINU ) ;
    
    ONUDIFESEGU := MOD ( NURESIDUO , CNUTOT_SEG_MINU ) ;
    PKERRORS.POP;
EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END CALCULATEDATEDIFFERENCE;












PROCEDURE COMMITTRANSACTION IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.CommitTransaction');
    COMMIT;
    PKERRORS.POP;
    EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END COMMITTRANSACTION;























PROCEDURE EXECDYNAMICFUNCTION
(
    ISBPROCDYANM	IN	VARCHAR2,
    ONUVALORFUNC	OUT	NUMBER
)
IS
			    
    NUCURSORHANDLE      NUMBER;
			    
    SBSENTENCE		VARCHAR2(2000);
			    
    NUDBMSSQL_ERR	NUMBER;
    
    PROCEDURE CLOSECURSOR IS
    BEGIN
        IF DBMS_SQL.IS_OPEN(NUCURSORHANDLE) THEN
            DBMS_SQL.CLOSE_CURSOR(NUCURSORHANDLE);
        END IF;
    END;
    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ExecDynamicFunction');
    
    NUCURSORHANDLE := DBMS_SQL.OPEN_CURSOR;
    
    SBSENTENCE := 'begin :nuValorFunc := '||ISBPROCDYANM||'; end;';
    DBMS_SQL.PARSE(NUCURSORHANDLE, SBSENTENCE, DBMS_SQL.NATIVE);
    
    DBMS_SQL.BIND_VARIABLE(NUCURSORHANDLE,':nuValorFunc',ONUVALORFUNC);
    NUDBMSSQL_ERR := DBMS_SQL.EXECUTE(NUCURSORHANDLE);
    DBMS_SQL.VARIABLE_VALUE(NUCURSORHANDLE,':nuValorFunc',ONUVALORFUNC);

    CLOSECURSOR;
    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        CLOSECURSOR;
    	PKERRORS.POP;
    	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        CLOSECURSOR;
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	    PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        CLOSECURSOR;
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END EXECDYNAMICFUNCTION;























PROCEDURE EXECDYNAMICFUNCTION
(
    ISBPROCDYANM	IN	VARCHAR2,
    OSBVALORFUNC	OUT     VARCHAR2
)
IS
			    
    NUCURSORHANDLE      NUMBER;
			    
    SBSENTENCE		VARCHAR2(2000);
			    
    NUDBMSSQL_ERR	NUMBER;
    
    CNUMAX_SIZE         CONSTANT NUMBER := 2000;
    
    PROCEDURE CLOSECURSOR IS
    BEGIN
        IF DBMS_SQL.IS_OPEN(NUCURSORHANDLE) THEN
            DBMS_SQL.CLOSE_CURSOR(NUCURSORHANDLE);
        END IF;
    END;
    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ExecDynamicFunction');
    
    NUCURSORHANDLE := DBMS_SQL.OPEN_CURSOR;
    
    SBSENTENCE := 'begin :sbValorFunc := '||ISBPROCDYANM||'; end;';
    DBMS_SQL.PARSE(NUCURSORHANDLE, SBSENTENCE, DBMS_SQL.NATIVE);
    
    DBMS_SQL.BIND_VARIABLE
        (
            NUCURSORHANDLE,
            ':sbValorFunc',
            OSBVALORFUNC,
            CNUMAX_SIZE
        );
    NUDBMSSQL_ERR := DBMS_SQL.EXECUTE(NUCURSORHANDLE);
    DBMS_SQL.VARIABLE_VALUE(NUCURSORHANDLE,':sbValorFunc',OSBVALORFUNC);

    CLOSECURSOR;
    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        CLOSECURSOR;
    	PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        CLOSECURSOR;
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        CLOSECURSOR;
    	PKERRORS.POP;
	    RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END EXECDYNAMICFUNCTION;












PROCEDURE EXECUTEDYNAMICPLSQL
    (
	SBDYNAMICPROC		IN 	VARCHAR2
    )
    IS
    SBDYNAMICPL		VARCHAR2(2000);
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ExecuteDynamicPlSql');
    
    SBDYNAMICPL := 'begin ' || SBDYNAMICPROC || ' end;' ;
    
    EXECUTEDYNAMICSQL( SBDYNAMICPL );-------------****diana
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END EXECUTEDYNAMICPLSQL;











PROCEDURE EXECUTEDYNAMICSQL
    (
	ISBSENTENCE		IN	VARCHAR2
    )
IS
    NUCURSORHANDLE	NUMBER;		
    NURECORDNUMBER	NUMBER;		
    
    PROCEDURE CLOSECURSOR IS
    BEGIN
        IF DBMS_SQL.IS_OPEN(NUCURSORHANDLE) THEN
            DBMS_SQL.CLOSE_CURSOR(NUCURSORHANDLE);
        END IF;
    END;
    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ExecuteDynamicSql');
    
    NUCURSORHANDLE := DBMS_SQL.OPEN_CURSOR;
    
    DBMS_SQL.PARSE( NUCURSORHANDLE, ISBSENTENCE, DBMS_SQL.NATIVE );
    
    NURECORDNUMBER := DBMS_SQL.EXECUTE( NUCURSORHANDLE );

    CLOSECURSOR;
    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
        CLOSECURSOR;
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        CLOSECURSOR;
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        CLOSECURSOR;
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END EXECUTEDYNAMICSQL;

FUNCTION EXECUTEPIPE (ISBCOMANDO 	IN 	VARCHAR2,
		      ISBCANAL	        IN	VARCHAR2)
RETURN NUMBER IS















NUSTATUS NUMBER;		
BEGIN
    PKERRORS.PUSH('pkExeComand.ExecutePipe');
    DBMS_PIPE.PACK_MESSAGE(ISBCOMANDO);
    NUSTATUS := DBMS_PIPE.SEND_MESSAGE (ISBCANAL);
    IF NUSTATUS <> PKCONSTPARSER.OK THEN
	RETURN (PKCONSTPARSER.NOK);
    END IF;
    PKERRORS.POP;
    RETURN (PKCONSTPARSER.OK);
END EXECUTEPIPE;












PROCEDURE ROLLBACKTRANSACTION IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.RollBackTransaction');
    ROLLBACK;
    PKERRORS.POP;
    EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END ROLLBACKTRANSACTION;












PROCEDURE ROLLBACKTRANSACTIONTOX IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.RollBackTransactionToX');
    ROLLBACK TO X;
    PKERRORS.POP;
    EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END ROLLBACKTRANSACTIONTOX;











PROCEDURE SETCONNECT_STRING
    (
	ISBCONNECT_STRING	IN	VARCHAR2
    )
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetConnect_String');
    
    SBCONNECT_STRING := ISBCONNECT_STRING ;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETCONNECT_STRING;











PROCEDURE SETPASSWORD
    (
	ISBPASSWORD	IN	VARCHAR2
    )
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetPassword');
    
    SBPASSWORD := ISBPASSWORD ;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETPASSWORD;











PROCEDURE SETPATHSQLREPORTS
    (
	ISBPATHSQLREPORTS	IN	VARCHAR2
    )
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetPathSqlReports');
    
    SBPATHSQLREPORTS := ISBPATHSQLREPORTS ;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETPATHSQLREPORTS;











PROCEDURE SETPATHUSERREPORTS
    (
	ISBPATHUSERREPORTS	IN	VARCHAR2
    )
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetPathUserReports');
    
    SBPATHUSERREPORTS := ISBPATHUSERREPORTS ;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETPATHUSERREPORTS;











PROCEDURE SETSERVICEREP
    (
	ISBFUNCIONA	IN	FUNCIONA.FUNCCODI%TYPE
    )
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetServiceRep');
    
    SBFUNCIONARIO := ISBFUNCIONA ;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETSERVICEREP;











PROCEDURE SETSQLTRACEOFF
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetSqlTraceOff');
    SYS.DBMS_SESSION.SET_SQL_TRACE (FALSE);
    PKERRORS.POP;
EXCEPTION
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETSQLTRACEOFF;











PROCEDURE SETSQLTRACEON
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetSqlTraceOn');
    SYS.DBMS_SESSION.SET_SQL_TRACE (TRUE);
    PKERRORS.POP;
EXCEPTION
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETSQLTRACEON;












PROCEDURE SETTRACEDATAOFF
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetTraceDataOff');
    
    GBLTRACEDATA := FALSE ;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETTRACEDATAOFF;




















PROCEDURE SETTRACEDATAON
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetTraceDataOn(1)');
    
    GBLTRACEDATA := TRUE ;
    SBTRACEOUTPUT:= 'DP';
    SBOBJECT     := NULL;

    ERRORS.SET_PUSH_DB_OFF;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETTRACEDATAON;























PROCEDURE SETTRACEDATAON
(
    ISBTRACEOUTPUT IN VARCHAR2,
    ISBOBJECT	   IN VARCHAR2
)
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.SetTraceDataOn(2)');
    
    GBLTRACEDATA := TRUE ;
    SBTRACEOUTPUT:= ISBTRACEOUTPUT;
    SBOBJECT 	 := ISBOBJECT;
    
    SBTERM 	 := USERENV('TERMINAL');
    SBUSER     	 := USER;

    ERRORS.SET_PUSH_DB_ON;
    ERRORS.SBOBJECTTRC := SBOBJECT;
    ERRORS.SBTERM      := SBTERM  ;
    ERRORS.SBUSER      := SBUSER  ;

    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END SETTRACEDATAON;

PROCEDURE TABLETRUNCATE (SBTABLTRUNC IN VARCHAR2) IS













    CUSQLDDLTRN INTEGER;
    SBCMDSQL VARCHAR2(256);
    NURET    INTEGER;
    
    PROCEDURE CLOSECURSOR IS
    BEGIN
        IF DBMS_SQL.IS_OPEN(CUSQLDDLTRN) THEN
            DBMS_SQL.CLOSE_CURSOR(CUSQLDDLTRN);
        END IF;
    END;
    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.TableTruncate');
    SBCMDSQL := 'truncate table ' || SBTABLTRUNC;
    IF (SYS.DBMS_SQL.IS_OPEN(CUSQLDDLTRN) = FALSE) THEN
        CUSQLDDLTRN := SYS.DBMS_SQL.OPEN_CURSOR;
    END IF;
    SYS.DBMS_SQL.PARSE(CUSQLDDLTRN, SBCMDSQL, DBMS_SQL.V7);
    NURET := SYS.DBMS_SQL.EXECUTE(CUSQLDDLTRN);

    CLOSECURSOR;
    PKERRORS.POP;

EXCEPTION
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	CLOSECURSOR;
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END TABLETRUNCATE;













PROCEDURE TRACEDATA
    (
	SBSTRING    IN    VARCHAR2
    )
IS
BEGIN
    
    
    
    IF ( GBLTRACEDATA ) THEN
    	IF ( SBTRACEOUTPUT = 'DB' ) THEN
    	    
    	    TRACEINSERTION( SBSTRING );
    	ELSE
    	    
    	    TRACEDISPLAY( SBSTRING );
    	END IF;
    END IF ;
END TRACEDATA;













PROCEDURE VALCURRENTDATE
    (
	IDTFECHA	IN	DATE
    )
    IS
    CNUINVALID_DATE	CONSTANT NUMBER := 1045;	
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValCurrentDate');
    
    IF ( IDTFECHA IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( TRUNC( IDTFECHA ) < TRUNC( SYSDATE ) ) THEN
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
    EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_DATE);
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALCURRENTDATE;


















PROCEDURE VALCURRENTDATETIME
    (
	IDTFECHA	IN	DATE
    )
    IS
    CNUINVALID_DATE	CONSTANT NUMBER := 1045;
    CNUDATENULL         CONSTANT NUMBER := 4113;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValCurrentDateTime');
    
    IF ( IDTFECHA IS NULL ) THEN
        PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
                                PKCONSTANTE.CSBMOD_SAT,
                                CNUDATENULL);
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    END IF;
    
    IF ( IDTFECHA < SYSDATE ) THEN
            	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_DATE);
            	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_DATE);
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALCURRENTDATETIME;














PROCEDURE VALDATEGREATER
    (
	IDTFECHAINICIAL	IN	DATE,
	IDTFECHAFINAL	IN	DATE
    )
    IS
    CNUFECHA_INICIAL_MAYOR	CONSTANT NUMBER := 8101;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValDateGreater');
    IF ( IDTFECHAINICIAL > IDTFECHAFINAL ) THEN
	PKERRORS.SETERRORCODE( CNUFECHA_INICIAL_MAYOR );
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
    EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALDATEGREATER;













PROCEDURE VALDATEGREATERCURRENT
    (
	IDTFECHA	IN	DATE
    )
    IS
    CNUINVALID_DATE	CONSTANT NUMBER := 2126;	
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValDateGreaterCurrent');
    
    IF ( IDTFECHA IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( TRUNC( IDTFECHA ) < TRUNC( SYSDATE ) ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIV_GES,
				PKCONSTANTE.CSBMOD_LIQ,
				CNUINVALID_DATE);
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALDATEGREATERCURRENT;















PROCEDURE VALDATELESSCURRENT
    (
	IDTFECHA	IN	DATE
    )
    IS
    CNUINVALID_DATE	CONSTANT NUMBER := 10034;	
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValDateLessCurrent');
    
    IF ( IDTFECHA IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( TRUNC( IDTFECHA ) > TRUNC( SYSDATE ) ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_DATE);
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALDATELESSCURRENT;














PROCEDURE VALDATERANGE
    (
	IDTFECHAINI	IN	DATE,
	IDTFECHAFIN	IN	DATE
    )
    IS
    CNUINVALID_RANGE	CONSTANT NUMBER := 1042;	
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValDateRange');
    
    IF ( IDTFECHAINI IS NULL OR IDTFECHAFIN IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( TRUNC( IDTFECHAINI ) > TRUNC( IDTFECHAFIN ) ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_RANGE);
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALDATERANGE;














PROCEDURE VALDATERANGEANDSYSDATE
    (
	IDTFECHAINI	IN	DATE,
	IDTFECHAFIN	IN	DATE
    )
    IS
    CNUINVALID_RANGE	CONSTANT NUMBER := 1042;
    CNUDATENULL      	CONSTANT NUMBER := 4113;
    CNUINVALID_SYSDATE 	CONSTANT NUMBER := 9047;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValDateRangeAndSysdate');
    
    IF ( IDTFECHAINI IS NULL OR IDTFECHAFIN IS NULL ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_SAT,
				CNUDATENULL);
	RAISE LOGIN_DENIED;
    END IF;
    
    IF ( TRUNC( IDTFECHAINI ) > TRUNC( IDTFECHAFIN ) ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_RANGE);
	RAISE LOGIN_DENIED;
    END IF;
    
    IF ( TRUNC( SYSDATE ) > TRUNC( IDTFECHAINI ) ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_SAT,
				CNUINVALID_SYSDATE);
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALDATERANGEANDSYSDATE;
















PROCEDURE VALDATETIMERANGE
    (
	IDTFECHAINI	IN	DATE,
	IDTFECHAFIN	IN	DATE
    )
    IS
    CNUINVALID_RANGE	CONSTANT NUMBER := 1042;
    CNUDATENULL      	CONSTANT NUMBER := 4113;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValDateTimeRange');
    
    IF ( IDTFECHAINI IS NULL OR IDTFECHAFIN IS NULL ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_SAT,
				CNUDATENULL);
	RAISE LOGIN_DENIED;
    END IF;
    
    IF ( IDTFECHAINI > IDTFECHAFIN ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_RANGE);
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALDATETIMERANGE;













PROCEDURE VALDATEY2K
    (
	DTFECHA	IN	DATE
    )
    IS
    SBANO	VARCHAR2(10);	
    NUANO	NUMBER(4);	
    CNUMILENIO	CONSTANT NUMBER(4) := 1000; 		
    CSBFORMATO_ANO	CONSTANT VARCHAR2(4) := 'yyyy';	
		    
    CNUFECHA_NO_CUMPLE_Y2K	CONSTANT NUMBER := 9549;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValDateY2K');
    
    SBANO := TO_CHAR( DTFECHA, CSBFORMATO_ANO );
    IF ( SBANO IS NULL ) THEN
	RAISE LOGIN_DENIED;
    END IF;
    NUANO := TO_NUMBER( SBANO );
    IF ( NUANO < CNUMILENIO ) THEN
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.SETERRORCODE( CNUFECHA_NO_CUMPLE_Y2K );
	PKERRORS.POP;
	RAISE;
    WHEN OTHERS THEN
	RAISE;
END VALDATEY2K;












PROCEDURE VALIDENTIFIERISVALID
    (
	ISBCADENA	IN	VARCHAR2
    )
IS
    SBCADUPPER			VARCHAR2(500);
    NUCURRCHAR			NUMBER;
    NUINDICE			NUMBER;
    CNUIDENTIFIERNOTVALID	CONSTANT NUMBER := 10073;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValIdentifierIsValid');
    SBCADUPPER := UPPER(ISBCADENA);
    
    IF ( SBCADUPPER IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( LENGTH(SBCADUPPER) > 30) THEN
        PKERRORS.SETERRORCODE(PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_LIQ,
        CNUIDENTIFIERNOTVALID);
        RAISE LOGIN_DENIED;
    END IF;
    
    NUCURRCHAR := ASCII(SUBSTR(SBCADUPPER,1,1));
    IF (NUCURRCHAR < 65 OR NUCURRCHAR > 90) THEN
        PKERRORS.SETERRORCODE(PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_LIQ,
        CNUIDENTIFIERNOTVALID);
        RAISE LOGIN_DENIED;
    END IF;
    
    
    FOR NUINDICE IN 2..LENGTH(SBCADUPPER) LOOP
        NUCURRCHAR := ASCII(SUBSTR(SBCADUPPER,NUINDICE,1));
        IF NOT  ( (NUCURRCHAR >= 65 AND NUCURRCHAR <= 90) OR
                  (NUCURRCHAR >= 48 AND NUCURRCHAR <= 57) OR
                   NUCURRCHAR = 36  OR  NUCURRCHAR = 95
                )
        THEN
        	PKERRORS.SETERRORCODE(PKCONSTANTE.CSBDIVISION,
				      PKCONSTANTE.CSBMOD_LIQ,
                                      CNUIDENTIFIERNOTVALID );
                RAISE LOGIN_DENIED;
	END IF;
    END LOOP;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALIDENTIFIERISVALID;













PROCEDURE VALPERCENTAGE
    (
	INUPORCENTAJE	IN	NUMBER
    )
    IS
    CNUBAD_PERCENTAGE	CONSTANT NUMBER := 1044; 
    CNUMAXPERC		CONSTANT NUMBER := 100.00;	 
    CNUMINPERC		CONSTANT NUMBER := 0.00;	 
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValPercentage');
    
    IF ( INUPORCENTAJE IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( INUPORCENTAJE > CNUMAXPERC OR INUPORCENTAJE < CNUMINPERC ) THEN
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
    EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
				CNUBAD_PERCENTAGE );
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALPERCENTAGE;











PROCEDURE VALVALUEEQUALGREATERZERO
    (
	INUVALUE	IN	NUMBER
    )
IS
    CNUEQUAL_GREATER_THAN_ZERO	CONSTANT NUMBER := 10404;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValValueEqualGreaterZero');
    
    IF ( INUVALUE IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( INUVALUE < 0 ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_BIL,
				CNUEQUAL_GREATER_THAN_ZERO );
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALVALUEEQUALGREATERZERO;


















PROCEDURE VALVALUEISPOSITIVE
    (
	INUVALUE	IN	NUMBER,
	INUCACHE	IN	NUMBER DEFAULT NULL
    )
IS
    CNUGREATER_THAN_ZERO	CONSTANT NUMBER := 6025;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValValueIsPositive');
    
    IF ( INUVALUE IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( INUVALUE <= 0 ) THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
				PKCONSTANTE.CSBMOD_SAT,
				CNUGREATER_THAN_ZERO );
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALVALUEISPOSITIVE;














PROCEDURE VALVALUERANGE
    (
	INUVALORINI	IN	NUMBER,
	INUVALORFIN	IN	NUMBER
    )
    IS
    CNUINVALID_RANGE	CONSTANT NUMBER := 1043;	
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValValueRange');
    
    IF ( INUVALORINI IS NULL OR INUVALORFIN IS NULL ) THEN
	PKERRORS.POP;
	RETURN;
    END IF;
    
    IF ( INUVALORINI > INUVALORFIN ) THEN
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
    EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_RANGE );
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALVALUERANGE;

















PROCEDURE VALIDEXECINDIVIDUALFORM
    (
	ISBFORMA	IN SA_EXECUTABLE.NAME%TYPE
    )
    IS
    SBWHERE	VARCHAR2(100);	
    
    CNUEJECUCION_NO_PERMITIDA	CONSTANT NUMBER := 10205;
    
    CNUASCII_COMILLA	CONSTANT NUMBER := 39;
    NUNUMBEROFRECS	NUMBER;	
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValidExecIndividualForm');
    
    SBWHERE :=  'FROM as_itemmenu WHERE itmeform = ' || CHR(CNUASCII_COMILLA)
		|| UPPER(ISBFORMA) || CHR(CNUASCII_COMILLA);
    NUNUMBEROFRECS := PKGENERALSERVICES.FNUGETNUMBEROFRECS (SBWHERE);
    IF ( NUNUMBEROFRECS = 0 ) THEN
	PKERRORS.SETERRORCODE
	    (
		PKCONSTANTE.CSBDIVISION,
		PKCONSTANTE.CSBMOD_CUS,
		CNUEJECUCION_NO_PERMITIDA
	    );
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALIDEXECINDIVIDUALFORM;















PROCEDURE VALIDOBJECT
    (
	ISBOBJECTNAME	IN	VARCHAR2
    )
    IS
    
    CSBVALIDOBJECT	CONSTANT USER_OBJECTS.STATUS%TYPE:='VALID';
    
    CNUINVALIDOBJECT	CONSTANT MENSAJE.MENSCODI%TYPE := 10017;
    SBSTATUS		USER_OBJECTS.STATUS%TYPE;
    SBERRMSG		VARCHAR2(2000);
    CURSOR CUUSER_OBJECTS IS
    SELECT STATUS
    FROM   USER_OBJECTS
    WHERE  OBJECT_NAME = ISBOBJECTNAME
    AND	   STATUS      = CSBVALIDOBJECT;
BEGIN
    PKERRORS.PUSH ( 'pkGeneralServices.ValidObject' );
    OPEN CUUSER_OBJECTS;
    FETCH CUUSER_OBJECTS INTO SBSTATUS;
    IF ( CUUSER_OBJECTS%NOTFOUND ) THEN
	CLOSE CUUSER_OBJECTS;
	PKERRORS.SETERRORCODE
	    (
		PKCONSTANTE.CSBDIVISION,
		PKCONSTANTE.CSBMOD_GRL,
		CNUINVALIDOBJECT
	    );
       RAISE LOGIN_DENIED;
    END IF;
    CLOSE CUUSER_OBJECTS;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	IF ( CUUSER_OBJECTS%ISOPEN ) THEN
	    CLOSE CUUSER_OBJECTS;
	END IF;
	RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	IF ( CUUSER_OBJECTS%ISOPEN ) THEN
	    CLOSE CUUSER_OBJECTS;
	END IF;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END;



























PROCEDURE VALIDATEYESORNOT
(
    INUCAMPO    IN VARCHAR2,
    ICNUCACHE   IN NUMBER DEFAULT 0
)
IS
    CSBSI CONSTANT VARCHAR2(1) := PKCONSTANTE.SI;
    CSBNO CONSTANT VARCHAR2(1) := PKCONSTANTE.NO;
    CNUCAMPO_NO_VALI  CONSTANT  NUMBER  := 44;
BEGIN
    PKERRORS.PUSH( 'pkGeneralServices.ValidateYesOrNot' );
    IF (UPPER( INUCAMPO ) NOT IN (CSBSI,CSBNO)) THEN
	PKERRORS.SETERRORCODE( PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_SAT,
			CNUCAMPO_NO_VALI );
	RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END VALIDATEYESORNOT;



















FUNCTION FBOHASRECORDS
    (
	ISBQUERY	IN	VARCHAR2
    )
    RETURN BOOLEAN
    IS
    NURECORDS	NUMBER;		
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fboHasRecords');
    
    NURECORDS := PKGENERALSERVICES.FNUGETNUMBEROFRECS ( ISBQUERY );
    IF ( NURECORDS = 0 ) THEN
	PKERRORS.POP;
	RETURN ( FALSE );
    END IF;
    PKERRORS.POP;
    RETURN( TRUE );
EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FBOHASRECORDS;




















FUNCTION FDTGETMAXDATE RETURN DATE IS
BEGIN
   PKERRORS.PUSH('pkGeneralServices.fdtGetMaxDate');
    
   PKERRORS.POP;
   RETURN TO_DATE('31-12-4732 23:59:59','dd-mm-yyyy hh24:mi:ss');
 EXCEPTION
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FDTGETMAXDATE;













FUNCTION FDTGETSYSTEMDATE RETURN DATE IS
BEGIN
    
    RETURN( SYSDATE );
END FDTGETSYSTEMDATE;














FUNCTION FNUCOUNTNUMOFRECS
(
        ISBWHERE    IN   VARCHAR2
)
RETURN NUMBER
IS
    NUNUM           NUMBER;            
    SBSTATMENT	VARCHAR2 (2000);       
    
    NUCURSORHANDLE      NUMBER;         
    NURECORDNUMBER      NUMBER;         
    
    PROCEDURE CLOSECURSOR IS
    BEGIN
        IF DBMS_SQL.IS_OPEN(NUCURSORHANDLE) THEN
            DBMS_SQL.CLOSE_CURSOR(NUCURSORHANDLE);
        END IF;
    END;

BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuCountNumOfRecs');
    
    SBSTATMENT := ISBWHERE;
    
    NUCURSORHANDLE := DBMS_SQL.OPEN_CURSOR;
    
    DBMS_SQL.PARSE( NUCURSORHANDLE, SBSTATMENT, DBMS_SQL.NATIVE );
    
    NURECORDNUMBER := DBMS_SQL.EXECUTE ( NUCURSORHANDLE );
    
    
    DBMS_SQL.DEFINE_COLUMN(NUCURSORHANDLE ,1, NUNUM);
    
    NURECORDNUMBER := DBMS_SQL.FETCH_ROWS ( NUCURSORHANDLE );
    
    DBMS_SQL.COLUMN_VALUE (NUCURSORHANDLE,1,NUNUM);

    CLOSECURSOR;
    PKERRORS.POP;
    RETURN (NUNUM);

EXCEPTION
    WHEN LOGIN_DENIED THEN
        CLOSECURSOR;
        PKERRORS.POP;
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        CLOSECURSOR;
        PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        CLOSECURSOR;
        PKERRORS.POP;
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUCOUNTNUMOFRECS;


















FUNCTION FNUGETCOLUMNSIZE
    (
	ISBTABLENAME	IN	USER_TAB_COLUMNS.TABLE_NAME%TYPE,
	ISBCOLUMNNAME	IN	USER_TAB_COLUMNS.COLUMN_NAME%TYPE
    )
    RETURN NUMBER IS
    NUSIZE	NUMBER;	
    
    
    CURSOR CUUSER_TAB_COLUMNS
    (
	ISBTNAME	VARCHAR2,
	ISBCNAME	VARCHAR2
    )
    IS
    SELECT DECODE (DATA_TYPE, 'NUMBER', DATA_PRECISION, DATA_LENGTH)
    FROM   USER_TAB_COLUMNS
    WHERE  TABLE_NAME  = ISBTNAME
    AND    COLUMN_NAME = ISBCNAME ;
    
    
    CNUMSG_COLUMNA_NO_ENCONTRADA	CONSTANT NUMBER := 30;
BEGIN
    PKERRORS.PUSH ('pkGeneralServices.fnuGetColumnSize');
    
    OPEN CUUSER_TAB_COLUMNS (UPPER(ISBTABLENAME),UPPER(ISBCOLUMNNAME));
    FETCH CUUSER_TAB_COLUMNS INTO NUSIZE ;
    
    IF (CUUSER_TAB_COLUMNS%NOTFOUND) THEN
	CLOSE CUUSER_TAB_COLUMNS;
	PKERRORS.SETERRORCODE
	    (
		PKCONSTANTE.CSBDIVISION,
		PKCONSTANTE.CSBMOD_GRL,
		CNUMSG_COLUMNA_NO_ENCONTRADA
	    );
	RAISE LOGIN_DENIED ;
    END IF;
    
    CLOSE CUUSER_TAB_COLUMNS;
    PKERRORS.POP;
    RETURN (NUSIZE);
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
	PKERRORS.POP;
	RAISE PKCONSTANTE.EXERROR_LEVEL2 ;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR (PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
	PKERRORS.POP ;
	RAISE_APPLICATION_ERROR (PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG);
END FNUGETCOLUMNSIZE ;














FUNCTION FNUGETHEXTONUMBER(ISBHEXT IN VARCHAR2)
RETURN NUMBER IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuGetHexToNumber');
    PKERRORS.POP;
    RETURN TO_NUMBER(UPPER(ISBHEXT),'XXXXXXXXXXXXXXXX');
EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUGETHEXTONUMBER;

































FUNCTION FNUGETMINVALUE
    (
	ISBTABLA	IN	VARCHAR2,
	ISBEXPRESION	IN	VARCHAR2,
	ISBWHERE	IN	VARCHAR2 DEFAULT NULL
    )
RETURN NUMBER IS
    
    
    
    
    
    
    SBSQLSTMT	VARCHAR2(2000);
    NUVALUE	NUMBER;
    
    
    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuGetMinValue');
    IF ( ISBWHERE IS NULL ) THEN
    
	SBSQLSTMT := 'SELECT MIN('|| ISBEXPRESION || ') FROM ' || ISBTABLA;
    ELSE
	SBSQLSTMT := 'SELECT MIN('|| ISBEXPRESION || ') FROM ' || ISBTABLA ||
		     ' WHERE '|| ISBWHERE;
    
    END IF;
    
    PKGENERALSERVICES.TRACEDATA('SQL:'||SBSQLSTMT);
    EXECUTE IMMEDIATE SBSQLSTMT INTO NUVALUE;
    PKERRORS.POP;
    RETURN NUVALUE;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUGETMINVALUE;























FUNCTION FNUGETMONTHSBETWEEN (
    IDTFECHAINI         IN      DATE,
    IDTFECHAFIN         IN      DATE,
    ICHTRUNCROUND       IN      CHAR DEFAULT 'T'
)
RETURN NUMBER
IS
    CCHTRUNC		CONSTANT CHAR := 'T'; 
    CCHROUND		CONSTANT CHAR := 'R'; 
    CNUDATENULL      	CONSTANT NUMBER := 4113;
    
    NUDIFERENCE		NUMBER := 0;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuGetMonthsBetween');
    
    IF ( IDTFECHAINI IS NULL OR IDTFECHAFIN IS NULL ) THEN
        PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
                				PKCONSTANTE.CSBMOD_SAT,
                				CNUDATENULL);
       	RAISE LOGIN_DENIED;
    END IF;
    IF ICHTRUNCROUND=CCHTRUNC THEN
    	NUDIFERENCE := TRUNC (MONTHS_BETWEEN (IDTFECHAINI,IDTFECHAFIN) );
    ELSIF ICHTRUNCROUND=CCHROUND THEN
    	NUDIFERENCE := ROUND (MONTHS_BETWEEN (IDTFECHAINI,IDTFECHAFIN) );
    END IF;
    PKERRORS.POP;
    RETURN (ABS(NUDIFERENCE));
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUGETMONTHSBETWEEN;





























FUNCTION FNUGETNEXTSEQUENCEVAL
    (
	SBSEQUENCENAME		IN	VARCHAR2
    )
RETURN NUMBER IS
    INVALID_SEQUENCE            EXCEPTION;
    PRAGMA                      EXCEPTION_INIT( INVALID_SEQUENCE, -2289 );
    
    
    
    
    CNUINVALID_SEQUENCE         CONSTANT NUMBER := 10;
    
    CSBSTRING_FIND              CONSTANT VARCHAR2(1) := '%';
    
    
    
    NUNEXT	NUMBER;
    
    
    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuGetNextSequenceVal');
    EXECUTE IMMEDIATE 'SELECT '||SBSEQUENCENAME||'.nextval FROM dual'
		INTO NUNEXT;
    PKERRORS.POP;
    RETURN(NUNEXT);
EXCEPTION
    WHEN INVALID_SEQUENCE THEN
        PKERRORS.POP;
        PKERRORS.SETERRORCODE( PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
            CNUINVALID_SEQUENCE );
        PKERRORS.CHANGEMESSAGE( CSBSTRING_FIND, SBSEQUENCENAME );
        RAISE LOGIN_DENIED;
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUGETNEXTSEQUENCEVAL;




























FUNCTION FNUGETNEXTSEQUENCEVAL_TROFF
(
    SBSEQUENCENAME IN VARCHAR2
) RETURN NUMBER IS

    INVALID_SEQUENCE EXCEPTION;
    PRAGMA EXCEPTION_INIT(INVALID_SEQUENCE, -2289);

    
    
    CNUINVALID_SEQUENCE CONSTANT NUMBER := 10;  
    CSBSTRING_FIND CONSTANT VARCHAR2(1) := '%'; 

    
    
    NUNEXT NUMBER;

BEGIN

    EXECUTE IMMEDIATE 'SELECT '||SBSEQUENCENAME||'.nextval FROM dual' INTO NUNEXT;
    RETURN(NUNEXT);

EXCEPTION
    WHEN INVALID_SEQUENCE THEN
        PKERRORS.SETERRORCODE
        (
            PKCONSTANTE.CSBDIVISION,
            PKCONSTANTE.CSBMOD_GRL,
            CNUINVALID_SEQUENCE
        );
        PKERRORS.CHANGEMESSAGE(CSBSTRING_FIND, SBSEQUENCENAME);
        RAISE LOGIN_DENIED;
    WHEN LOGIN_DENIED THEN
        RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
        PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
        RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUGETNEXTSEQUENCEVAL_TROFF;



















FUNCTION FNUGETNUMBEROFRECS
    (
	ISBQUERY	IN	VARCHAR2
    )
    RETURN NUMBER
    IS
    NUFILAS	NUMBER;		
    SBCOMANDO	VARCHAR2(1000);	
    NUCURSOR	NUMBER;		
    NURESULT	NUMBER;		
    
    PROCEDURE CLOSECURSOR IS
    BEGIN
        IF DBMS_SQL.IS_OPEN(NUCURSOR) THEN
            DBMS_SQL.CLOSE_CURSOR(NUCURSOR);
        END IF;
    END;
    
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuGetNumberOfRecs');
    SBCOMANDO := 'SELECT count(*) Registros ' || ISBQUERY;
    NUCURSOR := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE( NUCURSOR, SBCOMANDO, DBMS_SQL.NATIVE );
    DBMS_SQL.DEFINE_COLUMN( NUCURSOR, 1, NUFILAS );
    NURESULT := DBMS_SQL.EXECUTE( NUCURSOR );
    NURESULT := DBMS_SQL.FETCH_ROWS( NUCURSOR );
    DBMS_SQL.COLUMN_VALUE( NUCURSOR, 1, NUFILAS );

    CLOSECURSOR;
    PKERRORS.POP;
    RETURN( NUFILAS );

EXCEPTION
    WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	CLOSECURSOR;
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUGETNUMBEROFRECS;
















FUNCTION FSBCOUNTSENTENCE (
  ISBWHERE   IN     VARCHAR2
) RETURN VARCHAR2
IS
   SBSENTENCE       VARCHAR2 (2000);
BEGIN
    PKERRORS.PUSH ('pkGeneralServices.fsbCountSentence');


    SBSENTENCE := 'Select count(*) from ( ' || ISBWHERE || ' )';
    PKERRORS.POP;
    RETURN (SBSENTENCE);
EXCEPTION
    WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
        PKERRORS.POP;
        RAISE;
END FSBCOUNTSENTENCE;













FUNCTION FSBGETCOMPLETECONNSTR
RETURN VARCHAR2 IS
    SBCOMPLETECONNSTR	VARCHAR2(256);		
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetCompleteConnStr');
    
    SBCOMPLETECONNSTR := FSBGETUSERNAME || '/' ||
			 SBPASSWORD     || '@' ||
			 SBCONNECT_STRING ;
    PKERRORS.POP;
    RETURN( SBCOMPLETECONNSTR );
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
	PKERRORS.POP;
	NULL;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETCOMPLETECONNSTR;













FUNCTION FSBGETDATEFORMAT RETURN VARCHAR2 IS
    SBFORMATO	VARCHAR2(100);		
	
    FORMATO_FECHA_BD	CONSTANT VARCHAR2(20) := 'nls_date_format';
    
    CURSOR CUPARAMETER IS
    SELECT VALUE
    FROM   V$PARAMETER
    WHERE  NAME = FORMATO_FECHA_BD;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetDateFormat');
    OPEN CUPARAMETER;
    FETCH CUPARAMETER INTO SBFORMATO;
    CLOSE CUPARAMETER;
    PKERRORS.POP;
    RETURN( SBFORMATO );
    EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETDATEFORMAT;













FUNCTION FSBGETNUMBERTOHEX(INUNUMBER IN NUMBER)
RETURN VARCHAR2 IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetNumberToHex');
    PKERRORS.POP;
    RETURN RTRIM(LTRIM(TO_CHAR(INUNUMBER,'XXXXXXXXXXXXXX')));
EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETNUMBERTOHEX;













FUNCTION FSBGETPATHSQLREPORTS
RETURN VARCHAR2 IS
BEGIN
    
    RETURN( SBPATHSQLREPORTS );
END FSBGETPATHSQLREPORTS;













FUNCTION FSBGETPATHUSERREPORTS
RETURN VARCHAR2 IS
BEGIN
    
    RETURN( SBPATHUSERREPORTS );
END FSBGETPATHUSERREPORTS;























FUNCTION FSBGETPIPENAME
    (
	ISBPIPENAME	IN	VARCHAR2,
	ISBUSERDEFAULT	IN	VARCHAR2 DEFAULT 'S'
    )
    RETURN VARCHAR2
    IS
    SBUSER	VARCHAR2(200);		
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetPipeName');
    
    IF ( ISBUSERDEFAULT = PKCONSTANTE.SI ) THEN
	SBUSER := PKGENERALPARAMETERSMGR.FSBGETSTRINGVALUE
		    (
			'DAEMON_USER'
		    );
    ELSE
	SBUSER := PKGENERALSERVICES.FSBGETUSERNAME;
    END IF;
    PKERRORS.POP;
    RETURN( ISBPIPENAME || SBUSER );
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETPIPENAME;














FUNCTION FSBGETSERVICEREP
RETURN FUNCIONA.FUNCCODI%TYPE
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetServiceRep');
    
    PKERRORS.POP;
    RETURN ( SBFUNCIONARIO ) ;
EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
    	PKERRORS.POP;
        RAISE PKCONSTANTE.EXERROR_LEVEL2;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETSERVICEREP;
















FUNCTION FSBGETSTRINGNULL
    (
	ISBTABLE	IN	VARCHAR2,
	ISBCOLUMN	IN	VARCHAR2
    )
    RETURN VARCHAR2 IS
    
    CURSOR CUCOLUMNA
        (   ISBTABLE	VARCHAR2,
	    ISBCOLUMN	VARCHAR2
	) IS
    SELECT DATA_LENGTH
    FROM   USER_TAB_COLUMNS
    WHERE  TABLE_NAME  = UPPER( ISBTABLE )
    AND    COLUMN_NAME = UPPER( ISBCOLUMN );
    SBSTRINGNULO	VARCHAR2(100);	
    NUSIZE		NUMBER;		
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetStringNull');
    
    OPEN CUCOLUMNA( ISBTABLE, ISBCOLUMN );
    FETCH CUCOLUMNA INTO NUSIZE;
    IF ( CUCOLUMNA%NOTFOUND ) THEN
	CLOSE CUCOLUMNA;
	PKERRORS.POP;
	RETURN( TO_CHAR( PKBILLCONST.NULOSAT ) );
    END IF;
    CLOSE CUCOLUMNA;
    SBSTRINGNULO := LPAD( '-', NUSIZE, '-' );
    PKERRORS.POP;
    RETURN( SBSTRINGNULO );
EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETSTRINGNULL;














FUNCTION FSBGETSYSTEMDATE RETURN VARCHAR2 IS
    SBSTRCURDATE    VARCHAR2(100);          
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetSystemDate');
    
    SBSTRCURDATE := TO_CHAR ( FDTGETSYSTEMDATE, FSBGETDATEFORMAT ) ;
    PKERRORS.POP;
    
    RETURN ( SBSTRCURDATE );
    EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETSYSTEMDATE;

























FUNCTION FSBGETTERMINAL RETURN VARCHAR2 IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetTerminal');

    
    IF ( GSBTERMINAL IS NULL ) THEN
	GSBTERMINAL := UT_SESSION.GETTERMINAL; 
    END IF ;
    PKERRORS.POP;
    RETURN (GSBTERMINAL);
EXCEPTION
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	PKERRORS.POP;
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETTERMINAL;

















FUNCTION FSBGETUSERNAME
RETURN VARCHAR2 IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fsbGetUserName');
    
    IF ( GSBUSER IS NULL ) THEN
	GSBUSER := USER ;
    END IF ;
    PKERRORS.POP;
    RETURN( GSBUSER );
    EXCEPTION
	WHEN OTHERS THEN
	    PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	    RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FSBGETUSERNAME;














PROCEDURE RESETSEQUENCE
    (ISBSEQUENCENAME IN VARCHAR2,
     INUSTARTWITH    IN NUMBER DEFAULT 1)
IS
    SBCOMMAND VARCHAR2(2000);
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ResetSequence');
    SBCOMMAND := 'Create Sequence "'||UPPER(ISBSEQUENCENAME)||'"'||
                 ' Increment by 1 '||
                 ' Start With '||TO_CHAR(INUSTARTWITH);

    EXECUTE IMMEDIATE 'Drop Sequence "'||UPPER(ISBSEQUENCENAME)||'"';
    EXECUTE IMMEDIATE SBCOMMAND;
    PKERRORS.POP;
    EXCEPTION
        WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	PKERRORS.POP;
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );

END RESETSEQUENCE;















FUNCTION FDTGREATHERDATE( IDTDATE1 IN DATE,
                          IDTDATE2 IN DATE )
RETURN DATE IS
BEGIN
    
    IF (IDTDATE1 > IDTDATE2) THEN
        RETURN( IDTDATE1 );
    ELSE
        RETURN( IDTDATE2 );
    END IF;
END FDTGREATHERDATE;




















FUNCTION FSBVERSION RETURN VARCHAR2 IS
BEGIN
	RETURN CSBVERSION;
END;



















FUNCTION FNUGETNUMBERYEAR ( IDTDATE IN DATE) RETURN NUMBER IS
BEGIN
    RETURN TO_CHAR(IDTDATE,'YYYY');
END;


















PROCEDURE VALYEARWITHCURRENT
(
	INUYEAR 	IN 	NUMBER
)
IS
	NUANOACTUAL		NUMBER := NULL;
BEGIN
    PKERRORS.PUSH ('pkGeneralServices.ValYearWithCurrent');

	
	NUANOACTUAL := PKGENERALSERVICES.FNUGETNUMBERYEAR
                    (
                        PKGENERALSERVICES.FDTGETSYSTEMDATE
                    );

    IF ( INUYEAR > NUANOACTUAL ) THEN
		PKERRORS.SETERRORCODE( PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_BIL,
							   CNUYEARBAD );
		RAISE LOGIN_DENIED;
    END IF;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
		PKERRORS.POP;
		RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
		
		PKERRORS.POP;
		RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
		PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
		PKERRORS.POP;
		RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END VALYEARWITHCURRENT;


















PROCEDURE VALMONTH
(
	INUMONTH 	IN 	NUMBER
)
IS
BEGIN
    PKERRORS.PUSH ('pkGeneralServices.ValMonth');

    IF ((INUMONTH < 1) OR (INUMONTH > 12)) THEN
		PKERRORS.SETERRORCODE( PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
							   CNUMONTHBAD );
		RAISE LOGIN_DENIED;
    END IF;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
		PKERRORS.POP;
		RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
		
		PKERRORS.POP;
		RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
		PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
		PKERRORS.POP;
		RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);
END VALMONTH;






















FUNCTION FNUGETNUMBERORHASHOFSTRING
(
    ISBSTRING	IN	VARCHAR2,
    INUBASE     IN  NUMBER,
    INUSIZE     IN  NUMBER
)
RETURN NUMBER
IS
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuGetNumberOrHashOfString');
    PKERRORS.POP;
    RETURN ( TO_NUMBER(ISBSTRING) );
EXCEPTION
    WHEN OTHERS THEN
	   RETURN DBMS_UTILITY.GET_HASH_VALUE(ISBSTRING,INUBASE,INUSIZE) ;
END FNUGETNUMBERORHASHOFSTRING;
























PROCEDURE EXTPARAMFORSTRING
    (
      ISBSTRING         IN VARCHAR2,
      ISBDELSTRING      IN VARCHAR2,
      ISBDELPARAM       IN VARCHAR2,
      ISBDELVALUE       IN VARCHAR2,
      IOTBPARAMETERS    IN OUT NOCOPY UT_STRING.TYTB_STRPARAMETERS,
      ISBINITSTRING     IN VARCHAR2 DEFAULT NULL
   )
IS

  TBSTRINGS         UT_STRING.TYTB_STRING;          
  TBPARAMETERS      UT_STRING.TYTB_STRPARAMETERS;   
  TBPARAMETERSNULL  UT_STRING.TYTB_STRPARAMETERS;   
  NUIDX             NUMBER := 1;                    

BEGIN


    PKERRORS.PUSH('pkGeneralServices.ExtParamForString');

    
    UT_STRING.EXTSTRING (ISBSTRING,  ISBDELSTRING,   TBSTRINGS);

    
    FOR NUCONT IN 1 .. TBSTRINGS.COUNT LOOP

        IF TBSTRINGS.EXISTS(NUCONT) THEN
        
            IF ISBINITSTRING IS NULL OR INSTR(TBSTRINGS(NUCONT),ISBINITSTRING) > 0 THEN

                TBPARAMETERS := TBPARAMETERSNULL;

                
                UT_STRING.EXTPARAMETERS (TBSTRINGS(NUCONT),
                                         ISBDELPARAM,
                                         ISBDELVALUE,
                                         TBPARAMETERS);

                
                FOR NUCONTPAR IN 1 .. TBPARAMETERS.COUNT LOOP

                    IF TBPARAMETERS.EXISTS(NUCONTPAR) THEN

                        IOTBPARAMETERS(NUIDX).SBPARAMETER:= TBPARAMETERS(NUCONTPAR).SBPARAMETER;
                        IOTBPARAMETERS(NUIDX).SBVALUE:= TBPARAMETERS(NUCONTPAR).SBVALUE;
                        NUIDX :=  NUIDX + 1;

                    END IF;

                END LOOP;
                
            END IF;

        END IF;

    END LOOP;

    PKERRORS.POP;

EXCEPTION
    WHEN LOGIN_DENIED THEN
		PKERRORS.POP;
		RAISE LOGIN_DENIED;

    WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
		
		PKERRORS.POP;
		RAISE PKCONSTANTE.EXERROR_LEVEL2;

    WHEN OTHERS THEN
		PKERRORS.NOTIFYERROR(PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG);
		PKERRORS.POP;
		RAISE_APPLICATION_ERROR(PKCONSTANTE.NUERROR_LEVEL2,SBERRMSG);

END EXTPARAMFORSTRING;

    




















    PROCEDURE VALIDATEDATENULLITY
    (
        IDTDATE IN  DATE
    )
    IS
    BEGIN
    

        PKERRORS.PUSH( 'pkGeneralServices.ValidateDateNullity' );

        IF( IDTDATE IS NULL ) THEN
        
            PKERRORS.SETERRORCODE
            (
                PKCONSTANTE.CSBDIVISION,
                PKCONSTANTE.CSBMOD_GRL ,
                CNUNULLDATE
            );
            RAISE LOGIN_DENIED;
        
        END IF;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
            PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
            RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    
    END VALIDATEDATENULLITY;
























FUNCTION FNUIDPROCESO RETURN NUMBER
IS
    RCPROCESOS    PROCESOS%ROWTYPE;
    CNUNO_PROCESO CONSTANT NUMBER := 12535;
BEGIN
    PKERRORS.PUSH('pkGeneralServices.fnuIDProceso');

    RCPROCESOS := GE_BCPROCESOS.FRCPROGRAMA (PKERRORS.FSBGETAPPLICATION);

    
    IF ( RCPROCESOS.PROCCONS IS NULL ) THEN
        PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION,
        PKCONSTANTE.CSBMOD_BIL,
        CNUNO_PROCESO);
    	RAISE LOGIN_DENIED;
    END IF;

    PKERRORS.POP;
    RETURN (RCPROCESOS.PROCCONS);

EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END FNUIDPROCESO;

    





















    PROCEDURE VALFORMATOFECHA
    (
        ISBFECHA    IN  VARCHAR2,
        ISBFORMATO  IN  VARCHAR2
    )
    IS

        
        
        

        
        CNUMENSFORMHORA CONSTANT MENSAJE.MENSCODI%TYPE := 18534;

        
        
        

        
        DTFECHA DATE;

    BEGIN
    

        PKERRORS.PUSH
        (
            'pkGeneralServices.ValFormatoFecha'
        );

        BEGIN

            
            DTFECHA := TO_DATE( ISBFECHA, ISBFORMATO );

        EXCEPTION
            WHEN OTHERS THEN
            
                
                PKERRORS.SETERRORCODE
                (
                    PKCONSTANTE.CSBDIVISION,
                    PKCONSTANTE.CSBMOD_GRL ,
                    CNUMENSFORMHORA
                );

                PKERRORS.CHANGEMESSAGE
                (
                    '%1'    ,
                    ISBFECHA
                );

                PKERRORS.CHANGEMESSAGE
                (
                    '%2'      ,
                    ISBFORMATO
                );

                RAISE LOGIN_DENIED;
            
        
        END;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
        
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        
        WHEN OTHERS THEN
        
        	PKERRORS.NOTIFYERROR
            (
                PKERRORS.FSBLASTOBJECT,
                SQLERRM               ,
                SBERRMSG
            );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR
            (
                PKCONSTANTE.NUERROR_LEVEL2,
                SBERRMSG
            );
        
    
    END VALFORMATOFECHA;
    
    




















    PROCEDURE VALFECHAMENORACTUAL
    (
        IDTFECHA    IN  DATE
    )
    IS

        
        
        

        
        CNUMENSFECHAMAYIGACT    CONSTANT MENSAJE.MENSCODI%TYPE := 18586;

    BEGIN
    

        PKERRORS.PUSH
        (
            'pkGeneralServices.ValFechaMenorActual'
        );

        
        IF( TRUNC( IDTFECHA ) >= TRUNC( SYSDATE ) ) THEN
        
            
            PKERRORS.SETERRORCODE
            (
                PKCONSTANTE.CSBDIVISION,
                PKCONSTANTE.CSBMOD_GRL ,
                CNUMENSFECHAMAYIGACT
            );

            PKERRORS.CHANGEMESSAGE
            (
                '%1'                             ,
                TO_CHAR( IDTFECHA, 'DD-MM-YYYY' )
            );

            RAISE LOGIN_DENIED;
        
        END IF;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
        
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        
        WHEN OTHERS THEN
        
        	PKERRORS.NOTIFYERROR
            (
                PKERRORS.FSBLASTOBJECT,
                SQLERRM               ,
                SBERRMSG
            );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR
            (
                PKCONSTANTE.NUERROR_LEVEL2,
                SBERRMSG
            );
        
    
    END VALFECHAMENORACTUAL;
    

















PROCEDURE VALRANGOHORAS
(
INUHORAINI	IN	NUMBER,
INUHORAFIN	IN	NUMBER
)
IS
CNUINVALID_RANGE	      CONSTANT NUMBER := 1043;	
CNUINVALID_RANGE_HOUR	  CONSTANT NUMBER := 10060;	
BEGIN
    PKERRORS.PUSH('pkGeneralServices.ValRangoHoras');
    
    IF ( INUHORAINI IS NULL OR INUHORAFIN IS NULL ) THEN
    PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_RANGE_HOUR );
	RAISE LOGIN_DENIED;
    END IF;
    
    IF ( INUHORAINI > INUHORAFIN ) THEN
    PKERRORS.SETERRORCODE(  PKCONSTANTE.CSBDIVISION, PKCONSTANTE.CSBMOD_GRL,
				CNUINVALID_RANGE );
	RAISE LOGIN_DENIED;
    END IF;
    
    IF (INUHORAINI < 0 OR INUHORAFIN > 23) THEN
	PKERRORS.SETERRORCODE(PKCONSTANTE.CSBDIVISION,
     				  PKCONSTANTE.CSBMOD_GRL,
      				  CNUINVALID_RANGE_HOUR);
    RAISE LOGIN_DENIED;
    END IF;
    PKERRORS.POP;
    EXCEPTION
    WHEN LOGIN_DENIED THEN
	PKERRORS.POP;
	RAISE LOGIN_DENIED;
    WHEN OTHERS THEN
	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
END VALRANGOHORAS;

    












    PROCEDURE CREARSAVEPOINTX IS
    BEGIN
        PKERRORS.PUSH('pkGeneralServices.CrearSavePointX');
        SAVEPOINT X;
        PKERRORS.POP;
        EXCEPTION
        WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END CREARSAVEPOINTX;

    












    PROCEDURE CREARSAVEPOINT(ISBSAVEPOINT IN VARCHAR2) IS
    BEGIN
        PKERRORS.PUSH('pkGeneralServices.CrearSavePoint');
        PKGENERALSERVICES.EXECUTEDYNAMICPLSQL('SAVEPOINT '||ISBSAVEPOINT||';');
        PKERRORS.POP;
        EXCEPTION
        WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END CREARSAVEPOINT;

    












    PROCEDURE ROLLBACKTRANSACTIONTO(ISBSAVEPOINT IN VARCHAR2) IS
    BEGIN
        PKERRORS.PUSH('pkGeneralServices.RollBackTransactionTo');
        PKGENERALSERVICES.EXECUTEDYNAMICPLSQL('ROLLBACK TO '||ISBSAVEPOINT||';');
        PKERRORS.POP;
        EXCEPTION
        WHEN OTHERS THEN
    	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
    	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
    END ROLLBACKTRANSACTIONTO;
    
    





















    PROCEDURE ACTIVARRASTREO
    (
        INUNIVELRASTREO IN  NUMBER DEFAULT GCNUNIVELRASTREODEF  ,
        INUTIPORASTREO  IN  NUMBER DEFAULT GCNUTIPORASTREOSTDOUT
    )
    IS
    BEGIN
    

        PKERRORS.PUSH
        (
            'pkGeneralServices.ActivarRastreo'
        );
        
        
        IF( INUTIPORASTREO NOT IN ( GCNUTIPORASTREOSTDOUT, GCNUTIPORASTREOTABLA ) ) THEN
        
            
            GBLRASTREOACTIVO := FALSE;
            
            RETURN;
        
        END IF;
        
        
        VALVALUEISPOSITIVE
        (
            INUNIVELRASTREO
        );
        
        
        GBLRASTREOACTIVO := TRUE;
        
        
        GNUNIVELRASTREO := INUNIVELRASTREO;
        
        
        GNUTIPORASTREO := INUTIPORASTREO;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
        
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        
        WHEN OTHERS THEN
        
        	PKERRORS.NOTIFYERROR
            (
                PKERRORS.FSBLASTOBJECT,
                SQLERRM               ,
                SBERRMSG
            );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR
            (
                PKCONSTANTE.NUERROR_LEVEL2,
                SBERRMSG
            );
        
    
    END ACTIVARRASTREO;
    
    















    PROCEDURE DESACTIVARRASTREO
    IS
    BEGIN
    

        PKERRORS.PUSH
        (
            'pkGeneralServices.DesactivarRastreo'
        );

        
        GBLRASTREOACTIVO := FALSE;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
        
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        
        WHEN OTHERS THEN
        
        	PKERRORS.NOTIFYERROR
            (
                PKERRORS.FSBLASTOBJECT,
                SQLERRM               ,
                SBERRMSG
            );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR
            (
                PKCONSTANTE.NUERROR_LEVEL2,
                SBERRMSG
            );
        
    
    END DESACTIVARRASTREO;
    
    





















    PROCEDURE DESPLEGARRASTREO
    (
        ISBDATOS        IN  VARCHAR2                          ,
        INUNIVELRASTREO IN  NUMBER DEFAULT GCNUNIVELRASTREODEF
    )
    IS
    BEGIN
    

        PKERRORS.PUSH
        (
            'pkGeneralServices.DesplegarRastreo'
        );
        
        
        IF( GBLRASTREOACTIVO AND INUNIVELRASTREO <= GNUNIVELRASTREO ) THEN
        
            IF( GNUTIPORASTREO = GCNUTIPORASTREOSTDOUT ) THEN
            
                
                DBMS_OUTPUT.PUT_LINE
                (
                    LPAD( ISBDATOS, LENGTH( ISBDATOS ) + ( INUNIVELRASTREO - 1 ), GCSBCARACTERRASTREO )
                );
            
            ELSIF( GNUTIPORASTREO = GCNUTIPORASTREOTABLA ) THEN
            
                
                NULL;
            
            END IF;
        
        END IF;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
        
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
        
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        
        WHEN OTHERS THEN
        
        	PKERRORS.NOTIFYERROR
            (
                PKERRORS.FSBLASTOBJECT,
                SQLERRM               ,
                SBERRMSG
            );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR
            (
                PKCONSTANTE.NUERROR_LEVEL2,
                SBERRMSG
            );
        
    
    END DESPLEGARRASTREO;
    
    





















    PROCEDURE VALRUTAARCHIVO
    (
        ISBRUTA IN  VARCHAR2
    )
    IS

        
        
        

        
        CNUMENSRUTANULA CONSTANT MENSAJE.MENSCODI%TYPE := 13501;
        
        CNUMENSPERMISOS CONSTANT MENSAJE.MENSCODI%TYPE := 20882;
        
        CSBCOMANDOTOUCH CONSTANT VARCHAR2(50)          := 'touch';
        
        
        
        
        
        
        SBARCHMISC      VARCHAR2(50);
        
        NUCODIGOERROR   GE_ERROR_LOG.MESSAGE_ID%TYPE;

    BEGIN

        PKERRORS.PUSH
        (
            'pkGeneralServices.ValRutaArchivo'
        );

        
        IF( ISBRUTA IS NULL ) THEN

            
            PKERRORS.SETERRORCODE
            (
                PKCONSTANTE.CSBDIVISION,
                PKCONSTANTE.CSBMOD_GRL ,
                CNUMENSRUTANULA
            );

            
            RAISE LOGIN_DENIED;

        END IF;

        
        GE_BOFILEMANAGER.CHECKDIRECTORYISEXISTING
        (
            ISBRUTA
        );
        
        
        SBARCHMISC := '.dummy_' || TO_CHAR( SYSDATE, 'YYYYMMDDHH24MISS' );

        
        NUCODIGOERROR :=    UT_OSCOMMAND.RUN
                            (
                                CSBCOMANDOTOUCH                   ||
                                ' '                               ||
                                TRIM( TRAILING '/' FROM ISBRUTA ) ||
                                '/'                               ||
                                SBARCHMISC
                            );
                            
        
        IF( NUCODIGOERROR <> PKCONSTANTE.EXITO ) THEN

            
            PKERRORS.SETERRORCODE
            (
                PKCONSTANTE.CSBDIVISION,
                PKCONSTANTE.CSBMOD_BIL ,
                CNUMENSPERMISOS
            );

            PKERRORS.CHANGEMESSAGE
            (
                '%s1'  ,
                ISBRUTA
            );

            
            RAISE LOGIN_DENIED;

        END IF;

        
        NUCODIGOERROR :=    GE_BOFILEMANAGER.DELETEFILE
                            (
                                TRIM( TRAILING '/' FROM ISBRUTA ) ||
                                '/'                               ||
                                SBARCHMISC
                            );

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
        	PKERRORS.NOTIFYERROR
            (
                PKERRORS.FSBLASTOBJECT    ,
                SQLERRM                   ,
                PKGENERALSERVICES.SBERRMSG
            );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR
            (
                PKCONSTANTE.NUERROR_LEVEL2,
                PKGENERALSERVICES.SBERRMSG
            );
    END;
    
    



















    PROCEDURE VALARCHIVO
    (
        ISBRUTA     IN  VARCHAR2,
        ISBNOMBRE   IN  VARCHAR2
    )
    IS

        
        
        

        
        CNUMENSNOMBRENULO   CONSTANT MENSAJE.MENSCODI%TYPE := 13521;
        
        
        
        

        
        SBRUTAABSOLUTA      VARCHAR2(2000);

    BEGIN

        PKERRORS.PUSH
        (
            'pkGeneralServices.ValArchivo'
        );
        
        
        VALRUTAARCHIVO
        (
            ISBRUTA
        );

        
        IF( ISBNOMBRE IS NULL ) THEN

            
            PKERRORS.SETERRORCODE
            (
                PKCONSTANTE.CSBDIVISION,
                PKCONSTANTE.CSBMOD_GRL ,
                CNUMENSNOMBRENULO
            );

            
            RAISE LOGIN_DENIED;

        END IF;
        
        
        SBRUTAABSOLUTA := TRIM( TRAILING '/' FROM ISBRUTA ) || '/' || ISBNOMBRE;

        
        GE_BOFILEMANAGER.CHECKFILEISEXISTING
        (
            SBRUTAABSOLUTA
        );

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED THEN
            PKERRORS.POP;
            RAISE LOGIN_DENIED;
        WHEN PKCONSTANTE.EXERROR_LEVEL2 THEN
            PKERRORS.POP;
            RAISE PKCONSTANTE.EXERROR_LEVEL2;
        WHEN OTHERS THEN
        	PKERRORS.NOTIFYERROR
            (
                PKERRORS.FSBLASTOBJECT    ,
                SQLERRM                   ,
                PKGENERALSERVICES.SBERRMSG
            );
        	PKERRORS.POP;
        	RAISE_APPLICATION_ERROR
            (
                PKCONSTANTE.NUERROR_LEVEL2,
                PKGENERALSERVICES.SBERRMSG
            );
    END;
    
    


















    PROCEDURE SETTERMINAL
    (
        ISBTERMINAL IN VARCHAR2
    )
    IS
    BEGIN
        PKERRORS.PUSH('pkGeneralServices.SetTerminal');
        
        GSBTERMINAL := ISBTERMINAL;
        
        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            PKERRORS.POP;
        	RAISE;
        WHEN OTHERS THEN
        	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
        	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
        	RAISE;

    END SETTERMINAL;
    
    






















    PROCEDURE OPENREFCURSORWITHDYNAMICSQL
    (
        ISBSENTENCE IN  VARCHAR2,
        OCUCURSOR   OUT PKCONSTANTE.TYREFCURSOR
    )
    IS
    BEGIN
        PKERRORS.PUSH('pkGeneralServices.OpenRefCursorWithDynamicSQL');

        OPEN OCUCURSOR FOR ISBSENTENCE;

        PKERRORS.POP;

    EXCEPTION
        WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 OR EX.CONTROLLED_ERROR THEN
            PKERRORS.POP;
        	RAISE;
        WHEN OTHERS THEN
        	PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
            PKERRORS.POP;
        	RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
        	RAISE;

    END OPENREFCURSORWITHDYNAMICSQL;
    
    
    














    FUNCTION FBOEXEDYNBOLFUNCTION
    (
        ISBPARTIALSENTENCE          IN          VARCHAR2
    )
    RETURN BOOLEAN
    IS
        SBSENTENCE                      VARCHAR2(10000);
        NURETURN                        NUMBER;
        BORETURN                        BOOLEAN;
    BEGIN
    
        UT_TRACE.TRACE('Inicio [pkGeneralServices.fboExeDynBolFunction]', 1);
        
        SBSENTENCE := 'declare'||CHR(10)||
        'boReturn boolean;'||CHR(10)||
        'begin'||CHR(10)||
        'boReturn := '||ISBPARTIALSENTENCE||';'||CHR(10)||
        'if(boReturn)then'||CHR(10)||
        ':result :=  1;'||CHR(10)||
        'else'||CHR(10)||
        ':result := 0;'||CHR(10)||
        'end if;'||CHR(10)||
        'end;'||CHR(10);
        
        
        
        EXECUTE IMMEDIATE SBSENTENCE USING OUT NURETURN;
            
        IF( NURETURN = 1 ) THEN
        
            BORETURN := TRUE;
        
        ELSE
        
            BORETURN := FALSE;
        
        END IF;

        UT_TRACE.TRACE('Fin [pkGeneralServices.fboExeDynBolFunction]', 1);

        RETURN BORETURN;
    
    EXCEPTION
    
        WHEN EX.CONTROLLED_ERROR THEN
            UT_TRACE.TRACE('ex.CONTROLLED_ERROR [pkGeneralServices.fboExeDynBolFunction]', 1);
    	    RAISE EX.CONTROLLED_ERROR;

        WHEN OTHERS THEN
            ERRORS.SETERROR;
            UT_TRACE.TRACE('OTHERS [pkGeneralServices.fboExeDynBolFunction]', 1);
            RAISE EX.CONTROLLED_ERROR;
    
    END FBOEXEDYNBOLFUNCTION;

END PKGENERALSERVICES;