
CREATE OR REPLACE PACKAGE BODY FA_BCCHARGECAUSES IS
   SBERRMSG GE_ERROR_LOG.DESCRIPTION%TYPE;
   CSBVERSION CONSTANT VARCHAR2( 10 ) := 'SAO188118';
   TYPE TYRCCAUSESBYCLASS IS RECORD
    (
      TBCHARGECAUSES PKTBLCAUSCARG.TYCACACODI
    );
   TYPE TYTBCAUSESBYCLASS IS TABLE OF TYRCCAUSESBYCLASS INDEX BY BINARY_INTEGER;
   GTBCAUSESBYCLASS TYTBCAUSESBYCLASS;
   FUNCTION FSBVERSION
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN ( CSBVERSION );
   END FSBVERSION;
   PROCEDURE RAISEERROR( INUCHCAUSCLASS IN FA_CACACLTP.CCTPCLCC%TYPE, INUPRODTYPE IN FA_CACACLTP.CCTPSERV%TYPE )
    IS
      SBCLASSDESC FA_CLASCACA.CLCCDESC%TYPE;
      SBPRODTYPEDESC SERVICIO.SERVDESC%TYPE;
    BEGIN
      PKERRORS.PUSH( 'FA_BCChargeCauses.RaiseError' );
      UT_TRACE.TRACE( 'Inicia FA_BCChargeCauses.RaiseError', 5 );
      SBCLASSDESC := PKTBLFA_CLASCACA.FSBGETCLCCDESC( INUCHCAUSCLASS );
      SBCLASSDESC := SUBSTR( INUCHCAUSCLASS || ' - ' || SBCLASSDESC, 0, 100 );
      IF ( INUPRODTYPE = PKCONSTANTE.NULLNUM ) THEN
         SBPRODTYPEDESC := '(todos)';
       ELSE
         SBPRODTYPEDESC := PKTBLSERVICIO.FSBGETDESCRIPTION( INUPRODTYPE );
      END IF;
      SBPRODTYPEDESC := SUBSTR( INUPRODTYPE || ' - ' || SBPRODTYPEDESC, 0, 30 );
      ERRORS.SETERROR( 901523, SBCLASSDESC || '|' || SBPRODTYPEDESC );
      RAISE LOGIN_DENIED;
      UT_TRACE.TRACE( 'Finaliza FA_BCChargeCauses.RaiseError', 5 );
      PKERRORS.POP;
    EXCEPTION
      WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
         PKERRORS.POP;
         RAISE;
      WHEN EX.CONTROLLED_ERROR THEN
         PKERRORS.POP;
         RAISE;
      WHEN OTHERS THEN
         PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
         PKERRORS.POP;
         RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
   END RAISEERROR;
   PROCEDURE LOADDATAINMEMORY( INUCHCAUSCLASS IN FA_CACACLTP.CCTPCLCC%TYPE )
    IS
      NUCHARGECAUSE FA_CACACLTP.CCTPCACA%TYPE;
      NUPRODTYPE FA_CACACLTP.CCTPSERV%TYPE;
      CURSOR CUCHARGECAUSES IS
SELECT /*+ index (fa_cacacltp, IX_FA_CACACLTP01) */
                   cctpcaca, cctpserv
              FROM fa_cacacltp /*+ FA_BCChargeCauses.LoadDataInMemory */
             WHERE cctpclcc = inuChCausClass;
    BEGIN
      PKERRORS.PUSH( 'FA_BCChargeCauses.LoadDataInMemory' );
      UT_TRACE.TRACE( 'Inicia FA_BCChargeCauses.LoadDataInMemory', 5 );
      IF ( NOT GTBCAUSESBYCLASS.EXISTS( INUCHCAUSCLASS ) ) THEN
         TD( 'Cargando inf. en memoria para el clasificador: ' || INUCHCAUSCLASS );
         IF ( CUCHARGECAUSES%ISOPEN ) THEN
            CLOSE CUCHARGECAUSES;
         END IF;
         OPEN CUCHARGECAUSES;
         LOOP
            FETCH CUCHARGECAUSES
               INTO NUCHARGECAUSE, NUPRODTYPE;
            EXIT WHEN CUCHARGECAUSES%NOTFOUND;
            TD( 'Recuperando datos. TiPr: ' || NUPRODTYPE || ', Causa: ' || NUCHARGECAUSE );
            GTBCAUSESBYCLASS( INUCHCAUSCLASS ).TBCHARGECAUSES( NUPRODTYPE ) := NUCHARGECAUSE;
         END LOOP;
         CLOSE CUCHARGECAUSES;
       ELSE
         TD( 'Inf. cargada en memoria para el clasificador: ' || INUCHCAUSCLASS );
      END IF;
      UT_TRACE.TRACE( 'Finaliza FA_BCChargeCauses.LoadDataInMemory', 5 );
      PKERRORS.POP;
    EXCEPTION
      WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
         PKERRORS.POP;
         RAISE;
      WHEN EX.CONTROLLED_ERROR THEN
         PKERRORS.POP;
         RAISE;
      WHEN OTHERS THEN
         PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
         PKERRORS.POP;
         RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
   END LOADDATAINMEMORY;
   FUNCTION FNUGETCHARGECAUSE( INUCHCAUSCLASS IN FA_CACACLTP.CCTPCLCC%TYPE, INUPRODTYPE IN FA_CACACLTP.CCTPSERV%TYPE )
    RETURN FA_CACACLTP.CCTPCACA%TYPE
    IS
      NUCHARGECAUSE FA_CACACLTP.CCTPCACA%TYPE;
    BEGIN
      PKERRORS.PUSH( 'FA_BCChargeCauses.fnuGetChargeCause' );
      UT_TRACE.TRACE( 'Inicia FA_BCChargeCauses.fnuGetChargeCause', 5 );
      LOADDATAINMEMORY( INUCHCAUSCLASS );
      IF ( GTBCAUSESBYCLASS.EXISTS( INUCHCAUSCLASS ) ) THEN
         TD( 'Existen datos para el clasificador: ' || INUCHCAUSCLASS );
         IF ( GTBCAUSESBYCLASS( INUCHCAUSCLASS ).TBCHARGECAUSES.EXISTS( INUPRODTYPE ) ) THEN
            NUCHARGECAUSE := GTBCAUSESBYCLASS( INUCHCAUSCLASS ).TBCHARGECAUSES( INUPRODTYPE );
            TD( 'Causa: ' || NUCHARGECAUSE || ' encontrada para TiPr: ' || INUPRODTYPE );
          ELSIF ( GTBCAUSESBYCLASS( INUCHCAUSCLASS ).TBCHARGECAUSES.EXISTS( -1 ) ) THEN
            NUCHARGECAUSE := GTBCAUSESBYCLASS( INUCHCAUSCLASS ).TBCHARGECAUSES( -1 );
            TD( 'Causa: ' || NUCHARGECAUSE || ' encontrada para todos los TiPr' );
          ELSE
            TD( 'Causa no encontrada para el tipo de producto: ' || INUPRODTYPE );
            RAISEERROR( INUCHCAUSCLASS, INUPRODTYPE );
         END IF;
       ELSE
         TD( 'Causas no encontradas para el clasificador: ' || INUCHCAUSCLASS );
         RAISEERROR( INUCHCAUSCLASS, INUPRODTYPE );
      END IF;
      UT_TRACE.TRACE( 'Finaliza FA_BCChargeCauses.fnuGetChargeCause', 5 );
      PKERRORS.POP;
      RETURN ( NUCHARGECAUSE );
    EXCEPTION
      WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
         PKERRORS.POP;
         RAISE;
      WHEN EX.CONTROLLED_ERROR THEN
         PKERRORS.POP;
         RAISE;
      WHEN OTHERS THEN
         PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
         PKERRORS.POP;
         RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
   END FNUGETCHARGECAUSE;
   FUNCTION FRFGETCHARGECAUSE( INUCHCAUSCLASS IN FA_CACACLTP.CCTPCLCC%TYPE, INUPRODTYPE IN FA_CACACLTP.CCTPSERV%TYPE )
    RETURN PKCONSTANTE.TYREFCURSOR
    IS
      RFCAUSES PKCONSTANTE.TYREFCURSOR;
    BEGIN
      PKERRORS.PUSH( 'FA_BCChargeCauses.frfGetChargeCause' );
      UT_TRACE.TRACE( 'Inicia FA_BCChargeCauses.frfGetChargeCause', 5 );
      OPEN RFCAUSES FOR SELECT cacacodi id,
                   cacadesc description
            FROM   causcarg,
                   fa_cacacltp /*+ FA_BCChargeCauses.fnuGetChargeCause */
            WHERE  cctpcaca = cacacodi
            AND    cctpclcc = inuChCausClass
            AND   (cctpserv = inuProdType OR cctpserv = -1);
      UT_TRACE.TRACE( 'Finaliza FA_BCChargeCauses.frfGetChargeCause', 5 );
      PKERRORS.POP;
      RETURN ( RFCAUSES );
    EXCEPTION
      WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
         PKERRORS.POP;
         RAISE;
      WHEN EX.CONTROLLED_ERROR THEN
         PKERRORS.POP;
         RAISE;
      WHEN OTHERS THEN
         PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
         PKERRORS.POP;
         RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
   END FRFGETCHARGECAUSE;
   FUNCTION FTBGETCHARGECAUSE( INUCHCAUSCLASS IN FA_CACACLTP.CCTPCLCC%TYPE )
    RETURN PKTBLCAUSCARG.TYCACACODI
    IS
      TBCHARGECAUSES PKTBLCAUSCARG.TYCACACODI;
    BEGIN
      PKERRORS.PUSH( 'FA_BCChargeCauses.ftbGetChargeCause' );
      UT_TRACE.TRACE( 'Inicia FA_BCChargeCauses.ftbGetChargeCause', 5 );
      LOADDATAINMEMORY( INUCHCAUSCLASS );
      IF ( GTBCAUSESBYCLASS.EXISTS( INUCHCAUSCLASS ) ) THEN
         TD( 'Existen datos para el clasificador: ' || INUCHCAUSCLASS );
         TBCHARGECAUSES := GTBCAUSESBYCLASS( INUCHCAUSCLASS ).TBCHARGECAUSES;
       ELSE
         TD( 'Causas no encontradas para el clasificador: ' || INUCHCAUSCLASS );
         RAISEERROR( INUCHCAUSCLASS, PKCONSTANTE.NULLNUM );
      END IF;
      UT_TRACE.TRACE( 'Finaliza FA_BCChargeCauses.ftbGetChargeCause', 5 );
      PKERRORS.POP;
      RETURN ( TBCHARGECAUSES );
    EXCEPTION
      WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
         PKERRORS.POP;
         RAISE;
      WHEN EX.CONTROLLED_ERROR THEN
         PKERRORS.POP;
         RAISE;
      WHEN OTHERS THEN
         PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
         PKERRORS.POP;
         RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
   END FTBGETCHARGECAUSE;
   FUNCTION FRFGETCHARGECAUSE( INUCHCAUSCLASS IN FA_CACACLTP.CCTPCLCC%TYPE )
    RETURN PKCONSTANTE.TYREFCURSOR
    IS
      RFCAUSES PKCONSTANTE.TYREFCURSOR;
    BEGIN
      PKERRORS.PUSH( 'FA_BCChargeCauses.frfGetChargeCause' );
      UT_TRACE.TRACE( 'Inicia FA_BCChargeCauses.frfGetChargeCause', 5 );
      OPEN RFCAUSES FOR SELECT cacacodi id,
                   cacadesc description,
                   cctpserv parent
            FROM   causcarg,
                   fa_cacacltp /*+ FA_BCChargeCauses.fnuGetChargeCause */
            WHERE  cctpcaca = cacacodi
            AND    cctpclcc = inuChCausClass;
      UT_TRACE.TRACE( 'Finaliza FA_BCChargeCauses.frfGetChargeCause', 5 );
      PKERRORS.POP;
      RETURN ( RFCAUSES );
    EXCEPTION
      WHEN LOGIN_DENIED OR PKCONSTANTE.EXERROR_LEVEL2 THEN
         PKERRORS.POP;
         RAISE;
      WHEN EX.CONTROLLED_ERROR THEN
         PKERRORS.POP;
         RAISE;
      WHEN OTHERS THEN
         PKERRORS.NOTIFYERROR( PKERRORS.FSBLASTOBJECT, SQLERRM, SBERRMSG );
         PKERRORS.POP;
         RAISE_APPLICATION_ERROR( PKCONSTANTE.NUERROR_LEVEL2, SBERRMSG );
   END FRFGETCHARGECAUSE;
END FA_BCCHARGECAUSES;
/


