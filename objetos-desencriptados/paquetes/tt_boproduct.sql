CREATE OR REPLACE PACKAGE BODY TT_BOPRODUCT IS
   CSBVERSION CONSTANT VARCHAR2( 10 ) := 'SAO294637';
   CSBSET_TRACE CONSTANT GE_PARAMETER.VALUE%TYPE := GE_BOPARAMETER.FSBGET( 'TRACE_BD' );
   CSBTRACE_LEVEL CONSTANT GE_PARAMETER.VALUE%TYPE := GE_BOPARAMETER.FNUGET( 'TRACE_LEVEL' );
   CSBDAO_USE_CACHE CONSTANT GE_PARAMETER.PARAMETER_ID%TYPE := 'DAO_USE_CACHE';
   CNUPRODUCTHASDAMAGE CONSTANT NUMBER( 6 ) := 5128;
   CNUNULL_PRODUCT_ERROR CONSTANT GE_MESSAGE.MESSAGE_ID%TYPE := 900451;
   CNUPRODUCT_STATUS_ERROR CONSTANT GE_MESSAGE.MESSAGE_ID%TYPE := 1693;
   CNUORDER_ASODAMAGE CONSTANT GE_MESSAGE.MESSAGE_ID%TYPE := 900338;
   CNUINVALID_PROD_ERROR CONSTANT GE_MESSAGE.MESSAGE_ID%TYPE := 901395;
   CNUCOMMENT_TYPE CONSTANT GE_COMMENT_TYPE.COMMENT_TYPE_ID%TYPE := 3;
   FUNCTION FSBVERSION
    RETURN VARCHAR2
    IS
    BEGIN
      RETURN CSBVERSION;
   END FSBVERSION;
   FUNCTION FRCFIRSTDAMAGEREQUEST( INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE )
    RETURN DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT
    IS
      RCDAMAGE DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
    BEGIN
      FOR RCDAMAGEPRODUCT IN TT_BCPRODUCT.CUDAMPRODBYPROD( INUPRODUCTID )
       LOOP
         IF RCDAMAGEPRODUCT.DAMAGE_PRODU_STATUS NOT IN ( TT_BCCONSTANTS.CSBCLOSEDAMAGESTATUS, TT_BCCONSTANTS.CSBUNFOUNDEDDAMAGESTATUS ) THEN
            RCDAMAGE := RCDAMAGEPRODUCT;
            EXIT;
         END IF;
      END LOOP;
      RETURN RCDAMAGE;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END FRCFIRSTDAMAGEREQUEST;
   FUNCTION HAVEDAMAGE( INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE )
    RETURN BOOLEAN
    IS
      RCDAMAGE DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
    BEGIN
      RCDAMAGE := FRCFIRSTDAMAGEREQUEST( INUPRODUCTID );
      RETURN ( RCDAMAGE.PRODUCT_ID IS NOT NULL );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END HAVEDAMAGE;
   PROCEDURE VALIDPRODDONTHAVEDAMAGE( INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE )
    IS
      RCDAMAGE DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
      NUERR NUMBER;
      SBERR VARCHAR2( 4000 );
      NUPACKAGEID TT_DAMAGE_PRODUCT.PACKAGE_ID%TYPE;
    BEGIN
      RCDAMAGE := FRCFIRSTDAMAGEREQUEST( INUPRODUCTID );
      IF RCDAMAGE.PRODUCT_ID IS NOT NULL THEN
         ERRORS.SETERROR( CNUPRODUCTHASDAMAGE, INUPRODUCTID );
         ERRORS.GETERROR( NUERR, SBERR );
         ERRORS.SETMESSAGE( SBERR || ' EXTERNAL_ID[' || RPAD( RCDAMAGE.PACKAGE_ID, 15, ' ' ) || ']' );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END VALIDPRODDONTHAVEDAMAGE;
   PROCEDURE GETDAMAGESTOABSORB( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE, ITBFAULTTYPE IN GE_TYTBIDNUMBER, OTBDAMAGES OUT NOCOPY DAMO_PACKAGES.TYTBPACKAGE_ID )
    IS
      RCDAMAGE DATT_DAMAGE.STYTT_DAMAGE;
      DTINITIALDATE TT_DAMAGE.INITIAL_DATE%TYPE;
      NUFAULTTYPEID TT_DAMAGE.REG_DAMAGE_TYPE_ID%TYPE;
      NUINDEX BINARY_INTEGER;
      NUDAMAGESINDEX BINARY_INTEGER;
      TBDAMAGES DAMO_PACKAGES.TYTBPACKAGE_ID;
      BOABSORB BOOLEAN;
      NUORDERID OR_SCHED_DISPATCH.ORDER_ID%TYPE;
      SBDISPATCHSTATUS OR_SCHED_DISPATCH.DISPATCH_STATUS%TYPE;
      DTDISPATCHDATE OR_SCHED_DISPATCH.DATE_%TYPE;
      DTTODAY DATE := TRUNC( UT_DATE.FDTSYSDATE );
      SBCOMMENT GE_BOUTILITIES.STYSTATEMENTATTRIBUTE;
      PROCEDURE CLOSECUR
       IS
       BEGIN
         IF ( TT_BCPRODUCT.CUALLREGPRODUCTDAMAGES%ISOPEN ) THEN
            CLOSE TT_BCPRODUCT.CUALLREGPRODUCTDAMAGES;
         END IF;
       EXCEPTION
         WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
         WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
      END CLOSECUR;
    BEGIN
      DATT_DAMAGE.GETRECORD( INUFAULTID, RCDAMAGE );
      DTINITIALDATE := RCDAMAGE.INITIAL_DATE;
      NUFAULTTYPEID := NVL( RCDAMAGE.FINAL_DAMAGE_TYPE_ID, RCDAMAGE.REG_DAMAGE_TYPE_ID );
      CLOSECUR;
      IF ( ITBFAULTTYPE.COUNT = 0 ) THEN
         OPEN TT_BCPRODUCT.CUALLREGPRODUCTDAMAGES( INUPRODUCTID, DTINITIALDATE, GE_TYTBIDNUMBER( NUFAULTTYPEID ) );
       ELSE
         OPEN TT_BCPRODUCT.CUALLREGPRODUCTDAMAGES( INUPRODUCTID, DTINITIALDATE, ITBFAULTTYPE );
      END IF;
      NUINDEX := 1;
      SBCOMMENT := GE_BOMESSAGE.FSBGETMESSAGE( CNUORDER_ASODAMAGE, INUFAULTID );
      LOOP
         TBDAMAGES.DELETE;
         FETCH TT_BCPRODUCT.CUALLREGPRODUCTDAMAGES
            BULK COLLECT INTO TBDAMAGES
            LIMIT 100;
         NUDAMAGESINDEX := TBDAMAGES.FIRST;
         EXIT WHEN NUDAMAGESINDEX IS NULL;
         LOOP
            EXIT WHEN NUDAMAGESINDEX IS NULL;
            BOABSORB := TRUE;
            OR_BCANULLORDER.HASORDERSINMOVEXECSCHED( TBDAMAGES( NUDAMAGESINDEX ), NUORDERID, SBDISPATCHSTATUS, DTDISPATCHDATE );
            IF ( NUORDERID IS NOT NULL ) THEN
               BOABSORB := SBDISPATCHSTATUS IS NOT NULL;
               BOABSORB := BOABSORB AND ( DTDISPATCHDATE != DTTODAY );
               BOABSORB := BOABSORB AND ( SBDISPATCHSTATUS != OR_BCDISPATCH.CSBAVAILPROCESSING );
            END IF;
            IF ( BOABSORB ) THEN
               OTBDAMAGES( NUINDEX ) := TBDAMAGES( NUDAMAGESINDEX );
               NUINDEX := NUINDEX + 1;
             ELSE
               OR_BOORDERCOMMENT.ADDCOMMENT( NUORDERID, CNUCOMMENT_TYPE, SBCOMMENT );
            END IF;
            NUDAMAGESINDEX := TBDAMAGES.NEXT( NUDAMAGESINDEX );
         END LOOP;
      END LOOP;
      CLOSE TT_BCPRODUCT.CUALLREGPRODUCTDAMAGES;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         CLOSECUR;
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         CLOSECUR;
         RAISE EX.CONTROLLED_ERROR;
   END GETDAMAGESTOABSORB;
   PROCEDURE LINKPRODTOFAULT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE, INUELEMENTID IN TT_DAMAGE_PRODUCT.ELEMENT_ID%TYPE, ONUID OUT TT_DAMAGE_PRODUCT.DAMAGES_PRODUCT_ID%TYPE )
    IS
      RCDAMAGE_PRODUCT DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
    BEGIN
      TT_BCPRODUCT.GETDAMAPRODBYPACKANDPRODUCT( INUFAULTID, INUPRODUCTID, RCDAMAGE_PRODUCT );
      IF ( RCDAMAGE_PRODUCT.PACKAGE_ID = INUFAULTID ) THEN
         IF ( RCDAMAGE_PRODUCT.DAMAGE_PRODU_STATUS = TT_BCCONSTANTS.CSBNONPORCESEDDAMAGESTATUS ) THEN
            RCDAMAGE_PRODUCT.DAMAGE_PRODU_STATUS := TT_BCCONSTANTS.CSBOPENDAMAGESTATUS;
            DATT_DAMAGE_PRODUCT.UPDRECORD( RCDAMAGE_PRODUCT );
         END IF;
       ELSE
         RCDAMAGE_PRODUCT.DAMAGES_PRODUCT_ID := TT_BOSEQUENCE.FNUGETTT_DAMAGE_PRODUCT;
         RCDAMAGE_PRODUCT.PRODUCT_ID := INUPRODUCTID;
         RCDAMAGE_PRODUCT.ELEMENT_ID := INUELEMENTID;
         RCDAMAGE_PRODUCT.MAX_ATTENT_DATE := NULL;
         RCDAMAGE_PRODUCT.DAMAGE_PRODU_STATUS := TT_BCCONSTANTS.CSBOPENDAMAGESTATUS;
         RCDAMAGE_PRODUCT.PACKAGE_ID := INUFAULTID;
         RCDAMAGE_PRODUCT.REPAIRED := GE_BOCONSTANTS.CSBNO;
         DATT_DAMAGE_PRODUCT.INSRECORD( RCDAMAGE_PRODUCT );
      END IF;
      ONUID := RCDAMAGE_PRODUCT.DAMAGES_PRODUCT_ID;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END LINKPRODTOFAULT;
   PROCEDURE VALPRODUCT( INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE, IBLVALSTATUS IN BOOLEAN )
    IS
      NUPRODUCTSTATUSID PR_PRODUCT.PRODUCT_STATUS_ID%TYPE;
      RCPRODUCTSTATUS DAPS_PRODUCT_STATUS.STYPS_PRODUCT_STATUS;
    BEGIN
      IF ( INUPRODUCTID IS NULL ) THEN
         ERRORS.SETERROR( CNUNULL_PRODUCT_ERROR );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
      DAPR_PRODUCT.ACCKEY( INUPRODUCTID );
      IF ( IBLVALSTATUS ) THEN
         NUPRODUCTSTATUSID := DAPR_PRODUCT.FNUGETPRODUCT_STATUS_ID( INUPRODUCTID );
         RCPRODUCTSTATUS := PS_BOPRODSERVMANAGER.FRCGETPRODUCTSTATUS( NUPRODUCTSTATUSID );
         IF ( NOT ( ( ( RCPRODUCTSTATUS.IS_ACTIVE_PRODUCT = GE_BOCONSTANTS.CSBYES ) OR ( RCPRODUCTSTATUS.PRODUCT_STATUS_ID = PR_BOCONSTANTS.CNUPRODUCT_PEND_RETIRE ) ) AND ( RCPRODUCTSTATUS.PRODUCT_STATUS_ID != PR_BOCONSTANTS.CNUPRODUCT_INSTALL_PENDING ) ) ) THEN
            ERRORS.SETERROR( CNUPRODUCT_STATUS_ERROR, INUPRODUCTID || '|' || 'Adicion de Producto Afectado a Falla' );
            RAISE EX.CONTROLLED_ERROR;
         END IF;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END VALPRODUCT;
   PROCEDURE ADDPRODTOFAULT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, 
                             INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE, 
							 INUELEMENTID IN TT_DAMAGE_PRODUCT.ELEMENT_ID%TYPE, 
							 ISBPROCESSID IN ESTAPROG.ESPRPROG%TYPE, 
							 ONUID OUT TT_DAMAGE_PRODUCT.DAMAGES_PRODUCT_ID%TYPE, 
							 IBLLINK IN BOOLEAN := TRUE, 
							 ITBFAULTTYPE IN GE_TYTBIDNUMBER := GE_TYTBIDNUMBER() )
    IS
      TBDAMAGES DAMO_PACKAGES.TYTBPACKAGE_ID;
      NUINDEX BINARY_INTEGER;
      NUASSOID MO_PACKAGES_ASSO.PACKAGES_ASSO_ID%TYPE;
    BEGIN
      TT_BOPRODUCT.GETDAMAGESTOABSORB( INUFAULTID, INUPRODUCTID, ITBFAULTTYPE, TBDAMAGES );
      IF ( TBDAMAGES.COUNT > 0 ) THEN
         NUINDEX := TBDAMAGES.FIRST;
         LOOP
            EXIT WHEN NUINDEX IS NULL;
            TT_BOFAULT.ABSORBPACKAGE( INUFAULTID, TBDAMAGES( NUINDEX ), ISBPROCESSID, NUASSOID );
            NUINDEX := TBDAMAGES.NEXT( NUINDEX );
         END LOOP;
      END IF;
      IF ( IBLLINK ) THEN
         TT_BOPRODUCT.LINKPRODTOFAULT( INUFAULTID, INUPRODUCTID, INUELEMENTID, ONUID );
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END ADDPRODTOFAULT;
   PROCEDURE REMPRODFROMFAULT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE )
    IS
      NUINDEX BINARY_INTEGER;
      RCDAMAGE_PRODUCT DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
      TBPACKASSO DAMO_PACKAGES_ASSO.TYTBMO_PACKAGES_ASSO;
    BEGIN
      TT_BCPRODUCT.GETOPENDAMAPRODBYPACKANDPROD( INUFAULTID, INUPRODUCTID, RCDAMAGE_PRODUCT );
      IF ( RCDAMAGE_PRODUCT.DAMAGES_PRODUCT_ID IS NOT NULL ) THEN
         DATT_DAMAGE_PRODUCT.DELRECORD( RCDAMAGE_PRODUCT.DAMAGES_PRODUCT_ID );
         TBPACKASSO := TT_BCPRODUCT.FTBRELADAMAGBYPROD( INUFAULTID, INUPRODUCTID );
         NUINDEX := TBPACKASSO.FIRST;
         LOOP
            EXIT WHEN NUINDEX IS NULL;
            TT_BOFAULT.DESORBPACKAGE( TBPACKASSO( NUINDEX ).PACKAGE_ID, TBPACKASSO( NUINDEX ).PACKAGES_ASSO_ID );
            NUINDEX := TBPACKASSO.NEXT( NUINDEX );
         END LOOP;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END REMPRODFROMFAULT;
   PROCEDURE UPDATEFAULT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, IBLATTENDING IN BOOLEAN, IBLTOTALATTEND IN BOOLEAN )
    IS
      SBEJECUTAR VARCHAR( 2000 );
      NUJOBID USER_JOBS.JOB%TYPE;
    BEGIN
      UT_TRACE.TRACE( 'Inicia TT_BOProduct.UpdateFault', 15 );
      DATT_DAMAGE.UPDREG_DAMAGE_STATUS( INUFAULTID, TT_BCCONSTANTS.CSBPROCESSINGDAMAGESTATUS );
      SBEJECUTAR := ' DECLARE' || CHR( 10 ) || '    nuError     NUMBER;' || CHR( 10 ) || '    sbError     VARCHAR2(2000);' || CHR( 10 ) || ' BEGIN' || CHR( 10 ) || ' ' || TT_BCCONSTANTS.CSBUPD_SERV_INT_TAG || CHR( 10 ) || ' (' || CHR( 10 ) || INUFAULTID || ',' || CHR( 10 );
      IF ( IBLATTENDING ) THEN
         SBEJECUTAR := SBEJECUTAR || 'TRUE,' || CHR( 10 );
       ELSE
         SBEJECUTAR := SBEJECUTAR || 'FALSE,' || CHR( 10 );
      END IF;
      IF ( IBLTOTALATTEND ) THEN
         SBEJECUTAR := SBEJECUTAR || 'TRUE' || CHR( 10 );
       ELSE
         SBEJECUTAR := SBEJECUTAR || 'FALSE' || CHR( 10 );
      END IF;
      SBEJECUTAR := SBEJECUTAR || ' );' || CHR( 10 ) || '    EXCEPTION' || CHR( 10 ) || '        when ex.CONTROLLED_ERROR THEN' || CHR( 10 ) || '            raise ex.CONTROLLED_ERROR;' || CHR( 10 ) || '        when others THEN' || CHR( 10 ) || '            Errors.setError;' || CHR( 10 ) || '            raise ex.CONTROLLED_ERROR;' || CHR( 10 ) || ' END;';
      UT_TRACE.TRACE( 'Ejecuta [' || SBEJECUTAR || ']', 15 );
      PKBIUT_JOBMGR.CREATEJOBVALIDATEWHATDATE( SBEJECUTAR, SYSDATE, NULL, NUJOBID );
      UT_TRACE.TRACE( 'nujobId [' || NUJOBID || ']', 15 );
      UT_TRACE.TRACE( 'Finaliza TT_BOProduct.UpdateFault', 15 );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         UT_TRACE.TRACE( '=>CONTROLLED_ERROR TT_BOProduct.UpdateFault', 15 );
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         UT_TRACE.TRACE( '=>OTHERS_ERROR TT_BOProduct.UpdateFault', 15 );
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END UPDATEFAULT;
   FUNCTION REGISTERPROCESS( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, ISBTYPE IN VARCHAR2, IBLATTENDING IN BOOLEAN, IBLTOTALATTEND IN BOOLEAN )
    RETURN VARCHAR2
    IS
      SBPARAMETERS ESTAPROG.ESPRINFO%TYPE;
      NUCONSECUTIVE NUMBER := 0;
      SBPROCESSID ESTAPROG.ESPRPROG%TYPE;
      SBMESSAGE ESTAPROG.ESPRMESG%TYPE;
      TBPARAMETERS UT_STRING.TYTB_STRING;
    BEGIN
      UT_TRACE.TRACE( 'Inicia TT_BOProduct.RegisterProcess', 15 );
      WHILE ( PKTBLESTAPROG.FBLEXIST( ISBTYPE || INUFAULTID || '_' || NUCONSECUTIVE ) )
       LOOP
         NUCONSECUTIVE := NUCONSECUTIVE + 1;
      END LOOP;
      SBPROCESSID := ISBTYPE || INUFAULTID || '_' || NUCONSECUTIVE;
      SBMESSAGE := 'Proceso iniciado';
      PKSTATUSEXEPROGRAMMGR.VALIDATERECORDAT( SBPROCESSID );
      PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROGRAMAT( SBPROCESSID, SBMESSAGE, 100, 0 );
      TBPARAMETERS( 1 ) := TT_BCCONSTANTS.CSBFAULT_TAG || '=' || INUFAULTID;
      IF ( IBLATTENDING ) THEN
         TBPARAMETERS( 2 ) := TT_BCCONSTANTS.CSBATTENDING_TAG || '=TRUE';
       ELSE
         TBPARAMETERS( 2 ) := TT_BCCONSTANTS.CSBATTENDING_TAG || '=FALSE';
      END IF;
      IF ( IBLTOTALATTEND ) THEN
         TBPARAMETERS( 3 ) := TT_BCCONSTANTS.CSBTOTALATTEND_TAG || '=TRUE';
       ELSE
         TBPARAMETERS( 3 ) := TT_BCCONSTANTS.CSBTOTALATTEND_TAG || '=FALSE';
      END IF;
      SBPARAMETERS := UT_STRING.FSBSTRINGFROMTABLE( TBPARAMETERS, ';' );
      PKSTATUSEXEPROGRAMMGR.UPINFOEXEPROGRAM( SBPROCESSID, SBPARAMETERS );
      UT_TRACE.TRACE( 'Finaliza TT_BOProduct.RegisterProcess', 15 );
      RETURN SBPROCESSID;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         UT_TRACE.TRACE( '=>CONTROLLED_ERROR TT_BOProduct.RegisterProcess', 15 );
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         UT_TRACE.TRACE( '=>OTHERS_ERROR TT_BOProduct.RegisterProcess', 15 );
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END REGISTERPROCESS;
   PROCEDURE SETCACHE( IBLUSECACHE IN BOOLEAN )
    IS
    BEGIN
      DAGE_MESSAGE.SETUSECACHE( IBLUSECACHE );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END SETCACHE;
   PROCEDURE UNLOCKFAULT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, IBLLOCKED IN BOOLEAN )
    IS
    BEGIN
      IF ( IBLLOCKED ) THEN
         TT_BOFAULT.UNLOCKTT_DAMAGE( INUFAULTID );
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END UNLOCKFAULT;
   PROCEDURE JOBUPDATEFAULT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, IBLATTENDING IN BOOLEAN, IBLTOTALATTEND IN BOOLEAN )
    IS
      NUCURRTRACELVL NUMBER;
      SBPROCESSID ESTAPROG.ESPRPROG%TYPE;
      NUERRORCODE GE_ERROR_LOG.ERROR_LOG_ID%TYPE;
      SBERRORMESSAGE GE_ERROR_LOG.DESCRIPTION%TYPE;
      BLLOCKED BOOLEAN;
      PROCEDURE MANAGEERROR
       IS
       BEGIN
         UNLOCKFAULT( INUFAULTID, BLLOCKED );
         ERRORS.GETERROR( NUERRORCODE, SBERRORMESSAGE );
         PKSTATUSEXEPROGRAMMGR.UPDATEESTAPROGAT( SBPROCESSID, NUERRORCODE || ' - ' || SBERRORMESSAGE, 100, SYSDATE );
         UT_TRACE.SETLEVEL( NUCURRTRACELVL );
         ROLLBACK;
       EXCEPTION
         WHEN EX.CONTROLLED_ERROR THEN
            RAISE EX.CONTROLLED_ERROR;
         WHEN OTHERS THEN
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
      END MANAGEERROR;
      PROCEDURE DESORBEXISTING
       IS
         NUINDEX BINARY_INTEGER;
         TBDAMAGES DAMO_PACKAGES_ASSO.TYTBMO_PACKAGES_ASSO;
         RCDAMAGE DATT_DAMAGE.STYTT_DAMAGE;
         DTINITIALDATE TT_DAMAGE.INITIAL_DATE%TYPE;
         NUFAULTTYPEID TT_DAMAGE.REG_DAMAGE_TYPE_ID%TYPE;
       BEGIN
         IF ( TT_BCPRODUCT.CUPRODDAMTODESORB%ISOPEN ) THEN
            CLOSE TT_BCPRODUCT.CUPRODDAMTODESORB;
         END IF;
         DATT_DAMAGE.GETRECORD( INUFAULTID, RCDAMAGE );
         DTINITIALDATE := RCDAMAGE.INITIAL_DATE;
         NUFAULTTYPEID := NVL( RCDAMAGE.FINAL_DAMAGE_TYPE_ID, RCDAMAGE.REG_DAMAGE_TYPE_ID );
         OPEN TT_BCPRODUCT.CUPRODDAMTODESORB( INUFAULTID, DTINITIALDATE, NUFAULTTYPEID );
         LOOP
            TBDAMAGES.DELETE;
            FETCH TT_BCPRODUCT.CUPRODDAMTODESORB
               BULK COLLECT INTO TBDAMAGES
               LIMIT 100;
            NUINDEX := TBDAMAGES.FIRST;
            EXIT WHEN NUINDEX IS NULL;
            LOOP
               EXIT WHEN NUINDEX IS NULL;
               TT_BOFAULT.DESORBPACKAGE( TBDAMAGES( NUINDEX ).PACKAGE_ID, TBDAMAGES( NUINDEX ).PACKAGES_ASSO_ID );
               NUINDEX := TBDAMAGES.NEXT( NUINDEX );
            END LOOP;
            COMMIT;
         END LOOP;
         CLOSE TT_BCPRODUCT.CUPRODDAMTODESORB;
       EXCEPTION
         WHEN EX.CONTROLLED_ERROR THEN
            IF ( TT_BCPRODUCT.CUPRODDAMTODESORB%ISOPEN ) THEN
               CLOSE TT_BCPRODUCT.CUPRODDAMTODESORB;
            END IF;
            RAISE EX.CONTROLLED_ERROR;
         WHEN OTHERS THEN
            ERRORS.SETERROR;
            IF ( TT_BCPRODUCT.CUPRODDAMTODESORB%ISOPEN ) THEN
               CLOSE TT_BCPRODUCT.CUPRODDAMTODESORB;
            END IF;
            RAISE EX.CONTROLLED_ERROR;
      END DESORBEXISTING;
      PROCEDURE ABSORBNEW
       IS
         NUID TT_DAMAGE_PRODUCT.DAMAGES_PRODUCT_ID%TYPE;
         NUDAMAGESINDEX BINARY_INTEGER;
         TBDAMAGEPRODUCT DATT_DAMAGE_PRODUCT.TYTBTT_DAMAGE_PRODUCT;
       BEGIN
         IF ( TT_BCPRODUCT.CUOPENDAMPRDBYPACK%ISOPEN ) THEN
            CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
         END IF;
         OPEN TT_BCPRODUCT.CUOPENDAMPRDBYPACK( INUFAULTID );
         LOOP
            TBDAMAGEPRODUCT.DELETE;
            FETCH TT_BCPRODUCT.CUOPENDAMPRDBYPACK
               BULK COLLECT INTO TBDAMAGEPRODUCT
               LIMIT 100;
            NUDAMAGESINDEX := TBDAMAGEPRODUCT.FIRST;
            EXIT WHEN NUDAMAGESINDEX IS NULL;
            LOOP
               EXIT WHEN NUDAMAGESINDEX IS NULL;
               TT_BOPRODUCT.ADDPRODTOFAULT( INUFAULTID, TBDAMAGEPRODUCT( NUDAMAGESINDEX ).PRODUCT_ID, NULL, SBPROCESSID, NUID, FALSE );
               NUDAMAGESINDEX := TBDAMAGEPRODUCT.NEXT( NUDAMAGESINDEX );
            END LOOP;
            COMMIT;
         END LOOP;
         CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
       EXCEPTION
         WHEN EX.CONTROLLED_ERROR THEN
            IF ( TT_BCPRODUCT.CUOPENDAMPRDBYPACK%ISOPEN ) THEN
               CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
            END IF;
            RAISE EX.CONTROLLED_ERROR;
         WHEN OTHERS THEN
            ERRORS.SETERROR;
            IF ( TT_BCPRODUCT.CUOPENDAMPRDBYPACK%ISOPEN ) THEN
               CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
            END IF;
            RAISE EX.CONTROLLED_ERROR;
      END ABSORBNEW;
    BEGIN
      NUCURRTRACELVL := UT_TRACE.GETLEVEL;
      IF ( ( CSBSET_TRACE = GE_BOCONSTANTS.CSBYES ) AND ( NUCURRTRACELVL = 0 ) ) THEN
         UT_TRACE.SETLEVEL( CSBTRACE_LEVEL );
         UT_TRACE.SETOUTPUT( UT_TRACE.CNUTRACE_OUTPUT_DB );
      END IF;
      UT_TRACE.TRACE( 'Inicia TT_BOProduct.JobUpdateFault', 15 );
      SBPROCESSID := REGISTERPROCESS( INUFAULTID, TT_BCCONSTANTS.CSBPROCESS_TTAI, IBLATTENDING, IBLTOTALATTEND );
      UT_TRACE.TRACE( 'Proceso registrado [' || SBPROCESSID || ']', 15 );
      COMMIT;
      SETCACHE( TRUE );
      TT_BOFAULT.LOCKTT_DAMAGE( INUFAULTID );
      BLLOCKED := TRUE;
      PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROGRAMAT( SBPROCESSID, 'Inicia verificacion de da?os a producto a mantener asociados', 100, 25 );
      DESORBEXISTING;
      PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROGRAMAT( SBPROCESSID, 'Inicia busqueda de da?os a producto a absorber', 100, 50 );
      ABSORBNEW;
      PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROGRAMAT( SBPROCESSID, 'Inicia actualizacion de la prioridad de la falla', 100, 75 );
      TT_BOFAULT.UPDFAULTPRIORITY( INUFAULTID, SBPROCESSID );
      IF ( NOT ( IBLATTENDING ) ) THEN
         DATT_DAMAGE.UPDREG_DAMAGE_STATUS( INUFAULTID, TT_BOCONSTANTS.CSBREGISTEREDDAMAGESTATUS );
      END IF;
      TT_BOFAULT.UNLOCKTT_DAMAGE( INUFAULTID );
      BLLOCKED := FALSE;
      PKSTATUSEXEPROGRAMMGR.UPSTATUSEXEPROGRAMAT( SBPROCESSID, 'Proceso termino correctamente', 100, 100 );
      UT_TRACE.TRACE( 'Finaliza TT_BOProduct.JobUpdateFault', 15 );
      UT_TRACE.SETLEVEL( NUCURRTRACELVL );
      IF ( IBLATTENDING ) THEN
         TT_BOFAULT.ATTENDFAULTPROC( INUFAULTID, IBLTOTALATTEND );
      END IF;
      COMMIT;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         MANAGEERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         MANAGEERROR;
   END JOBUPDATEFAULT;
   PROCEDURE SETATTENDPRODUCT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE )
    IS
      RCDAMAGE_PRODUCT DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
    BEGIN
      TT_BCPRODUCT.GETDAMAPRODBYPACKANDPRODUCT( INUFAULTID, INUPRODUCTID, RCDAMAGE_PRODUCT );
      IF ( RCDAMAGE_PRODUCT.PACKAGE_ID = INUFAULTID ) THEN
         IF ( RCDAMAGE_PRODUCT.DAMAGE_PRODU_STATUS = TT_BCCONSTANTS.CSBOPENDAMAGESTATUS ) THEN
            DATT_DAMAGE_PRODUCT.UPDREPAIRED( RCDAMAGE_PRODUCT.DAMAGES_PRODUCT_ID, TT_BCCONSTANTS.CSBATTENDED_REPAIR );
         END IF;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END SETATTENDPRODUCT;
   PROCEDURE VALATTENDPRODUCT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE )
    IS
      RCDAMAGE_PRODUCT DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
    BEGIN
      TT_BCPRODUCT.GETDAMAPRODBYPACKANDPRODUCT( INUFAULTID, INUPRODUCTID, RCDAMAGE_PRODUCT );
      IF ( RCDAMAGE_PRODUCT.PACKAGE_ID = INUFAULTID ) THEN
         IF ( RCDAMAGE_PRODUCT.DAMAGE_PRODU_STATUS != TT_BCCONSTANTS.CSBOPENDAMAGESTATUS ) THEN
            ERRORS.SETERROR( CNUINVALID_PROD_ERROR, INUPRODUCTID );
            RAISE EX.CONTROLLED_ERROR;
         END IF;
       ELSE
         ERRORS.SETERROR( CNUINVALID_PROD_ERROR, INUPRODUCTID );
         RAISE EX.CONTROLLED_ERROR;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END VALATTENDPRODUCT;
   FUNCTION FNUGETPRODSUSPTIME( INUPRODUCTID IN PR_PRODUCT.PRODUCT_ID%TYPE, IDTINITIALDATE IN TT_DAMAGE.INITIAL_DATE%TYPE, IDTFINALDATE IN MO_PACKAGES.ATTENTION_DATE%TYPE )
    RETURN NUMBER
    IS
      NUSUSPTIME NUMBER;
      TBSUSPENSIONS TT_BCPRODUCT.TYTBSUSPENSIONS;
      NUINDEX BINARY_INTEGER;
      NUNEXTINDEX BINARY_INTEGER;
    BEGIN
      NUSUSPTIME := 0;
      TBSUSPENSIONS := TT_BCPRODUCT.FTBGETPRODSUSPS( INUPRODUCTID, IDTINITIALDATE, IDTFINALDATE );
      NUINDEX := TBSUSPENSIONS.FIRST;
      LOOP
         EXIT WHEN NUINDEX IS NULL;
         NUNEXTINDEX := TBSUSPENSIONS.NEXT( NUINDEX );
         EXIT WHEN NUNEXTINDEX IS NULL;
         IF ( TBSUSPENSIONS( NUINDEX ).FINAL_DATE > TBSUSPENSIONS( NUNEXTINDEX ).INITIAL_DATE ) THEN
            IF ( TBSUSPENSIONS( NUINDEX ).FINAL_DATE < TBSUSPENSIONS( NUNEXTINDEX ).FINAL_DATE ) THEN
               TBSUSPENSIONS( NUINDEX ).FINAL_DATE := TBSUSPENSIONS( NUNEXTINDEX ).FINAL_DATE;
               TBSUSPENSIONS.DELETE( NUNEXTINDEX );
             ELSE
               TBSUSPENSIONS.DELETE( NUNEXTINDEX );
            END IF;
          ELSE
            NUINDEX := TBSUSPENSIONS.NEXT( NUINDEX );
         END IF;
      END LOOP;
      NUINDEX := TBSUSPENSIONS.FIRST;
      LOOP
         EXIT WHEN NUINDEX IS NULL;
         NUSUSPTIME := NUSUSPTIME + ( TBSUSPENSIONS( NUINDEX ).FINAL_DATE - TBSUSPENSIONS( NUINDEX ).INITIAL_DATE );
         NUINDEX := TBSUSPENSIONS.NEXT( NUINDEX );
      END LOOP;
      IF ( NUSUSPTIME > ( IDTFINALDATE - IDTINITIALDATE ) ) THEN
         NUSUSPTIME := IDTFINALDATE - IDTINITIALDATE;
      END IF;
      NUSUSPTIME := NUSUSPTIME * 1440;
      RETURN NUSUSPTIME;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END FNUGETPRODSUSPTIME;
   FUNCTION TIMEOUTPROCESSALLPRODUCTSTATUS( INUPRODUCT_ID IN PR_PRODUCT.PRODUCT_ID%TYPE, IDTINITIAL_DATE IN TT_DAMAGE.INITIAL_DATE%TYPE, IDTATTENTION_DATE IN MO_PACKAGES.ATTENTION_DATE%TYPE, IBLAUTHORIZETIMEOUT IN BOOLEAN, INUPACKAGEID IN PR_TIMEOUT_COMPONENT.PACKAGE_ID%TYPE := NULL, INUELEMENTID IN PR_TIMEOUT_COMPONENT.ELEMENT_ID%TYPE := NULL, INUTIMEOUTID IN PR_TIMEOUT_COMPONENT.TIMEOUT_COMPONENT_ID%TYPE := NULL )
    RETURN TT_DAMAGE_PRODUCT.COMPENSATED_TIME%TYPE
    IS
      NUCOMPONENTMAIN_ID MO_COMPONENT.COMPONENT_ID%TYPE;
      DTFINALDATE MO_PACKAGES.ATTENTION_DATE%TYPE;
      NUPRODUCTSTATUS PS_PRODUCT_STATUS.PRODUCT_STATUS_ID%TYPE;
      DTRETIREDATE PR_PRODUCT_RETIRE.RETIRE_DATE%TYPE := NULL;
      DTAUTHDATE PR_TIMEOUT_COMPONENT.AUTHORIZATION_DATE%TYPE := NULL;
      NUCOMPTIME NUMBER;
      NUSUSPTIME NUMBER;
    BEGIN
      UT_TRACE.TRACE( 'INICIA TT_BOProduct.TimeOutProcessAllProductStatus:' || CHR( 10 ) || 'inuProduct_id[' || INUPRODUCT_ID || ']' || CHR( 10 ) || 'idtInitial_date[' || IDTINITIAL_DATE || ']-' || CHR( 10 ) || 'idtAttention_date[' || IDTATTENTION_DATE || ']', 15 );
      NUPRODUCTSTATUS := DAPR_PRODUCT.FNUGETPRODUCT_STATUS_ID( INUPRODUCT_ID );
      NUCOMPONENTMAIN_ID := PR_BCPRODUCT.FNUGETMAINCOMP( INUPRODUCT_ID );
      IF ( PS_BOPRODSERVMANAGER.FRCGETPRODUCTSTATUS( NUPRODUCTSTATUS ).IS_ACTIVE_PRODUCT = GE_BOCONSTANTS.CSBYES ) THEN
         DTFINALDATE := IDTATTENTION_DATE;
       ELSE
         DTRETIREDATE := PR_BCRETIRE.FDTGETLASTDATERETIREBYPROD( INUPRODUCT_ID );
         IF ( DTRETIREDATE IS NULL ) THEN
            DTFINALDATE := IDTATTENTION_DATE;
          ELSE
            IF ( DTRETIREDATE < IDTINITIAL_DATE ) THEN
               RETURN NULL;
            END IF;
            IF ( DTRETIREDATE < IDTATTENTION_DATE ) THEN
               DTFINALDATE := DTRETIREDATE;
             ELSE
               DTFINALDATE := IDTATTENTION_DATE;
            END IF;
         END IF;
      END IF;
      NUCOMPTIME := ( DTFINALDATE - IDTINITIAL_DATE ) * 1440;
      NUSUSPTIME := FNUGETPRODSUSPTIME( INUPRODUCT_ID, IDTINITIAL_DATE, DTFINALDATE );
      NUCOMPTIME := NUCOMPTIME - NUSUSPTIME;
      IF ( NUCOMPTIME < 0 ) THEN
         NUCOMPTIME := 0;
      END IF;
      IF ( IBLAUTHORIZETIMEOUT ) THEN
         DTAUTHDATE := UT_DATE.FDTSYSDATE;
      END IF;
      IF ( INUTIMEOUTID IS NULL ) THEN
         PR_BOTIMESCHEDULER.REGISTER( NUCOMPONENTMAIN_ID, IDTINITIAL_DATE, DTFINALDATE, INUPACKAGEID, INUELEMENTID, NUSUSPTIME, DTAUTHDATE, NUCOMPTIME );
       ELSE
         PR_BOTIMESCHEDULER.UPDRECORD( INUTIMEOUTID, IDTINITIAL_DATE, DTFINALDATE, NUCOMPONENTMAIN_ID, INUPACKAGEID, INUELEMENTID, NUSUSPTIME, DTAUTHDATE, NUCOMPTIME );
      END IF;
      RETURN NUCOMPTIME;
      UT_TRACE.TRACE( 'FIN TT_BOProduct.TimeOutProcessAllProductStatus:', 15 );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END TIMEOUTPROCESSALLPRODUCTSTATUS;
   PROCEDURE ATTENDPRODUCT( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, ISBPRODSTATUS IN TT_DAMAGE_PRODUCT.DAMAGE_PRODU_STATUS%TYPE, IBLAUTHORIZETIMEOUT IN BOOLEAN, ISBAPPROVAL IN TT_DAMAGE.APPROVAL%TYPE, IDTINITIALDATE IN TT_DAMAGE.INITIAL_DATE%TYPE, IDTATTENTIONDATE IN MO_PACKAGES.ATTENTION_DATE%TYPE, IORCDAMAGE_PRODUCT IN OUT NOCOPY DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT )
    IS
      NUINDEX BINARY_INTEGER;
      TBPACKASSO DAMO_PACKAGES_ASSO.TYTBMO_PACKAGES_ASSO;
    BEGIN
      IORCDAMAGE_PRODUCT.ATENTION_DATE := IDTATTENTIONDATE;
      IORCDAMAGE_PRODUCT.DAMAGE_PRODU_STATUS := ISBPRODSTATUS;
      IORCDAMAGE_PRODUCT.REPAIRED := TT_BCCONSTANTS.CSBREPAIRED;
      IF ( ( ISBAPPROVAL = TT_BCCONSTANTS.CSBCOMP_PENDING ) AND ( ISBPRODSTATUS = TT_BCCONSTANTS.CSBCLOSEDAMAGESTATUS ) ) THEN
         IORCDAMAGE_PRODUCT.COMPENSATED_TIME := TIMEOUTPROCESSALLPRODUCTSTATUS( IORCDAMAGE_PRODUCT.PRODUCT_ID, IDTINITIALDATE, IDTATTENTIONDATE, IBLAUTHORIZETIMEOUT, INUFAULTID, IORCDAMAGE_PRODUCT.ELEMENT_ID );
      END IF;
      DATT_DAMAGE_PRODUCT.UPDRECORD( IORCDAMAGE_PRODUCT );
      TBPACKASSO := TT_BCPRODUCT.FTBRELADAMAGBYPROD( IORCDAMAGE_PRODUCT.PACKAGE_ID, IORCDAMAGE_PRODUCT.PRODUCT_ID );
      NUINDEX := TBPACKASSO.FIRST;
      LOOP
         EXIT WHEN NUINDEX IS NULL;
         IF ( ISBPRODSTATUS = TT_BCCONSTANTS.CSBCLOSEDAMAGESTATUS ) THEN
            OR_BOANULLORDER.ANULLACTIVITIES( TBPACKASSO( NUINDEX ).PACKAGE_ID, NULL, NULL, TRUE );
          ELSE
            TT_BOFAULT.DESORBPACKAGE( TBPACKASSO( NUINDEX ).PACKAGE_ID, TBPACKASSO( NUINDEX ).PACKAGES_ASSO_ID );
         END IF;
         NUINDEX := TBPACKASSO.NEXT( NUINDEX );
      END LOOP;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END ATTENDPRODUCT;
   PROCEDURE ATTENDALLPRODS( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, ISBPRODSTATUS IN TT_DAMAGE_PRODUCT.DAMAGE_PRODU_STATUS%TYPE, IBLAUTHORIZETIMEOUT IN BOOLEAN, ISBAPPROVAL IN TT_DAMAGE.APPROVAL%TYPE, IDTINITIALDATE IN TT_DAMAGE.INITIAL_DATE%TYPE, IDTATTENTIONDATE IN MO_PACKAGES.ATTENTION_DATE%TYPE )
    IS
      NUDAMAGESINDEX BINARY_INTEGER;
      TBDAMAGEPRODUCT DATT_DAMAGE_PRODUCT.TYTBTT_DAMAGE_PRODUCT;
      RCDAMAGE_PRODUCT DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
      RCDAMAGE_PRODUCTNULL DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
    BEGIN
      UT_TRACE.INIT;
      UT_TRACE.SETOUTPUT( UT_TRACE.CNUTRACE_OUTPUT_DB );
      UT_TRACE.SETLEVEL( 15 );
      UT_TRACE.TRACE( 'INICIO' );
      IF ( TT_BCPRODUCT.CUOPENDAMPRDBYPACK%ISOPEN ) THEN
         CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
      END IF;
      OPEN TT_BCPRODUCT.CUOPENDAMPRDBYPACK( INUFAULTID );
      LOOP
         TBDAMAGEPRODUCT.DELETE;
         FETCH TT_BCPRODUCT.CUOPENDAMPRDBYPACK
            BULK COLLECT INTO TBDAMAGEPRODUCT
            LIMIT 100;
         NUDAMAGESINDEX := TBDAMAGEPRODUCT.FIRST;
         EXIT WHEN NUDAMAGESINDEX IS NULL;
         LOOP
            EXIT WHEN NUDAMAGESINDEX IS NULL;
            RCDAMAGE_PRODUCT := RCDAMAGE_PRODUCTNULL;
            RCDAMAGE_PRODUCT := TBDAMAGEPRODUCT( NUDAMAGESINDEX );
            ATTENDPRODUCT( INUFAULTID, ISBPRODSTATUS, IBLAUTHORIZETIMEOUT, ISBAPPROVAL, IDTINITIALDATE, IDTATTENTIONDATE, RCDAMAGE_PRODUCT );
            NUDAMAGESINDEX := TBDAMAGEPRODUCT.NEXT( NUDAMAGESINDEX );
         END LOOP;
         COMMIT;
      END LOOP;
      CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         ROLLBACK;
         IF ( TT_BCPRODUCT.CUOPENDAMPRDBYPACK%ISOPEN ) THEN
            CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
         END IF;
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         ROLLBACK;
         IF ( TT_BCPRODUCT.CUOPENDAMPRDBYPACK%ISOPEN ) THEN
            CLOSE TT_BCPRODUCT.CUOPENDAMPRDBYPACK;
         END IF;
         RAISE EX.CONTROLLED_ERROR;
   END ATTENDALLPRODS;
   PROCEDURE ATTENDSELPRODS( INUFAULTID IN TT_DAMAGE.PACKAGE_ID%TYPE, ISBPRODSTATUS IN TT_DAMAGE_PRODUCT.DAMAGE_PRODU_STATUS%TYPE, IBLAUTHORIZETIMEOUT IN BOOLEAN, ISBAPPROVAL IN TT_DAMAGE.APPROVAL%TYPE, IDTINITIALDATE IN TT_DAMAGE.INITIAL_DATE%TYPE, IDTATTENTIONDATE IN MO_PACKAGES.ATTENTION_DATE%TYPE )
    IS
      NUDAMAGESINDEX BINARY_INTEGER;
      TBDAMAGEPRODUCT DATT_DAMAGE_PRODUCT.TYTBTT_DAMAGE_PRODUCT;
      RCDAMAGE_PRODUCT DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
      RCDAMAGE_PRODUCTNULL DATT_DAMAGE_PRODUCT.STYTT_DAMAGE_PRODUCT;
    BEGIN
      UT_TRACE.INIT;
      UT_TRACE.SETOUTPUT( UT_TRACE.CNUTRACE_OUTPUT_DB );
      UT_TRACE.SETLEVEL( 15 );
      UT_TRACE.TRACE( 'INICIO' );
      IF ( TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK%ISOPEN ) THEN
         CLOSE TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK;
      END IF;
      OPEN TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK( INUFAULTID );
      LOOP
         TBDAMAGEPRODUCT.DELETE;
         FETCH TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK
            BULK COLLECT INTO TBDAMAGEPRODUCT
            LIMIT 100;
         NUDAMAGESINDEX := TBDAMAGEPRODUCT.FIRST;
         EXIT WHEN NUDAMAGESINDEX IS NULL;
         LOOP
            EXIT WHEN NUDAMAGESINDEX IS NULL;
            RCDAMAGE_PRODUCT := RCDAMAGE_PRODUCTNULL;
            RCDAMAGE_PRODUCT := TBDAMAGEPRODUCT( NUDAMAGESINDEX );
            ATTENDPRODUCT( INUFAULTID, ISBPRODSTATUS, IBLAUTHORIZETIMEOUT, ISBAPPROVAL, IDTINITIALDATE, IDTATTENTIONDATE, RCDAMAGE_PRODUCT );
            NUDAMAGESINDEX := TBDAMAGEPRODUCT.NEXT( NUDAMAGESINDEX );
         END LOOP;
         COMMIT;
      END LOOP;
      CLOSE TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         ROLLBACK;
         IF ( TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK%ISOPEN ) THEN
            CLOSE TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK;
         END IF;
         RAISE EX.CONTROLLED_ERROR;
      WHEN OTHERS THEN
         ERRORS.SETERROR;
         ROLLBACK;
         IF ( TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK%ISOPEN ) THEN
            CLOSE TT_BCPRODUCT.CUOPENSELDAMPRDBYPACK;
         END IF;
         RAISE EX.CONTROLLED_ERROR;
   END ATTENDSELPRODS;
   PROCEDURE ANNULPACKAGE( INUPACKAGEID IN MO_PACKAGES.PACKAGE_ID%TYPE )
    IS
      NUINDEX BINARY_INTEGER;
      TBPACKASSO DAMO_PACKAGES_ASSO.TYTBMO_PACKAGES_ASSO;
      NUFAULTID TT_DAMAGE.PACKAGE_ID%TYPE;
      BLLOCKED BOOLEAN;
    BEGIN
      TBPACKASSO := TT_BCPRODUCT.FTBRELAFAULTSBYPRODDAM( INUPACKAGEID );
      NUINDEX := TBPACKASSO.FIRST;
      LOOP
         EXIT WHEN NUINDEX IS NULL;
         NUFAULTID := TBPACKASSO( NUINDEX ).PACKAGE_ID_ASSO;
         TT_BOFAULT.VALFAULTSTATUS( NUFAULTID );
         TT_BOFAULT.LOCKTT_DAMAGE( NUFAULTID );
         BLLOCKED := TRUE;
         TT_BOFAULT.DESORBPACKAGE( TBPACKASSO( NUINDEX ).PACKAGE_ID, TBPACKASSO( NUINDEX ).PACKAGES_ASSO_ID );
         TT_BOFAULT.UNLOCKTT_DAMAGE( NUFAULTID );
         BLLOCKED := FALSE;
         NUFAULTID := NULL;
         NUINDEX := TBPACKASSO.NEXT( NUINDEX );
      END LOOP;
      TT_BODAMAGEALGORITHM.ATTFAULTPRODJOBCALLER( INUPACKAGEID, NULL );
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         IF ( BLLOCKED AND ( NUFAULTID IS NOT NULL ) ) THEN
            TT_BOFAULT.UNLOCKTT_DAMAGE( NUFAULTID );
         END IF;
      WHEN OTHERS THEN
         IF ( BLLOCKED AND ( NUFAULTID IS NOT NULL ) ) THEN
            TT_BOFAULT.UNLOCKTT_DAMAGE( NUFAULTID );
         END IF;
   END ANNULPACKAGE;
   FUNCTION FBLVALDAMABSORPTION( INUPRODUCTID IN TT_DAMAGE_PRODUCT.PRODUCT_ID%TYPE, INUPACKAGEID IN MO_PACKAGES.PACKAGE_ID%TYPE )
    RETURN BOOLEAN
    IS
      TBFAULTTYPEPROD GE_TYTBIDNUMBER;
      TBFAULTTYPEABD GE_TYTBIDNUMBER;
      TBFAULTTYPEABR GE_TYTBIDNUMBER;
      RCFAULTPROD DAMO_PACKAGES.STYMO_PACKAGES;
      NUASSOID MO_PACKAGES_ASSO.PACKAGES_ASSO_ID%TYPE;
      NUCAUSALID MO_MOTIVE.CAUSAL_ID%TYPE;
      PROCEDURE GETFAULTTYPEABSORBERS( ITBFAULTTYPES IN GE_TYTBIDNUMBER, INUELEMENTTYPEID IN TT_DAMAGE_ELEMENT.ELEMENT_TYPE_ID%TYPE, OTBFAULTTYPEID OUT GE_TYTBIDNUMBER )
       IS
         TBFATHERELEMENTS DAIF_NODE.TYTBID;
       BEGIN
         UT_TRACE.TRACE( 'Inicia TT_BODamageProduct.GetFaultTypeAbsorbers [' || ITBFAULTTYPES.COUNT || ']', 15 );
         OTBFAULTTYPEID := GE_TYTBIDNUMBER();
         FOR RCROW IN TT_BCELEMENT.CUFAULTTYPESABSORBERS( INUELEMENTTYPEID, ITBFAULTTYPES )
          LOOP
            OTBFAULTTYPEID.EXTEND( 1 );
            OTBFAULTTYPEID( OTBFAULTTYPEID.COUNT ) := RCROW.DAMAGE_TYPE_ID;
            UT_TRACE.TRACE( '--> Tipo de Falla que Absorbe [' || RCROW.DAMAGE_TYPE_ID || ']', 15 );
         END LOOP;
         UT_TRACE.TRACE( 'Finaliza TT_BODamageProduct.GetFaultTypeAbsorbers[' || OTBFAULTTYPEID.COUNT || ']', 15 );
       EXCEPTION
         WHEN EX.CONTROLLED_ERROR THEN
            UT_TRACE.TRACE( 'Error : ex.CONTROLLED_ERROR', 15 );
            RAISE;
         WHEN OTHERS THEN
            UT_TRACE.TRACE( 'Error : others', 15 );
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
      END;
      PROCEDURE GETFAULTTYPABSBYCAUSAL( ITBFAULTTYPES IN GE_TYTBIDNUMBER, INUELEMENTTYPEID IN TT_DAMAGE_ELEMENT.ELEMENT_TYPE_ID%TYPE, OTBFAULTTYPEID OUT GE_TYTBIDNUMBER )
       IS
         TBFATHERELEMENTS DAIF_NODE.TYTBID;
       BEGIN
         UT_TRACE.TRACE( 'Inicia TT_BODamageProduct.GetFaultTypAbsByCausal', 15 );
         OTBFAULTTYPEID := GE_TYTBIDNUMBER();
         FOR RCROW IN TT_BCELEMENT.CUFAULTTYPABSCAUSAL( INUELEMENTTYPEID, ITBFAULTTYPES )
          LOOP
            OTBFAULTTYPEID.EXTEND( 1 );
            OTBFAULTTYPEID( OTBFAULTTYPEID.COUNT ) := RCROW.DAMAGE_TYPE_ID;
            UT_TRACE.TRACE( '--> Tipo de Falla que Absorbe [' || RCROW.DAMAGE_TYPE_ID || ']', 15 );
         END LOOP;
         UT_TRACE.TRACE( 'Finaliza TT_BODamageProduct.GetFaultTypAbsByCausal[' || OTBFAULTTYPEID.COUNT || ']', 15 );
       EXCEPTION
         WHEN EX.CONTROLLED_ERROR THEN
            UT_TRACE.TRACE( 'Error : ex.CONTROLLED_ERROR', 15 );
            RAISE;
         WHEN OTHERS THEN
            UT_TRACE.TRACE( 'Error : others', 15 );
            ERRORS.SETERROR;
            RAISE EX.CONTROLLED_ERROR;
      END;
    BEGIN
      UT_TRACE.TRACE( 'Inicia TT_BOProduct.fblValDamAbsorption [' || INUPRODUCTID || '][' || INUPACKAGEID || ']', 15 );
      RCFAULTPROD := DAMO_PACKAGES.FRCGETRECORD( INUPACKAGEID );
      FOR RCROW IN MO_BCMOTIVE.CUMOTIVESBYPACKAGE( INUPACKAGEID )
       LOOP
         NUCAUSALID := RCROW.CAUSAL_ID;
      END LOOP;
      TBFAULTTYPEPROD := GE_TYTBIDNUMBER( NUCAUSALID );
      FOR RCROW IN TT_BCPRODUCT.CUDAMELEBYPRODANDSTAT( INUPRODUCTID, TT_BOCONSTANTS.CSBOPENDAMAGESTATUS )
       LOOP
         TBFAULTTYPEABD := TBFAULTTYPEPROD;
         UT_TRACE.TRACE( 'Da?o Encontrado [' || RCROW.PACKAGE_ID || ']', 15 );
         FOR RCROWELEMS IN TT_BCELEMENT.CUGETELEMENTSFATHER( RCROW.ELEMENT_ID, RCROW.PACKAGE_ID )
          LOOP
            UT_TRACE.TRACE( 'Elemento Analizado [' || RCROWELEMS.ELEMENT_ID || '][' || RCROWELEMS.FATHER_ELEMENT_ID || ']', 15 );
            IF ( DAIF_ELEMENT_TYPE.FNUGETELEMENT_GROUP_ID( RCROWELEMS.ELEMENT_TYPE_ID ) = IF_BOPARAMETER.FNUGETNODEELEMENT ) THEN
               IF ( TBFAULTTYPEPROD.COUNT > 0 ) THEN
                  GETFAULTTYPABSBYCAUSAL( TBFAULTTYPEABD, RCROWELEMS.ELEMENT_TYPE_ID, TBFAULTTYPEABR );
                  TBFAULTTYPEPROD := NULL;
                ELSE
                  GETFAULTTYPEABSORBERS( TBFAULTTYPEABD, RCROWELEMS.ELEMENT_TYPE_ID, TBFAULTTYPEABR );
               END IF;
               IF ( TBFAULTTYPEABR.COUNT = 0 ) THEN
                  UT_TRACE.TRACE( '--> No Absorbe', 15 );
                  EXIT;
               END IF;
               IF ( RCROWELEMS.FATHER_ELEMENT_ID = -1 ) THEN
                  IF ( TT_BCFAULT.FBLISABSORBED( INUPACKAGEID ) ) THEN
                     RETURN TRUE;
                  END IF;
                  IF ( NOT TT_BCFAULT.FBLISABSORBED( RCROWELEMS.PACKAGE_ID ) ) THEN
                     UT_TRACE.TRACE( '--> Absorbe', 15 );
                     BEGIN
                        TT_BOFAULT.ABSORBPACKAGE( RCROWELEMS.PACKAGE_ID, RCFAULTPROD.PACKAGE_ID, NULL, NUASSOID );
                        RETURN TRUE;
                      EXCEPTION
                        WHEN EX.CONTROLLED_ERROR THEN
                           UT_TRACE.TRACE( 'Error : ex.CONTROLLED_ERROR', 15 );
                        WHEN OTHERS THEN
                           UT_TRACE.TRACE( 'Error : others', 15 );
                           ERRORS.SETERROR;
                     END;
                  END IF;
                ELSE
                  UT_TRACE.TRACE( 'Se pasa al siguiente nivel', 15 );
                  TBFAULTTYPEABD := TBFAULTTYPEABR;
               END IF;
             ELSE
               UT_TRACE.TRACE( '--> Es asignable', 15 );
            END IF;
         END LOOP;
      END LOOP;
      IF ( TT_BCFAULT.FBLISABSORBED( INUPACKAGEID ) ) THEN
         UT_TRACE.TRACE( 'Finaliza TT_BOProduct.fblValDamAbsorption [true]', 15 );
         RETURN TRUE;
       ELSE
         UT_TRACE.TRACE( 'Finaliza TT_BOProduct.fblValDamAbsorption [False]', 15 );
         RETURN FALSE;
      END IF;
    EXCEPTION
      WHEN EX.CONTROLLED_ERROR THEN
         UT_TRACE.TRACE( 'Error : ex.CONTROLLED_ERROR', 15 );
         RAISE;
      WHEN OTHERS THEN
         UT_TRACE.TRACE( 'Error : others', 15 );
         ERRORS.SETERROR;
         RAISE EX.CONTROLLED_ERROR;
   END;
END TT_BOPRODUCT;
/


